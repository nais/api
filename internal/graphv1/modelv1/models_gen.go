// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package modelv1

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/users"
)

// The query root for the NAIS GraphQL API.
type Query struct {
}

// Team type.
type Team struct {
	ID string `json:"id"`
	// Unique slug of the team.
	Slug slug.Slug `json:"slug"`
	// Purpose of the team.
	Purpose string `json:"purpose"`
	// The ID of the Azure AD group for the team. This value is managed by the Azure AD reconciler.
	AzureGroupID *string `json:"azureGroupID,omitempty"`
	// The slug of the GitHub team. This value is managed by the GitHub reconciler.
	GitHubTeamSlug *string `json:"gitHubTeamSlug,omitempty"`
	// The email address of the Google group for the team. This value is managed by the Google Workspace reconciler.
	GoogleGroupEmail *string `json:"googleGroupEmail,omitempty"`
	// The Google artifact registry for the team.
	GoogleArtifactRegistry *string `json:"googleArtifactRegistry,omitempty"`
	// The CDN bucket for the team.
	CdnBucket *string `json:"cdnBucket,omitempty"`
	// Timestamp of the last successful synchronization of the team.
	LastSuccessfulSync *time.Time `json:"lastSuccessfulSync,omitempty"`
	// Slack channel for the team.
	SlackChannel string `json:"slackChannel"`
	// Whether or not the team is currently being deleted.
	DeletionInProgress bool `json:"deletionInProgress"`
	// Whether or not the viewer is an owner of the team.
	ViewerIsOwner bool `json:"viewerIsOwner"`
	// Whether or not the viewer is a member of the team.
	ViewerIsMember bool `json:"viewerIsMember"`
}

// Team deletion key type.
type TeamDeleteKey struct {
	// The unique key used to confirm the deletion of a team.
	Key string `json:"key"`
	// The creation timestamp of the key.
	CreatedAt time.Time `json:"createdAt"`
	// Expiration timestamp of the key.
	Expires time.Time `json:"expires"`
	// The user who created the key.
	CreatedBy users.User `json:"createdBy"`
	// The team the delete key is for.
	Team Team `json:"team"`
}

type UserOrder struct {
	Field     UserOrderField `json:"field"`
	Direction OrderDirection `json:"direction"`
}

type OrderDirection string

const (
	// Ascending sort order.
	OrderDirectionAsc OrderDirection = "ASC"
	// Descending sort order.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderField string

const (
	// Order by name
	UserOrderFieldName UserOrderField = "NAME"
	// Order by email
	UserOrderFieldEmail UserOrderField = "EMAIL"
)

var AllUserOrderField = []UserOrderField{
	UserOrderFieldName,
	UserOrderFieldEmail,
}

func (e UserOrderField) IsValid() bool {
	switch e {
	case UserOrderFieldName, UserOrderFieldEmail:
		return true
	}
	return false
}

func (e UserOrderField) String() string {
	return string(e)
}

func (e *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

func (e UserOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

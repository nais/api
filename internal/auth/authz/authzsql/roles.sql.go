// Code generated by sqlc. DO NOT EDIT.
// source: roles.sql

package authzsql

import (
	"context"

	"github.com/google/uuid"
	"github.com/nais/api/internal/slug"
)

const assignGlobalRoleToUser = `-- name: AssignGlobalRoleToUser :exec
INSERT INTO
	user_roles (user_id, role_name)
VALUES
	($1, $2)
ON CONFLICT DO NOTHING
`

type AssignGlobalRoleToUserParams struct {
	UserID   uuid.UUID
	RoleName string
}

func (q *Queries) AssignGlobalRoleToUser(ctx context.Context, arg AssignGlobalRoleToUserParams) error {
	_, err := q.db.Exec(ctx, assignGlobalRoleToUser, arg.UserID, arg.RoleName)
	return err
}

const assignRoleToServiceAccount = `-- name: AssignRoleToServiceAccount :exec
INSERT INTO
	service_account_roles (service_account_id, role_name)
VALUES
	($1, $2)
ON CONFLICT DO NOTHING
`

type AssignRoleToServiceAccountParams struct {
	ServiceAccountID uuid.UUID
	RoleName         string
}

func (q *Queries) AssignRoleToServiceAccount(ctx context.Context, arg AssignRoleToServiceAccountParams) error {
	_, err := q.db.Exec(ctx, assignRoleToServiceAccount, arg.ServiceAccountID, arg.RoleName)
	return err
}

const assignTeamRoleToUser = `-- name: AssignTeamRoleToUser :exec
INSERT INTO
	user_roles (user_id, role_name, target_team_slug)
VALUES
	($1, $2, $3::slug)
ON CONFLICT DO NOTHING
`

type AssignTeamRoleToUserParams struct {
	UserID         uuid.UUID
	RoleName       string
	TargetTeamSlug slug.Slug
}

func (q *Queries) AssignTeamRoleToUser(ctx context.Context, arg AssignTeamRoleToUserParams) error {
	_, err := q.db.Exec(ctx, assignTeamRoleToUser, arg.UserID, arg.RoleName, arg.TargetTeamSlug)
	return err
}

const countRoles = `-- name: CountRoles :one
SELECT
	COUNT(*)
FROM
	roles
`

func (q *Queries) CountRoles(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRoles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT
	name, description, is_only_global
FROM
	roles
WHERE
	name = $1
`

func (q *Queries) GetRoleByName(ctx context.Context, name string) (*Role, error) {
	row := q.db.QueryRow(ctx, getRoleByName, name)
	var i Role
	err := row.Scan(&i.Name, &i.Description, &i.IsOnlyGlobal)
	return &i, err
}

const getRolesForServiceAccounts = `-- name: GetRolesForServiceAccounts :many
SELECT
	service_account_id,
	JSON_AGG(
		JSON_BUILD_OBJECT(
			'role_name',
			role_name,
			'target_team_slug',
			service_accounts.team_slug
		)
	) AS roles
FROM
	service_account_roles
	JOIN service_accounts ON service_accounts.id = service_account_roles.service_account_id
WHERE
	service_account_id = ANY ($1::UUID[])
GROUP BY
	service_account_id
ORDER BY
	service_account_id
`

type GetRolesForServiceAccountsRow struct {
	ServiceAccountID uuid.UUID
	Roles            []byte
}

func (q *Queries) GetRolesForServiceAccounts(ctx context.Context, serviceAccountIds []uuid.UUID) ([]*GetRolesForServiceAccountsRow, error) {
	rows, err := q.db.Query(ctx, getRolesForServiceAccounts, serviceAccountIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRolesForServiceAccountsRow{}
	for rows.Next() {
		var i GetRolesForServiceAccountsRow
		if err := rows.Scan(&i.ServiceAccountID, &i.Roles); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolesForUsers = `-- name: GetRolesForUsers :many
SELECT
	user_id,
	JSON_AGG(
		JSON_BUILD_OBJECT(
			'name',
			role_name,
			'target_team_slug',
			target_team_slug
		)
	) AS roles
FROM
	user_roles
WHERE
	user_id = ANY ($1::UUID[])
GROUP BY
	user_id
ORDER BY
	user_id
`

type GetRolesForUsersRow struct {
	UserID uuid.UUID
	Roles  []byte
}

// TODO: This should be rewritten to fetch rows from the roles table instead as it uses the authz.Role struct, which reflects rows from the roles table.
func (q *Queries) GetRolesForUsers(ctx context.Context, userIds []uuid.UUID) ([]*GetRolesForUsersRow, error) {
	rows, err := q.db.Query(ctx, getRolesForUsers, userIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRolesForUsersRow{}
	for rows.Next() {
		var i GetRolesForUsersRow
		if err := rows.Scan(&i.UserID, &i.Roles); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasGlobalAuthorization = `-- name: HasGlobalAuthorization :one
SELECT
	(
		EXISTS (
			SELECT
				a.name
			FROM
				authorizations a
				INNER JOIN role_authorizations ra ON ra.authorization_name = a.name
				INNER JOIN user_roles ur ON ur.role_name = ra.role_name
			WHERE
				ur.user_id = $1
				AND a.name = $2
				AND ur.target_team_slug IS NULL
		)
		OR EXISTS (
			SELECT
				id
			FROM
				user_roles
			WHERE
				user_id = $1
				AND role_name = 'Admin'
				AND target_team_slug IS NULL
		)
	)::BOOLEAN
`

type HasGlobalAuthorizationParams struct {
	UserID            uuid.UUID
	AuthorizationName string
}

func (q *Queries) HasGlobalAuthorization(ctx context.Context, arg HasGlobalAuthorizationParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasGlobalAuthorization, arg.UserID, arg.AuthorizationName)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const hasTeamAuthorization = `-- name: HasTeamAuthorization :one
SELECT
	(
		EXISTS (
			SELECT
				a.name
			FROM
				authorizations a
				INNER JOIN role_authorizations ra ON ra.authorization_name = a.name
				INNER JOIN user_roles ur ON ur.role_name = ra.role_name
			WHERE
				ur.user_id = $1
				AND a.name = $2
				AND (
					ur.target_team_slug = $3::slug
					OR ur.target_team_slug IS NULL
				)
		)
		OR EXISTS (
			SELECT
				1
			FROM
				user_roles
			WHERE
				user_id = $1
				AND role_name = 'Admin'
				AND target_team_slug IS NULL
		)
	)::BOOLEAN
`

type HasTeamAuthorizationParams struct {
	UserID            uuid.UUID
	AuthorizationName string
	TeamSlug          slug.Slug
}

func (q *Queries) HasTeamAuthorization(ctx context.Context, arg HasTeamAuthorizationParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasTeamAuthorization, arg.UserID, arg.AuthorizationName, arg.TeamSlug)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const isAdmin = `-- name: IsAdmin :one
SELECT
	EXISTS (
		SELECT
			1
		FROM
			user_roles
		WHERE
			user_id = $1
			AND role_name = 'Admin'
			AND target_team_slug IS NULL
	)
`

func (q *Queries) IsAdmin(ctx context.Context, userID uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isAdmin, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listRoles = `-- name: ListRoles :many
SELECT
	name, description, is_only_global
FROM
	roles
ORDER BY
	name ASC
OFFSET
	$1
LIMIT
	$2
`

type ListRolesParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) ListRoles(ctx context.Context, arg ListRolesParams) ([]*Role, error) {
	rows, err := q.db.Query(ctx, listRoles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.Name, &i.Description, &i.IsOnlyGlobal); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeGlobalAdmin = `-- name: RevokeGlobalAdmin :exec
DELETE FROM user_roles
WHERE
	user_id = $1
	AND role_name = 'Admin'
	AND target_team_slug IS NULL
`

func (q *Queries) RevokeGlobalAdmin(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeGlobalAdmin, userID)
	return err
}

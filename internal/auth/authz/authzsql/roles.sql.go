// Code generated by sqlc. DO NOT EDIT.
// source: roles.sql

package authzsql

import (
	"context"

	"github.com/google/uuid"
	"github.com/nais/api/internal/slug"
)

const assignGlobalRoleToUser = `-- name: AssignGlobalRoleToUser :exec
INSERT INTO
	user_roles (user_id, role_name)
VALUES
	($1, $2)
ON CONFLICT DO NOTHING
`

type AssignGlobalRoleToUserParams struct {
	UserID   uuid.UUID
	RoleName string
}

func (q *Queries) AssignGlobalRoleToUser(ctx context.Context, arg AssignGlobalRoleToUserParams) error {
	_, err := q.db.Exec(ctx, assignGlobalRoleToUser, arg.UserID, arg.RoleName)
	return err
}

const assignRoleToServiceAccount = `-- name: AssignRoleToServiceAccount :exec
INSERT INTO
	service_account_roles (service_account_id, role_name)
VALUES
	($1, $2)
ON CONFLICT DO NOTHING
`

type AssignRoleToServiceAccountParams struct {
	ServiceAccountID uuid.UUID
	RoleName         string
}

func (q *Queries) AssignRoleToServiceAccount(ctx context.Context, arg AssignRoleToServiceAccountParams) error {
	_, err := q.db.Exec(ctx, assignRoleToServiceAccount, arg.ServiceAccountID, arg.RoleName)
	return err
}

const assignTeamRoleToUser = `-- name: AssignTeamRoleToUser :exec
INSERT INTO
	user_roles (user_id, role_name, target_team_slug)
VALUES
	($1, $2, $3::slug)
ON CONFLICT DO NOTHING
`

type AssignTeamRoleToUserParams struct {
	UserID         uuid.UUID
	RoleName       string
	TargetTeamSlug slug.Slug
}

func (q *Queries) AssignTeamRoleToUser(ctx context.Context, arg AssignTeamRoleToUserParams) error {
	_, err := q.db.Exec(ctx, assignTeamRoleToUser, arg.UserID, arg.RoleName, arg.TargetTeamSlug)
	return err
}

const countRoles = `-- name: CountRoles :one
SELECT
	COUNT(*)
FROM
	roles
`

func (q *Queries) CountRoles(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRoles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRolesForServiceAccount = `-- name: CountRolesForServiceAccount :one
SELECT
	COUNT(*)
FROM
	service_account_roles
WHERE
	service_account_id = $1
`

func (q *Queries) CountRolesForServiceAccount(ctx context.Context, serviceAccountID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countRolesForServiceAccount, serviceAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT
	name, description, is_only_global
FROM
	roles
WHERE
	name = $1
`

func (q *Queries) GetRoleByName(ctx context.Context, name string) (*Role, error) {
	row := q.db.QueryRow(ctx, getRoleByName, name)
	var i Role
	err := row.Scan(&i.Name, &i.Description, &i.IsOnlyGlobal)
	return &i, err
}

const getRolesForServiceAccounts = `-- name: GetRolesForServiceAccounts :many
SELECT
	service_account_id,
	JSON_AGG(
		JSON_BUILD_OBJECT(
			'name',
			role.name,
			'description',
			role.description,
			'target_team_slug',
			service_accounts.team_slug
		)
	) AS roles
FROM
	service_account_roles
	JOIN service_accounts ON service_accounts.id = service_account_roles.service_account_id
	JOIN roles role ON role.name = service_account_roles.role_name
WHERE
	service_account_id = ANY ($1::UUID[])
GROUP BY
	service_account_id
ORDER BY
	service_account_id
`

type GetRolesForServiceAccountsRow struct {
	ServiceAccountID uuid.UUID
	Roles            []byte
}

func (q *Queries) GetRolesForServiceAccounts(ctx context.Context, serviceAccountIds []uuid.UUID) ([]*GetRolesForServiceAccountsRow, error) {
	rows, err := q.db.Query(ctx, getRolesForServiceAccounts, serviceAccountIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRolesForServiceAccountsRow{}
	for rows.Next() {
		var i GetRolesForServiceAccountsRow
		if err := rows.Scan(&i.ServiceAccountID, &i.Roles); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolesForUsers = `-- name: GetRolesForUsers :many
SELECT
	user_id,
	JSON_AGG(
		JSON_BUILD_OBJECT(
			'name',
			role_name,
			'target_team_slug',
			target_team_slug
		)
	) AS roles
FROM
	user_roles
WHERE
	user_id = ANY ($1::UUID[])
GROUP BY
	user_id
ORDER BY
	user_id
`

type GetRolesForUsersRow struct {
	UserID uuid.UUID
	Roles  []byte
}

// TODO: This should be rewritten to fetch rows from the roles table instead as it uses the authz.Role struct, which reflects rows from the roles table.
func (q *Queries) GetRolesForUsers(ctx context.Context, userIds []uuid.UUID) ([]*GetRolesForUsersRow, error) {
	rows, err := q.db.Query(ctx, getRolesForUsers, userIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRolesForUsersRow{}
	for rows.Next() {
		var i GetRolesForUsersRow
		if err := rows.Scan(&i.UserID, &i.Roles); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasGlobalAuthorization = `-- name: HasGlobalAuthorization :one
SELECT
	(
		EXISTS (
			SELECT
				1
			FROM
				authorizations a
				INNER JOIN role_authorizations ra ON ra.authorization_name = a.name
				INNER JOIN user_roles ur ON ur.role_name = ra.role_name
			WHERE
				ur.user_id = $1
				AND a.name = $2
				AND ur.target_team_slug IS NULL
		)
		OR EXISTS (
			SELECT
				1
			FROM
				users
			WHERE
				id = $1
				AND admin = TRUE
		)
	)::BOOLEAN
`

type HasGlobalAuthorizationParams struct {
	UserID            uuid.UUID
	AuthorizationName string
}

func (q *Queries) HasGlobalAuthorization(ctx context.Context, arg HasGlobalAuthorizationParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasGlobalAuthorization, arg.UserID, arg.AuthorizationName)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const hasTeamAuthorization = `-- name: HasTeamAuthorization :one
SELECT
	(
		EXISTS (
			SELECT
				1
			FROM
				authorizations a
				INNER JOIN role_authorizations ra ON ra.authorization_name = a.name
				INNER JOIN user_roles ur ON ur.role_name = ra.role_name
			WHERE
				ur.user_id = $1
				AND a.name = $2
				AND (
					ur.target_team_slug = $3::slug
					OR ur.target_team_slug IS NULL
				)
		)
		OR EXISTS (
			SELECT
				1
			FROM
				users
			WHERE
				id = $1
				AND admin = TRUE
		)
	)::BOOLEAN
`

type HasTeamAuthorizationParams struct {
	UserID            uuid.UUID
	AuthorizationName string
	TeamSlug          slug.Slug
}

func (q *Queries) HasTeamAuthorization(ctx context.Context, arg HasTeamAuthorizationParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasTeamAuthorization, arg.UserID, arg.AuthorizationName, arg.TeamSlug)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const listRoles = `-- name: ListRoles :many
SELECT
	name, description, is_only_global
FROM
	roles
ORDER BY
	name ASC
OFFSET
	$1
LIMIT
	$2
`

type ListRolesParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) ListRoles(ctx context.Context, arg ListRolesParams) ([]*Role, error) {
	rows, err := q.db.Query(ctx, listRoles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.Name, &i.Description, &i.IsOnlyGlobal); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRolesForServiceAccount = `-- name: ListRolesForServiceAccount :many
SELECT
	roles.name, roles.description, roles.is_only_global
FROM
	roles
	JOIN service_account_roles sar ON roles.name = sar.role_name
WHERE
	sar.service_account_id = $1
ORDER BY
	roles.name
OFFSET
	$2
LIMIT
	$3
`

type ListRolesForServiceAccountParams struct {
	ServiceAccountID uuid.UUID
	Offset           int32
	Limit            int32
}

func (q *Queries) ListRolesForServiceAccount(ctx context.Context, arg ListRolesForServiceAccountParams) ([]*Role, error) {
	rows, err := q.db.Query(ctx, listRolesForServiceAccount, arg.ServiceAccountID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.Name, &i.Description, &i.IsOnlyGlobal); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeRoleFromServiceAccount = `-- name: RevokeRoleFromServiceAccount :exec
DELETE FROM service_account_roles
WHERE
	service_account_id = $1
	AND role_name = $2
`

type RevokeRoleFromServiceAccountParams struct {
	ServiceAccountID uuid.UUID
	RoleName         string
}

func (q *Queries) RevokeRoleFromServiceAccount(ctx context.Context, arg RevokeRoleFromServiceAccountParams) error {
	_, err := q.db.Exec(ctx, revokeRoleFromServiceAccount, arg.ServiceAccountID, arg.RoleName)
	return err
}

const serviceAccountCanAssignRole = `-- name: ServiceAccountCanAssignRole :one
WITH
	inner_role_authorizations AS (
		SELECT
			ARRAY_AGG(authorization_name) AS authorizations
		FROM
			role_authorizations ra
		WHERE
			ra.role_name = $1
	),
	user_authorizations AS (
		SELECT
			ARRAY_AGG(ra.authorization_name) AS authorizations
		FROM
			role_authorizations ra
			JOIN service_account_roles sar ON sar.role_name = ra.role_name
			JOIN service_accounts sa ON sa.id = sar.service_account_id
		WHERE
			sar.service_account_id = $2
			AND (
				sa.team_slug IS NULL
				OR sa.team_slug = $3
			)
	)
SELECT
	(
		EXISTS (
			SELECT
				1
			FROM
				inner_role_authorizations
			WHERE
				authorizations <@ (
					SELECT
						authorizations
					FROM
						user_authorizations
				)
		)
	)::BOOLEAN
`

type ServiceAccountCanAssignRoleParams struct {
	RoleName         string
	ServiceAccountID uuid.UUID
	TeamSlug         *slug.Slug
}

func (q *Queries) ServiceAccountCanAssignRole(ctx context.Context, arg ServiceAccountCanAssignRoleParams) (bool, error) {
	row := q.db.QueryRow(ctx, serviceAccountCanAssignRole, arg.RoleName, arg.ServiceAccountID, arg.TeamSlug)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const serviceAccountHasGlobalAuthorization = `-- name: ServiceAccountHasGlobalAuthorization :one
SELECT
	(
		EXISTS (
			SELECT
				1
			FROM
				role_authorizations ra
				INNER JOIN service_account_roles sar ON sar.role_name = ra.role_name
				INNER JOIN service_accounts sa ON sa.id = sar.service_account_id
			WHERE
				sa.id = $1
				AND ra.authorization_name = $2
				AND sa.team_slug IS NULL
		)
	)::BOOLEAN
`

type ServiceAccountHasGlobalAuthorizationParams struct {
	ServiceAccountID  uuid.UUID
	AuthorizationName string
}

func (q *Queries) ServiceAccountHasGlobalAuthorization(ctx context.Context, arg ServiceAccountHasGlobalAuthorizationParams) (bool, error) {
	row := q.db.QueryRow(ctx, serviceAccountHasGlobalAuthorization, arg.ServiceAccountID, arg.AuthorizationName)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const serviceAccountHasRole = `-- name: ServiceAccountHasRole :one
SELECT
	EXISTS (
		SELECT
			1
		FROM
			service_account_roles
		WHERE
			service_account_id = $1
			AND role_name = $2
	)
`

type ServiceAccountHasRoleParams struct {
	ServiceAccountID uuid.UUID
	RoleName         string
}

func (q *Queries) ServiceAccountHasRole(ctx context.Context, arg ServiceAccountHasRoleParams) (bool, error) {
	row := q.db.QueryRow(ctx, serviceAccountHasRole, arg.ServiceAccountID, arg.RoleName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const serviceAccountHasTeamAuthorization = `-- name: ServiceAccountHasTeamAuthorization :one
SELECT
	(
		EXISTS (
			SELECT
				1
			FROM
				role_authorizations ra
				INNER JOIN service_account_roles sar ON sar.role_name = ra.role_name
				INNER JOIN service_accounts sa ON sa.id = sar.service_account_id
			WHERE
				sa.id = $1
				AND ra.authorization_name = $2
				AND (
					sa.team_slug IS NULL
					OR sa.team_slug = $3::slug
				)
		)
	)::BOOLEAN
`

type ServiceAccountHasTeamAuthorizationParams struct {
	ServiceAccountID  uuid.UUID
	AuthorizationName string
	TeamSlug          slug.Slug
}

func (q *Queries) ServiceAccountHasTeamAuthorization(ctx context.Context, arg ServiceAccountHasTeamAuthorizationParams) (bool, error) {
	row := q.db.QueryRow(ctx, serviceAccountHasTeamAuthorization, arg.ServiceAccountID, arg.AuthorizationName, arg.TeamSlug)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const userCanAssignRole = `-- name: UserCanAssignRole :one
WITH
	inner_role_authorizations AS (
		SELECT
			ARRAY_AGG(authorization_name) AS authorizations
		FROM
			role_authorizations ra
		WHERE
			ra.role_name = $2
	),
	user_authorizations AS (
		SELECT
			ARRAY_AGG(ra.authorization_name) AS authorizations
		FROM
			role_authorizations ra
			JOIN user_roles ur ON ur.role_name = ra.role_name
		WHERE
			ur.user_id = $1
			AND (
				ur.target_team_slug IS NULL
				OR ur.target_team_slug = $3
			)
	)
SELECT
	(
		EXISTS (
			SELECT
				1
			FROM
				inner_role_authorizations
			WHERE
				authorizations <@ (
					SELECT
						authorizations
					FROM
						user_authorizations
				)
		)
		OR EXISTS (
			SELECT
				1
			FROM
				users
			WHERE
				users.id = $1
				AND admin = TRUE
		)
	)::BOOLEAN
`

type UserCanAssignRoleParams struct {
	UserID         uuid.UUID
	RoleName       string
	TargetTeamSlug *slug.Slug
}

func (q *Queries) UserCanAssignRole(ctx context.Context, arg UserCanAssignRoleParams) (bool, error) {
	row := q.db.QueryRow(ctx, userCanAssignRole, arg.UserID, arg.RoleName, arg.TargetTeamSlug)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

// Code generated by sqlc. DO NOT EDIT.
// source: issue.sql

package issuesql

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getIssueByID = `-- name: GetIssueByID :one
SELECT
	id, issue_type, resource_name, resource_type, team, env, severity, message, issue_details, created_at
FROM
	issues
WHERE
	id = $1
`

func (q *Queries) GetIssueByID(ctx context.Context, id uuid.UUID) (*Issue, error) {
	row := q.db.QueryRow(ctx, getIssueByID, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IssueType,
		&i.ResourceName,
		&i.ResourceType,
		&i.Team,
		&i.Env,
		&i.Severity,
		&i.Message,
		&i.IssueDetails,
		&i.CreatedAt,
	)
	return &i, err
}

const getSeverityScoreForWorkload = `-- name: GetSeverityScoreForWorkload :one
SELECT
	SUM(
		CASE
			WHEN severity = 'CRITICAL'::severity_level THEN 10000
			WHEN severity = 'WARNING'::severity_level THEN 100
			WHEN severity = 'TODO'::severity_level THEN 1
			ELSE 0
		END
	) AS severity_score
FROM
	issues
WHERE
	resource_name = $1
	AND resource_type = $2
	AND env = $3
	AND team = $4
`

type GetSeverityScoreForWorkloadParams struct {
	ResourceName string
	ResourceType string
	Env          string
	Team         string
}

func (q *Queries) GetSeverityScoreForWorkload(ctx context.Context, arg GetSeverityScoreForWorkloadParams) (int64, error) {
	row := q.db.QueryRow(ctx, getSeverityScoreForWorkload,
		arg.ResourceName,
		arg.ResourceType,
		arg.Env,
		arg.Team,
	)
	var severity_score int64
	err := row.Scan(&severity_score)
	return severity_score, err
}

const listIssues = `-- name: ListIssues :many
SELECT
	id, issue_type, resource_name, resource_type, team, env, severity, message, issue_details, created_at,
	COUNT(*) OVER () AS total_count
FROM
	issues
WHERE
	team = $1
	AND (
		$2::TEXT[] IS NULL
		OR env = ANY ($2::TEXT[])
	)
	AND (
		$3::TEXT IS NULL
		OR issue_type = $3::TEXT
	)
	AND (
		$4::severity_level IS NULL
		OR severity = $4::severity_level
	)
	AND (
		$5::TEXT IS NULL
		OR resource_type = $5::TEXT
	)
	AND (
		$6::TEXT IS NULL
		OR resource_name = $6::TEXT
	)
ORDER BY
	CASE
		WHEN $7::TEXT = 'env:asc' THEN env
	END ASC,
	CASE
		WHEN $7::TEXT = 'env:desc' THEN env
	END DESC,
	CASE
		WHEN $7::TEXT = 'issue_type:asc' THEN issue_type
	END ASC,
	CASE
		WHEN $7::TEXT = 'issue_type:desc' THEN issue_type
	END DESC,
	CASE
		WHEN $7::TEXT = 'resource_type:asc' THEN resource_type
	END ASC,
	CASE
		WHEN $7::TEXT = 'resource_type:desc' THEN resource_type
	END DESC,
	CASE
		WHEN $7::TEXT = 'resource_name:asc' THEN resource_name
	END ASC,
	CASE
		WHEN $7::TEXT = 'resource_name:desc' THEN resource_name
	END DESC,
	CASE
		WHEN $7::TEXT = 'severity:asc' THEN severity
	END ASC,
	CASE
		WHEN $7::TEXT = 'severity:desc' THEN severity
	END DESC,
	severity DESC,
	id
OFFSET
	$8
LIMIT
	$9
`

type ListIssuesParams struct {
	Team         string
	Env          []string
	IssueType    *string
	Severity     NullSeverityLevel
	ResourceType *string
	ResourceName *string
	OrderBy      string
	Offset       int32
	Limit        int32
}

type ListIssuesRow struct {
	ID           uuid.UUID
	IssueType    string
	ResourceName string
	ResourceType string
	Team         string
	Env          string
	Severity     SeverityLevel
	Message      string
	IssueDetails []byte
	CreatedAt    pgtype.Timestamptz
	TotalCount   int64
}

func (q *Queries) ListIssues(ctx context.Context, arg ListIssuesParams) ([]*ListIssuesRow, error) {
	rows, err := q.db.Query(ctx, listIssues,
		arg.Team,
		arg.Env,
		arg.IssueType,
		arg.Severity,
		arg.ResourceType,
		arg.ResourceName,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListIssuesRow{}
	for rows.Next() {
		var i ListIssuesRow
		if err := rows.Scan(
			&i.ID,
			&i.IssueType,
			&i.ResourceName,
			&i.ResourceType,
			&i.Team,
			&i.Env,
			&i.Severity,
			&i.Message,
			&i.IssueDetails,
			&i.CreatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

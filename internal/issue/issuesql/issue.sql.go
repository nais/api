// Code generated by sqlc. DO NOT EDIT.
// source: issue.sql

package issuesql

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getIssueByID = `-- name: GetIssueByID :one
SELECT
	id, issue_type, resource_name, resource_type, team, env, severity, message, issue_details, created_at
FROM
	issues
WHERE
	id = $1
`

func (q *Queries) GetIssueByID(ctx context.Context, id uuid.UUID) (*Issue, error) {
	row := q.db.QueryRow(ctx, getIssueByID, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IssueType,
		&i.ResourceName,
		&i.ResourceType,
		&i.Team,
		&i.Env,
		&i.Severity,
		&i.Message,
		&i.IssueDetails,
		&i.CreatedAt,
	)
	return &i, err
}

const listIssuesForTeam = `-- name: ListIssuesForTeam :many
SELECT
	id, issue_type, resource_name, resource_type, team, env, severity, message, issue_details, created_at,
	COUNT(*) OVER () AS total_count
FROM
	issues
WHERE
	team = $1
	AND (
		$2::TEXT[] IS NULL
		OR env = ANY ($2::TEXT[])
	)
	AND (
		$3::TEXT IS NULL
		OR issue_type = $3::TEXT
	)
	AND (
		$4::TEXT IS NULL
		OR severity = $4::TEXT
	)
	AND (
		$5::TEXT IS NULL
		OR resource_type = $5::TEXT
	)
ORDER BY
	CASE
		WHEN $6::TEXT = 'env:asc' THEN env
	END ASC,
	CASE
		WHEN $6::TEXT = 'env:desc' THEN env
	END DESC,
	CASE
		WHEN $6::TEXT = 'issue_type:asc' THEN issue_type
	END ASC,
	CASE
		WHEN $6::TEXT = 'issue_type:desc' THEN issue_type
	END DESC,
	CASE
		WHEN $6::TEXT = 'resource_type:asc' THEN resource_type
	END ASC,
	CASE
		WHEN $6::TEXT = 'resource_type:desc' THEN resource_type
	END DESC,
	CASE
		WHEN $6::TEXT = 'resource_name:asc' THEN resource_name
	END ASC,
	CASE
		WHEN $6::TEXT = 'resource_name:desc' THEN resource_name
	END DESC,
	CASE
		WHEN $6::TEXT = 'severity:asc' THEN severity
	END ASC,
	CASE
		WHEN $6::TEXT = 'severity:desc' THEN severity
	END DESC,
	severity,
	id
OFFSET
	$7
LIMIT
	$8
`

type ListIssuesForTeamParams struct {
	Team         string
	Env          []string
	IssueType    *string
	Severity     *string
	ResourceType *string
	OrderBy      string
	Offset       int32
	Limit        int32
}

type ListIssuesForTeamRow struct {
	ID           uuid.UUID
	IssueType    string
	ResourceName string
	ResourceType string
	Team         string
	Env          string
	Severity     string
	Message      string
	IssueDetails []byte
	CreatedAt    pgtype.Timestamptz
	TotalCount   int64
}

func (q *Queries) ListIssuesForTeam(ctx context.Context, arg ListIssuesForTeamParams) ([]*ListIssuesForTeamRow, error) {
	rows, err := q.db.Query(ctx, listIssuesForTeam,
		arg.Team,
		arg.Env,
		arg.IssueType,
		arg.Severity,
		arg.ResourceType,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListIssuesForTeamRow{}
	for rows.Next() {
		var i ListIssuesForTeamRow
		if err := rows.Scan(
			&i.ID,
			&i.IssueType,
			&i.ResourceName,
			&i.ResourceType,
			&i.Team,
			&i.Env,
			&i.Severity,
			&i.Message,
			&i.IssueDetails,
			&i.CreatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

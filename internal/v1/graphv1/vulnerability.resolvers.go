package graphv1

import (
	"context"
	"fmt"

	"github.com/nais/api/internal/v1/graphv1/gengqlv1"
	"github.com/nais/api/internal/v1/graphv1/pagination"
	"github.com/nais/api/internal/v1/team"
	"github.com/nais/api/internal/v1/vulnerability"
	"github.com/nais/api/internal/v1/workload"
	"github.com/nais/api/internal/v1/workload/application"
	"github.com/nais/api/internal/v1/workload/job"
)

func (r *containerImageResolver) HasSbom(ctx context.Context, obj *workload.ContainerImage) (bool, error) {
	metadata, err := vulnerability.GetImageMetadata(ctx, obj.Ref())
	if err != nil {
		return false, err
	}
	return metadata.HasSBOM, nil
}

func (r *containerImageResolver) Vulnerabilities(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *vulnerability.ImageVulnerabilityOrder) (*pagination.Connection[*vulnerability.ImageVulnerability], error) {
	panic(fmt.Errorf("not implemented: Vulnerabilities - vulnerabilities"))
}

func (r *containerImageResolver) VulnerabilitySummary(ctx context.Context, obj *workload.ContainerImage) (*vulnerability.ImageVulnerabilitySummary, error) {
	metadata, err := vulnerability.GetImageMetadata(ctx, obj.Ref())
	if err != nil {
		return nil, err
	}

	return metadata.Summary, nil
}

func (r *containerImageResolver) WorkloadReferences(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ContainerImageWorkloadReference], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListWorkloadReferences(ctx, obj.Ref(), page)
}

func (r *containerImageWorkloadReferenceResolver) Workload(ctx context.Context, obj *vulnerability.ContainerImageWorkloadReference) (workload.Workload, error) {
	return getWorkload(ctx, obj.Reference, obj.TeamSlug, obj.EnvironmentName)
}

func (r *teamResolver) VulnerabilitySummary(ctx context.Context, obj *team.Team) (*vulnerability.TeamVulnerabilitySummary, error) {
	images, err := vulnerability.GetTeamMetadata(ctx, obj.Slug)
	if err != nil {
		return nil, fmt.Errorf("getting metadata for team %q: %w", obj.Slug, err)
	}

	retVal := &vulnerability.TeamVulnerabilitySummary{
		TeamSlug: obj.Slug,
	}
	for _, image := range images {
		if image.Summary == nil {
			continue
		}
		if image.Summary.Critical > 0 {
			retVal.Critical += image.Summary.Critical
		}
		if image.Summary.High > 0 {
			retVal.High += image.Summary.High
		}
		if image.Summary.Medium > 0 {
			retVal.Medium += image.Summary.Medium
		}
		if image.Summary.Low > 0 {
			retVal.Low += image.Summary.Low
		}
		if image.Summary.Unassigned > 0 {
			retVal.Unassigned += image.Summary.Unassigned
		}
		if image.Summary.RiskScore > 0 {
			retVal.RiskScore += image.Summary.RiskScore
		}
	}

	apps := application.ListAllForTeam(ctx, obj.Slug)
	jobs := job.ListAllForTeam(ctx, obj.Slug)

	if len(apps) == 0 && len(jobs) == 0 {
		retVal.Coverage = 0.0
	} else {
		retVal.Coverage = float64(retVal.BomCount) / float64(len(apps)+len(jobs)) * 100
	}

	return retVal, nil
}

func (r *teamVulnerabilitySummaryResolver) Ranking(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRanking, error) {
	return vulnerability.GetTeamRanking(ctx, obj.TeamSlug)
}

func (r *teamVulnerabilitySummaryResolver) RiskScoreTrend(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRiskScoreTrend, error) {
	return vulnerability.GetTeamRiskScoreTrend(ctx, obj.TeamSlug)
}

func (r *Resolver) ContainerImageWorkloadReference() gengqlv1.ContainerImageWorkloadReferenceResolver {
	return &containerImageWorkloadReferenceResolver{r}
}

func (r *Resolver) TeamVulnerabilitySummary() gengqlv1.TeamVulnerabilitySummaryResolver {
	return &teamVulnerabilitySummaryResolver{r}
}

type (
	containerImageWorkloadReferenceResolver struct{ *Resolver }
	teamVulnerabilitySummaryResolver        struct{ *Resolver }
)

extend type Team {
	"NAIS jobs owned by the team."
	jobs(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: JobOrder
	): JobConnection!
}

extend type Mutation {
	"Delete a job."
	deleteJob(input: DeleteJobInput!): DeleteJobPayload!

	"Trigger a job"
	triggerJob(input: TriggerJobInput!): TriggerJobPayload!
}

extend type TeamEnvironment {
	"NAIS job in the team environment."
	job(name: String!): Job!
}

type Job implements Node & Workload {
	"The globally unique ID of the job."
	id: ID!

	"The name of the job."
	name: String!

	"The team that owns the job."
	team: Team!

	"The environment the job is deployed in."
	environment: TeamEnvironment!

	"The container image of the job."
	image: ContainerImage!

	"Resources for the job."
	resources: JobResources!

	"List of authentication and authorization for the job."
	authIntegrations: [JobAuthIntegrations!]!

	"Optional schedule for the job. Jobs with no schedule are run once."
	schedule: JobSchedule

	"The job runs."
	runs(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): JobRunConnection!

	"The job manifest."
	manifest: JobManifest!
}

type JobManifest implements WorkloadManifest {
	"The manifest content, serialized as a YAML document."
	content: String!
}

type JobSchedule {
	"The cron expression for the job."
	expression: String!

	"The time zone for the job. Defaults to UTC."
	timeZone: String!
}

union JobAuthIntegrations = EntraIDAuthIntegration | MaskinportenAuthIntegration

type JobResources implements WorkloadResources {
	limits: WorkloadResourceQuantity!
	requests: WorkloadResourceQuantity!
}

type JobRun implements Node {
	"The globally unique ID of the job run."
	id: ID!

	"The name of the job run."
	name: String!

	"The start time of the job."
	startTime: Time

	"The completion time of the job."
	completionTime: Time

	"The status of the job run."
	status: JobRunStatus!

	image: ContainerImage!

	# podNames: [String!]!
	# duration: String!
	# image: String!
	# message: String!
	# failed: Boolean!
}

enum JobRunStatus {
	"Job run is pending."
	PENDING

	"Job run is running."
	RUNNING

	"Job run is succeeded."
	SUCCEEDED

	"Job run is failed."
	FAILED

	"Job run is unknown."
	UNKNOWN
}

type JobConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Job!]!

	"List of edges."
	edges: [JobEdge!]!
}

type JobRunConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [JobRun!]!

	"List of edges."
	edges: [JobRunEdge!]!
}

type JobEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The job."
	node: Job!
}

type JobRunEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The job run."
	node: JobRun!
}

input JobOrder {
	"The field to order items by."
	field: JobOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

enum JobOrderField {
	"Order jobs by name."
	NAME

	"Order jobs by status."
	STATUS

	"Order jobs by the name of the environment."
	ENVIRONMENT

	"Order Jobs by the deployment time."
	DEPLOYMENT_TIME
}

extend union SearchNode = Job
extend enum SearchType {
	JOB
}

input DeleteJobInput {
	"Name of the job."
	name: String!
	"Slug of the team that owns the job."
	teamSlug: Slug!
	"Name of the environment where the job runs."
	environmentName: String!
}

type DeleteJobPayload {
	"The team that owned the deleted job."
	team: Team
}

input TriggerJobInput {
	"Name of the job."
	name: String!
	"Slug of the team that owns the job."
	teamSlug: Slug!
	"Name of the environment where the job runs."
	environmentName: String!
	"Name of the new run. Must be unique within the team."
	runName: String!
}

type TriggerJobPayload {
	"The job that was triggered."
	job: Job
	"The new job run."
	jobRun: JobRun
}

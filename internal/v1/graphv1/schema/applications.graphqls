extend type Team {
	"NAIS applications owned by the team."
	applications(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: ApplicationOrder

		"Filtering options for items returned from the connection."
		filter: TeamApplicationsFilter
	): ApplicationConnection!
}

extend type TeamEnvironment {
	"NAIS application in the team environment."
	application(name: String!): Application!
}

extend type Mutation {
	"Delete an application."
	deleteApplication(input: DeleteApplicationInput!): DeleteApplicationPayload!

	"Restart an application."
	restartApplication(input: RestartApplicationInput!): RestartApplicationPayload!
}

extend type TeamInventoryCounts {
	applications: TeamInventoryCountApplications!
}

type TeamInventoryCountApplications {
	"Total number of applications."
	total: Int!

	"Number of applications considered not nais."
	notNais: Int!
}

"""
TODO: write
"""
type Application implements Node & Workload {
	"The globally unique ID of the application."
	id: ID!

	"The name of the application."
	name: String!

	"The team that owns the application."
	team: Team!

	"The environment the application is deployed in."
	environment: TeamEnvironment!

	"The container image of the application."
	image: ContainerImage!

	"Resources for the application."
	resources: ApplicationResources!

	"List of ingresses for the application."
	ingresses: [Ingress!]!

	"List of authentication and authorization for the application."
	authIntegrations: [ApplicationAuthIntegrations!]!

	"The application manifest."
	manifest: ApplicationManifest!

	instances(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): ApplicationInstanceConnection!
}

input TeamApplicationsFilter {
	name: String!
}

type ApplicationManifest implements WorkloadManifest {
	"The manifest content, serialized as a YAML document."
	content: String!
}

union ApplicationAuthIntegrations =
	| EntraIDAuthIntegration
	| IDPortenAuthIntegration
	| MaskinportenAuthIntegration
	| TokenXAuthIntegration

type ApplicationResources implements WorkloadResources {
	"Instances using resources above this threshold will be killed."
	limits: WorkloadResourceQuantity!

	"How many resources are allocated to each instance."
	requests: WorkloadResourceQuantity!

	"Scaling strategies for the application."
	scaling: ApplicationScaling!
}

"""
TODO: write
"""
type ApplicationScaling {
	"The minimum number of application instances."
	minInstances: Int!

	"The maximum number of application instances."
	maxInstances: Int!

	"Scaling strategies for the application."
	strategies: [ScalingStrategy!]!
}

union ScalingStrategy = CPUScalingStrategy | KafkaLagScalingStrategy

"""
A scaling strategy based on CPU usage

Read more: https://docs.nais.io/workloads/application/reference/automatic-scaling/#cpu-based-scaling
"""
type CPUScalingStrategy {
	"The threshold that must be met for the scaling to trigger."
	threshold: Int!
}

type KafkaLagScalingStrategy {
	"The threshold that must be met for the scaling to trigger."
	threshold: Int!

	"The consumer group of the topic."
	consumerGroup: String!

	"The name of the Kafka topic."
	topicName: String!
}

type ApplicationConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Application!]!

	"List of edges."
	edges: [ApplicationEdge!]!
}

type ApplicationEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The application."
	node: Application!
}

"Ordering options when fetching applications."
input ApplicationOrder {
	"The field to order items by."
	field: ApplicationOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

enum ApplicationOrderField {
	"Order applications by name."
	NAME

	"Order applications by the name of the environment."
	ENVIRONMENT
}

extend union SearchNode = Application
extend enum SearchType {
	APPLICATION
}

input DeleteApplicationInput {
	"Name of the application."
	name: String!

	"Slug of the team that owns the application."
	teamSlug: Slug!

	"Name of the environment where the application runs."
	environmentName: String!
}

type DeleteApplicationPayload {
	"The team that owned the deleted application."
	team: Team

	"Whether or not the application was deleted."
	success: Boolean
}

input RestartApplicationInput {
	"Name of the application."
	name: String!

	"Slug of the team that owns the application."
	teamSlug: Slug!

	"Name of the environment where the application runs."
	environmentName: String!
}

type RestartApplicationPayload {
	"The application that was restarted."
	application: Application
}

type Ingress {
	"URL for the ingress."
	url: String!

	"Type of ingress."
	type: IngressType!
}

enum IngressType {
	UNKNOWN
	EXTERNAL
	INTERNAL
	AUTHENTICATED
}

type ApplicationInstance implements Node {
	id: ID!
	name: String!
	image: ContainerImage!
	restarts: Int!
	created: Time!
	status: ApplicationInstanceStatus!
}

type ApplicationInstanceStatus {
	state: ApplicationInstanceState!
	message: String!
}

enum ApplicationInstanceState {
	RUNNING
	FAILING
	UNKNOWN
}

type ApplicationInstanceConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [ApplicationInstance!]!

	"List of edges."
	edges: [ApplicationInstanceEdge!]!
}

type ApplicationInstanceEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The instance."
	node: ApplicationInstance!
}

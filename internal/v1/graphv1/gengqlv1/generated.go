// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gengqlv1

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/v1/auditv1"
	"github.com/nais/api/internal/v1/cost"
	"github.com/nais/api/internal/v1/github/repository"
	"github.com/nais/api/internal/v1/graphv1/ident"
	"github.com/nais/api/internal/v1/graphv1/modelv1"
	"github.com/nais/api/internal/v1/graphv1/pagination"
	"github.com/nais/api/internal/v1/graphv1/scalar"
	"github.com/nais/api/internal/v1/persistence"
	"github.com/nais/api/internal/v1/persistence/bigquery"
	"github.com/nais/api/internal/v1/persistence/bucket"
	"github.com/nais/api/internal/v1/persistence/kafkatopic"
	"github.com/nais/api/internal/v1/persistence/opensearch"
	"github.com/nais/api/internal/v1/persistence/redis"
	"github.com/nais/api/internal/v1/persistence/sqlinstance"
	"github.com/nais/api/internal/v1/reconciler"
	"github.com/nais/api/internal/v1/searchv1"
	"github.com/nais/api/internal/v1/team"
	"github.com/nais/api/internal/v1/user"
	"github.com/nais/api/internal/v1/utilization"
	"github.com/nais/api/internal/v1/vulnerability"
	"github.com/nais/api/internal/v1/workload"
	"github.com/nais/api/internal/v1/workload/application"
	"github.com/nais/api/internal/v1/workload/job"
	"github.com/nais/api/internal/v1/workload/netpol"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Application() ApplicationResolver
	BigQueryDataset() BigQueryDatasetResolver
	Bucket() BucketResolver
	ContainerImage() ContainerImageResolver
	ContainerImageWorkloadReference() ContainerImageWorkloadReferenceResolver
	DeleteApplicationPayload() DeleteApplicationPayloadResolver
	DeleteJobPayload() DeleteJobPayloadResolver
	Job() JobResolver
	KafkaTopic() KafkaTopicResolver
	KafkaTopicAcl() KafkaTopicAclResolver
	Mutation() MutationResolver
	NetworkPolicyRule() NetworkPolicyRuleResolver
	OpenSearch() OpenSearchResolver
	OpenSearchAccess() OpenSearchAccessResolver
	Query() QueryResolver
	Reconciler() ReconcilerResolver
	RedisInstance() RedisInstanceResolver
	RedisInstanceAccess() RedisInstanceAccessResolver
	RemoveTeamMemberPayload() RemoveTeamMemberPayloadResolver
	Repository() RepositoryResolver
	RestartApplicationPayload() RestartApplicationPayloadResolver
	SqlDatabase() SqlDatabaseResolver
	SqlInstance() SqlInstanceResolver
	Team() TeamResolver
	TeamCost() TeamCostResolver
	TeamDeleteKey() TeamDeleteKeyResolver
	TeamEnvironment() TeamEnvironmentResolver
	TeamMember() TeamMemberResolver
	TeamMemberAddedAuditEntryData() TeamMemberAddedAuditEntryDataResolver
	TeamMemberRemovedAuditEntryData() TeamMemberRemovedAuditEntryDataResolver
	TeamMemberSetRoleAuditEntryData() TeamMemberSetRoleAuditEntryDataResolver
	TeamUtilizationData() TeamUtilizationDataResolver
	TeamUtilizationEnvironmentDataPoint() TeamUtilizationEnvironmentDataPointResolver
	User() UserResolver
	WorkloadCost() WorkloadCostResolver
	WorkloadUtilization() WorkloadUtilizationResolver
	WorkloadUtilizationData() WorkloadUtilizationDataResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AddRepositoryToTeamPayload struct {
		Repository func(childComplexity int) int
	}

	AddTeamMemberPayload struct {
		Member func(childComplexity int) int
	}

	Application struct {
		AuthIntegrations func(childComplexity int) int
		BigQueryDatasets func(childComplexity int, orderBy *bigquery.BigQueryDatasetOrder) int
		Buckets          func(childComplexity int, orderBy *bucket.BucketOrder) int
		Cost             func(childComplexity int) int
		Environment      func(childComplexity int) int
		ID               func(childComplexity int) int
		Image            func(childComplexity int) int
		Ingresses        func(childComplexity int) int
		KafkaTopicAcls   func(childComplexity int, orderBy *kafkatopic.KafkaTopicACLOrder) int
		Manifest         func(childComplexity int) int
		Name             func(childComplexity int) int
		NetworkPolicy    func(childComplexity int) int
		OpenSearch       func(childComplexity int) int
		RedisInstances   func(childComplexity int, orderBy *redis.RedisInstanceOrder) int
		Resources        func(childComplexity int) int
		SQLInstances     func(childComplexity int, orderBy *sqlinstance.SQLInstanceOrder) int
		Team             func(childComplexity int) int
		Utilization      func(childComplexity int) int
	}

	ApplicationConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ApplicationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ApplicationManifest struct {
		Content func(childComplexity int) int
	}

	ApplicationResources struct {
		Limits   func(childComplexity int) int
		Requests func(childComplexity int) int
		Scaling  func(childComplexity int) int
	}

	ApplicationScaling struct {
		MaxInstances func(childComplexity int) int
		MinInstances func(childComplexity int) int
		Strategies   func(childComplexity int) int
	}

	AuditEntryConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	AuditEntryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BigQueryDataset struct {
		Access          func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bigquery.BigQueryDatasetAccessOrder) int
		CascadingDelete func(childComplexity int) int
		Cost            func(childComplexity int) int
		Description     func(childComplexity int) int
		Environment     func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Status          func(childComplexity int) int
		Team            func(childComplexity int) int
		Workload        func(childComplexity int) int
	}

	BigQueryDatasetAccess struct {
		Email func(childComplexity int) int
		Role  func(childComplexity int) int
	}

	BigQueryDatasetAccessConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	BigQueryDatasetAccessEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BigQueryDatasetConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	BigQueryDatasetCost struct {
		Sum func(childComplexity int) int
	}

	BigQueryDatasetEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BigQueryDatasetStatus struct {
		CreationTime     func(childComplexity int) int
		LastModifiedTime func(childComplexity int) int
	}

	Bucket struct {
		CascadingDelete          func(childComplexity int) int
		Environment              func(childComplexity int) int
		ID                       func(childComplexity int) int
		Name                     func(childComplexity int) int
		PublicAccessPrevention   func(childComplexity int) int
		Status                   func(childComplexity int) int
		Team                     func(childComplexity int) int
		UniformBucketLevelAccess func(childComplexity int) int
		Workload                 func(childComplexity int) int
	}

	BucketConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	BucketEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BucketStatus struct {
		State func(childComplexity int) int
	}

	CPUScalingStrategy struct {
		Threshold func(childComplexity int) int
	}

	ConfirmTeamDeletionPayload struct {
		DeletionStarted func(childComplexity int) int
	}

	ContainerImage struct {
		HasSbom              func(childComplexity int) int
		ID                   func(childComplexity int) int
		Name                 func(childComplexity int) int
		Tag                  func(childComplexity int) int
		Vulnerabilities      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *vulnerability.ImageVulnerabilityOrder) int
		VulnerabilitySummary func(childComplexity int) int
		WorkloadReferences   func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
	}

	ContainerImageWorkloadReference struct {
		Workload func(childComplexity int) int
	}

	ContainerImageWorkloadReferenceConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ContainerImageWorkloadReferenceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	CreateTeamPayload struct {
		Team func(childComplexity int) int
	}

	DeleteApplicationPayload struct {
		Team func(childComplexity int) int
	}

	DeleteJobPayload struct {
		Team func(childComplexity int) int
	}

	EntraIDAuthIntegration struct {
		Name func(childComplexity int) int
	}

	ExternalNetworkPolicyHost struct {
		Ports  func(childComplexity int) int
		Target func(childComplexity int) int
	}

	ExternalNetworkPolicyIpv4 struct {
		Ports  func(childComplexity int) int
		Target func(childComplexity int) int
	}

	IDPortenAuthIntegration struct {
		Name func(childComplexity int) int
	}

	ImageVulnerability struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Identifier  func(childComplexity int) int
		Package     func(childComplexity int) int
		Severity    func(childComplexity int) int
		State       func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	ImageVulnerabilityConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ImageVulnerabilityEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ImageVulnerabilitySummary struct {
		Critical   func(childComplexity int) int
		High       func(childComplexity int) int
		Low        func(childComplexity int) int
		Medium     func(childComplexity int) int
		RiskScore  func(childComplexity int) int
		Total      func(childComplexity int) int
		Unassigned func(childComplexity int) int
	}

	InboundNetworkPolicy struct {
		Rules func(childComplexity int) int
	}

	Job struct {
		AuthIntegrations func(childComplexity int) int
		BigQueryDatasets func(childComplexity int, orderBy *bigquery.BigQueryDatasetOrder) int
		Buckets          func(childComplexity int, orderBy *bucket.BucketOrder) int
		Cost             func(childComplexity int) int
		Environment      func(childComplexity int) int
		ID               func(childComplexity int) int
		Image            func(childComplexity int) int
		KafkaTopicAcls   func(childComplexity int, orderBy *kafkatopic.KafkaTopicACLOrder) int
		Manifest         func(childComplexity int) int
		Name             func(childComplexity int) int
		NetworkPolicy    func(childComplexity int) int
		OpenSearch       func(childComplexity int) int
		RedisInstances   func(childComplexity int, orderBy *redis.RedisInstanceOrder) int
		Resources        func(childComplexity int) int
		Runs             func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		SQLInstances     func(childComplexity int, orderBy *sqlinstance.SQLInstanceOrder) int
		Schedule         func(childComplexity int) int
		Team             func(childComplexity int) int
	}

	JobConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	JobEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	JobManifest struct {
		Content func(childComplexity int) int
	}

	JobResources struct {
		Limits   func(childComplexity int) int
		Requests func(childComplexity int) int
	}

	JobRun struct {
		CompletionTime func(childComplexity int) int
		ID             func(childComplexity int) int
		Image          func(childComplexity int) int
		Name           func(childComplexity int) int
		StartTime      func(childComplexity int) int
		Status         func(childComplexity int) int
	}

	JobRunConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	JobRunEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	JobSchedule struct {
		Expression func(childComplexity int) int
		TimeZone   func(childComplexity int) int
	}

	KafkaLagScalingStrategy struct {
		ConsumerGroup func(childComplexity int) int
		Threshold     func(childComplexity int) int
		TopicName     func(childComplexity int) int
	}

	KafkaTopic struct {
		ACL           func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter *kafkatopic.KafkaTopicACLFilter, orderBy *kafkatopic.KafkaTopicACLOrder) int
		Configuration func(childComplexity int) int
		Environment   func(childComplexity int) int
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Pool          func(childComplexity int) int
		Status        func(childComplexity int) int
		Team          func(childComplexity int) int
	}

	KafkaTopicAcl struct {
		Access       func(childComplexity int) int
		Team         func(childComplexity int) int
		TeamName     func(childComplexity int) int
		Topic        func(childComplexity int) int
		Workload     func(childComplexity int) int
		WorkloadName func(childComplexity int) int
	}

	KafkaTopicAclConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	KafkaTopicAclEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	KafkaTopicConfiguration struct {
		CleanupPolicy         func(childComplexity int) int
		MaxMessageBytes       func(childComplexity int) int
		MinimumInSyncReplicas func(childComplexity int) int
		Partitions            func(childComplexity int) int
		Replication           func(childComplexity int) int
		RetentionBytes        func(childComplexity int) int
		RetentionHours        func(childComplexity int) int
		SegmentHours          func(childComplexity int) int
	}

	KafkaTopicConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	KafkaTopicEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	KafkaTopicStatus struct {
		State func(childComplexity int) int
	}

	MaskinportenAuthIntegration struct {
		Name func(childComplexity int) int
	}

	Mutation struct {
		AddRepositoryToTeam      func(childComplexity int, input repository.AddRepositoryToTeamInput) int
		AddTeamMember            func(childComplexity int, input team.AddTeamMemberInput) int
		ConfigureReconciler      func(childComplexity int, name string, config []*reconciler.ReconcilerConfigInput) int
		ConfirmTeamDeletion      func(childComplexity int, input team.ConfirmTeamDeletionInput) int
		CreateTeam               func(childComplexity int, input team.CreateTeamInput) int
		DeleteApplication        func(childComplexity int, input application.DeleteApplicationInput) int
		DeleteJob                func(childComplexity int, input job.DeleteJobInput) int
		DisableReconciler        func(childComplexity int, name string) int
		EnableReconciler         func(childComplexity int, name string) int
		RemoveRepositoryFromTeam func(childComplexity int, input repository.RemoveRepositoryFromTeamInput) int
		RemoveTeamMember         func(childComplexity int, input team.RemoveTeamMemberInput) int
		RequestTeamDeletion      func(childComplexity int, input team.RequestTeamDeletionInput) int
		RestartApplication       func(childComplexity int, input application.RestartApplicationInput) int
		SetTeamMemberRole        func(childComplexity int, input team.SetTeamMemberRoleInput) int
		SynchronizeTeam          func(childComplexity int, input team.SynchronizeTeamInput) int
		UpdateTeam               func(childComplexity int, input team.UpdateTeamInput) int
		UpdateTeamEnvironment    func(childComplexity int, input team.UpdateTeamEnvironmentInput) int
	}

	NetworkPolicy struct {
		Inbound  func(childComplexity int) int
		Outbound func(childComplexity int) int
	}

	NetworkPolicyRule struct {
		Mutual             func(childComplexity int) int
		TargetTeam         func(childComplexity int) int
		TargetTeamSlug     func(childComplexity int) int
		TargetWorkload     func(childComplexity int) int
		TargetWorkloadName func(childComplexity int) int
	}

	OpenSearch struct {
		Access      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *opensearch.OpenSearchAccessOrder) int
		Cost        func(childComplexity int) int
		Environment func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Status      func(childComplexity int) int
		Team        func(childComplexity int) int
		Workload    func(childComplexity int) int
	}

	OpenSearchAccess struct {
		Access   func(childComplexity int) int
		Workload func(childComplexity int) int
	}

	OpenSearchAccessConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	OpenSearchAccessEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	OpenSearchConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	OpenSearchCost struct {
		Sum func(childComplexity int) int
	}

	OpenSearchEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	OpenSearchStatus struct {
		State func(childComplexity int) int
	}

	OutboundNetworkPolicy struct {
		External func(childComplexity int) int
		Rules    func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		PageEnd         func(childComplexity int) int
		PageStart       func(childComplexity int) int
		StartCursor     func(childComplexity int) int
		TotalCount      func(childComplexity int) int
	}

	Query struct {
		Me               func(childComplexity int) int
		Node             func(childComplexity int, id ident.Ident) int
		Reconcilers      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Search           func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter searchv1.SearchFilter) int
		Team             func(childComplexity int, slug slug.Slug) int
		Teams            func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.TeamOrder) int
		TeamsUtilization func(childComplexity int, resourceType utilization.UtilizationResourceType) int
		User             func(childComplexity int, id ident.Ident) int
		Users            func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *user.UserOrder) int
	}

	Reconciler struct {
		Config      func(childComplexity int) int
		Configured  func(childComplexity int) int
		Description func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Enabled     func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	ReconcilerConfig struct {
		Configured  func(childComplexity int) int
		Description func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Key         func(childComplexity int) int
		Secret      func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	ReconcilerConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ReconcilerEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RedisInstance struct {
		Access      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *redis.RedisInstanceAccessOrder) int
		Cost        func(childComplexity int) int
		Environment func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Status      func(childComplexity int) int
		Team        func(childComplexity int) int
		Workload    func(childComplexity int) int
	}

	RedisInstanceAccess struct {
		Access   func(childComplexity int) int
		Workload func(childComplexity int) int
	}

	RedisInstanceAccessConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	RedisInstanceAccessEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RedisInstanceConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	RedisInstanceCost struct {
		Sum func(childComplexity int) int
	}

	RedisInstanceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RedisInstanceStatus struct {
		State func(childComplexity int) int
	}

	RemoveRepositoryFromTeamPayload struct {
		Success func(childComplexity int) int
	}

	RemoveTeamMemberPayload struct {
		Team func(childComplexity int) int
		User func(childComplexity int) int
	}

	Repository struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
		Team func(childComplexity int) int
	}

	RepositoryConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	RepositoryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RequestTeamDeletionPayload struct {
		Key func(childComplexity int) int
	}

	RestartApplicationPayload struct {
		Application func(childComplexity int) int
	}

	SearchNodeConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	SearchNodeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ServiceCost struct {
		Cost    func(childComplexity int) int
		Service func(childComplexity int) int
	}

	ServiceCostSeries struct {
		Date     func(childComplexity int) int
		Services func(childComplexity int) int
		Sum      func(childComplexity int) int
	}

	SetTeamMemberRolePayload struct {
		Member func(childComplexity int) int
	}

	SqlDatabase struct {
		Charset        func(childComplexity int) int
		Collation      func(childComplexity int) int
		DeletionPolicy func(childComplexity int) int
		Environment    func(childComplexity int) int
		Healthy        func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
		Team           func(childComplexity int) int
	}

	SqlInstance struct {
		BackupConfiguration func(childComplexity int) int
		CascadingDelete     func(childComplexity int) int
		ConnectionName      func(childComplexity int) int
		Database            func(childComplexity int) int
		DiskAutoresize      func(childComplexity int) int
		DiskAutoresizeLimit func(childComplexity int) int
		Environment         func(childComplexity int) int
		Flags               func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Healthy             func(childComplexity int) int
		HighAvailability    func(childComplexity int) int
		ID                  func(childComplexity int) int
		MaintenanceVersion  func(childComplexity int) int
		MaintenanceWindow   func(childComplexity int) int
		Name                func(childComplexity int) int
		ProjectID           func(childComplexity int) int
		Status              func(childComplexity int) int
		Team                func(childComplexity int) int
		Tier                func(childComplexity int) int
		Users               func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *sqlinstance.SQLInstanceUserOrder) int
		Version             func(childComplexity int) int
		Workload            func(childComplexity int) int
	}

	SqlInstanceBackupConfiguration struct {
		Enabled                     func(childComplexity int) int
		PointInTimeRecovery         func(childComplexity int) int
		RetainedBackups             func(childComplexity int) int
		StartTime                   func(childComplexity int) int
		TransactionLogRetentionDays func(childComplexity int) int
	}

	SqlInstanceConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	SqlInstanceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	SqlInstanceFlag struct {
		Name  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	SqlInstanceFlagConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	SqlInstanceFlagEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	SqlInstanceMaintenanceWindow struct {
		Day  func(childComplexity int) int
		Hour func(childComplexity int) int
	}

	SqlInstanceStatus struct {
		PrivateIPAddress func(childComplexity int) int
		PublicIPAddress  func(childComplexity int) int
	}

	SqlInstanceUser struct {
		Authentication func(childComplexity int) int
		Name           func(childComplexity int) int
	}

	SqlInstanceUserConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	SqlInstanceUserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	SynchronizeTeamPayload struct {
		Team func(childComplexity int) int
	}

	Team struct {
		Applications           func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *application.ApplicationOrder) int
		AuditEntries           func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		AzureGroupID           func(childComplexity int) int
		BigQueryDatasets       func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bigquery.BigQueryDatasetOrder) int
		Buckets                func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bucket.BucketOrder) int
		CdnBucket              func(childComplexity int) int
		Cost                   func(childComplexity int) int
		DeleteKey              func(childComplexity int, key string) int
		DeletionInProgress     func(childComplexity int) int
		Environment            func(childComplexity int, name string) int
		Environments           func(childComplexity int) int
		GitHubTeamSlug         func(childComplexity int) int
		GoogleArtifactRegistry func(childComplexity int) int
		GoogleGroupEmail       func(childComplexity int) int
		ID                     func(childComplexity int) int
		Jobs                   func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *job.JobOrder) int
		KafkaTopics            func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *kafkatopic.KafkaTopicOrder) int
		LastSuccessfulSync     func(childComplexity int) int
		Member                 func(childComplexity int, email string) int
		Members                func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.TeamMemberOrder) int
		OpenSearchInstances    func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *opensearch.OpenSearchOrder) int
		Purpose                func(childComplexity int) int
		RedisInstances         func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *redis.RedisInstanceOrder) int
		Repositories           func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter *repository.TeamRepositoryFilter) int
		SQLInstances           func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *sqlinstance.SQLInstanceOrder) int
		SlackChannel           func(childComplexity int) int
		Slug                   func(childComplexity int) int
		ViewerIsMember         func(childComplexity int) int
		ViewerIsOwner          func(childComplexity int) int
		VulnerabilitySummary   func(childComplexity int) int
		WorkloadUtilization    func(childComplexity int, resourceType utilization.UtilizationResourceType) int
		Workloads              func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *workload.WorkloadOrder) int
	}

	TeamConfirmDeleteKeyAuditEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	TeamCost struct {
		Daily          func(childComplexity int, from scalar.Date, to scalar.Date) int
		MonthlySummary func(childComplexity int) int
	}

	TeamCostMonthlySample struct {
		Cost func(childComplexity int) int
		Date func(childComplexity int) int
	}

	TeamCostMonthlySummary struct {
		Series func(childComplexity int) int
		Sum    func(childComplexity int) int
	}

	TeamCostPeriod struct {
		Series func(childComplexity int) int
		Sum    func(childComplexity int) int
	}

	TeamCreateDeleteKeyAuditEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamCreatedAuditEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamDeleteKey struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int) int
		Expires   func(childComplexity int) int
		Key       func(childComplexity int) int
		Team      func(childComplexity int) int
	}

	TeamEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TeamEnvironment struct {
		Application        func(childComplexity int, name string) int
		BigQueryDataset    func(childComplexity int, name string) int
		Bucket             func(childComplexity int, name string) int
		GCPProjectID       func(childComplexity int) int
		ID                 func(childComplexity int) int
		Job                func(childComplexity int, name string) int
		KafkaTopic         func(childComplexity int, name string) int
		Name               func(childComplexity int) int
		OpenSearchInstance func(childComplexity int, name string) int
		RedisInstance      func(childComplexity int, name string) int
		SQLInstance        func(childComplexity int, name string) int
		SlackAlertsChannel func(childComplexity int) int
		Team               func(childComplexity int) int
	}

	TeamEnvironmentUpdatedAuditEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamEnvironmentUpdatedAuditEntryData struct {
		EnvironmentName func(childComplexity int) int
		UpdatedFields   func(childComplexity int) int
	}

	TeamEnvironmentUpdatedAuditEntryDataUpdatedField struct {
		Field    func(childComplexity int) int
		NewValue func(childComplexity int) int
		OldValue func(childComplexity int) int
	}

	TeamMember struct {
		Role func(childComplexity int) int
		Team func(childComplexity int) int
		User func(childComplexity int) int
	}

	TeamMemberAddedAuditEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamMemberAddedAuditEntryData struct {
		Role      func(childComplexity int) int
		User      func(childComplexity int) int
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	TeamMemberConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	TeamMemberEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TeamMemberRemovedAuditEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamMemberRemovedAuditEntryData struct {
		User      func(childComplexity int) int
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	TeamMemberSetRoleAuditEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamMemberSetRoleAuditEntryData struct {
		Role      func(childComplexity int) int
		User      func(childComplexity int) int
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	TeamUpdatedAuditEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamUpdatedAuditEntryData struct {
		UpdatedFields func(childComplexity int) int
	}

	TeamUpdatedAuditEntryDataUpdatedField struct {
		Field    func(childComplexity int) int
		NewValue func(childComplexity int) int
		OldValue func(childComplexity int) int
	}

	TeamUtilizationData struct {
		Environment func(childComplexity int) int
		Requested   func(childComplexity int) int
		Team        func(childComplexity int) int
		Used        func(childComplexity int) int
	}

	TeamUtilizationEnvironmentDataPoint struct {
		Environment func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	TeamVulnerabilitySummary struct {
		BomCount   func(childComplexity int) int
		Coverage   func(childComplexity int) int
		Critical   func(childComplexity int) int
		High       func(childComplexity int) int
		Low        func(childComplexity int) int
		Medium     func(childComplexity int) int
		RiskScore  func(childComplexity int) int
		Unassigned func(childComplexity int) int
	}

	TokenXAuthIntegration struct {
		Name func(childComplexity int) int
	}

	UpdateTeamEnvironmentPayload struct {
		Environment func(childComplexity int) int
	}

	UpdateTeamPayload struct {
		Team func(childComplexity int) int
	}

	User struct {
		Email      func(childComplexity int) int
		ExternalID func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		Teams      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.UserTeamOrder) int
	}

	UserConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UtilizationDataPoint struct {
		Timestamp func(childComplexity int) int
		Value     func(childComplexity int) int
	}

	WorkloadConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	WorkloadCost struct {
		Daily   func(childComplexity int, from scalar.Date, to scalar.Date) int
		Monthly func(childComplexity int) int
	}

	WorkloadCostPeriod struct {
		Series func(childComplexity int) int
		Sum    func(childComplexity int) int
	}

	WorkloadEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	WorkloadResourceQuantity struct {
		CPU    func(childComplexity int) int
		Memory func(childComplexity int) int
	}

	WorkloadUtilization struct {
		Current   func(childComplexity int, resourceType utilization.UtilizationResourceType) int
		Requested func(childComplexity int, resourceType utilization.UtilizationResourceType) int
		Series    func(childComplexity int, input utilization.WorkloadUtilizationSeriesInput) int
	}

	WorkloadUtilizationData struct {
		Requested func(childComplexity int) int
		Used      func(childComplexity int) int
		Workload  func(childComplexity int) int
	}
}

type ApplicationResolver interface {
	Team(ctx context.Context, obj *application.Application) (*team.Team, error)
	Environment(ctx context.Context, obj *application.Application) (*team.TeamEnvironment, error)

	AuthIntegrations(ctx context.Context, obj *application.Application) ([]workload.ApplicationAuthIntegrations, error)
	Manifest(ctx context.Context, obj *application.Application) (*application.ApplicationManifest, error)
	Cost(ctx context.Context, obj *application.Application) (*cost.WorkloadCost, error)
	NetworkPolicy(ctx context.Context, obj *application.Application) (*netpol.NetworkPolicy, error)
	BigQueryDatasets(ctx context.Context, obj *application.Application, orderBy *bigquery.BigQueryDatasetOrder) (*pagination.Connection[*bigquery.BigQueryDataset], error)
	RedisInstances(ctx context.Context, obj *application.Application, orderBy *redis.RedisInstanceOrder) (*pagination.Connection[*redis.RedisInstance], error)
	OpenSearch(ctx context.Context, obj *application.Application) (*opensearch.OpenSearch, error)
	Buckets(ctx context.Context, obj *application.Application, orderBy *bucket.BucketOrder) (*pagination.Connection[*bucket.Bucket], error)
	KafkaTopicAcls(ctx context.Context, obj *application.Application, orderBy *kafkatopic.KafkaTopicACLOrder) (*pagination.Connection[*kafkatopic.KafkaTopicACL], error)
	SQLInstances(ctx context.Context, obj *application.Application, orderBy *sqlinstance.SQLInstanceOrder) (*pagination.Connection[*sqlinstance.SQLInstance], error)
	Utilization(ctx context.Context, obj *application.Application) (*utilization.WorkloadUtilization, error)
}
type BigQueryDatasetResolver interface {
	Team(ctx context.Context, obj *bigquery.BigQueryDataset) (*team.Team, error)
	Environment(ctx context.Context, obj *bigquery.BigQueryDataset) (*team.TeamEnvironment, error)

	Access(ctx context.Context, obj *bigquery.BigQueryDataset, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bigquery.BigQueryDatasetAccessOrder) (*pagination.Connection[*bigquery.BigQueryDatasetAccess], error)

	Workload(ctx context.Context, obj *bigquery.BigQueryDataset) (workload.Workload, error)
	Cost(ctx context.Context, obj *bigquery.BigQueryDataset) (*cost.BigQueryDatasetCost, error)
}
type BucketResolver interface {
	Team(ctx context.Context, obj *bucket.Bucket) (*team.Team, error)
	Environment(ctx context.Context, obj *bucket.Bucket) (*team.TeamEnvironment, error)

	Workload(ctx context.Context, obj *bucket.Bucket) (workload.Workload, error)
}
type ContainerImageResolver interface {
	HasSbom(ctx context.Context, obj *workload.ContainerImage) (bool, error)
	Vulnerabilities(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *vulnerability.ImageVulnerabilityOrder) (*pagination.Connection[*vulnerability.ImageVulnerability], error)
	VulnerabilitySummary(ctx context.Context, obj *workload.ContainerImage) (*vulnerability.ImageVulnerabilitySummary, error)
	WorkloadReferences(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ContainerImageWorkloadReference], error)
}
type ContainerImageWorkloadReferenceResolver interface {
	Workload(ctx context.Context, obj *vulnerability.ContainerImageWorkloadReference) (workload.Workload, error)
}
type DeleteApplicationPayloadResolver interface {
	Team(ctx context.Context, obj *application.DeleteApplicationPayload) (*team.Team, error)
}
type DeleteJobPayloadResolver interface {
	Team(ctx context.Context, obj *job.DeleteJobPayload) (*team.Team, error)
}
type JobResolver interface {
	Team(ctx context.Context, obj *job.Job) (*team.Team, error)
	Environment(ctx context.Context, obj *job.Job) (*team.TeamEnvironment, error)

	AuthIntegrations(ctx context.Context, obj *job.Job) ([]workload.JobAuthIntegrations, error)

	Runs(ctx context.Context, obj *job.Job, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*job.JobRun], error)
	Manifest(ctx context.Context, obj *job.Job) (*job.JobManifest, error)
	Cost(ctx context.Context, obj *job.Job) (*cost.WorkloadCost, error)
	NetworkPolicy(ctx context.Context, obj *job.Job) (*netpol.NetworkPolicy, error)
	BigQueryDatasets(ctx context.Context, obj *job.Job, orderBy *bigquery.BigQueryDatasetOrder) (*pagination.Connection[*bigquery.BigQueryDataset], error)
	RedisInstances(ctx context.Context, obj *job.Job, orderBy *redis.RedisInstanceOrder) (*pagination.Connection[*redis.RedisInstance], error)
	OpenSearch(ctx context.Context, obj *job.Job) (*opensearch.OpenSearch, error)
	Buckets(ctx context.Context, obj *job.Job, orderBy *bucket.BucketOrder) (*pagination.Connection[*bucket.Bucket], error)
	KafkaTopicAcls(ctx context.Context, obj *job.Job, orderBy *kafkatopic.KafkaTopicACLOrder) (*pagination.Connection[*kafkatopic.KafkaTopicACL], error)
	SQLInstances(ctx context.Context, obj *job.Job, orderBy *sqlinstance.SQLInstanceOrder) (*pagination.Connection[*sqlinstance.SQLInstance], error)
}
type KafkaTopicResolver interface {
	Team(ctx context.Context, obj *kafkatopic.KafkaTopic) (*team.Team, error)
	Environment(ctx context.Context, obj *kafkatopic.KafkaTopic) (*team.TeamEnvironment, error)
	ACL(ctx context.Context, obj *kafkatopic.KafkaTopic, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter *kafkatopic.KafkaTopicACLFilter, orderBy *kafkatopic.KafkaTopicACLOrder) (*pagination.Connection[*kafkatopic.KafkaTopicACL], error)
}
type KafkaTopicAclResolver interface {
	Team(ctx context.Context, obj *kafkatopic.KafkaTopicACL) (*team.Team, error)
	Workload(ctx context.Context, obj *kafkatopic.KafkaTopicACL) (workload.Workload, error)
	Topic(ctx context.Context, obj *kafkatopic.KafkaTopicACL) (*kafkatopic.KafkaTopic, error)
}
type MutationResolver interface {
	DeleteApplication(ctx context.Context, input application.DeleteApplicationInput) (*application.DeleteApplicationPayload, error)
	RestartApplication(ctx context.Context, input application.RestartApplicationInput) (*application.RestartApplicationPayload, error)
	DeleteJob(ctx context.Context, input job.DeleteJobInput) (*job.DeleteJobPayload, error)
	EnableReconciler(ctx context.Context, name string) (*reconciler.Reconciler, error)
	DisableReconciler(ctx context.Context, name string) (*reconciler.Reconciler, error)
	ConfigureReconciler(ctx context.Context, name string, config []*reconciler.ReconcilerConfigInput) (*reconciler.Reconciler, error)
	AddRepositoryToTeam(ctx context.Context, input repository.AddRepositoryToTeamInput) (*repository.AddRepositoryToTeamPayload, error)
	RemoveRepositoryFromTeam(ctx context.Context, input repository.RemoveRepositoryFromTeamInput) (*repository.RemoveRepositoryFromTeamPayload, error)
	CreateTeam(ctx context.Context, input team.CreateTeamInput) (*team.CreateTeamPayload, error)
	UpdateTeam(ctx context.Context, input team.UpdateTeamInput) (*team.UpdateTeamPayload, error)
	UpdateTeamEnvironment(ctx context.Context, input team.UpdateTeamEnvironmentInput) (*team.UpdateTeamEnvironmentPayload, error)
	SynchronizeTeam(ctx context.Context, input team.SynchronizeTeamInput) (*team.SynchronizeTeamPayload, error)
	RequestTeamDeletion(ctx context.Context, input team.RequestTeamDeletionInput) (*team.RequestTeamDeletionPayload, error)
	ConfirmTeamDeletion(ctx context.Context, input team.ConfirmTeamDeletionInput) (*team.ConfirmTeamDeletionPayload, error)
	AddTeamMember(ctx context.Context, input team.AddTeamMemberInput) (*team.AddTeamMemberPayload, error)
	RemoveTeamMember(ctx context.Context, input team.RemoveTeamMemberInput) (*team.RemoveTeamMemberPayload, error)
	SetTeamMemberRole(ctx context.Context, input team.SetTeamMemberRoleInput) (*team.SetTeamMemberRolePayload, error)
}
type NetworkPolicyRuleResolver interface {
	TargetWorkload(ctx context.Context, obj *netpol.NetworkPolicyRule) (workload.Workload, error)

	TargetTeam(ctx context.Context, obj *netpol.NetworkPolicyRule) (*team.Team, error)
	Mutual(ctx context.Context, obj *netpol.NetworkPolicyRule) (bool, error)
}
type OpenSearchResolver interface {
	Team(ctx context.Context, obj *opensearch.OpenSearch) (*team.Team, error)
	Environment(ctx context.Context, obj *opensearch.OpenSearch) (*team.TeamEnvironment, error)

	Workload(ctx context.Context, obj *opensearch.OpenSearch) (workload.Workload, error)
	Access(ctx context.Context, obj *opensearch.OpenSearch, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *opensearch.OpenSearchAccessOrder) (*pagination.Connection[*opensearch.OpenSearchAccess], error)
	Cost(ctx context.Context, obj *opensearch.OpenSearch) (*cost.OpenSearchCost, error)
}
type OpenSearchAccessResolver interface {
	Workload(ctx context.Context, obj *opensearch.OpenSearchAccess) (workload.Workload, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id ident.Ident) (modelv1.Node, error)
	Reconcilers(ctx context.Context, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*reconciler.Reconciler], error)
	Search(ctx context.Context, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter searchv1.SearchFilter) (*pagination.Connection[searchv1.SearchNode], error)
	Teams(ctx context.Context, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.TeamOrder) (*pagination.Connection[*team.Team], error)
	Team(ctx context.Context, slug slug.Slug) (*team.Team, error)
	Users(ctx context.Context, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *user.UserOrder) (*pagination.Connection[*user.User], error)
	User(ctx context.Context, id ident.Ident) (*user.User, error)
	Me(ctx context.Context) (user.AuthenticatedUser, error)
	TeamsUtilization(ctx context.Context, resourceType utilization.UtilizationResourceType) ([]*utilization.TeamUtilizationData, error)
}
type ReconcilerResolver interface {
	Config(ctx context.Context, obj *reconciler.Reconciler) ([]*reconciler.ReconcilerConfig, error)
	Configured(ctx context.Context, obj *reconciler.Reconciler) (bool, error)
}
type RedisInstanceResolver interface {
	Team(ctx context.Context, obj *redis.RedisInstance) (*team.Team, error)
	Environment(ctx context.Context, obj *redis.RedisInstance) (*team.TeamEnvironment, error)
	Access(ctx context.Context, obj *redis.RedisInstance, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *redis.RedisInstanceAccessOrder) (*pagination.Connection[*redis.RedisInstanceAccess], error)
	Workload(ctx context.Context, obj *redis.RedisInstance) (workload.Workload, error)

	Cost(ctx context.Context, obj *redis.RedisInstance) (*cost.RedisInstanceCost, error)
}
type RedisInstanceAccessResolver interface {
	Workload(ctx context.Context, obj *redis.RedisInstanceAccess) (workload.Workload, error)
}
type RemoveTeamMemberPayloadResolver interface {
	User(ctx context.Context, obj *team.RemoveTeamMemberPayload) (*user.User, error)
	Team(ctx context.Context, obj *team.RemoveTeamMemberPayload) (*team.Team, error)
}
type RepositoryResolver interface {
	Team(ctx context.Context, obj *repository.Repository) (*team.Team, error)
}
type RestartApplicationPayloadResolver interface {
	Application(ctx context.Context, obj *application.RestartApplicationPayload) (*application.Application, error)
}
type SqlDatabaseResolver interface {
	Team(ctx context.Context, obj *sqlinstance.SQLDatabase) (*team.Team, error)
	Environment(ctx context.Context, obj *sqlinstance.SQLDatabase) (*team.TeamEnvironment, error)
}
type SqlInstanceResolver interface {
	Team(ctx context.Context, obj *sqlinstance.SQLInstance) (*team.Team, error)
	Environment(ctx context.Context, obj *sqlinstance.SQLInstance) (*team.TeamEnvironment, error)
	Workload(ctx context.Context, obj *sqlinstance.SQLInstance) (workload.Workload, error)

	Database(ctx context.Context, obj *sqlinstance.SQLInstance) (*sqlinstance.SQLDatabase, error)
	Flags(ctx context.Context, obj *sqlinstance.SQLInstance, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*sqlinstance.SQLInstanceFlag], error)
	Users(ctx context.Context, obj *sqlinstance.SQLInstance, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *sqlinstance.SQLInstanceUserOrder) (*pagination.Connection[*sqlinstance.SQLInstanceUser], error)
}
type TeamResolver interface {
	Member(ctx context.Context, obj *team.Team, email string) (*team.TeamMember, error)
	Members(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.TeamMemberOrder) (*pagination.Connection[*team.TeamMember], error)

	ViewerIsOwner(ctx context.Context, obj *team.Team) (bool, error)
	ViewerIsMember(ctx context.Context, obj *team.Team) (bool, error)
	Environments(ctx context.Context, obj *team.Team) ([]*team.TeamEnvironment, error)
	Environment(ctx context.Context, obj *team.Team, name string) (*team.TeamEnvironment, error)
	DeleteKey(ctx context.Context, obj *team.Team, key string) (*team.TeamDeleteKey, error)
	Applications(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *application.ApplicationOrder) (*pagination.Connection[*application.Application], error)
	AuditEntries(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[auditv1.AuditEntry], error)
	Cost(ctx context.Context, obj *team.Team) (*cost.TeamCost, error)
	Jobs(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *job.JobOrder) (*pagination.Connection[*job.Job], error)
	BigQueryDatasets(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bigquery.BigQueryDatasetOrder) (*pagination.Connection[*bigquery.BigQueryDataset], error)
	RedisInstances(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *redis.RedisInstanceOrder) (*pagination.Connection[*redis.RedisInstance], error)
	OpenSearchInstances(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *opensearch.OpenSearchOrder) (*pagination.Connection[*opensearch.OpenSearch], error)
	Buckets(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bucket.BucketOrder) (*pagination.Connection[*bucket.Bucket], error)
	KafkaTopics(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *kafkatopic.KafkaTopicOrder) (*pagination.Connection[*kafkatopic.KafkaTopic], error)
	SQLInstances(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *sqlinstance.SQLInstanceOrder) (*pagination.Connection[*sqlinstance.SQLInstance], error)
	Repositories(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter *repository.TeamRepositoryFilter) (*pagination.Connection[*repository.Repository], error)
	WorkloadUtilization(ctx context.Context, obj *team.Team, resourceType utilization.UtilizationResourceType) ([]*utilization.WorkloadUtilizationData, error)
	VulnerabilitySummary(ctx context.Context, obj *team.Team) (*vulnerability.TeamVulnerabilitySummary, error)
	Workloads(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *workload.WorkloadOrder) (*pagination.Connection[workload.Workload], error)
}
type TeamCostResolver interface {
	Daily(ctx context.Context, obj *cost.TeamCost, from scalar.Date, to scalar.Date) (*cost.TeamCostPeriod, error)
	MonthlySummary(ctx context.Context, obj *cost.TeamCost) (*cost.TeamCostMonthlySummary, error)
}
type TeamDeleteKeyResolver interface {
	CreatedBy(ctx context.Context, obj *team.TeamDeleteKey) (*user.User, error)
	Team(ctx context.Context, obj *team.TeamDeleteKey) (*team.Team, error)
}
type TeamEnvironmentResolver interface {
	Team(ctx context.Context, obj *team.TeamEnvironment) (*team.Team, error)
	Application(ctx context.Context, obj *team.TeamEnvironment, name string) (*application.Application, error)
	Job(ctx context.Context, obj *team.TeamEnvironment, name string) (*job.Job, error)
	BigQueryDataset(ctx context.Context, obj *team.TeamEnvironment, name string) (*bigquery.BigQueryDataset, error)
	Bucket(ctx context.Context, obj *team.TeamEnvironment, name string) (*bucket.Bucket, error)
	KafkaTopic(ctx context.Context, obj *team.TeamEnvironment, name string) (*kafkatopic.KafkaTopic, error)
	OpenSearchInstance(ctx context.Context, obj *team.TeamEnvironment, name string) (*opensearch.OpenSearch, error)
	RedisInstance(ctx context.Context, obj *team.TeamEnvironment, name string) (*redis.RedisInstance, error)
	SQLInstance(ctx context.Context, obj *team.TeamEnvironment, name string) (*sqlinstance.SQLInstance, error)
}
type TeamMemberResolver interface {
	Team(ctx context.Context, obj *team.TeamMember) (*team.Team, error)
	User(ctx context.Context, obj *team.TeamMember) (*user.User, error)
}
type TeamMemberAddedAuditEntryDataResolver interface {
	User(ctx context.Context, obj *team.TeamMemberAddedAuditEntryData) (*user.User, error)
}
type TeamMemberRemovedAuditEntryDataResolver interface {
	User(ctx context.Context, obj *team.TeamMemberRemovedAuditEntryData) (*user.User, error)
}
type TeamMemberSetRoleAuditEntryDataResolver interface {
	User(ctx context.Context, obj *team.TeamMemberSetRoleAuditEntryData) (*user.User, error)
}
type TeamUtilizationDataResolver interface {
	Team(ctx context.Context, obj *utilization.TeamUtilizationData) (*team.Team, error)

	Environment(ctx context.Context, obj *utilization.TeamUtilizationData) (*team.TeamEnvironment, error)
}
type TeamUtilizationEnvironmentDataPointResolver interface {
	Environment(ctx context.Context, obj *utilization.TeamUtilizationEnvironmentDataPoint) (*team.TeamEnvironment, error)
}
type UserResolver interface {
	Teams(ctx context.Context, obj *user.User, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.UserTeamOrder) (*pagination.Connection[*team.TeamMember], error)
}
type WorkloadCostResolver interface {
	Daily(ctx context.Context, obj *cost.WorkloadCost, from scalar.Date, to scalar.Date) (*cost.WorkloadCostPeriod, error)
	Monthly(ctx context.Context, obj *cost.WorkloadCost) (*cost.WorkloadCostPeriod, error)
}
type WorkloadUtilizationResolver interface {
	Current(ctx context.Context, obj *utilization.WorkloadUtilization, resourceType utilization.UtilizationResourceType) (float64, error)
	Requested(ctx context.Context, obj *utilization.WorkloadUtilization, resourceType utilization.UtilizationResourceType) (float64, error)
	Series(ctx context.Context, obj *utilization.WorkloadUtilization, input utilization.WorkloadUtilizationSeriesInput) ([]*utilization.UtilizationDataPoint, error)
}
type WorkloadUtilizationDataResolver interface {
	Workload(ctx context.Context, obj *utilization.WorkloadUtilizationData) (workload.Workload, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AddRepositoryToTeamPayload.repository":
		if e.complexity.AddRepositoryToTeamPayload.Repository == nil {
			break
		}

		return e.complexity.AddRepositoryToTeamPayload.Repository(childComplexity), true

	case "AddTeamMemberPayload.member":
		if e.complexity.AddTeamMemberPayload.Member == nil {
			break
		}

		return e.complexity.AddTeamMemberPayload.Member(childComplexity), true

	case "Application.authIntegrations":
		if e.complexity.Application.AuthIntegrations == nil {
			break
		}

		return e.complexity.Application.AuthIntegrations(childComplexity), true

	case "Application.bigQueryDatasets":
		if e.complexity.Application.BigQueryDatasets == nil {
			break
		}

		args, err := ec.field_Application_bigQueryDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.BigQueryDatasets(childComplexity, args["orderBy"].(*bigquery.BigQueryDatasetOrder)), true

	case "Application.buckets":
		if e.complexity.Application.Buckets == nil {
			break
		}

		args, err := ec.field_Application_buckets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.Buckets(childComplexity, args["orderBy"].(*bucket.BucketOrder)), true

	case "Application.cost":
		if e.complexity.Application.Cost == nil {
			break
		}

		return e.complexity.Application.Cost(childComplexity), true

	case "Application.environment":
		if e.complexity.Application.Environment == nil {
			break
		}

		return e.complexity.Application.Environment(childComplexity), true

	case "Application.id":
		if e.complexity.Application.ID == nil {
			break
		}

		return e.complexity.Application.ID(childComplexity), true

	case "Application.image":
		if e.complexity.Application.Image == nil {
			break
		}

		return e.complexity.Application.Image(childComplexity), true

	case "Application.ingresses":
		if e.complexity.Application.Ingresses == nil {
			break
		}

		return e.complexity.Application.Ingresses(childComplexity), true

	case "Application.kafkaTopicAcls":
		if e.complexity.Application.KafkaTopicAcls == nil {
			break
		}

		args, err := ec.field_Application_kafkaTopicAcls_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.KafkaTopicAcls(childComplexity, args["orderBy"].(*kafkatopic.KafkaTopicACLOrder)), true

	case "Application.manifest":
		if e.complexity.Application.Manifest == nil {
			break
		}

		return e.complexity.Application.Manifest(childComplexity), true

	case "Application.name":
		if e.complexity.Application.Name == nil {
			break
		}

		return e.complexity.Application.Name(childComplexity), true

	case "Application.networkPolicy":
		if e.complexity.Application.NetworkPolicy == nil {
			break
		}

		return e.complexity.Application.NetworkPolicy(childComplexity), true

	case "Application.openSearch":
		if e.complexity.Application.OpenSearch == nil {
			break
		}

		return e.complexity.Application.OpenSearch(childComplexity), true

	case "Application.redisInstances":
		if e.complexity.Application.RedisInstances == nil {
			break
		}

		args, err := ec.field_Application_redisInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.RedisInstances(childComplexity, args["orderBy"].(*redis.RedisInstanceOrder)), true

	case "Application.resources":
		if e.complexity.Application.Resources == nil {
			break
		}

		return e.complexity.Application.Resources(childComplexity), true

	case "Application.sqlInstances":
		if e.complexity.Application.SQLInstances == nil {
			break
		}

		args, err := ec.field_Application_sqlInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.SQLInstances(childComplexity, args["orderBy"].(*sqlinstance.SQLInstanceOrder)), true

	case "Application.team":
		if e.complexity.Application.Team == nil {
			break
		}

		return e.complexity.Application.Team(childComplexity), true

	case "Application.utilization":
		if e.complexity.Application.Utilization == nil {
			break
		}

		return e.complexity.Application.Utilization(childComplexity), true

	case "ApplicationConnection.edges":
		if e.complexity.ApplicationConnection.Edges == nil {
			break
		}

		return e.complexity.ApplicationConnection.Edges(childComplexity), true

	case "ApplicationConnection.nodes":
		if e.complexity.ApplicationConnection.Nodes == nil {
			break
		}

		return e.complexity.ApplicationConnection.Nodes(childComplexity), true

	case "ApplicationConnection.pageInfo":
		if e.complexity.ApplicationConnection.PageInfo == nil {
			break
		}

		return e.complexity.ApplicationConnection.PageInfo(childComplexity), true

	case "ApplicationEdge.cursor":
		if e.complexity.ApplicationEdge.Cursor == nil {
			break
		}

		return e.complexity.ApplicationEdge.Cursor(childComplexity), true

	case "ApplicationEdge.node":
		if e.complexity.ApplicationEdge.Node == nil {
			break
		}

		return e.complexity.ApplicationEdge.Node(childComplexity), true

	case "ApplicationManifest.content":
		if e.complexity.ApplicationManifest.Content == nil {
			break
		}

		return e.complexity.ApplicationManifest.Content(childComplexity), true

	case "ApplicationResources.limits":
		if e.complexity.ApplicationResources.Limits == nil {
			break
		}

		return e.complexity.ApplicationResources.Limits(childComplexity), true

	case "ApplicationResources.requests":
		if e.complexity.ApplicationResources.Requests == nil {
			break
		}

		return e.complexity.ApplicationResources.Requests(childComplexity), true

	case "ApplicationResources.scaling":
		if e.complexity.ApplicationResources.Scaling == nil {
			break
		}

		return e.complexity.ApplicationResources.Scaling(childComplexity), true

	case "ApplicationScaling.maxInstances":
		if e.complexity.ApplicationScaling.MaxInstances == nil {
			break
		}

		return e.complexity.ApplicationScaling.MaxInstances(childComplexity), true

	case "ApplicationScaling.minInstances":
		if e.complexity.ApplicationScaling.MinInstances == nil {
			break
		}

		return e.complexity.ApplicationScaling.MinInstances(childComplexity), true

	case "ApplicationScaling.strategies":
		if e.complexity.ApplicationScaling.Strategies == nil {
			break
		}

		return e.complexity.ApplicationScaling.Strategies(childComplexity), true

	case "AuditEntryConnection.edges":
		if e.complexity.AuditEntryConnection.Edges == nil {
			break
		}

		return e.complexity.AuditEntryConnection.Edges(childComplexity), true

	case "AuditEntryConnection.nodes":
		if e.complexity.AuditEntryConnection.Nodes == nil {
			break
		}

		return e.complexity.AuditEntryConnection.Nodes(childComplexity), true

	case "AuditEntryConnection.pageInfo":
		if e.complexity.AuditEntryConnection.PageInfo == nil {
			break
		}

		return e.complexity.AuditEntryConnection.PageInfo(childComplexity), true

	case "AuditEntryEdge.cursor":
		if e.complexity.AuditEntryEdge.Cursor == nil {
			break
		}

		return e.complexity.AuditEntryEdge.Cursor(childComplexity), true

	case "AuditEntryEdge.node":
		if e.complexity.AuditEntryEdge.Node == nil {
			break
		}

		return e.complexity.AuditEntryEdge.Node(childComplexity), true

	case "BigQueryDataset.access":
		if e.complexity.BigQueryDataset.Access == nil {
			break
		}

		args, err := ec.field_BigQueryDataset_access_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.BigQueryDataset.Access(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*bigquery.BigQueryDatasetAccessOrder)), true

	case "BigQueryDataset.cascadingDelete":
		if e.complexity.BigQueryDataset.CascadingDelete == nil {
			break
		}

		return e.complexity.BigQueryDataset.CascadingDelete(childComplexity), true

	case "BigQueryDataset.cost":
		if e.complexity.BigQueryDataset.Cost == nil {
			break
		}

		return e.complexity.BigQueryDataset.Cost(childComplexity), true

	case "BigQueryDataset.description":
		if e.complexity.BigQueryDataset.Description == nil {
			break
		}

		return e.complexity.BigQueryDataset.Description(childComplexity), true

	case "BigQueryDataset.environment":
		if e.complexity.BigQueryDataset.Environment == nil {
			break
		}

		return e.complexity.BigQueryDataset.Environment(childComplexity), true

	case "BigQueryDataset.id":
		if e.complexity.BigQueryDataset.ID == nil {
			break
		}

		return e.complexity.BigQueryDataset.ID(childComplexity), true

	case "BigQueryDataset.name":
		if e.complexity.BigQueryDataset.Name == nil {
			break
		}

		return e.complexity.BigQueryDataset.Name(childComplexity), true

	case "BigQueryDataset.status":
		if e.complexity.BigQueryDataset.Status == nil {
			break
		}

		return e.complexity.BigQueryDataset.Status(childComplexity), true

	case "BigQueryDataset.team":
		if e.complexity.BigQueryDataset.Team == nil {
			break
		}

		return e.complexity.BigQueryDataset.Team(childComplexity), true

	case "BigQueryDataset.workload":
		if e.complexity.BigQueryDataset.Workload == nil {
			break
		}

		return e.complexity.BigQueryDataset.Workload(childComplexity), true

	case "BigQueryDatasetAccess.email":
		if e.complexity.BigQueryDatasetAccess.Email == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccess.Email(childComplexity), true

	case "BigQueryDatasetAccess.role":
		if e.complexity.BigQueryDatasetAccess.Role == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccess.Role(childComplexity), true

	case "BigQueryDatasetAccessConnection.edges":
		if e.complexity.BigQueryDatasetAccessConnection.Edges == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccessConnection.Edges(childComplexity), true

	case "BigQueryDatasetAccessConnection.nodes":
		if e.complexity.BigQueryDatasetAccessConnection.Nodes == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccessConnection.Nodes(childComplexity), true

	case "BigQueryDatasetAccessConnection.pageInfo":
		if e.complexity.BigQueryDatasetAccessConnection.PageInfo == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccessConnection.PageInfo(childComplexity), true

	case "BigQueryDatasetAccessEdge.cursor":
		if e.complexity.BigQueryDatasetAccessEdge.Cursor == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccessEdge.Cursor(childComplexity), true

	case "BigQueryDatasetAccessEdge.node":
		if e.complexity.BigQueryDatasetAccessEdge.Node == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccessEdge.Node(childComplexity), true

	case "BigQueryDatasetConnection.edges":
		if e.complexity.BigQueryDatasetConnection.Edges == nil {
			break
		}

		return e.complexity.BigQueryDatasetConnection.Edges(childComplexity), true

	case "BigQueryDatasetConnection.nodes":
		if e.complexity.BigQueryDatasetConnection.Nodes == nil {
			break
		}

		return e.complexity.BigQueryDatasetConnection.Nodes(childComplexity), true

	case "BigQueryDatasetConnection.pageInfo":
		if e.complexity.BigQueryDatasetConnection.PageInfo == nil {
			break
		}

		return e.complexity.BigQueryDatasetConnection.PageInfo(childComplexity), true

	case "BigQueryDatasetCost.sum":
		if e.complexity.BigQueryDatasetCost.Sum == nil {
			break
		}

		return e.complexity.BigQueryDatasetCost.Sum(childComplexity), true

	case "BigQueryDatasetEdge.cursor":
		if e.complexity.BigQueryDatasetEdge.Cursor == nil {
			break
		}

		return e.complexity.BigQueryDatasetEdge.Cursor(childComplexity), true

	case "BigQueryDatasetEdge.node":
		if e.complexity.BigQueryDatasetEdge.Node == nil {
			break
		}

		return e.complexity.BigQueryDatasetEdge.Node(childComplexity), true

	case "BigQueryDatasetStatus.creationTime":
		if e.complexity.BigQueryDatasetStatus.CreationTime == nil {
			break
		}

		return e.complexity.BigQueryDatasetStatus.CreationTime(childComplexity), true

	case "BigQueryDatasetStatus.lastModifiedTime":
		if e.complexity.BigQueryDatasetStatus.LastModifiedTime == nil {
			break
		}

		return e.complexity.BigQueryDatasetStatus.LastModifiedTime(childComplexity), true

	case "Bucket.cascadingDelete":
		if e.complexity.Bucket.CascadingDelete == nil {
			break
		}

		return e.complexity.Bucket.CascadingDelete(childComplexity), true

	case "Bucket.environment":
		if e.complexity.Bucket.Environment == nil {
			break
		}

		return e.complexity.Bucket.Environment(childComplexity), true

	case "Bucket.id":
		if e.complexity.Bucket.ID == nil {
			break
		}

		return e.complexity.Bucket.ID(childComplexity), true

	case "Bucket.name":
		if e.complexity.Bucket.Name == nil {
			break
		}

		return e.complexity.Bucket.Name(childComplexity), true

	case "Bucket.publicAccessPrevention":
		if e.complexity.Bucket.PublicAccessPrevention == nil {
			break
		}

		return e.complexity.Bucket.PublicAccessPrevention(childComplexity), true

	case "Bucket.status":
		if e.complexity.Bucket.Status == nil {
			break
		}

		return e.complexity.Bucket.Status(childComplexity), true

	case "Bucket.team":
		if e.complexity.Bucket.Team == nil {
			break
		}

		return e.complexity.Bucket.Team(childComplexity), true

	case "Bucket.uniformBucketLevelAccess":
		if e.complexity.Bucket.UniformBucketLevelAccess == nil {
			break
		}

		return e.complexity.Bucket.UniformBucketLevelAccess(childComplexity), true

	case "Bucket.workload":
		if e.complexity.Bucket.Workload == nil {
			break
		}

		return e.complexity.Bucket.Workload(childComplexity), true

	case "BucketConnection.edges":
		if e.complexity.BucketConnection.Edges == nil {
			break
		}

		return e.complexity.BucketConnection.Edges(childComplexity), true

	case "BucketConnection.nodes":
		if e.complexity.BucketConnection.Nodes == nil {
			break
		}

		return e.complexity.BucketConnection.Nodes(childComplexity), true

	case "BucketConnection.pageInfo":
		if e.complexity.BucketConnection.PageInfo == nil {
			break
		}

		return e.complexity.BucketConnection.PageInfo(childComplexity), true

	case "BucketEdge.cursor":
		if e.complexity.BucketEdge.Cursor == nil {
			break
		}

		return e.complexity.BucketEdge.Cursor(childComplexity), true

	case "BucketEdge.node":
		if e.complexity.BucketEdge.Node == nil {
			break
		}

		return e.complexity.BucketEdge.Node(childComplexity), true

	case "BucketStatus.state":
		if e.complexity.BucketStatus.State == nil {
			break
		}

		return e.complexity.BucketStatus.State(childComplexity), true

	case "CPUScalingStrategy.threshold":
		if e.complexity.CPUScalingStrategy.Threshold == nil {
			break
		}

		return e.complexity.CPUScalingStrategy.Threshold(childComplexity), true

	case "ConfirmTeamDeletionPayload.deletionStarted":
		if e.complexity.ConfirmTeamDeletionPayload.DeletionStarted == nil {
			break
		}

		return e.complexity.ConfirmTeamDeletionPayload.DeletionStarted(childComplexity), true

	case "ContainerImage.hasSBOM":
		if e.complexity.ContainerImage.HasSbom == nil {
			break
		}

		return e.complexity.ContainerImage.HasSbom(childComplexity), true

	case "ContainerImage.id":
		if e.complexity.ContainerImage.ID == nil {
			break
		}

		return e.complexity.ContainerImage.ID(childComplexity), true

	case "ContainerImage.name":
		if e.complexity.ContainerImage.Name == nil {
			break
		}

		return e.complexity.ContainerImage.Name(childComplexity), true

	case "ContainerImage.tag":
		if e.complexity.ContainerImage.Tag == nil {
			break
		}

		return e.complexity.ContainerImage.Tag(childComplexity), true

	case "ContainerImage.vulnerabilities":
		if e.complexity.ContainerImage.Vulnerabilities == nil {
			break
		}

		args, err := ec.field_ContainerImage_vulnerabilities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ContainerImage.Vulnerabilities(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*vulnerability.ImageVulnerabilityOrder)), true

	case "ContainerImage.vulnerabilitySummary":
		if e.complexity.ContainerImage.VulnerabilitySummary == nil {
			break
		}

		return e.complexity.ContainerImage.VulnerabilitySummary(childComplexity), true

	case "ContainerImage.workloadReferences":
		if e.complexity.ContainerImage.WorkloadReferences == nil {
			break
		}

		args, err := ec.field_ContainerImage_workloadReferences_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ContainerImage.WorkloadReferences(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "ContainerImageWorkloadReference.workload":
		if e.complexity.ContainerImageWorkloadReference.Workload == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReference.Workload(childComplexity), true

	case "ContainerImageWorkloadReferenceConnection.edges":
		if e.complexity.ContainerImageWorkloadReferenceConnection.Edges == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReferenceConnection.Edges(childComplexity), true

	case "ContainerImageWorkloadReferenceConnection.nodes":
		if e.complexity.ContainerImageWorkloadReferenceConnection.Nodes == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReferenceConnection.Nodes(childComplexity), true

	case "ContainerImageWorkloadReferenceConnection.pageInfo":
		if e.complexity.ContainerImageWorkloadReferenceConnection.PageInfo == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReferenceConnection.PageInfo(childComplexity), true

	case "ContainerImageWorkloadReferenceEdge.cursor":
		if e.complexity.ContainerImageWorkloadReferenceEdge.Cursor == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReferenceEdge.Cursor(childComplexity), true

	case "ContainerImageWorkloadReferenceEdge.node":
		if e.complexity.ContainerImageWorkloadReferenceEdge.Node == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReferenceEdge.Node(childComplexity), true

	case "CreateTeamPayload.team":
		if e.complexity.CreateTeamPayload.Team == nil {
			break
		}

		return e.complexity.CreateTeamPayload.Team(childComplexity), true

	case "DeleteApplicationPayload.team":
		if e.complexity.DeleteApplicationPayload.Team == nil {
			break
		}

		return e.complexity.DeleteApplicationPayload.Team(childComplexity), true

	case "DeleteJobPayload.team":
		if e.complexity.DeleteJobPayload.Team == nil {
			break
		}

		return e.complexity.DeleteJobPayload.Team(childComplexity), true

	case "EntraIDAuthIntegration.name":
		if e.complexity.EntraIDAuthIntegration.Name == nil {
			break
		}

		return e.complexity.EntraIDAuthIntegration.Name(childComplexity), true

	case "ExternalNetworkPolicyHost.ports":
		if e.complexity.ExternalNetworkPolicyHost.Ports == nil {
			break
		}

		return e.complexity.ExternalNetworkPolicyHost.Ports(childComplexity), true

	case "ExternalNetworkPolicyHost.target":
		if e.complexity.ExternalNetworkPolicyHost.Target == nil {
			break
		}

		return e.complexity.ExternalNetworkPolicyHost.Target(childComplexity), true

	case "ExternalNetworkPolicyIpv4.ports":
		if e.complexity.ExternalNetworkPolicyIpv4.Ports == nil {
			break
		}

		return e.complexity.ExternalNetworkPolicyIpv4.Ports(childComplexity), true

	case "ExternalNetworkPolicyIpv4.target":
		if e.complexity.ExternalNetworkPolicyIpv4.Target == nil {
			break
		}

		return e.complexity.ExternalNetworkPolicyIpv4.Target(childComplexity), true

	case "IDPortenAuthIntegration.name":
		if e.complexity.IDPortenAuthIntegration.Name == nil {
			break
		}

		return e.complexity.IDPortenAuthIntegration.Name(childComplexity), true

	case "ImageVulnerability.description":
		if e.complexity.ImageVulnerability.Description == nil {
			break
		}

		return e.complexity.ImageVulnerability.Description(childComplexity), true

	case "ImageVulnerability.id":
		if e.complexity.ImageVulnerability.ID == nil {
			break
		}

		return e.complexity.ImageVulnerability.ID(childComplexity), true

	case "ImageVulnerability.identifier":
		if e.complexity.ImageVulnerability.Identifier == nil {
			break
		}

		return e.complexity.ImageVulnerability.Identifier(childComplexity), true

	case "ImageVulnerability.package":
		if e.complexity.ImageVulnerability.Package == nil {
			break
		}

		return e.complexity.ImageVulnerability.Package(childComplexity), true

	case "ImageVulnerability.severity":
		if e.complexity.ImageVulnerability.Severity == nil {
			break
		}

		return e.complexity.ImageVulnerability.Severity(childComplexity), true

	case "ImageVulnerability.state":
		if e.complexity.ImageVulnerability.State == nil {
			break
		}

		return e.complexity.ImageVulnerability.State(childComplexity), true

	case "ImageVulnerability.url":
		if e.complexity.ImageVulnerability.URL == nil {
			break
		}

		return e.complexity.ImageVulnerability.URL(childComplexity), true

	case "ImageVulnerabilityConnection.edges":
		if e.complexity.ImageVulnerabilityConnection.Edges == nil {
			break
		}

		return e.complexity.ImageVulnerabilityConnection.Edges(childComplexity), true

	case "ImageVulnerabilityConnection.nodes":
		if e.complexity.ImageVulnerabilityConnection.Nodes == nil {
			break
		}

		return e.complexity.ImageVulnerabilityConnection.Nodes(childComplexity), true

	case "ImageVulnerabilityConnection.pageInfo":
		if e.complexity.ImageVulnerabilityConnection.PageInfo == nil {
			break
		}

		return e.complexity.ImageVulnerabilityConnection.PageInfo(childComplexity), true

	case "ImageVulnerabilityEdge.cursor":
		if e.complexity.ImageVulnerabilityEdge.Cursor == nil {
			break
		}

		return e.complexity.ImageVulnerabilityEdge.Cursor(childComplexity), true

	case "ImageVulnerabilityEdge.node":
		if e.complexity.ImageVulnerabilityEdge.Node == nil {
			break
		}

		return e.complexity.ImageVulnerabilityEdge.Node(childComplexity), true

	case "ImageVulnerabilitySummary.critical":
		if e.complexity.ImageVulnerabilitySummary.Critical == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.Critical(childComplexity), true

	case "ImageVulnerabilitySummary.high":
		if e.complexity.ImageVulnerabilitySummary.High == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.High(childComplexity), true

	case "ImageVulnerabilitySummary.low":
		if e.complexity.ImageVulnerabilitySummary.Low == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.Low(childComplexity), true

	case "ImageVulnerabilitySummary.medium":
		if e.complexity.ImageVulnerabilitySummary.Medium == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.Medium(childComplexity), true

	case "ImageVulnerabilitySummary.riskScore":
		if e.complexity.ImageVulnerabilitySummary.RiskScore == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.RiskScore(childComplexity), true

	case "ImageVulnerabilitySummary.total":
		if e.complexity.ImageVulnerabilitySummary.Total == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.Total(childComplexity), true

	case "ImageVulnerabilitySummary.unassigned":
		if e.complexity.ImageVulnerabilitySummary.Unassigned == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.Unassigned(childComplexity), true

	case "InboundNetworkPolicy.rules":
		if e.complexity.InboundNetworkPolicy.Rules == nil {
			break
		}

		return e.complexity.InboundNetworkPolicy.Rules(childComplexity), true

	case "Job.authIntegrations":
		if e.complexity.Job.AuthIntegrations == nil {
			break
		}

		return e.complexity.Job.AuthIntegrations(childComplexity), true

	case "Job.bigQueryDatasets":
		if e.complexity.Job.BigQueryDatasets == nil {
			break
		}

		args, err := ec.field_Job_bigQueryDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.BigQueryDatasets(childComplexity, args["orderBy"].(*bigquery.BigQueryDatasetOrder)), true

	case "Job.buckets":
		if e.complexity.Job.Buckets == nil {
			break
		}

		args, err := ec.field_Job_buckets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.Buckets(childComplexity, args["orderBy"].(*bucket.BucketOrder)), true

	case "Job.cost":
		if e.complexity.Job.Cost == nil {
			break
		}

		return e.complexity.Job.Cost(childComplexity), true

	case "Job.environment":
		if e.complexity.Job.Environment == nil {
			break
		}

		return e.complexity.Job.Environment(childComplexity), true

	case "Job.id":
		if e.complexity.Job.ID == nil {
			break
		}

		return e.complexity.Job.ID(childComplexity), true

	case "Job.image":
		if e.complexity.Job.Image == nil {
			break
		}

		return e.complexity.Job.Image(childComplexity), true

	case "Job.kafkaTopicAcls":
		if e.complexity.Job.KafkaTopicAcls == nil {
			break
		}

		args, err := ec.field_Job_kafkaTopicAcls_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.KafkaTopicAcls(childComplexity, args["orderBy"].(*kafkatopic.KafkaTopicACLOrder)), true

	case "Job.manifest":
		if e.complexity.Job.Manifest == nil {
			break
		}

		return e.complexity.Job.Manifest(childComplexity), true

	case "Job.name":
		if e.complexity.Job.Name == nil {
			break
		}

		return e.complexity.Job.Name(childComplexity), true

	case "Job.networkPolicy":
		if e.complexity.Job.NetworkPolicy == nil {
			break
		}

		return e.complexity.Job.NetworkPolicy(childComplexity), true

	case "Job.openSearch":
		if e.complexity.Job.OpenSearch == nil {
			break
		}

		return e.complexity.Job.OpenSearch(childComplexity), true

	case "Job.redisInstances":
		if e.complexity.Job.RedisInstances == nil {
			break
		}

		args, err := ec.field_Job_redisInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.RedisInstances(childComplexity, args["orderBy"].(*redis.RedisInstanceOrder)), true

	case "Job.resources":
		if e.complexity.Job.Resources == nil {
			break
		}

		return e.complexity.Job.Resources(childComplexity), true

	case "Job.runs":
		if e.complexity.Job.Runs == nil {
			break
		}

		args, err := ec.field_Job_runs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.Runs(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Job.sqlInstances":
		if e.complexity.Job.SQLInstances == nil {
			break
		}

		args, err := ec.field_Job_sqlInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.SQLInstances(childComplexity, args["orderBy"].(*sqlinstance.SQLInstanceOrder)), true

	case "Job.schedule":
		if e.complexity.Job.Schedule == nil {
			break
		}

		return e.complexity.Job.Schedule(childComplexity), true

	case "Job.team":
		if e.complexity.Job.Team == nil {
			break
		}

		return e.complexity.Job.Team(childComplexity), true

	case "JobConnection.edges":
		if e.complexity.JobConnection.Edges == nil {
			break
		}

		return e.complexity.JobConnection.Edges(childComplexity), true

	case "JobConnection.nodes":
		if e.complexity.JobConnection.Nodes == nil {
			break
		}

		return e.complexity.JobConnection.Nodes(childComplexity), true

	case "JobConnection.pageInfo":
		if e.complexity.JobConnection.PageInfo == nil {
			break
		}

		return e.complexity.JobConnection.PageInfo(childComplexity), true

	case "JobEdge.cursor":
		if e.complexity.JobEdge.Cursor == nil {
			break
		}

		return e.complexity.JobEdge.Cursor(childComplexity), true

	case "JobEdge.node":
		if e.complexity.JobEdge.Node == nil {
			break
		}

		return e.complexity.JobEdge.Node(childComplexity), true

	case "JobManifest.content":
		if e.complexity.JobManifest.Content == nil {
			break
		}

		return e.complexity.JobManifest.Content(childComplexity), true

	case "JobResources.limits":
		if e.complexity.JobResources.Limits == nil {
			break
		}

		return e.complexity.JobResources.Limits(childComplexity), true

	case "JobResources.requests":
		if e.complexity.JobResources.Requests == nil {
			break
		}

		return e.complexity.JobResources.Requests(childComplexity), true

	case "JobRun.completionTime":
		if e.complexity.JobRun.CompletionTime == nil {
			break
		}

		return e.complexity.JobRun.CompletionTime(childComplexity), true

	case "JobRun.id":
		if e.complexity.JobRun.ID == nil {
			break
		}

		return e.complexity.JobRun.ID(childComplexity), true

	case "JobRun.image":
		if e.complexity.JobRun.Image == nil {
			break
		}

		return e.complexity.JobRun.Image(childComplexity), true

	case "JobRun.name":
		if e.complexity.JobRun.Name == nil {
			break
		}

		return e.complexity.JobRun.Name(childComplexity), true

	case "JobRun.startTime":
		if e.complexity.JobRun.StartTime == nil {
			break
		}

		return e.complexity.JobRun.StartTime(childComplexity), true

	case "JobRun.status":
		if e.complexity.JobRun.Status == nil {
			break
		}

		return e.complexity.JobRun.Status(childComplexity), true

	case "JobRunConnection.edges":
		if e.complexity.JobRunConnection.Edges == nil {
			break
		}

		return e.complexity.JobRunConnection.Edges(childComplexity), true

	case "JobRunConnection.nodes":
		if e.complexity.JobRunConnection.Nodes == nil {
			break
		}

		return e.complexity.JobRunConnection.Nodes(childComplexity), true

	case "JobRunConnection.pageInfo":
		if e.complexity.JobRunConnection.PageInfo == nil {
			break
		}

		return e.complexity.JobRunConnection.PageInfo(childComplexity), true

	case "JobRunEdge.cursor":
		if e.complexity.JobRunEdge.Cursor == nil {
			break
		}

		return e.complexity.JobRunEdge.Cursor(childComplexity), true

	case "JobRunEdge.node":
		if e.complexity.JobRunEdge.Node == nil {
			break
		}

		return e.complexity.JobRunEdge.Node(childComplexity), true

	case "JobSchedule.expression":
		if e.complexity.JobSchedule.Expression == nil {
			break
		}

		return e.complexity.JobSchedule.Expression(childComplexity), true

	case "JobSchedule.timeZone":
		if e.complexity.JobSchedule.TimeZone == nil {
			break
		}

		return e.complexity.JobSchedule.TimeZone(childComplexity), true

	case "KafkaLagScalingStrategy.consumerGroup":
		if e.complexity.KafkaLagScalingStrategy.ConsumerGroup == nil {
			break
		}

		return e.complexity.KafkaLagScalingStrategy.ConsumerGroup(childComplexity), true

	case "KafkaLagScalingStrategy.threshold":
		if e.complexity.KafkaLagScalingStrategy.Threshold == nil {
			break
		}

		return e.complexity.KafkaLagScalingStrategy.Threshold(childComplexity), true

	case "KafkaLagScalingStrategy.topicName":
		if e.complexity.KafkaLagScalingStrategy.TopicName == nil {
			break
		}

		return e.complexity.KafkaLagScalingStrategy.TopicName(childComplexity), true

	case "KafkaTopic.acl":
		if e.complexity.KafkaTopic.ACL == nil {
			break
		}

		args, err := ec.field_KafkaTopic_acl_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KafkaTopic.ACL(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["filter"].(*kafkatopic.KafkaTopicACLFilter), args["orderBy"].(*kafkatopic.KafkaTopicACLOrder)), true

	case "KafkaTopic.configuration":
		if e.complexity.KafkaTopic.Configuration == nil {
			break
		}

		return e.complexity.KafkaTopic.Configuration(childComplexity), true

	case "KafkaTopic.environment":
		if e.complexity.KafkaTopic.Environment == nil {
			break
		}

		return e.complexity.KafkaTopic.Environment(childComplexity), true

	case "KafkaTopic.id":
		if e.complexity.KafkaTopic.ID == nil {
			break
		}

		return e.complexity.KafkaTopic.ID(childComplexity), true

	case "KafkaTopic.name":
		if e.complexity.KafkaTopic.Name == nil {
			break
		}

		return e.complexity.KafkaTopic.Name(childComplexity), true

	case "KafkaTopic.pool":
		if e.complexity.KafkaTopic.Pool == nil {
			break
		}

		return e.complexity.KafkaTopic.Pool(childComplexity), true

	case "KafkaTopic.status":
		if e.complexity.KafkaTopic.Status == nil {
			break
		}

		return e.complexity.KafkaTopic.Status(childComplexity), true

	case "KafkaTopic.team":
		if e.complexity.KafkaTopic.Team == nil {
			break
		}

		return e.complexity.KafkaTopic.Team(childComplexity), true

	case "KafkaTopicAcl.access":
		if e.complexity.KafkaTopicAcl.Access == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.Access(childComplexity), true

	case "KafkaTopicAcl.team":
		if e.complexity.KafkaTopicAcl.Team == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.Team(childComplexity), true

	case "KafkaTopicAcl.teamName":
		if e.complexity.KafkaTopicAcl.TeamName == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.TeamName(childComplexity), true

	case "KafkaTopicAcl.topic":
		if e.complexity.KafkaTopicAcl.Topic == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.Topic(childComplexity), true

	case "KafkaTopicAcl.workload":
		if e.complexity.KafkaTopicAcl.Workload == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.Workload(childComplexity), true

	case "KafkaTopicAcl.workloadName":
		if e.complexity.KafkaTopicAcl.WorkloadName == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.WorkloadName(childComplexity), true

	case "KafkaTopicAclConnection.edges":
		if e.complexity.KafkaTopicAclConnection.Edges == nil {
			break
		}

		return e.complexity.KafkaTopicAclConnection.Edges(childComplexity), true

	case "KafkaTopicAclConnection.nodes":
		if e.complexity.KafkaTopicAclConnection.Nodes == nil {
			break
		}

		return e.complexity.KafkaTopicAclConnection.Nodes(childComplexity), true

	case "KafkaTopicAclConnection.pageInfo":
		if e.complexity.KafkaTopicAclConnection.PageInfo == nil {
			break
		}

		return e.complexity.KafkaTopicAclConnection.PageInfo(childComplexity), true

	case "KafkaTopicAclEdge.cursor":
		if e.complexity.KafkaTopicAclEdge.Cursor == nil {
			break
		}

		return e.complexity.KafkaTopicAclEdge.Cursor(childComplexity), true

	case "KafkaTopicAclEdge.node":
		if e.complexity.KafkaTopicAclEdge.Node == nil {
			break
		}

		return e.complexity.KafkaTopicAclEdge.Node(childComplexity), true

	case "KafkaTopicConfiguration.cleanupPolicy":
		if e.complexity.KafkaTopicConfiguration.CleanupPolicy == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.CleanupPolicy(childComplexity), true

	case "KafkaTopicConfiguration.maxMessageBytes":
		if e.complexity.KafkaTopicConfiguration.MaxMessageBytes == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.MaxMessageBytes(childComplexity), true

	case "KafkaTopicConfiguration.minimumInSyncReplicas":
		if e.complexity.KafkaTopicConfiguration.MinimumInSyncReplicas == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.MinimumInSyncReplicas(childComplexity), true

	case "KafkaTopicConfiguration.partitions":
		if e.complexity.KafkaTopicConfiguration.Partitions == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.Partitions(childComplexity), true

	case "KafkaTopicConfiguration.replication":
		if e.complexity.KafkaTopicConfiguration.Replication == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.Replication(childComplexity), true

	case "KafkaTopicConfiguration.retentionBytes":
		if e.complexity.KafkaTopicConfiguration.RetentionBytes == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.RetentionBytes(childComplexity), true

	case "KafkaTopicConfiguration.retentionHours":
		if e.complexity.KafkaTopicConfiguration.RetentionHours == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.RetentionHours(childComplexity), true

	case "KafkaTopicConfiguration.segmentHours":
		if e.complexity.KafkaTopicConfiguration.SegmentHours == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.SegmentHours(childComplexity), true

	case "KafkaTopicConnection.edges":
		if e.complexity.KafkaTopicConnection.Edges == nil {
			break
		}

		return e.complexity.KafkaTopicConnection.Edges(childComplexity), true

	case "KafkaTopicConnection.nodes":
		if e.complexity.KafkaTopicConnection.Nodes == nil {
			break
		}

		return e.complexity.KafkaTopicConnection.Nodes(childComplexity), true

	case "KafkaTopicConnection.pageInfo":
		if e.complexity.KafkaTopicConnection.PageInfo == nil {
			break
		}

		return e.complexity.KafkaTopicConnection.PageInfo(childComplexity), true

	case "KafkaTopicEdge.cursor":
		if e.complexity.KafkaTopicEdge.Cursor == nil {
			break
		}

		return e.complexity.KafkaTopicEdge.Cursor(childComplexity), true

	case "KafkaTopicEdge.node":
		if e.complexity.KafkaTopicEdge.Node == nil {
			break
		}

		return e.complexity.KafkaTopicEdge.Node(childComplexity), true

	case "KafkaTopicStatus.state":
		if e.complexity.KafkaTopicStatus.State == nil {
			break
		}

		return e.complexity.KafkaTopicStatus.State(childComplexity), true

	case "MaskinportenAuthIntegration.name":
		if e.complexity.MaskinportenAuthIntegration.Name == nil {
			break
		}

		return e.complexity.MaskinportenAuthIntegration.Name(childComplexity), true

	case "Mutation.addRepositoryToTeam":
		if e.complexity.Mutation.AddRepositoryToTeam == nil {
			break
		}

		args, err := ec.field_Mutation_addRepositoryToTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRepositoryToTeam(childComplexity, args["input"].(repository.AddRepositoryToTeamInput)), true

	case "Mutation.addTeamMember":
		if e.complexity.Mutation.AddTeamMember == nil {
			break
		}

		args, err := ec.field_Mutation_addTeamMember_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTeamMember(childComplexity, args["input"].(team.AddTeamMemberInput)), true

	case "Mutation.configureReconciler":
		if e.complexity.Mutation.ConfigureReconciler == nil {
			break
		}

		args, err := ec.field_Mutation_configureReconciler_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfigureReconciler(childComplexity, args["name"].(string), args["config"].([]*reconciler.ReconcilerConfigInput)), true

	case "Mutation.confirmTeamDeletion":
		if e.complexity.Mutation.ConfirmTeamDeletion == nil {
			break
		}

		args, err := ec.field_Mutation_confirmTeamDeletion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmTeamDeletion(childComplexity, args["input"].(team.ConfirmTeamDeletionInput)), true

	case "Mutation.createTeam":
		if e.complexity.Mutation.CreateTeam == nil {
			break
		}

		args, err := ec.field_Mutation_createTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTeam(childComplexity, args["input"].(team.CreateTeamInput)), true

	case "Mutation.deleteApplication":
		if e.complexity.Mutation.DeleteApplication == nil {
			break
		}

		args, err := ec.field_Mutation_deleteApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteApplication(childComplexity, args["input"].(application.DeleteApplicationInput)), true

	case "Mutation.deleteJob":
		if e.complexity.Mutation.DeleteJob == nil {
			break
		}

		args, err := ec.field_Mutation_deleteJob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteJob(childComplexity, args["input"].(job.DeleteJobInput)), true

	case "Mutation.disableReconciler":
		if e.complexity.Mutation.DisableReconciler == nil {
			break
		}

		args, err := ec.field_Mutation_disableReconciler_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisableReconciler(childComplexity, args["name"].(string)), true

	case "Mutation.enableReconciler":
		if e.complexity.Mutation.EnableReconciler == nil {
			break
		}

		args, err := ec.field_Mutation_enableReconciler_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnableReconciler(childComplexity, args["name"].(string)), true

	case "Mutation.removeRepositoryFromTeam":
		if e.complexity.Mutation.RemoveRepositoryFromTeam == nil {
			break
		}

		args, err := ec.field_Mutation_removeRepositoryFromTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveRepositoryFromTeam(childComplexity, args["input"].(repository.RemoveRepositoryFromTeamInput)), true

	case "Mutation.removeTeamMember":
		if e.complexity.Mutation.RemoveTeamMember == nil {
			break
		}

		args, err := ec.field_Mutation_removeTeamMember_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveTeamMember(childComplexity, args["input"].(team.RemoveTeamMemberInput)), true

	case "Mutation.requestTeamDeletion":
		if e.complexity.Mutation.RequestTeamDeletion == nil {
			break
		}

		args, err := ec.field_Mutation_requestTeamDeletion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestTeamDeletion(childComplexity, args["input"].(team.RequestTeamDeletionInput)), true

	case "Mutation.restartApplication":
		if e.complexity.Mutation.RestartApplication == nil {
			break
		}

		args, err := ec.field_Mutation_restartApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartApplication(childComplexity, args["input"].(application.RestartApplicationInput)), true

	case "Mutation.setTeamMemberRole":
		if e.complexity.Mutation.SetTeamMemberRole == nil {
			break
		}

		args, err := ec.field_Mutation_setTeamMemberRole_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTeamMemberRole(childComplexity, args["input"].(team.SetTeamMemberRoleInput)), true

	case "Mutation.synchronizeTeam":
		if e.complexity.Mutation.SynchronizeTeam == nil {
			break
		}

		args, err := ec.field_Mutation_synchronizeTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SynchronizeTeam(childComplexity, args["input"].(team.SynchronizeTeamInput)), true

	case "Mutation.updateTeam":
		if e.complexity.Mutation.UpdateTeam == nil {
			break
		}

		args, err := ec.field_Mutation_updateTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTeam(childComplexity, args["input"].(team.UpdateTeamInput)), true

	case "Mutation.updateTeamEnvironment":
		if e.complexity.Mutation.UpdateTeamEnvironment == nil {
			break
		}

		args, err := ec.field_Mutation_updateTeamEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTeamEnvironment(childComplexity, args["input"].(team.UpdateTeamEnvironmentInput)), true

	case "NetworkPolicy.inbound":
		if e.complexity.NetworkPolicy.Inbound == nil {
			break
		}

		return e.complexity.NetworkPolicy.Inbound(childComplexity), true

	case "NetworkPolicy.outbound":
		if e.complexity.NetworkPolicy.Outbound == nil {
			break
		}

		return e.complexity.NetworkPolicy.Outbound(childComplexity), true

	case "NetworkPolicyRule.mutual":
		if e.complexity.NetworkPolicyRule.Mutual == nil {
			break
		}

		return e.complexity.NetworkPolicyRule.Mutual(childComplexity), true

	case "NetworkPolicyRule.targetTeam":
		if e.complexity.NetworkPolicyRule.TargetTeam == nil {
			break
		}

		return e.complexity.NetworkPolicyRule.TargetTeam(childComplexity), true

	case "NetworkPolicyRule.targetTeamSlug":
		if e.complexity.NetworkPolicyRule.TargetTeamSlug == nil {
			break
		}

		return e.complexity.NetworkPolicyRule.TargetTeamSlug(childComplexity), true

	case "NetworkPolicyRule.targetWorkload":
		if e.complexity.NetworkPolicyRule.TargetWorkload == nil {
			break
		}

		return e.complexity.NetworkPolicyRule.TargetWorkload(childComplexity), true

	case "NetworkPolicyRule.targetWorkloadName":
		if e.complexity.NetworkPolicyRule.TargetWorkloadName == nil {
			break
		}

		return e.complexity.NetworkPolicyRule.TargetWorkloadName(childComplexity), true

	case "OpenSearch.access":
		if e.complexity.OpenSearch.Access == nil {
			break
		}

		args, err := ec.field_OpenSearch_access_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.OpenSearch.Access(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*opensearch.OpenSearchAccessOrder)), true

	case "OpenSearch.cost":
		if e.complexity.OpenSearch.Cost == nil {
			break
		}

		return e.complexity.OpenSearch.Cost(childComplexity), true

	case "OpenSearch.environment":
		if e.complexity.OpenSearch.Environment == nil {
			break
		}

		return e.complexity.OpenSearch.Environment(childComplexity), true

	case "OpenSearch.id":
		if e.complexity.OpenSearch.ID == nil {
			break
		}

		return e.complexity.OpenSearch.ID(childComplexity), true

	case "OpenSearch.name":
		if e.complexity.OpenSearch.Name == nil {
			break
		}

		return e.complexity.OpenSearch.Name(childComplexity), true

	case "OpenSearch.status":
		if e.complexity.OpenSearch.Status == nil {
			break
		}

		return e.complexity.OpenSearch.Status(childComplexity), true

	case "OpenSearch.team":
		if e.complexity.OpenSearch.Team == nil {
			break
		}

		return e.complexity.OpenSearch.Team(childComplexity), true

	case "OpenSearch.workload":
		if e.complexity.OpenSearch.Workload == nil {
			break
		}

		return e.complexity.OpenSearch.Workload(childComplexity), true

	case "OpenSearchAccess.access":
		if e.complexity.OpenSearchAccess.Access == nil {
			break
		}

		return e.complexity.OpenSearchAccess.Access(childComplexity), true

	case "OpenSearchAccess.workload":
		if e.complexity.OpenSearchAccess.Workload == nil {
			break
		}

		return e.complexity.OpenSearchAccess.Workload(childComplexity), true

	case "OpenSearchAccessConnection.edges":
		if e.complexity.OpenSearchAccessConnection.Edges == nil {
			break
		}

		return e.complexity.OpenSearchAccessConnection.Edges(childComplexity), true

	case "OpenSearchAccessConnection.nodes":
		if e.complexity.OpenSearchAccessConnection.Nodes == nil {
			break
		}

		return e.complexity.OpenSearchAccessConnection.Nodes(childComplexity), true

	case "OpenSearchAccessConnection.pageInfo":
		if e.complexity.OpenSearchAccessConnection.PageInfo == nil {
			break
		}

		return e.complexity.OpenSearchAccessConnection.PageInfo(childComplexity), true

	case "OpenSearchAccessEdge.cursor":
		if e.complexity.OpenSearchAccessEdge.Cursor == nil {
			break
		}

		return e.complexity.OpenSearchAccessEdge.Cursor(childComplexity), true

	case "OpenSearchAccessEdge.node":
		if e.complexity.OpenSearchAccessEdge.Node == nil {
			break
		}

		return e.complexity.OpenSearchAccessEdge.Node(childComplexity), true

	case "OpenSearchConnection.edges":
		if e.complexity.OpenSearchConnection.Edges == nil {
			break
		}

		return e.complexity.OpenSearchConnection.Edges(childComplexity), true

	case "OpenSearchConnection.nodes":
		if e.complexity.OpenSearchConnection.Nodes == nil {
			break
		}

		return e.complexity.OpenSearchConnection.Nodes(childComplexity), true

	case "OpenSearchConnection.pageInfo":
		if e.complexity.OpenSearchConnection.PageInfo == nil {
			break
		}

		return e.complexity.OpenSearchConnection.PageInfo(childComplexity), true

	case "OpenSearchCost.sum":
		if e.complexity.OpenSearchCost.Sum == nil {
			break
		}

		return e.complexity.OpenSearchCost.Sum(childComplexity), true

	case "OpenSearchEdge.cursor":
		if e.complexity.OpenSearchEdge.Cursor == nil {
			break
		}

		return e.complexity.OpenSearchEdge.Cursor(childComplexity), true

	case "OpenSearchEdge.node":
		if e.complexity.OpenSearchEdge.Node == nil {
			break
		}

		return e.complexity.OpenSearchEdge.Node(childComplexity), true

	case "OpenSearchStatus.state":
		if e.complexity.OpenSearchStatus.State == nil {
			break
		}

		return e.complexity.OpenSearchStatus.State(childComplexity), true

	case "OutboundNetworkPolicy.external":
		if e.complexity.OutboundNetworkPolicy.External == nil {
			break
		}

		return e.complexity.OutboundNetworkPolicy.External(childComplexity), true

	case "OutboundNetworkPolicy.rules":
		if e.complexity.OutboundNetworkPolicy.Rules == nil {
			break
		}

		return e.complexity.OutboundNetworkPolicy.Rules(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.pageEnd":
		if e.complexity.PageInfo.PageEnd == nil {
			break
		}

		return e.complexity.PageInfo.PageEnd(childComplexity), true

	case "PageInfo.pageStart":
		if e.complexity.PageInfo.PageStart == nil {
			break
		}

		return e.complexity.PageInfo.PageStart(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PageInfo.totalCount":
		if e.complexity.PageInfo.TotalCount == nil {
			break
		}

		return e.complexity.PageInfo.TotalCount(childComplexity), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(ident.Ident)), true

	case "Query.reconcilers":
		if e.complexity.Query.Reconcilers == nil {
			break
		}

		args, err := ec.field_Query_reconcilers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Reconcilers(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Query.search":
		if e.complexity.Query.Search == nil {
			break
		}

		args, err := ec.field_Query_search_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Search(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["filter"].(searchv1.SearchFilter)), true

	case "Query.team":
		if e.complexity.Query.Team == nil {
			break
		}

		args, err := ec.field_Query_team_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Team(childComplexity, args["slug"].(slug.Slug)), true

	case "Query.teams":
		if e.complexity.Query.Teams == nil {
			break
		}

		args, err := ec.field_Query_teams_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Teams(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*team.TeamOrder)), true

	case "Query.teamsUtilization":
		if e.complexity.Query.TeamsUtilization == nil {
			break
		}

		args, err := ec.field_Query_teamsUtilization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TeamsUtilization(childComplexity, args["resourceType"].(utilization.UtilizationResourceType)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(ident.Ident)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*user.UserOrder)), true

	case "Reconciler.config":
		if e.complexity.Reconciler.Config == nil {
			break
		}

		return e.complexity.Reconciler.Config(childComplexity), true

	case "Reconciler.configured":
		if e.complexity.Reconciler.Configured == nil {
			break
		}

		return e.complexity.Reconciler.Configured(childComplexity), true

	case "Reconciler.description":
		if e.complexity.Reconciler.Description == nil {
			break
		}

		return e.complexity.Reconciler.Description(childComplexity), true

	case "Reconciler.displayName":
		if e.complexity.Reconciler.DisplayName == nil {
			break
		}

		return e.complexity.Reconciler.DisplayName(childComplexity), true

	case "Reconciler.enabled":
		if e.complexity.Reconciler.Enabled == nil {
			break
		}

		return e.complexity.Reconciler.Enabled(childComplexity), true

	case "Reconciler.name":
		if e.complexity.Reconciler.Name == nil {
			break
		}

		return e.complexity.Reconciler.Name(childComplexity), true

	case "ReconcilerConfig.configured":
		if e.complexity.ReconcilerConfig.Configured == nil {
			break
		}

		return e.complexity.ReconcilerConfig.Configured(childComplexity), true

	case "ReconcilerConfig.description":
		if e.complexity.ReconcilerConfig.Description == nil {
			break
		}

		return e.complexity.ReconcilerConfig.Description(childComplexity), true

	case "ReconcilerConfig.displayName":
		if e.complexity.ReconcilerConfig.DisplayName == nil {
			break
		}

		return e.complexity.ReconcilerConfig.DisplayName(childComplexity), true

	case "ReconcilerConfig.key":
		if e.complexity.ReconcilerConfig.Key == nil {
			break
		}

		return e.complexity.ReconcilerConfig.Key(childComplexity), true

	case "ReconcilerConfig.secret":
		if e.complexity.ReconcilerConfig.Secret == nil {
			break
		}

		return e.complexity.ReconcilerConfig.Secret(childComplexity), true

	case "ReconcilerConfig.value":
		if e.complexity.ReconcilerConfig.Value == nil {
			break
		}

		return e.complexity.ReconcilerConfig.Value(childComplexity), true

	case "ReconcilerConnection.edges":
		if e.complexity.ReconcilerConnection.Edges == nil {
			break
		}

		return e.complexity.ReconcilerConnection.Edges(childComplexity), true

	case "ReconcilerConnection.nodes":
		if e.complexity.ReconcilerConnection.Nodes == nil {
			break
		}

		return e.complexity.ReconcilerConnection.Nodes(childComplexity), true

	case "ReconcilerConnection.pageInfo":
		if e.complexity.ReconcilerConnection.PageInfo == nil {
			break
		}

		return e.complexity.ReconcilerConnection.PageInfo(childComplexity), true

	case "ReconcilerEdge.cursor":
		if e.complexity.ReconcilerEdge.Cursor == nil {
			break
		}

		return e.complexity.ReconcilerEdge.Cursor(childComplexity), true

	case "ReconcilerEdge.node":
		if e.complexity.ReconcilerEdge.Node == nil {
			break
		}

		return e.complexity.ReconcilerEdge.Node(childComplexity), true

	case "RedisInstance.access":
		if e.complexity.RedisInstance.Access == nil {
			break
		}

		args, err := ec.field_RedisInstance_access_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RedisInstance.Access(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*redis.RedisInstanceAccessOrder)), true

	case "RedisInstance.cost":
		if e.complexity.RedisInstance.Cost == nil {
			break
		}

		return e.complexity.RedisInstance.Cost(childComplexity), true

	case "RedisInstance.environment":
		if e.complexity.RedisInstance.Environment == nil {
			break
		}

		return e.complexity.RedisInstance.Environment(childComplexity), true

	case "RedisInstance.id":
		if e.complexity.RedisInstance.ID == nil {
			break
		}

		return e.complexity.RedisInstance.ID(childComplexity), true

	case "RedisInstance.name":
		if e.complexity.RedisInstance.Name == nil {
			break
		}

		return e.complexity.RedisInstance.Name(childComplexity), true

	case "RedisInstance.status":
		if e.complexity.RedisInstance.Status == nil {
			break
		}

		return e.complexity.RedisInstance.Status(childComplexity), true

	case "RedisInstance.team":
		if e.complexity.RedisInstance.Team == nil {
			break
		}

		return e.complexity.RedisInstance.Team(childComplexity), true

	case "RedisInstance.workload":
		if e.complexity.RedisInstance.Workload == nil {
			break
		}

		return e.complexity.RedisInstance.Workload(childComplexity), true

	case "RedisInstanceAccess.access":
		if e.complexity.RedisInstanceAccess.Access == nil {
			break
		}

		return e.complexity.RedisInstanceAccess.Access(childComplexity), true

	case "RedisInstanceAccess.workload":
		if e.complexity.RedisInstanceAccess.Workload == nil {
			break
		}

		return e.complexity.RedisInstanceAccess.Workload(childComplexity), true

	case "RedisInstanceAccessConnection.edges":
		if e.complexity.RedisInstanceAccessConnection.Edges == nil {
			break
		}

		return e.complexity.RedisInstanceAccessConnection.Edges(childComplexity), true

	case "RedisInstanceAccessConnection.nodes":
		if e.complexity.RedisInstanceAccessConnection.Nodes == nil {
			break
		}

		return e.complexity.RedisInstanceAccessConnection.Nodes(childComplexity), true

	case "RedisInstanceAccessConnection.pageInfo":
		if e.complexity.RedisInstanceAccessConnection.PageInfo == nil {
			break
		}

		return e.complexity.RedisInstanceAccessConnection.PageInfo(childComplexity), true

	case "RedisInstanceAccessEdge.cursor":
		if e.complexity.RedisInstanceAccessEdge.Cursor == nil {
			break
		}

		return e.complexity.RedisInstanceAccessEdge.Cursor(childComplexity), true

	case "RedisInstanceAccessEdge.node":
		if e.complexity.RedisInstanceAccessEdge.Node == nil {
			break
		}

		return e.complexity.RedisInstanceAccessEdge.Node(childComplexity), true

	case "RedisInstanceConnection.edges":
		if e.complexity.RedisInstanceConnection.Edges == nil {
			break
		}

		return e.complexity.RedisInstanceConnection.Edges(childComplexity), true

	case "RedisInstanceConnection.nodes":
		if e.complexity.RedisInstanceConnection.Nodes == nil {
			break
		}

		return e.complexity.RedisInstanceConnection.Nodes(childComplexity), true

	case "RedisInstanceConnection.pageInfo":
		if e.complexity.RedisInstanceConnection.PageInfo == nil {
			break
		}

		return e.complexity.RedisInstanceConnection.PageInfo(childComplexity), true

	case "RedisInstanceCost.sum":
		if e.complexity.RedisInstanceCost.Sum == nil {
			break
		}

		return e.complexity.RedisInstanceCost.Sum(childComplexity), true

	case "RedisInstanceEdge.cursor":
		if e.complexity.RedisInstanceEdge.Cursor == nil {
			break
		}

		return e.complexity.RedisInstanceEdge.Cursor(childComplexity), true

	case "RedisInstanceEdge.node":
		if e.complexity.RedisInstanceEdge.Node == nil {
			break
		}

		return e.complexity.RedisInstanceEdge.Node(childComplexity), true

	case "RedisInstanceStatus.state":
		if e.complexity.RedisInstanceStatus.State == nil {
			break
		}

		return e.complexity.RedisInstanceStatus.State(childComplexity), true

	case "RemoveRepositoryFromTeamPayload.success":
		if e.complexity.RemoveRepositoryFromTeamPayload.Success == nil {
			break
		}

		return e.complexity.RemoveRepositoryFromTeamPayload.Success(childComplexity), true

	case "RemoveTeamMemberPayload.team":
		if e.complexity.RemoveTeamMemberPayload.Team == nil {
			break
		}

		return e.complexity.RemoveTeamMemberPayload.Team(childComplexity), true

	case "RemoveTeamMemberPayload.user":
		if e.complexity.RemoveTeamMemberPayload.User == nil {
			break
		}

		return e.complexity.RemoveTeamMemberPayload.User(childComplexity), true

	case "Repository.id":
		if e.complexity.Repository.ID == nil {
			break
		}

		return e.complexity.Repository.ID(childComplexity), true

	case "Repository.name":
		if e.complexity.Repository.Name == nil {
			break
		}

		return e.complexity.Repository.Name(childComplexity), true

	case "Repository.team":
		if e.complexity.Repository.Team == nil {
			break
		}

		return e.complexity.Repository.Team(childComplexity), true

	case "RepositoryConnection.edges":
		if e.complexity.RepositoryConnection.Edges == nil {
			break
		}

		return e.complexity.RepositoryConnection.Edges(childComplexity), true

	case "RepositoryConnection.nodes":
		if e.complexity.RepositoryConnection.Nodes == nil {
			break
		}

		return e.complexity.RepositoryConnection.Nodes(childComplexity), true

	case "RepositoryConnection.pageInfo":
		if e.complexity.RepositoryConnection.PageInfo == nil {
			break
		}

		return e.complexity.RepositoryConnection.PageInfo(childComplexity), true

	case "RepositoryEdge.cursor":
		if e.complexity.RepositoryEdge.Cursor == nil {
			break
		}

		return e.complexity.RepositoryEdge.Cursor(childComplexity), true

	case "RepositoryEdge.node":
		if e.complexity.RepositoryEdge.Node == nil {
			break
		}

		return e.complexity.RepositoryEdge.Node(childComplexity), true

	case "RequestTeamDeletionPayload.key":
		if e.complexity.RequestTeamDeletionPayload.Key == nil {
			break
		}

		return e.complexity.RequestTeamDeletionPayload.Key(childComplexity), true

	case "RestartApplicationPayload.application":
		if e.complexity.RestartApplicationPayload.Application == nil {
			break
		}

		return e.complexity.RestartApplicationPayload.Application(childComplexity), true

	case "SearchNodeConnection.edges":
		if e.complexity.SearchNodeConnection.Edges == nil {
			break
		}

		return e.complexity.SearchNodeConnection.Edges(childComplexity), true

	case "SearchNodeConnection.nodes":
		if e.complexity.SearchNodeConnection.Nodes == nil {
			break
		}

		return e.complexity.SearchNodeConnection.Nodes(childComplexity), true

	case "SearchNodeConnection.pageInfo":
		if e.complexity.SearchNodeConnection.PageInfo == nil {
			break
		}

		return e.complexity.SearchNodeConnection.PageInfo(childComplexity), true

	case "SearchNodeEdge.cursor":
		if e.complexity.SearchNodeEdge.Cursor == nil {
			break
		}

		return e.complexity.SearchNodeEdge.Cursor(childComplexity), true

	case "SearchNodeEdge.node":
		if e.complexity.SearchNodeEdge.Node == nil {
			break
		}

		return e.complexity.SearchNodeEdge.Node(childComplexity), true

	case "ServiceCost.cost":
		if e.complexity.ServiceCost.Cost == nil {
			break
		}

		return e.complexity.ServiceCost.Cost(childComplexity), true

	case "ServiceCost.service":
		if e.complexity.ServiceCost.Service == nil {
			break
		}

		return e.complexity.ServiceCost.Service(childComplexity), true

	case "ServiceCostSeries.date":
		if e.complexity.ServiceCostSeries.Date == nil {
			break
		}

		return e.complexity.ServiceCostSeries.Date(childComplexity), true

	case "ServiceCostSeries.services":
		if e.complexity.ServiceCostSeries.Services == nil {
			break
		}

		return e.complexity.ServiceCostSeries.Services(childComplexity), true

	case "ServiceCostSeries.sum":
		if e.complexity.ServiceCostSeries.Sum == nil {
			break
		}

		return e.complexity.ServiceCostSeries.Sum(childComplexity), true

	case "SetTeamMemberRolePayload.member":
		if e.complexity.SetTeamMemberRolePayload.Member == nil {
			break
		}

		return e.complexity.SetTeamMemberRolePayload.Member(childComplexity), true

	case "SqlDatabase.charset":
		if e.complexity.SqlDatabase.Charset == nil {
			break
		}

		return e.complexity.SqlDatabase.Charset(childComplexity), true

	case "SqlDatabase.collation":
		if e.complexity.SqlDatabase.Collation == nil {
			break
		}

		return e.complexity.SqlDatabase.Collation(childComplexity), true

	case "SqlDatabase.deletionPolicy":
		if e.complexity.SqlDatabase.DeletionPolicy == nil {
			break
		}

		return e.complexity.SqlDatabase.DeletionPolicy(childComplexity), true

	case "SqlDatabase.environment":
		if e.complexity.SqlDatabase.Environment == nil {
			break
		}

		return e.complexity.SqlDatabase.Environment(childComplexity), true

	case "SqlDatabase.healthy":
		if e.complexity.SqlDatabase.Healthy == nil {
			break
		}

		return e.complexity.SqlDatabase.Healthy(childComplexity), true

	case "SqlDatabase.id":
		if e.complexity.SqlDatabase.ID == nil {
			break
		}

		return e.complexity.SqlDatabase.ID(childComplexity), true

	case "SqlDatabase.name":
		if e.complexity.SqlDatabase.Name == nil {
			break
		}

		return e.complexity.SqlDatabase.Name(childComplexity), true

	case "SqlDatabase.team":
		if e.complexity.SqlDatabase.Team == nil {
			break
		}

		return e.complexity.SqlDatabase.Team(childComplexity), true

	case "SqlInstance.backupConfiguration":
		if e.complexity.SqlInstance.BackupConfiguration == nil {
			break
		}

		return e.complexity.SqlInstance.BackupConfiguration(childComplexity), true

	case "SqlInstance.cascadingDelete":
		if e.complexity.SqlInstance.CascadingDelete == nil {
			break
		}

		return e.complexity.SqlInstance.CascadingDelete(childComplexity), true

	case "SqlInstance.connectionName":
		if e.complexity.SqlInstance.ConnectionName == nil {
			break
		}

		return e.complexity.SqlInstance.ConnectionName(childComplexity), true

	case "SqlInstance.database":
		if e.complexity.SqlInstance.Database == nil {
			break
		}

		return e.complexity.SqlInstance.Database(childComplexity), true

	case "SqlInstance.diskAutoresize":
		if e.complexity.SqlInstance.DiskAutoresize == nil {
			break
		}

		return e.complexity.SqlInstance.DiskAutoresize(childComplexity), true

	case "SqlInstance.diskAutoresizeLimit":
		if e.complexity.SqlInstance.DiskAutoresizeLimit == nil {
			break
		}

		return e.complexity.SqlInstance.DiskAutoresizeLimit(childComplexity), true

	case "SqlInstance.environment":
		if e.complexity.SqlInstance.Environment == nil {
			break
		}

		return e.complexity.SqlInstance.Environment(childComplexity), true

	case "SqlInstance.flags":
		if e.complexity.SqlInstance.Flags == nil {
			break
		}

		args, err := ec.field_SqlInstance_flags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SqlInstance.Flags(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "SqlInstance.healthy":
		if e.complexity.SqlInstance.Healthy == nil {
			break
		}

		return e.complexity.SqlInstance.Healthy(childComplexity), true

	case "SqlInstance.highAvailability":
		if e.complexity.SqlInstance.HighAvailability == nil {
			break
		}

		return e.complexity.SqlInstance.HighAvailability(childComplexity), true

	case "SqlInstance.id":
		if e.complexity.SqlInstance.ID == nil {
			break
		}

		return e.complexity.SqlInstance.ID(childComplexity), true

	case "SqlInstance.maintenanceVersion":
		if e.complexity.SqlInstance.MaintenanceVersion == nil {
			break
		}

		return e.complexity.SqlInstance.MaintenanceVersion(childComplexity), true

	case "SqlInstance.maintenanceWindow":
		if e.complexity.SqlInstance.MaintenanceWindow == nil {
			break
		}

		return e.complexity.SqlInstance.MaintenanceWindow(childComplexity), true

	case "SqlInstance.name":
		if e.complexity.SqlInstance.Name == nil {
			break
		}

		return e.complexity.SqlInstance.Name(childComplexity), true

	case "SqlInstance.projectID":
		if e.complexity.SqlInstance.ProjectID == nil {
			break
		}

		return e.complexity.SqlInstance.ProjectID(childComplexity), true

	case "SqlInstance.status":
		if e.complexity.SqlInstance.Status == nil {
			break
		}

		return e.complexity.SqlInstance.Status(childComplexity), true

	case "SqlInstance.team":
		if e.complexity.SqlInstance.Team == nil {
			break
		}

		return e.complexity.SqlInstance.Team(childComplexity), true

	case "SqlInstance.tier":
		if e.complexity.SqlInstance.Tier == nil {
			break
		}

		return e.complexity.SqlInstance.Tier(childComplexity), true

	case "SqlInstance.users":
		if e.complexity.SqlInstance.Users == nil {
			break
		}

		args, err := ec.field_SqlInstance_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SqlInstance.Users(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*sqlinstance.SQLInstanceUserOrder)), true

	case "SqlInstance.version":
		if e.complexity.SqlInstance.Version == nil {
			break
		}

		return e.complexity.SqlInstance.Version(childComplexity), true

	case "SqlInstance.workload":
		if e.complexity.SqlInstance.Workload == nil {
			break
		}

		return e.complexity.SqlInstance.Workload(childComplexity), true

	case "SqlInstanceBackupConfiguration.enabled":
		if e.complexity.SqlInstanceBackupConfiguration.Enabled == nil {
			break
		}

		return e.complexity.SqlInstanceBackupConfiguration.Enabled(childComplexity), true

	case "SqlInstanceBackupConfiguration.pointInTimeRecovery":
		if e.complexity.SqlInstanceBackupConfiguration.PointInTimeRecovery == nil {
			break
		}

		return e.complexity.SqlInstanceBackupConfiguration.PointInTimeRecovery(childComplexity), true

	case "SqlInstanceBackupConfiguration.retainedBackups":
		if e.complexity.SqlInstanceBackupConfiguration.RetainedBackups == nil {
			break
		}

		return e.complexity.SqlInstanceBackupConfiguration.RetainedBackups(childComplexity), true

	case "SqlInstanceBackupConfiguration.startTime":
		if e.complexity.SqlInstanceBackupConfiguration.StartTime == nil {
			break
		}

		return e.complexity.SqlInstanceBackupConfiguration.StartTime(childComplexity), true

	case "SqlInstanceBackupConfiguration.transactionLogRetentionDays":
		if e.complexity.SqlInstanceBackupConfiguration.TransactionLogRetentionDays == nil {
			break
		}

		return e.complexity.SqlInstanceBackupConfiguration.TransactionLogRetentionDays(childComplexity), true

	case "SqlInstanceConnection.edges":
		if e.complexity.SqlInstanceConnection.Edges == nil {
			break
		}

		return e.complexity.SqlInstanceConnection.Edges(childComplexity), true

	case "SqlInstanceConnection.nodes":
		if e.complexity.SqlInstanceConnection.Nodes == nil {
			break
		}

		return e.complexity.SqlInstanceConnection.Nodes(childComplexity), true

	case "SqlInstanceConnection.pageInfo":
		if e.complexity.SqlInstanceConnection.PageInfo == nil {
			break
		}

		return e.complexity.SqlInstanceConnection.PageInfo(childComplexity), true

	case "SqlInstanceEdge.cursor":
		if e.complexity.SqlInstanceEdge.Cursor == nil {
			break
		}

		return e.complexity.SqlInstanceEdge.Cursor(childComplexity), true

	case "SqlInstanceEdge.node":
		if e.complexity.SqlInstanceEdge.Node == nil {
			break
		}

		return e.complexity.SqlInstanceEdge.Node(childComplexity), true

	case "SqlInstanceFlag.name":
		if e.complexity.SqlInstanceFlag.Name == nil {
			break
		}

		return e.complexity.SqlInstanceFlag.Name(childComplexity), true

	case "SqlInstanceFlag.value":
		if e.complexity.SqlInstanceFlag.Value == nil {
			break
		}

		return e.complexity.SqlInstanceFlag.Value(childComplexity), true

	case "SqlInstanceFlagConnection.edges":
		if e.complexity.SqlInstanceFlagConnection.Edges == nil {
			break
		}

		return e.complexity.SqlInstanceFlagConnection.Edges(childComplexity), true

	case "SqlInstanceFlagConnection.nodes":
		if e.complexity.SqlInstanceFlagConnection.Nodes == nil {
			break
		}

		return e.complexity.SqlInstanceFlagConnection.Nodes(childComplexity), true

	case "SqlInstanceFlagConnection.pageInfo":
		if e.complexity.SqlInstanceFlagConnection.PageInfo == nil {
			break
		}

		return e.complexity.SqlInstanceFlagConnection.PageInfo(childComplexity), true

	case "SqlInstanceFlagEdge.cursor":
		if e.complexity.SqlInstanceFlagEdge.Cursor == nil {
			break
		}

		return e.complexity.SqlInstanceFlagEdge.Cursor(childComplexity), true

	case "SqlInstanceFlagEdge.node":
		if e.complexity.SqlInstanceFlagEdge.Node == nil {
			break
		}

		return e.complexity.SqlInstanceFlagEdge.Node(childComplexity), true

	case "SqlInstanceMaintenanceWindow.day":
		if e.complexity.SqlInstanceMaintenanceWindow.Day == nil {
			break
		}

		return e.complexity.SqlInstanceMaintenanceWindow.Day(childComplexity), true

	case "SqlInstanceMaintenanceWindow.hour":
		if e.complexity.SqlInstanceMaintenanceWindow.Hour == nil {
			break
		}

		return e.complexity.SqlInstanceMaintenanceWindow.Hour(childComplexity), true

	case "SqlInstanceStatus.privateIpAddress":
		if e.complexity.SqlInstanceStatus.PrivateIPAddress == nil {
			break
		}

		return e.complexity.SqlInstanceStatus.PrivateIPAddress(childComplexity), true

	case "SqlInstanceStatus.publicIpAddress":
		if e.complexity.SqlInstanceStatus.PublicIPAddress == nil {
			break
		}

		return e.complexity.SqlInstanceStatus.PublicIPAddress(childComplexity), true

	case "SqlInstanceUser.authentication":
		if e.complexity.SqlInstanceUser.Authentication == nil {
			break
		}

		return e.complexity.SqlInstanceUser.Authentication(childComplexity), true

	case "SqlInstanceUser.name":
		if e.complexity.SqlInstanceUser.Name == nil {
			break
		}

		return e.complexity.SqlInstanceUser.Name(childComplexity), true

	case "SqlInstanceUserConnection.edges":
		if e.complexity.SqlInstanceUserConnection.Edges == nil {
			break
		}

		return e.complexity.SqlInstanceUserConnection.Edges(childComplexity), true

	case "SqlInstanceUserConnection.nodes":
		if e.complexity.SqlInstanceUserConnection.Nodes == nil {
			break
		}

		return e.complexity.SqlInstanceUserConnection.Nodes(childComplexity), true

	case "SqlInstanceUserConnection.pageInfo":
		if e.complexity.SqlInstanceUserConnection.PageInfo == nil {
			break
		}

		return e.complexity.SqlInstanceUserConnection.PageInfo(childComplexity), true

	case "SqlInstanceUserEdge.cursor":
		if e.complexity.SqlInstanceUserEdge.Cursor == nil {
			break
		}

		return e.complexity.SqlInstanceUserEdge.Cursor(childComplexity), true

	case "SqlInstanceUserEdge.node":
		if e.complexity.SqlInstanceUserEdge.Node == nil {
			break
		}

		return e.complexity.SqlInstanceUserEdge.Node(childComplexity), true

	case "SynchronizeTeamPayload.team":
		if e.complexity.SynchronizeTeamPayload.Team == nil {
			break
		}

		return e.complexity.SynchronizeTeamPayload.Team(childComplexity), true

	case "Team.applications":
		if e.complexity.Team.Applications == nil {
			break
		}

		args, err := ec.field_Team_applications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Applications(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*application.ApplicationOrder)), true

	case "Team.auditEntries":
		if e.complexity.Team.AuditEntries == nil {
			break
		}

		args, err := ec.field_Team_auditEntries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.AuditEntries(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Team.azureGroupID":
		if e.complexity.Team.AzureGroupID == nil {
			break
		}

		return e.complexity.Team.AzureGroupID(childComplexity), true

	case "Team.bigQueryDatasets":
		if e.complexity.Team.BigQueryDatasets == nil {
			break
		}

		args, err := ec.field_Team_bigQueryDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.BigQueryDatasets(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*bigquery.BigQueryDatasetOrder)), true

	case "Team.buckets":
		if e.complexity.Team.Buckets == nil {
			break
		}

		args, err := ec.field_Team_buckets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Buckets(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*bucket.BucketOrder)), true

	case "Team.cdnBucket":
		if e.complexity.Team.CdnBucket == nil {
			break
		}

		return e.complexity.Team.CdnBucket(childComplexity), true

	case "Team.cost":
		if e.complexity.Team.Cost == nil {
			break
		}

		return e.complexity.Team.Cost(childComplexity), true

	case "Team.deleteKey":
		if e.complexity.Team.DeleteKey == nil {
			break
		}

		args, err := ec.field_Team_deleteKey_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.DeleteKey(childComplexity, args["key"].(string)), true

	case "Team.deletionInProgress":
		if e.complexity.Team.DeletionInProgress == nil {
			break
		}

		return e.complexity.Team.DeletionInProgress(childComplexity), true

	case "Team.environment":
		if e.complexity.Team.Environment == nil {
			break
		}

		args, err := ec.field_Team_environment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Environment(childComplexity, args["name"].(string)), true

	case "Team.environments":
		if e.complexity.Team.Environments == nil {
			break
		}

		return e.complexity.Team.Environments(childComplexity), true

	case "Team.gitHubTeamSlug":
		if e.complexity.Team.GitHubTeamSlug == nil {
			break
		}

		return e.complexity.Team.GitHubTeamSlug(childComplexity), true

	case "Team.googleArtifactRegistry":
		if e.complexity.Team.GoogleArtifactRegistry == nil {
			break
		}

		return e.complexity.Team.GoogleArtifactRegistry(childComplexity), true

	case "Team.googleGroupEmail":
		if e.complexity.Team.GoogleGroupEmail == nil {
			break
		}

		return e.complexity.Team.GoogleGroupEmail(childComplexity), true

	case "Team.id":
		if e.complexity.Team.ID == nil {
			break
		}

		return e.complexity.Team.ID(childComplexity), true

	case "Team.jobs":
		if e.complexity.Team.Jobs == nil {
			break
		}

		args, err := ec.field_Team_jobs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Jobs(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*job.JobOrder)), true

	case "Team.kafkaTopics":
		if e.complexity.Team.KafkaTopics == nil {
			break
		}

		args, err := ec.field_Team_kafkaTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.KafkaTopics(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*kafkatopic.KafkaTopicOrder)), true

	case "Team.lastSuccessfulSync":
		if e.complexity.Team.LastSuccessfulSync == nil {
			break
		}

		return e.complexity.Team.LastSuccessfulSync(childComplexity), true

	case "Team.member":
		if e.complexity.Team.Member == nil {
			break
		}

		args, err := ec.field_Team_member_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Member(childComplexity, args["email"].(string)), true

	case "Team.members":
		if e.complexity.Team.Members == nil {
			break
		}

		args, err := ec.field_Team_members_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Members(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*team.TeamMemberOrder)), true

	case "Team.openSearchInstances":
		if e.complexity.Team.OpenSearchInstances == nil {
			break
		}

		args, err := ec.field_Team_openSearchInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.OpenSearchInstances(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*opensearch.OpenSearchOrder)), true

	case "Team.purpose":
		if e.complexity.Team.Purpose == nil {
			break
		}

		return e.complexity.Team.Purpose(childComplexity), true

	case "Team.redisInstances":
		if e.complexity.Team.RedisInstances == nil {
			break
		}

		args, err := ec.field_Team_redisInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.RedisInstances(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*redis.RedisInstanceOrder)), true

	case "Team.repositories":
		if e.complexity.Team.Repositories == nil {
			break
		}

		args, err := ec.field_Team_repositories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Repositories(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["filter"].(*repository.TeamRepositoryFilter)), true

	case "Team.sqlInstances":
		if e.complexity.Team.SQLInstances == nil {
			break
		}

		args, err := ec.field_Team_sqlInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.SQLInstances(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*sqlinstance.SQLInstanceOrder)), true

	case "Team.slackChannel":
		if e.complexity.Team.SlackChannel == nil {
			break
		}

		return e.complexity.Team.SlackChannel(childComplexity), true

	case "Team.slug":
		if e.complexity.Team.Slug == nil {
			break
		}

		return e.complexity.Team.Slug(childComplexity), true

	case "Team.viewerIsMember":
		if e.complexity.Team.ViewerIsMember == nil {
			break
		}

		return e.complexity.Team.ViewerIsMember(childComplexity), true

	case "Team.viewerIsOwner":
		if e.complexity.Team.ViewerIsOwner == nil {
			break
		}

		return e.complexity.Team.ViewerIsOwner(childComplexity), true

	case "Team.vulnerabilitySummary":
		if e.complexity.Team.VulnerabilitySummary == nil {
			break
		}

		return e.complexity.Team.VulnerabilitySummary(childComplexity), true

	case "Team.workloadUtilization":
		if e.complexity.Team.WorkloadUtilization == nil {
			break
		}

		args, err := ec.field_Team_workloadUtilization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.WorkloadUtilization(childComplexity, args["resourceType"].(utilization.UtilizationResourceType)), true

	case "Team.workloads":
		if e.complexity.Team.Workloads == nil {
			break
		}

		args, err := ec.field_Team_workloads_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Workloads(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*workload.WorkloadOrder)), true

	case "TeamConfirmDeleteKeyAuditEntry.actor":
		if e.complexity.TeamConfirmDeleteKeyAuditEntry.Actor == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyAuditEntry.Actor(childComplexity), true

	case "TeamConfirmDeleteKeyAuditEntry.createdAt":
		if e.complexity.TeamConfirmDeleteKeyAuditEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyAuditEntry.CreatedAt(childComplexity), true

	case "TeamConfirmDeleteKeyAuditEntry.environmentName":
		if e.complexity.TeamConfirmDeleteKeyAuditEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyAuditEntry.EnvironmentName(childComplexity), true

	case "TeamConfirmDeleteKeyAuditEntry.id":
		if e.complexity.TeamConfirmDeleteKeyAuditEntry.ID == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyAuditEntry.ID(childComplexity), true

	case "TeamConfirmDeleteKeyAuditEntry.message":
		if e.complexity.TeamConfirmDeleteKeyAuditEntry.Message == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyAuditEntry.Message(childComplexity), true

	case "TeamConfirmDeleteKeyAuditEntry.resourceName":
		if e.complexity.TeamConfirmDeleteKeyAuditEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyAuditEntry.ResourceName(childComplexity), true

	case "TeamConfirmDeleteKeyAuditEntry.resourceType":
		if e.complexity.TeamConfirmDeleteKeyAuditEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyAuditEntry.ResourceType(childComplexity), true

	case "TeamConfirmDeleteKeyAuditEntry.teamSlug":
		if e.complexity.TeamConfirmDeleteKeyAuditEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyAuditEntry.TeamSlug(childComplexity), true

	case "TeamConnection.edges":
		if e.complexity.TeamConnection.Edges == nil {
			break
		}

		return e.complexity.TeamConnection.Edges(childComplexity), true

	case "TeamConnection.nodes":
		if e.complexity.TeamConnection.Nodes == nil {
			break
		}

		return e.complexity.TeamConnection.Nodes(childComplexity), true

	case "TeamConnection.pageInfo":
		if e.complexity.TeamConnection.PageInfo == nil {
			break
		}

		return e.complexity.TeamConnection.PageInfo(childComplexity), true

	case "TeamCost.daily":
		if e.complexity.TeamCost.Daily == nil {
			break
		}

		args, err := ec.field_TeamCost_daily_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamCost.Daily(childComplexity, args["from"].(scalar.Date), args["to"].(scalar.Date)), true

	case "TeamCost.monthlySummary":
		if e.complexity.TeamCost.MonthlySummary == nil {
			break
		}

		return e.complexity.TeamCost.MonthlySummary(childComplexity), true

	case "TeamCostMonthlySample.cost":
		if e.complexity.TeamCostMonthlySample.Cost == nil {
			break
		}

		return e.complexity.TeamCostMonthlySample.Cost(childComplexity), true

	case "TeamCostMonthlySample.date":
		if e.complexity.TeamCostMonthlySample.Date == nil {
			break
		}

		return e.complexity.TeamCostMonthlySample.Date(childComplexity), true

	case "TeamCostMonthlySummary.series":
		if e.complexity.TeamCostMonthlySummary.Series == nil {
			break
		}

		return e.complexity.TeamCostMonthlySummary.Series(childComplexity), true

	case "TeamCostMonthlySummary.sum":
		if e.complexity.TeamCostMonthlySummary.Sum == nil {
			break
		}

		return e.complexity.TeamCostMonthlySummary.Sum(childComplexity), true

	case "TeamCostPeriod.series":
		if e.complexity.TeamCostPeriod.Series == nil {
			break
		}

		return e.complexity.TeamCostPeriod.Series(childComplexity), true

	case "TeamCostPeriod.sum":
		if e.complexity.TeamCostPeriod.Sum == nil {
			break
		}

		return e.complexity.TeamCostPeriod.Sum(childComplexity), true

	case "TeamCreateDeleteKeyAuditEntry.actor":
		if e.complexity.TeamCreateDeleteKeyAuditEntry.Actor == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyAuditEntry.Actor(childComplexity), true

	case "TeamCreateDeleteKeyAuditEntry.createdAt":
		if e.complexity.TeamCreateDeleteKeyAuditEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyAuditEntry.CreatedAt(childComplexity), true

	case "TeamCreateDeleteKeyAuditEntry.environmentName":
		if e.complexity.TeamCreateDeleteKeyAuditEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyAuditEntry.EnvironmentName(childComplexity), true

	case "TeamCreateDeleteKeyAuditEntry.id":
		if e.complexity.TeamCreateDeleteKeyAuditEntry.ID == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyAuditEntry.ID(childComplexity), true

	case "TeamCreateDeleteKeyAuditEntry.message":
		if e.complexity.TeamCreateDeleteKeyAuditEntry.Message == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyAuditEntry.Message(childComplexity), true

	case "TeamCreateDeleteKeyAuditEntry.resourceName":
		if e.complexity.TeamCreateDeleteKeyAuditEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyAuditEntry.ResourceName(childComplexity), true

	case "TeamCreateDeleteKeyAuditEntry.resourceType":
		if e.complexity.TeamCreateDeleteKeyAuditEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyAuditEntry.ResourceType(childComplexity), true

	case "TeamCreateDeleteKeyAuditEntry.teamSlug":
		if e.complexity.TeamCreateDeleteKeyAuditEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyAuditEntry.TeamSlug(childComplexity), true

	case "TeamCreatedAuditEntry.actor":
		if e.complexity.TeamCreatedAuditEntry.Actor == nil {
			break
		}

		return e.complexity.TeamCreatedAuditEntry.Actor(childComplexity), true

	case "TeamCreatedAuditEntry.createdAt":
		if e.complexity.TeamCreatedAuditEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamCreatedAuditEntry.CreatedAt(childComplexity), true

	case "TeamCreatedAuditEntry.environmentName":
		if e.complexity.TeamCreatedAuditEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamCreatedAuditEntry.EnvironmentName(childComplexity), true

	case "TeamCreatedAuditEntry.id":
		if e.complexity.TeamCreatedAuditEntry.ID == nil {
			break
		}

		return e.complexity.TeamCreatedAuditEntry.ID(childComplexity), true

	case "TeamCreatedAuditEntry.message":
		if e.complexity.TeamCreatedAuditEntry.Message == nil {
			break
		}

		return e.complexity.TeamCreatedAuditEntry.Message(childComplexity), true

	case "TeamCreatedAuditEntry.resourceName":
		if e.complexity.TeamCreatedAuditEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamCreatedAuditEntry.ResourceName(childComplexity), true

	case "TeamCreatedAuditEntry.resourceType":
		if e.complexity.TeamCreatedAuditEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamCreatedAuditEntry.ResourceType(childComplexity), true

	case "TeamCreatedAuditEntry.teamSlug":
		if e.complexity.TeamCreatedAuditEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamCreatedAuditEntry.TeamSlug(childComplexity), true

	case "TeamDeleteKey.createdAt":
		if e.complexity.TeamDeleteKey.CreatedAt == nil {
			break
		}

		return e.complexity.TeamDeleteKey.CreatedAt(childComplexity), true

	case "TeamDeleteKey.createdBy":
		if e.complexity.TeamDeleteKey.CreatedBy == nil {
			break
		}

		return e.complexity.TeamDeleteKey.CreatedBy(childComplexity), true

	case "TeamDeleteKey.expires":
		if e.complexity.TeamDeleteKey.Expires == nil {
			break
		}

		return e.complexity.TeamDeleteKey.Expires(childComplexity), true

	case "TeamDeleteKey.key":
		if e.complexity.TeamDeleteKey.Key == nil {
			break
		}

		return e.complexity.TeamDeleteKey.Key(childComplexity), true

	case "TeamDeleteKey.team":
		if e.complexity.TeamDeleteKey.Team == nil {
			break
		}

		return e.complexity.TeamDeleteKey.Team(childComplexity), true

	case "TeamEdge.cursor":
		if e.complexity.TeamEdge.Cursor == nil {
			break
		}

		return e.complexity.TeamEdge.Cursor(childComplexity), true

	case "TeamEdge.node":
		if e.complexity.TeamEdge.Node == nil {
			break
		}

		return e.complexity.TeamEdge.Node(childComplexity), true

	case "TeamEnvironment.application":
		if e.complexity.TeamEnvironment.Application == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_application_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.Application(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.bigQueryDataset":
		if e.complexity.TeamEnvironment.BigQueryDataset == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_bigQueryDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.BigQueryDataset(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.bucket":
		if e.complexity.TeamEnvironment.Bucket == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_bucket_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.Bucket(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.gcpProjectID":
		if e.complexity.TeamEnvironment.GCPProjectID == nil {
			break
		}

		return e.complexity.TeamEnvironment.GCPProjectID(childComplexity), true

	case "TeamEnvironment.id":
		if e.complexity.TeamEnvironment.ID == nil {
			break
		}

		return e.complexity.TeamEnvironment.ID(childComplexity), true

	case "TeamEnvironment.job":
		if e.complexity.TeamEnvironment.Job == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_job_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.Job(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.kafkaTopic":
		if e.complexity.TeamEnvironment.KafkaTopic == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_kafkaTopic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.KafkaTopic(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.name":
		if e.complexity.TeamEnvironment.Name == nil {
			break
		}

		return e.complexity.TeamEnvironment.Name(childComplexity), true

	case "TeamEnvironment.openSearchInstance":
		if e.complexity.TeamEnvironment.OpenSearchInstance == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_openSearchInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.OpenSearchInstance(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.redisInstance":
		if e.complexity.TeamEnvironment.RedisInstance == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_redisInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.RedisInstance(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.sqlInstance":
		if e.complexity.TeamEnvironment.SQLInstance == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_sqlInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.SQLInstance(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.slackAlertsChannel":
		if e.complexity.TeamEnvironment.SlackAlertsChannel == nil {
			break
		}

		return e.complexity.TeamEnvironment.SlackAlertsChannel(childComplexity), true

	case "TeamEnvironment.team":
		if e.complexity.TeamEnvironment.Team == nil {
			break
		}

		return e.complexity.TeamEnvironment.Team(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntry.actor":
		if e.complexity.TeamEnvironmentUpdatedAuditEntry.Actor == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntry.Actor(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntry.createdAt":
		if e.complexity.TeamEnvironmentUpdatedAuditEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntry.CreatedAt(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntry.data":
		if e.complexity.TeamEnvironmentUpdatedAuditEntry.Data == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntry.Data(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntry.environmentName":
		if e.complexity.TeamEnvironmentUpdatedAuditEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntry.EnvironmentName(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntry.id":
		if e.complexity.TeamEnvironmentUpdatedAuditEntry.ID == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntry.ID(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntry.message":
		if e.complexity.TeamEnvironmentUpdatedAuditEntry.Message == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntry.Message(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntry.resourceName":
		if e.complexity.TeamEnvironmentUpdatedAuditEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntry.ResourceName(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntry.resourceType":
		if e.complexity.TeamEnvironmentUpdatedAuditEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntry.ResourceType(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntry.teamSlug":
		if e.complexity.TeamEnvironmentUpdatedAuditEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntry.TeamSlug(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntryData.environmentName":
		if e.complexity.TeamEnvironmentUpdatedAuditEntryData.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntryData.EnvironmentName(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntryData.updatedFields":
		if e.complexity.TeamEnvironmentUpdatedAuditEntryData.UpdatedFields == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntryData.UpdatedFields(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntryDataUpdatedField.field":
		if e.complexity.TeamEnvironmentUpdatedAuditEntryDataUpdatedField.Field == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntryDataUpdatedField.Field(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntryDataUpdatedField.newValue":
		if e.complexity.TeamEnvironmentUpdatedAuditEntryDataUpdatedField.NewValue == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntryDataUpdatedField.NewValue(childComplexity), true

	case "TeamEnvironmentUpdatedAuditEntryDataUpdatedField.oldValue":
		if e.complexity.TeamEnvironmentUpdatedAuditEntryDataUpdatedField.OldValue == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedAuditEntryDataUpdatedField.OldValue(childComplexity), true

	case "TeamMember.role":
		if e.complexity.TeamMember.Role == nil {
			break
		}

		return e.complexity.TeamMember.Role(childComplexity), true

	case "TeamMember.team":
		if e.complexity.TeamMember.Team == nil {
			break
		}

		return e.complexity.TeamMember.Team(childComplexity), true

	case "TeamMember.user":
		if e.complexity.TeamMember.User == nil {
			break
		}

		return e.complexity.TeamMember.User(childComplexity), true

	case "TeamMemberAddedAuditEntry.actor":
		if e.complexity.TeamMemberAddedAuditEntry.Actor == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntry.Actor(childComplexity), true

	case "TeamMemberAddedAuditEntry.createdAt":
		if e.complexity.TeamMemberAddedAuditEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntry.CreatedAt(childComplexity), true

	case "TeamMemberAddedAuditEntry.data":
		if e.complexity.TeamMemberAddedAuditEntry.Data == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntry.Data(childComplexity), true

	case "TeamMemberAddedAuditEntry.environmentName":
		if e.complexity.TeamMemberAddedAuditEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntry.EnvironmentName(childComplexity), true

	case "TeamMemberAddedAuditEntry.id":
		if e.complexity.TeamMemberAddedAuditEntry.ID == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntry.ID(childComplexity), true

	case "TeamMemberAddedAuditEntry.message":
		if e.complexity.TeamMemberAddedAuditEntry.Message == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntry.Message(childComplexity), true

	case "TeamMemberAddedAuditEntry.resourceName":
		if e.complexity.TeamMemberAddedAuditEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntry.ResourceName(childComplexity), true

	case "TeamMemberAddedAuditEntry.resourceType":
		if e.complexity.TeamMemberAddedAuditEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntry.ResourceType(childComplexity), true

	case "TeamMemberAddedAuditEntry.teamSlug":
		if e.complexity.TeamMemberAddedAuditEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntry.TeamSlug(childComplexity), true

	case "TeamMemberAddedAuditEntryData.role":
		if e.complexity.TeamMemberAddedAuditEntryData.Role == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntryData.Role(childComplexity), true

	case "TeamMemberAddedAuditEntryData.user":
		if e.complexity.TeamMemberAddedAuditEntryData.User == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntryData.User(childComplexity), true

	case "TeamMemberAddedAuditEntryData.userEmail":
		if e.complexity.TeamMemberAddedAuditEntryData.UserEmail == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntryData.UserEmail(childComplexity), true

	case "TeamMemberAddedAuditEntryData.userID":
		if e.complexity.TeamMemberAddedAuditEntryData.UserID == nil {
			break
		}

		return e.complexity.TeamMemberAddedAuditEntryData.UserID(childComplexity), true

	case "TeamMemberConnection.edges":
		if e.complexity.TeamMemberConnection.Edges == nil {
			break
		}

		return e.complexity.TeamMemberConnection.Edges(childComplexity), true

	case "TeamMemberConnection.nodes":
		if e.complexity.TeamMemberConnection.Nodes == nil {
			break
		}

		return e.complexity.TeamMemberConnection.Nodes(childComplexity), true

	case "TeamMemberConnection.pageInfo":
		if e.complexity.TeamMemberConnection.PageInfo == nil {
			break
		}

		return e.complexity.TeamMemberConnection.PageInfo(childComplexity), true

	case "TeamMemberEdge.cursor":
		if e.complexity.TeamMemberEdge.Cursor == nil {
			break
		}

		return e.complexity.TeamMemberEdge.Cursor(childComplexity), true

	case "TeamMemberEdge.node":
		if e.complexity.TeamMemberEdge.Node == nil {
			break
		}

		return e.complexity.TeamMemberEdge.Node(childComplexity), true

	case "TeamMemberRemovedAuditEntry.actor":
		if e.complexity.TeamMemberRemovedAuditEntry.Actor == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntry.Actor(childComplexity), true

	case "TeamMemberRemovedAuditEntry.createdAt":
		if e.complexity.TeamMemberRemovedAuditEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntry.CreatedAt(childComplexity), true

	case "TeamMemberRemovedAuditEntry.data":
		if e.complexity.TeamMemberRemovedAuditEntry.Data == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntry.Data(childComplexity), true

	case "TeamMemberRemovedAuditEntry.environmentName":
		if e.complexity.TeamMemberRemovedAuditEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntry.EnvironmentName(childComplexity), true

	case "TeamMemberRemovedAuditEntry.id":
		if e.complexity.TeamMemberRemovedAuditEntry.ID == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntry.ID(childComplexity), true

	case "TeamMemberRemovedAuditEntry.message":
		if e.complexity.TeamMemberRemovedAuditEntry.Message == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntry.Message(childComplexity), true

	case "TeamMemberRemovedAuditEntry.resourceName":
		if e.complexity.TeamMemberRemovedAuditEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntry.ResourceName(childComplexity), true

	case "TeamMemberRemovedAuditEntry.resourceType":
		if e.complexity.TeamMemberRemovedAuditEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntry.ResourceType(childComplexity), true

	case "TeamMemberRemovedAuditEntry.teamSlug":
		if e.complexity.TeamMemberRemovedAuditEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntry.TeamSlug(childComplexity), true

	case "TeamMemberRemovedAuditEntryData.user":
		if e.complexity.TeamMemberRemovedAuditEntryData.User == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntryData.User(childComplexity), true

	case "TeamMemberRemovedAuditEntryData.userEmail":
		if e.complexity.TeamMemberRemovedAuditEntryData.UserEmail == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntryData.UserEmail(childComplexity), true

	case "TeamMemberRemovedAuditEntryData.userID":
		if e.complexity.TeamMemberRemovedAuditEntryData.UserID == nil {
			break
		}

		return e.complexity.TeamMemberRemovedAuditEntryData.UserID(childComplexity), true

	case "TeamMemberSetRoleAuditEntry.actor":
		if e.complexity.TeamMemberSetRoleAuditEntry.Actor == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntry.Actor(childComplexity), true

	case "TeamMemberSetRoleAuditEntry.createdAt":
		if e.complexity.TeamMemberSetRoleAuditEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntry.CreatedAt(childComplexity), true

	case "TeamMemberSetRoleAuditEntry.data":
		if e.complexity.TeamMemberSetRoleAuditEntry.Data == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntry.Data(childComplexity), true

	case "TeamMemberSetRoleAuditEntry.environmentName":
		if e.complexity.TeamMemberSetRoleAuditEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntry.EnvironmentName(childComplexity), true

	case "TeamMemberSetRoleAuditEntry.id":
		if e.complexity.TeamMemberSetRoleAuditEntry.ID == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntry.ID(childComplexity), true

	case "TeamMemberSetRoleAuditEntry.message":
		if e.complexity.TeamMemberSetRoleAuditEntry.Message == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntry.Message(childComplexity), true

	case "TeamMemberSetRoleAuditEntry.resourceName":
		if e.complexity.TeamMemberSetRoleAuditEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntry.ResourceName(childComplexity), true

	case "TeamMemberSetRoleAuditEntry.resourceType":
		if e.complexity.TeamMemberSetRoleAuditEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntry.ResourceType(childComplexity), true

	case "TeamMemberSetRoleAuditEntry.teamSlug":
		if e.complexity.TeamMemberSetRoleAuditEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntry.TeamSlug(childComplexity), true

	case "TeamMemberSetRoleAuditEntryData.role":
		if e.complexity.TeamMemberSetRoleAuditEntryData.Role == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntryData.Role(childComplexity), true

	case "TeamMemberSetRoleAuditEntryData.user":
		if e.complexity.TeamMemberSetRoleAuditEntryData.User == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntryData.User(childComplexity), true

	case "TeamMemberSetRoleAuditEntryData.userEmail":
		if e.complexity.TeamMemberSetRoleAuditEntryData.UserEmail == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntryData.UserEmail(childComplexity), true

	case "TeamMemberSetRoleAuditEntryData.userID":
		if e.complexity.TeamMemberSetRoleAuditEntryData.UserID == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleAuditEntryData.UserID(childComplexity), true

	case "TeamUpdatedAuditEntry.actor":
		if e.complexity.TeamUpdatedAuditEntry.Actor == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntry.Actor(childComplexity), true

	case "TeamUpdatedAuditEntry.createdAt":
		if e.complexity.TeamUpdatedAuditEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntry.CreatedAt(childComplexity), true

	case "TeamUpdatedAuditEntry.data":
		if e.complexity.TeamUpdatedAuditEntry.Data == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntry.Data(childComplexity), true

	case "TeamUpdatedAuditEntry.environmentName":
		if e.complexity.TeamUpdatedAuditEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntry.EnvironmentName(childComplexity), true

	case "TeamUpdatedAuditEntry.id":
		if e.complexity.TeamUpdatedAuditEntry.ID == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntry.ID(childComplexity), true

	case "TeamUpdatedAuditEntry.message":
		if e.complexity.TeamUpdatedAuditEntry.Message == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntry.Message(childComplexity), true

	case "TeamUpdatedAuditEntry.resourceName":
		if e.complexity.TeamUpdatedAuditEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntry.ResourceName(childComplexity), true

	case "TeamUpdatedAuditEntry.resourceType":
		if e.complexity.TeamUpdatedAuditEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntry.ResourceType(childComplexity), true

	case "TeamUpdatedAuditEntry.teamSlug":
		if e.complexity.TeamUpdatedAuditEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntry.TeamSlug(childComplexity), true

	case "TeamUpdatedAuditEntryData.updatedFields":
		if e.complexity.TeamUpdatedAuditEntryData.UpdatedFields == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntryData.UpdatedFields(childComplexity), true

	case "TeamUpdatedAuditEntryDataUpdatedField.field":
		if e.complexity.TeamUpdatedAuditEntryDataUpdatedField.Field == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntryDataUpdatedField.Field(childComplexity), true

	case "TeamUpdatedAuditEntryDataUpdatedField.newValue":
		if e.complexity.TeamUpdatedAuditEntryDataUpdatedField.NewValue == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntryDataUpdatedField.NewValue(childComplexity), true

	case "TeamUpdatedAuditEntryDataUpdatedField.oldValue":
		if e.complexity.TeamUpdatedAuditEntryDataUpdatedField.OldValue == nil {
			break
		}

		return e.complexity.TeamUpdatedAuditEntryDataUpdatedField.OldValue(childComplexity), true

	case "TeamUtilizationData.environment":
		if e.complexity.TeamUtilizationData.Environment == nil {
			break
		}

		return e.complexity.TeamUtilizationData.Environment(childComplexity), true

	case "TeamUtilizationData.requested":
		if e.complexity.TeamUtilizationData.Requested == nil {
			break
		}

		return e.complexity.TeamUtilizationData.Requested(childComplexity), true

	case "TeamUtilizationData.team":
		if e.complexity.TeamUtilizationData.Team == nil {
			break
		}

		return e.complexity.TeamUtilizationData.Team(childComplexity), true

	case "TeamUtilizationData.used":
		if e.complexity.TeamUtilizationData.Used == nil {
			break
		}

		return e.complexity.TeamUtilizationData.Used(childComplexity), true

	case "TeamUtilizationEnvironmentDataPoint.environment":
		if e.complexity.TeamUtilizationEnvironmentDataPoint.Environment == nil {
			break
		}

		return e.complexity.TeamUtilizationEnvironmentDataPoint.Environment(childComplexity), true

	case "TeamUtilizationEnvironmentDataPoint.value":
		if e.complexity.TeamUtilizationEnvironmentDataPoint.Value == nil {
			break
		}

		return e.complexity.TeamUtilizationEnvironmentDataPoint.Value(childComplexity), true

	case "TeamVulnerabilitySummary.bomCount":
		if e.complexity.TeamVulnerabilitySummary.BomCount == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.BomCount(childComplexity), true

	case "TeamVulnerabilitySummary.coverage":
		if e.complexity.TeamVulnerabilitySummary.Coverage == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Coverage(childComplexity), true

	case "TeamVulnerabilitySummary.critical":
		if e.complexity.TeamVulnerabilitySummary.Critical == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Critical(childComplexity), true

	case "TeamVulnerabilitySummary.high":
		if e.complexity.TeamVulnerabilitySummary.High == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.High(childComplexity), true

	case "TeamVulnerabilitySummary.low":
		if e.complexity.TeamVulnerabilitySummary.Low == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Low(childComplexity), true

	case "TeamVulnerabilitySummary.medium":
		if e.complexity.TeamVulnerabilitySummary.Medium == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Medium(childComplexity), true

	case "TeamVulnerabilitySummary.riskScore":
		if e.complexity.TeamVulnerabilitySummary.RiskScore == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.RiskScore(childComplexity), true

	case "TeamVulnerabilitySummary.unassigned":
		if e.complexity.TeamVulnerabilitySummary.Unassigned == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Unassigned(childComplexity), true

	case "TokenXAuthIntegration.name":
		if e.complexity.TokenXAuthIntegration.Name == nil {
			break
		}

		return e.complexity.TokenXAuthIntegration.Name(childComplexity), true

	case "UpdateTeamEnvironmentPayload.environment":
		if e.complexity.UpdateTeamEnvironmentPayload.Environment == nil {
			break
		}

		return e.complexity.UpdateTeamEnvironmentPayload.Environment(childComplexity), true

	case "UpdateTeamPayload.team":
		if e.complexity.UpdateTeamPayload.Team == nil {
			break
		}

		return e.complexity.UpdateTeamPayload.Team(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.externalID":
		if e.complexity.User.ExternalID == nil {
			break
		}

		return e.complexity.User.ExternalID(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.teams":
		if e.complexity.User.Teams == nil {
			break
		}

		args, err := ec.field_User_teams_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Teams(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*team.UserTeamOrder)), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.nodes":
		if e.complexity.UserConnection.Nodes == nil {
			break
		}

		return e.complexity.UserConnection.Nodes(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	case "UtilizationDataPoint.timestamp":
		if e.complexity.UtilizationDataPoint.Timestamp == nil {
			break
		}

		return e.complexity.UtilizationDataPoint.Timestamp(childComplexity), true

	case "UtilizationDataPoint.value":
		if e.complexity.UtilizationDataPoint.Value == nil {
			break
		}

		return e.complexity.UtilizationDataPoint.Value(childComplexity), true

	case "WorkloadConnection.edges":
		if e.complexity.WorkloadConnection.Edges == nil {
			break
		}

		return e.complexity.WorkloadConnection.Edges(childComplexity), true

	case "WorkloadConnection.nodes":
		if e.complexity.WorkloadConnection.Nodes == nil {
			break
		}

		return e.complexity.WorkloadConnection.Nodes(childComplexity), true

	case "WorkloadConnection.pageInfo":
		if e.complexity.WorkloadConnection.PageInfo == nil {
			break
		}

		return e.complexity.WorkloadConnection.PageInfo(childComplexity), true

	case "WorkloadCost.daily":
		if e.complexity.WorkloadCost.Daily == nil {
			break
		}

		args, err := ec.field_WorkloadCost_daily_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkloadCost.Daily(childComplexity, args["from"].(scalar.Date), args["to"].(scalar.Date)), true

	case "WorkloadCost.monthly":
		if e.complexity.WorkloadCost.Monthly == nil {
			break
		}

		return e.complexity.WorkloadCost.Monthly(childComplexity), true

	case "WorkloadCostPeriod.series":
		if e.complexity.WorkloadCostPeriod.Series == nil {
			break
		}

		return e.complexity.WorkloadCostPeriod.Series(childComplexity), true

	case "WorkloadCostPeriod.sum":
		if e.complexity.WorkloadCostPeriod.Sum == nil {
			break
		}

		return e.complexity.WorkloadCostPeriod.Sum(childComplexity), true

	case "WorkloadEdge.cursor":
		if e.complexity.WorkloadEdge.Cursor == nil {
			break
		}

		return e.complexity.WorkloadEdge.Cursor(childComplexity), true

	case "WorkloadEdge.node":
		if e.complexity.WorkloadEdge.Node == nil {
			break
		}

		return e.complexity.WorkloadEdge.Node(childComplexity), true

	case "WorkloadResourceQuantity.cpu":
		if e.complexity.WorkloadResourceQuantity.CPU == nil {
			break
		}

		return e.complexity.WorkloadResourceQuantity.CPU(childComplexity), true

	case "WorkloadResourceQuantity.memory":
		if e.complexity.WorkloadResourceQuantity.Memory == nil {
			break
		}

		return e.complexity.WorkloadResourceQuantity.Memory(childComplexity), true

	case "WorkloadUtilization.current":
		if e.complexity.WorkloadUtilization.Current == nil {
			break
		}

		args, err := ec.field_WorkloadUtilization_current_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkloadUtilization.Current(childComplexity, args["resourceType"].(utilization.UtilizationResourceType)), true

	case "WorkloadUtilization.requested":
		if e.complexity.WorkloadUtilization.Requested == nil {
			break
		}

		args, err := ec.field_WorkloadUtilization_requested_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkloadUtilization.Requested(childComplexity, args["resourceType"].(utilization.UtilizationResourceType)), true

	case "WorkloadUtilization.series":
		if e.complexity.WorkloadUtilization.Series == nil {
			break
		}

		args, err := ec.field_WorkloadUtilization_series_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkloadUtilization.Series(childComplexity, args["input"].(utilization.WorkloadUtilizationSeriesInput)), true

	case "WorkloadUtilizationData.requested":
		if e.complexity.WorkloadUtilizationData.Requested == nil {
			break
		}

		return e.complexity.WorkloadUtilizationData.Requested(childComplexity), true

	case "WorkloadUtilizationData.used":
		if e.complexity.WorkloadUtilizationData.Used == nil {
			break
		}

		return e.complexity.WorkloadUtilizationData.Used(childComplexity), true

	case "WorkloadUtilizationData.workload":
		if e.complexity.WorkloadUtilizationData.Workload == nil {
			break
		}

		return e.complexity.WorkloadUtilizationData.Workload(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddRepositoryToTeamInput,
		ec.unmarshalInputAddTeamMemberInput,
		ec.unmarshalInputApplicationOrder,
		ec.unmarshalInputBigQueryDatasetAccessOrder,
		ec.unmarshalInputBigQueryDatasetOrder,
		ec.unmarshalInputBucketOrder,
		ec.unmarshalInputConfirmTeamDeletionInput,
		ec.unmarshalInputCreateTeamInput,
		ec.unmarshalInputDeleteApplicationInput,
		ec.unmarshalInputDeleteJobInput,
		ec.unmarshalInputImageVulnerabilityOrder,
		ec.unmarshalInputJobOrder,
		ec.unmarshalInputKafkaTopicAclFilter,
		ec.unmarshalInputKafkaTopicAclOrder,
		ec.unmarshalInputKafkaTopicOrder,
		ec.unmarshalInputOpenSearchAccessOrder,
		ec.unmarshalInputOpenSearchOrder,
		ec.unmarshalInputReconcilerConfigInput,
		ec.unmarshalInputRedisInstanceAccessOrder,
		ec.unmarshalInputRedisInstanceOrder,
		ec.unmarshalInputRemoveRepositoryFromTeamInput,
		ec.unmarshalInputRemoveTeamMemberInput,
		ec.unmarshalInputRequestTeamDeletionInput,
		ec.unmarshalInputRestartApplicationInput,
		ec.unmarshalInputSearchFilter,
		ec.unmarshalInputSetTeamMemberRoleInput,
		ec.unmarshalInputSqlInstanceOrder,
		ec.unmarshalInputSqlInstanceUserOrder,
		ec.unmarshalInputSynchronizeTeamInput,
		ec.unmarshalInputTeamMemberOrder,
		ec.unmarshalInputTeamOrder,
		ec.unmarshalInputTeamRepositoryFilter,
		ec.unmarshalInputUpdateTeamEnvironmentInput,
		ec.unmarshalInputUpdateTeamInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserTeamOrder,
		ec.unmarshalInputWorkloadOrder,
		ec.unmarshalInputWorkloadUtilizationSeriesInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/applications.graphqls", Input: `extend type Team {
	"NAIS applications owned by the team."
	applications(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: ApplicationOrder
	): ApplicationConnection!
}

extend type TeamEnvironment {
	"NAIS application in the team environment."
	application(name: String!): Application!
}

extend type Mutation {
	"Delete an application."
	deleteApplication(input: DeleteApplicationInput!): DeleteApplicationPayload!

	"Restart an application."
	restartApplication(input: RestartApplicationInput!): RestartApplicationPayload!
}

"""
TODO: write
"""
type Application implements Node & Workload {
	"The globally unique ID of the application."
	id: ID!

	"The name of the application."
	name: String!

	"The team that owns the application."
	team: Team!

	"The environment the application is deployed in."
	environment: TeamEnvironment!

	"The container image of the application."
	image: ContainerImage!

	"Resources for the application."
	resources: ApplicationResources!

	"List of ingresses for the application."
	ingresses: [String!]!

	"List of authentication and authorization for the application."
	authIntegrations: [ApplicationAuthIntegrations!]!

	"The application manifest."
	manifest: ApplicationManifest!

	# instances: [Instance!]!
	# autoScaling: AutoScaling!
}

type ApplicationManifest implements WorkloadManifest {
	"The manifest content, serialized as a YAML document."
	content: String!
}

union ApplicationAuthIntegrations =
	| EntraIDAuthIntegration
	| IDPortenAuthIntegration
	| MaskinportenAuthIntegration
	| TokenXAuthIntegration

type ApplicationResources implements WorkloadResources {
	"Instances using resources above this threshold will be killed."
	limits: WorkloadResourceQuantity!

	"How many resources are allocated to each instance."
	requests: WorkloadResourceQuantity!

	"Scaling strategies for the application."
	scaling: ApplicationScaling!
}

"""
TODO: write
"""
type ApplicationScaling {
	"The minimum number of application instances."
	minInstances: Int!

	"The maximum number of application instances."
	maxInstances: Int!

	"Scaling strategies for the application."
	strategies: [ScalingStrategy!]!
}

union ScalingStrategy = CPUScalingStrategy | KafkaLagScalingStrategy

"""
A scaling strategy based on CPU usage

Read more: https://docs.nais.io/workloads/application/reference/automatic-scaling/#cpu-based-scaling
"""
type CPUScalingStrategy {
	"The threshold that must be met for the scaling to trigger."
	threshold: Int!
}

type KafkaLagScalingStrategy {
	"The threshold that must be met for the scaling to trigger."
	threshold: Int!

	"The consumer group of the topic."
	consumerGroup: String!

	"The name of the Kafka topic."
	topicName: String!
}

type ApplicationConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Application!]!

	"List of edges."
	edges: [ApplicationEdge!]!
}

type ApplicationEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The application."
	node: Application!
}

"Ordering options when fetching applications."
input ApplicationOrder {
	"The field to order items by."
	field: ApplicationOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

enum ApplicationOrderField {
	"Order applications by name."
	NAME

	"Order applications by status."
	STATUS

	"Order applications by the name of the environment."
	ENVIRONMENT

	"Order applications by the deployment time."
	DEPLOYMENT_TIME
}

extend union SearchNode = Application
extend enum SearchType {
	APPLICATION
}

input DeleteApplicationInput {
	"Name of the application."
	name: String!
	"Slug of the team that owns the application."
	teamSlug: Slug!
	"Name of the environment where the application runs."
	environmentName: String!
}

type DeleteApplicationPayload {
	"The team that owned the deleted application."
	team: Team
}

input RestartApplicationInput {
	"Name of the application."
	name: String!
	"Slug of the team that owns the application."
	teamSlug: Slug!
	"Name of the environment where the application runs."
	environmentName: String!
}

type RestartApplicationPayload {
	"The application that was restarted."
	application: Application
}
`, BuiltIn: false},
	{Name: "../schema/auditlog.graphqls", Input: `extend type Team {
	"Audit entries associated with the team."
	auditEntries(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): AuditEntryConnection!
}

interface AuditEntry implements Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: AuditResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug

	"The environment name that the entry belongs to."
	environmentName: String
}

"The type of the resource that was affected by the action."
enum AuditResourceType {
	UNKNOWN
}

type AuditEntryConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [AuditEntry!]!

	"List of edges."
	edges: [AuditEntryEdge!]!
}

type AuditEntryEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The audit entry."
	node: AuditEntry!
}
`, BuiltIn: false},
	{Name: "../schema/cost.graphqls", Input: `extend type Team {
	"The cost for the team."
	cost: TeamCost!
}

type TeamCost {
	daily(
		"Start date of the period, inclusive."
		from: Date!

		"End date of the period, inclusive."
		to: Date!
	): TeamCostPeriod!

	monthlySummary: TeamCostMonthlySummary!
}

type TeamCostMonthlySummary {
	"The total cost for the last 12 months."
	sum: Float!

	"The cost series."
	series: [TeamCostMonthlySample!]! # TODO: Ask Vebjørn about naming things for analytic purposes
}

type TeamCostMonthlySample {
	"The last date with cost data in the month."
	date: Date!

	"The total cost for the month."
	cost: Float!
}

type TeamCostPeriod {
	"The total cost for the period."
	sum: Float!

	"The cost series."
	series: [ServiceCostSeries!]!
}

extend interface Workload {
	"The cost for a workload."
	cost: WorkloadCost!
}

extend type Application {
	"The cost for the application."
	cost: WorkloadCost!
}

extend type Job {
	"The cost for the job."
	cost: WorkloadCost!
}

type WorkloadCost {
	"Get the cost for a workload within a time period."
	daily(
		"Start date of the period, inclusive."
		from: Date!

		"End date of the period, inclusive."
		to: Date!
	): WorkloadCostPeriod!

	"The cost for the last 12 months."
	monthly: WorkloadCostPeriod!
}

type WorkloadCostPeriod {
	"The total cost for the period."
	sum: Float!

	"The cost series."
	series: [ServiceCostSeries!]!
}

type ServiceCostSeries {
	"The date for the cost. When calculating the cost for a monthly period, the date will be the last day of the month that has cost data."
	date: Date!

	"The sum of the cost across all services."
	sum: Float!

	"The cost for the services used by the workload."
	services: [ServiceCost!]!
}

type ServiceCost {
	"The name of the service."
	service: String!

	"The cost in euros."
	cost: Float!
}

extend type OpenSearch {
	cost: OpenSearchCost!
}

type OpenSearchCost {
	sum: Float!
}

extend type RedisInstance {
	cost: RedisInstanceCost!
}

type RedisInstanceCost {
	sum: Float!
}

extend type BigQueryDataset {
	cost: BigQueryDatasetCost!
}

type BigQueryDatasetCost {
	sum: Float!
}
`, BuiltIn: false},
	{Name: "../schema/jobs.graphqls", Input: `extend type Team {
	"NAIS jobs owned by the team."
	jobs(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: JobOrder
	): JobConnection!
}

extend type Mutation {
	"Delete an job."
	deleteJob(input: DeleteJobInput!): DeleteJobPayload!
}

extend type TeamEnvironment {
	"NAIS job in the team environment."
	job(name: String!): Job!
}

type Job implements Node & Workload {
	"The globally unique ID of the job."
	id: ID!

	"The name of the job."
	name: String!

	"The team that owns the job."
	team: Team!

	"The environment the job is deployed in."
	environment: TeamEnvironment!

	"The container image of the job."
	image: ContainerImage!

	"Resources for the job."
	resources: JobResources!

	"List of authentication and authorization for the job."
	authIntegrations: [JobAuthIntegrations!]!

	"Optional schedule for the job. Jobs with no schedule are run once."
	schedule: JobSchedule

	"The job runs."
	runs(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): JobRunConnection!

	"The job manifest."
	manifest: JobManifest!
}

type JobManifest implements WorkloadManifest {
	"The manifest content, serialized as a YAML document."
	content: String!
}

type JobSchedule {
	"The cron expression for the job."
	expression: String!

	"The time zone for the job. Defaults to UTC."
	timeZone: String!
}

union JobAuthIntegrations = EntraIDAuthIntegration | MaskinportenAuthIntegration

type JobResources implements WorkloadResources {
	limits: WorkloadResourceQuantity!
	requests: WorkloadResourceQuantity!
}

type JobRun implements Node {
	"The globally unique ID of the job run."
	id: ID!

	"The name of the job run."
	name: String!

	"The start time of the job."
	startTime: Time

	"The completion time of the job."
	completionTime: Time

	"The status of the job run."
	status: JobRunStatus!

	image: ContainerImage!

	# podNames: [String!]!
	# duration: String!
	# image: String!
	# message: String!
	# failed: Boolean!
}

enum JobRunStatus {
	"Job run is pending."
	PENDING

	"Job run is running."
	RUNNING

	"Job run is succeeded."
	SUCCEEDED

	"Job run is failed."
	FAILED

	"Job run is unknown."
	UNKNOWN
}

type JobConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Job!]!

	"List of edges."
	edges: [JobEdge!]!
}

type JobRunConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [JobRun!]!

	"List of edges."
	edges: [JobRunEdge!]!
}

type JobEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The job."
	node: Job!
}

type JobRunEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The job run."
	node: JobRun!
}

input JobOrder {
	"The field to order items by."
	field: JobOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

enum JobOrderField {
	"Order jobs by name."
	NAME

	"Order jobs by status."
	STATUS

	"Order jobs by the name of the environment."
	ENVIRONMENT

	"Order Jobs by the deployment time."
	DEPLOYMENT_TIME
}

extend union SearchNode = Job
extend enum SearchType {
	JOB
}

input DeleteJobInput {
	"Name of the job."
	name: String!
	"Slug of the team that owns the job."
	teamSlug: Slug!
	"Name of the environment where the job runs."
	environmentName: String!
}

type DeleteJobPayload {
	"The team that owned the deleted job."
	team: Team
}
`, BuiltIn: false},
	{Name: "../schema/netpol.graphqls", Input: `extend interface Workload {
	"Network policies for the workload."
	networkPolicy: NetworkPolicy!
}

extend type Application {
	"Network policies for the application."
	networkPolicy: NetworkPolicy!
}

extend type Job {
	"Network policies for the job."
	networkPolicy: NetworkPolicy!
}

interface ExternalNetworkPolicyTarget {
	target: String!
	ports: [Int!]!
}

type ExternalNetworkPolicyHost implements ExternalNetworkPolicyTarget {
	target: String!
	ports: [Int!]!
}

type ExternalNetworkPolicyIpv4 implements ExternalNetworkPolicyTarget {
	target: String!
	ports: [Int!]!
}

type NetworkPolicyRule {
	targetWorkloadName: String!
	targetWorkload: Workload
	targetTeamSlug: Slug!
	targetTeam: Team
	mutual: Boolean!
}

type InboundNetworkPolicy {
	rules: [NetworkPolicyRule!]!
}

type OutboundNetworkPolicy {
	rules: [NetworkPolicyRule!]!
	external: [ExternalNetworkPolicyTarget!]!
}

type NetworkPolicy {
	inbound: InboundNetworkPolicy!
	outbound: OutboundNetworkPolicy!
}
`, BuiltIn: false},
	{Name: "../schema/persistence.graphqls", Input: `###
### Extend Team type with persistence fields
###

extend type Team {
	"BigQuery datasets owned by the team."
	bigQueryDatasets(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: BigQueryDatasetOrder
	): BigQueryDatasetConnection!

	"Redis instances owned by the team."
	redisInstances(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: RedisInstanceOrder
	): RedisInstanceConnection!

	"OpenSearch instances owned by the team."
	openSearchInstances(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: OpenSearchOrder
	): OpenSearchConnection!

	"Google Cloud Storage buckets owned by the team."
	buckets(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: BucketOrder
	): BucketConnection!

	"Kafka topics owned by the team."
	kafkaTopics(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: KafkaTopicOrder
	): KafkaTopicConnection!

	"SQL instances owned by the team."
	sqlInstances(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: SqlInstanceOrder
	): SqlInstanceConnection!
}

extend type TeamEnvironment {
	"BigQuery datasets in the team environment."
	bigQueryDataset(name: String!): BigQueryDataset!

	"Storage bucket in the team environment."
	bucket(name: String!): Bucket!

	"Kafka topic in the team environment."
	kafkaTopic(name: String!): KafkaTopic!

	"OpenSearch instance in the team environment."
	openSearchInstance(name: String!): OpenSearch!

	"Redis instance in the team environment."
	redisInstance(name: String!): RedisInstance!

	"SQL instance in the team environment."
	sqlInstance(name: String!): SqlInstance!
}

###
### Extend Workload interface with persistence fields
###

extend interface Workload {
	"BigQuery datasets referenced by the workload. This does not currently support pagination, but will return all available datasets."
	bigQueryDatasets(
		"Ordering options for items returned from the connection."
		orderBy: BigQueryDatasetOrder
	): BigQueryDatasetConnection!

	"Redis instances referenced by the workload. This does not currently support pagination, but will return all available Redis instances."
	redisInstances(
		"Ordering options for items returned from the connection."
		orderBy: RedisInstanceOrder
	): RedisInstanceConnection!

	"OpenSearch instance referenced by the workload."
	openSearch: OpenSearch

	"Google Cloud Storage referenced by the workload. This does not currently support pagination, but will return all available buckets."
	buckets(
		"Ordering options for items returned from the connection."
		orderBy: BucketOrder
	): BucketConnection!

	"Kafka topics the workload has access to. This does not currently support pagination, but will return all available Kafka topics."
	kafkaTopicAcls(
		"Ordering options for items returned from the connection."
		orderBy: KafkaTopicAclOrder
	): KafkaTopicAclConnection!

	"SQL instances referenced by the workload. This does not currently support pagination, but will return all available SQL instances."
	sqlInstances(
		"Ordering options for items returned from the connection."
		orderBy: SqlInstanceOrder
	): SqlInstanceConnection!
}

###
### Extend Application type with persistence fields
###

extend type Application {
	"BigQuery datasets referenced by the application. This does not currently support pagination, but will return all available datasets."
	bigQueryDatasets(
		"Ordering options for items returned from the connection."
		orderBy: BigQueryDatasetOrder
	): BigQueryDatasetConnection!

	"Redis instances referenced by the application. This does not currently support pagination, but will return all available Redis instances."
	redisInstances(
		"Ordering options for items returned from the connection."
		orderBy: RedisInstanceOrder
	): RedisInstanceConnection!

	"OpenSearch instance referenced by the workload."
	openSearch: OpenSearch

	"Google Cloud Storage referenced by the application. This does not currently support pagination, but will return all available buckets."
	buckets(
		"Ordering options for items returned from the connection."
		orderBy: BucketOrder
	): BucketConnection!

	"Kafka topics the application has access to. This does not currently support pagination, but will return all available Kafka topics."
	kafkaTopicAcls(
		"Ordering options for items returned from the connection."
		orderBy: KafkaTopicAclOrder
	): KafkaTopicAclConnection!

	"SQL instances referenced by the application. This does not currently support pagination, but will return all available SQL instances."
	sqlInstances(
		"Ordering options for items returned from the connection."
		orderBy: SqlInstanceOrder
	): SqlInstanceConnection!
}

###
### Extend Job type with persistence fields
###

extend type Job {
	"BigQuery datasets referenced by the job. This does not currently support pagination, but will return all available datasets."
	bigQueryDatasets(
		"Ordering options for items returned from the connection."
		orderBy: BigQueryDatasetOrder
	): BigQueryDatasetConnection!

	"Redis instances referenced by the job. This does not currently support pagination, but will return all available Redis instances."
	redisInstances(
		"Ordering options for items returned from the connection."
		orderBy: RedisInstanceOrder
	): RedisInstanceConnection!

	"OpenSearch instance referenced by the workload."
	openSearch: OpenSearch

	"Google Cloud Storage referenced by the job. This does not currently support pagination, but will return all available buckets."
	buckets(
		"Ordering options for items returned from the connection."
		orderBy: BucketOrder
	): BucketConnection!

	"Kafka topics the job has access to. This does not currently support pagination, but will return all available Kafka topics."
	kafkaTopicAcls(
		"Ordering options for items returned from the connection."
		orderBy: KafkaTopicAclOrder
	): KafkaTopicAclConnection!

	"SQL instances referenced by the job. This does not currently support pagination, but will return all available SQL instances."
	sqlInstances(
		"Ordering options for items returned from the connection."
		orderBy: SqlInstanceOrder
	): SqlInstanceConnection!
}

interface Persistence implements Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment!
}

type BigQueryDataset implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment!
	cascadingDelete: Boolean!
	description: String
	access(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		orderBy: BigQueryDatasetAccessOrder
	): BigQueryDatasetAccessConnection!
	status: BigQueryDatasetStatus!
	workload: Workload
}

type BigQueryDatasetAccess {
	role: String!
	email: String!
}

type BigQueryDatasetStatus {
	creationTime: Time!
	lastModifiedTime: Time
}

type Bucket implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment!
	cascadingDelete: Boolean!
	publicAccessPrevention: String!
	uniformBucketLevelAccess: Boolean!
	workload: Workload
	status: BucketStatus!
}

type BucketStatus {
	state: String!
}

type KafkaTopic implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment!
	acl(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		filter: KafkaTopicAclFilter
		orderBy: KafkaTopicAclOrder
	): KafkaTopicAclConnection!
	configuration: KafkaTopicConfiguration
	pool: String!
	status: KafkaTopicStatus!
}

type KafkaTopicAcl {
	access: String!
	workloadName: String!
	teamName: String!
	team: Team
	workload: Workload
	topic: KafkaTopic!
}

type KafkaTopicConfiguration {
	cleanupPolicy: String
	maxMessageBytes: Int
	minimumInSyncReplicas: Int
	partitions: Int
	replication: Int
	retentionBytes: Int
	retentionHours: Int
	segmentHours: Int
}

type KafkaTopicStatus {
	state: String!
}

type OpenSearch implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment!
	status: OpenSearchStatus!
	workload: Workload
	access(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		orderBy: OpenSearchAccessOrder
	): OpenSearchAccessConnection!
}

type OpenSearchAccess {
	workload: Workload!
	access: String!
}

type OpenSearchStatus {
	state: String!
}

type RedisInstance implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment!
	access(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		orderBy: RedisInstanceAccessOrder
	): RedisInstanceAccessConnection!
	workload: Workload
	status: RedisInstanceStatus!
}

type RedisInstanceAccess {
	workload: Workload!
	access: String!
}

type RedisInstanceStatus {
	state: String!
}

type SqlDatabase implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment!
	charset: String
	collation: String
	deletionPolicy: String
	healthy: Boolean!
}

type SqlInstance implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment!
	workload: Workload
	cascadingDelete: Boolean!
	connectionName: String
	diskAutoresize: Boolean
	diskAutoresizeLimit: Int
	highAvailability: Boolean!
	healthy: Boolean!
	maintenanceVersion: String
	maintenanceWindow: SqlInstanceMaintenanceWindow
	backupConfiguration: SqlInstanceBackupConfiguration
	projectID: String!
	tier: String!
	version: String
	status: SqlInstanceStatus!
	database: SqlDatabase
	flags(first: Int, after: Cursor, last: Int, before: Cursor): SqlInstanceFlagConnection!
	users(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		orderBy: SqlInstanceUserOrder
	): SqlInstanceUserConnection!
}

type SqlInstanceBackupConfiguration {
	enabled: Boolean
	startTime: String
	retainedBackups: Int
	pointInTimeRecovery: Boolean
	transactionLogRetentionDays: Int
}

type SqlInstanceFlag {
	name: String!
	value: String!
}

type SqlInstanceMaintenanceWindow {
	day: Int!
	hour: Int!
}

type SqlInstanceStatus {
	publicIpAddress: String
	privateIpAddress: String
}

type SqlInstanceUser {
	name: String!
	authentication: String!
}

type BigQueryDatasetAccessConnection {
	pageInfo: PageInfo!
	nodes: [BigQueryDatasetAccess!]!
	edges: [BigQueryDatasetAccessEdge!]!
}

type BigQueryDatasetConnection {
	pageInfo: PageInfo!
	nodes: [BigQueryDataset!]!
	edges: [BigQueryDatasetEdge!]!
}

type BucketConnection {
	pageInfo: PageInfo!
	nodes: [Bucket!]!
	edges: [BucketEdge!]!
}

type KafkaTopicConnection {
	pageInfo: PageInfo!
	nodes: [KafkaTopic!]!
	edges: [KafkaTopicEdge!]!
}

type KafkaTopicAclConnection {
	pageInfo: PageInfo!
	nodes: [KafkaTopicAcl!]!
	edges: [KafkaTopicAclEdge!]!
}

type OpenSearchAccessConnection {
	pageInfo: PageInfo!
	nodes: [OpenSearchAccess!]!
	edges: [OpenSearchAccessEdge!]!
}

type OpenSearchConnection {
	pageInfo: PageInfo!
	nodes: [OpenSearch!]!
	edges: [OpenSearchEdge!]!
}

type RedisInstanceAccessConnection {
	pageInfo: PageInfo!
	nodes: [RedisInstanceAccess!]!
	edges: [RedisInstanceAccessEdge!]!
}

type RedisInstanceConnection {
	pageInfo: PageInfo!
	nodes: [RedisInstance!]!
	edges: [RedisInstanceEdge!]!
}

type SqlInstanceConnection {
	pageInfo: PageInfo!
	nodes: [SqlInstance!]!
	edges: [SqlInstanceEdge!]!
}

type SqlInstanceFlagConnection {
	pageInfo: PageInfo!
	nodes: [SqlInstanceFlag!]!
	edges: [SqlInstanceFlagEdge!]!
}

type SqlInstanceUserConnection {
	pageInfo: PageInfo!
	nodes: [SqlInstanceUser!]!
	edges: [SqlInstanceUserEdge!]!
}

type BigQueryDatasetAccessEdge {
	cursor: Cursor!
	node: BigQueryDatasetAccess!
}

type BigQueryDatasetEdge {
	cursor: Cursor!
	node: BigQueryDataset!
}

type BucketEdge {
	cursor: Cursor!
	node: Bucket!
}

type KafkaTopicEdge {
	cursor: Cursor!
	node: KafkaTopic!
}

type KafkaTopicAclEdge {
	cursor: Cursor!
	node: KafkaTopicAcl!
}

type OpenSearchAccessEdge {
	cursor: Cursor!
	node: OpenSearchAccess!
}

type OpenSearchEdge {
	cursor: Cursor!
	node: OpenSearch!
}

type RedisInstanceAccessEdge {
	cursor: Cursor!
	node: RedisInstanceAccess!
}

type RedisInstanceEdge {
	cursor: Cursor!
	node: RedisInstance!
}

type SqlInstanceEdge {
	cursor: Cursor!
	node: SqlInstance!
}

type SqlInstanceFlagEdge {
	cursor: Cursor!
	node: SqlInstanceFlag!
}

type SqlInstanceUserEdge {
	cursor: Cursor!
	node: SqlInstanceUser!
}

input BigQueryDatasetAccessOrder {
	field: BigQueryDatasetAccessOrderField!
	direction: OrderDirection!
}

input BigQueryDatasetOrder {
	field: BigQueryDatasetOrderField!
	direction: OrderDirection!
}

input BucketOrder {
	field: BucketOrderField!
	direction: OrderDirection!
}

input KafkaTopicAclFilter {
	team: Slug
	workload: String
}

input KafkaTopicOrder {
	field: KafkaTopicOrderField!
	direction: OrderDirection!
}

input KafkaTopicAclOrder {
	field: KafkaTopicAclOrderField!
	direction: OrderDirection!
}

input OpenSearchAccessOrder {
	field: OpenSearchAccessOrderField!
	direction: OrderDirection!
}

input OpenSearchOrder {
	field: OpenSearchOrderField!
	direction: OrderDirection!
}

input RedisInstanceAccessOrder {
	field: RedisInstanceAccessOrderField!
	direction: OrderDirection!
}

input RedisInstanceOrder {
	field: RedisInstanceOrderField!
	direction: OrderDirection!
}

input SqlInstanceOrder {
	field: SqlInstanceOrderField!
	direction: OrderDirection!
}

input SqlInstanceUserOrder {
	field: SqlInstanceUserOrderField!
	direction: OrderDirection!
}

enum BigQueryDatasetAccessOrderField {
	ROLE
	EMAIL
}

enum BigQueryDatasetOrderField {
	NAME
	ENVIRONMENT
}

enum BucketOrderField {
	NAME
	ENVIRONMENT
}

enum KafkaTopicOrderField {
	NAME
	ENVIRONMENT
}

enum KafkaTopicAclOrderField {
	TOPIC_NAME
	TEAM_SLUG
	CONSUMER
	ACCESS
}

enum RedisInstanceAccessOrderField {
	ACCESS
	WORKLOAD
}

enum OpenSearchAccessOrderField {
	ACCESS
	WORKLOAD
}

enum OpenSearchOrderField {
	NAME
	ENVIRONMENT
}

enum RedisInstanceOrderField {
	NAME
	ENVIRONMENT
}

enum SqlInstanceOrderField {
	NAME
	VERSION
	ENVIRONMENT
}

enum SqlInstanceUserOrderField {
	NAME
	AUTHENTICATION
}

extend union SearchNode =
	| SqlInstance
	| RedisInstance
	| OpenSearch
	| KafkaTopic
	| Bucket
	| BigQueryDataset
extend enum SearchType {
	SQL_INSTANCE
	REDIS_INSTANCE
	OPENSEARCH
	KAFKA_TOPIC
	BUCKET
	BIGQUERY_DATASET
}
`, BuiltIn: false},
	{Name: "../schema/reconcilers.graphqls", Input: `extend type Mutation {
	"""
	Enable a reconciler

	A reconciler must be fully configured before it can be enabled.
	"""
	enableReconciler("The name of the reconciler to enable." name: String!): Reconciler!

	"""
	Disable a reconciler

	The reconciler configuration will be left intact.
	"""
	disableReconciler("The name of the reconciler to disable." name: String!): Reconciler!

	"Configure a reconciler."
	configureReconciler(
		"The name of the reconciler to configure."
		name: String!

		"List of reconciler config inputs."
		config: [ReconcilerConfigInput!]!
	): Reconciler!
}

extend type Query {
	"Get a collection of reconcilers."
	reconcilers(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): ReconcilerConnection!
}

type ReconcilerConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Reconciler!]!

	"List of edges."
	edges: [ReconcilerEdge!]!
}

type ReconcilerEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The reconciler."
	node: Reconciler!
}

"Reconciler type."
type Reconciler {
	"The name of the reconciler."
	name: String!

	"The human-friendly name of the reconciler."
	displayName: String!

	"Description of what the reconciler is responsible for."
	description: String!

	"Whether or not the reconciler is enabled."
	enabled: Boolean!

	"Reconciler configuration keys and descriptions."
	config: [ReconcilerConfig!]!

	"Whether or not the reconciler is fully configured and ready to be enabled."
	configured: Boolean!

	# "Audit logs for this reconciler."
	# auditLogs(offset: Int, limit: Int): AuditLogList!

	# "Potential errors that have occurred during the reconciler's operation."
	# errors(offset: Int, limit: Int): ReconcilerErrorList!
}

# type ReconcilerErrorList {
#   nodes: [ReconcilerError!]!
#   pageInfo: PageInfo!
# }

# type ReconcilerError {
#   id: ID!
#   correlationId: ID!
#   createdAt: Time!
#   message: String!
#   team: Team!
# }

"Reconciler configuration type."
type ReconcilerConfig {
	"Configuration key."
	key: String!

	"The human-friendly name of the configuration key."
	displayName: String!

	"Configuration description."
	description: String!

	"Whether or not the configuration key has a value."
	configured: Boolean!

	"Whether or not the configuration value is considered a secret. Secret values will not be exposed through the API."
	secret: Boolean!

	"Configuration value. This will be set to null if the value is considered a secret."
	value: String
}

"Reconciler configuration input."
input ReconcilerConfigInput {
	"Configuration key."
	key: String!

	"Configuration value."
	value: String!
}
`, BuiltIn: false},
	{Name: "../schema/repository.graphqls", Input: `extend type Team {
	repositories(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		filter: TeamRepositoryFilter
	): RepositoryConnection!
}

extend type Mutation {
	"Add a team repository."
	addRepositoryToTeam(input: AddRepositoryToTeamInput!): AddRepositoryToTeamPayload!

	"Remove a team repository."
	removeRepositoryFromTeam(input: RemoveRepositoryFromTeamInput!): RemoveRepositoryFromTeamPayload!
}

input AddRepositoryToTeamInput {
	"Slug of the team to add the repository to."
	teamSlug: Slug!

	"Name of the repository, with the org prefix, for instance 'org/repo'."
	repositoryName: String!
}

type AddRepositoryToTeamPayload {
	"Repository that was added to the team."
	repository: Repository
}

input RemoveRepositoryFromTeamInput {
	"Slug of the team to remove the repository from."
	teamSlug: Slug!

	"Name of the repository, with the org prefix, for instance 'org/repo'."
	repositoryName: String!
}

type RemoveRepositoryFromTeamPayload {
	"Whether or not the repository was removed from the team."
	success: Boolean
}

type RepositoryConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Repository!]!

	"List of edges."
	edges: [RepositoryEdge!]!
}

type RepositoryEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The GitHub repository."
	node: Repository!
}

type Repository implements Node {
	"ID of the repository."
	id: ID!

	"Name of the repository, with the organization prefix."
	name: String!

	"Team this repository is connected to."
	team: Team!
}

input TeamRepositoryFilter {
	"Filter by repository name containing the phrase."
	name: String
}
`, BuiltIn: false},
	{Name: "../schema/scalars.graphqls", Input: `"Time is a string in [RFC 3339](https://rfc-editor.org/rfc/rfc3339.html) format, with sub-second precision added if present."
scalar Time

"Date type in YYYY-MM-DD format."
scalar Date

"""
The slug must:

- contain only lowercase alphanumeric characters or hyphens
- contain at least 3 characters and at most 30 characters
- start with an alphabetic character
- end with an alphanumeric character
- not contain two hyphens in a row

Examples of valid slugs:

- ` + "`" + `some-value` + "`" + `
- ` + "`" + `someothervalue` + "`" + `
- ` + "`" + `my-team-123` + "`" + `
"""
scalar Slug

"""
A cursor for use in pagination

Cursors are opaque strings that are returned by the server for paginated results, and used when performing backwards / forwards pagination.
"""
scalar Cursor
`, BuiltIn: false},
	{Name: "../schema/schema.graphqls", Input: `"The query root for the NAIS GraphQL API."
type Query {
	"Fetch an object using its globally unique ID."
	node(id: ID!): Node
}

"The mutation root for the NAIS GraphQL API."
type Mutation

"""
This interface is implemented by types that supports the [Global Object Identification specification](https://graphql.org/learn/global-object-identification/).
"""
interface Node {
	"Globally unique ID of the object."
	id: ID!
}

"""
This type is used for paginating the connection

Learn more about how we have implemented pagination in the [GraphQL Best Practices documentation](https://graphql.org/learn/pagination/).
"""
type PageInfo {
	"Whether or not there exists a next page in the connection."
	hasNextPage: Boolean!

	"The cursor for the last item in the edges. This cursor is used when paginating forwards."
	endCursor: Cursor

	"Whether or not there exists a previous page in the connection."
	hasPreviousPage: Boolean!

	"The cursor for the first item in the edges. This cursor is used when paginating backwards."
	startCursor: Cursor

	"The total amount of items in the connection."
	totalCount: Int!

	"The offset of the first item in the connection."
	pageStart: Int!

	"The offset of the last item in the connection."
	pageEnd: Int!
}

"Possible directions in which to order a list of items."
enum OrderDirection {
	"Ascending sort order."
	ASC

	"Descending sort order."
	DESC
}
`, BuiltIn: false},
	{Name: "../schema/search.graphqls", Input: `extend type Query {
	search(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		filter: SearchFilter!
	): SearchNodeConnection!
}

union SearchNode = Team

input SearchFilter {
	query: String!
	type: SearchType
}

type SearchNodeConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [SearchNode!]!

	"List of edges."
	edges: [SearchNodeEdge!]!
}

type SearchNodeEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The SearchNode."
	node: SearchNode!
}

enum SearchType {
	TEAM
}
`, BuiltIn: false},
	{Name: "../schema/teams.graphqls", Input: `extend type Query {
	"Get a list of teams."
	teams(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: TeamOrder
	): TeamConnection!

	"Get a team by its slug."
	team(slug: Slug!): Team!
}

extend type Mutation {
	"""
	Create a new NAIS team

	The user creating the team will be granted team ownership, unless the user is a service account, in which case the
	team will not get an initial owner. To add one or more owners to the team, refer to the ` + "`" + `addTeamOwners` + "`" + ` mutation.

	Creation of a team will also create external resources for the team, which will be managed by the NAIS API
	reconcilers. This will be done asynchronously.

	Refer to the [official NAIS documentation](https://docs.nais.io/explanations/team/) for more information regarding
	NAIS teams.
	"""
	createTeam(input: CreateTeamInput!): CreateTeamPayload!

	"""
	Update an existing NAIS team

	This mutation can be used to update the team purpose and the main Slack channel. It is not possible to update the
	team slug.
	"""
	updateTeam(input: UpdateTeamInput!): UpdateTeamPayload!

	"""
	Update an environment for a team
	"""
	updateTeamEnvironment(input: UpdateTeamEnvironmentInput!): UpdateTeamEnvironmentPayload!

	"""
	Manually synchronize a team

	This action will trigger a full synchronization of the team with the configured third party systems. The process is
	asynchronous.
	"""
	synchronizeTeam(input: SynchronizeTeamInput!): SynchronizeTeamPayload!

	"""
	Request a key that can be used to trigger a team deletion process

	Deleting a team is a two step process. First an owner of the team (or an admin) must request a team deletion key,
	and then a second owner of the team (or an admin) must confirm the deletion using the confirmTeamDeletion mutation.

	The returned delete key is valid for an hour, and can only be used once.

	Note: Service accounts are not allowed to request team delete keys.
	"""
	requestTeamDeletion(input: RequestTeamDeletionInput!): RequestTeamDeletionPayload!

	"""
	Confirm a team deletion

	This will start the actual team deletion process, which will be done in an asynchronous manner. All external
	entities controlled by NAIS will also be deleted.

	WARNING: There is no going back after starting this process.

	Note: Service accounts are not allowed to confirm a team deletion.
	"""
	confirmTeamDeletion(input: ConfirmTeamDeletionInput!): ConfirmTeamDeletionPayload!

	"""
	Add a team member

	If the user is already a member or an owner of the team, the mutation will result in an error.
	"""
	addTeamMember(input: AddTeamMemberInput!): AddTeamMemberPayload!

	"""
	Remove a team member

	If the user is not already a member or an owner of the team, the mutation will result in an error.
	"""
	removeTeamMember(input: RemoveTeamMemberInput!): RemoveTeamMemberPayload!

	"""
	Assign a role to a team member

	The user must already be a member of the team for this mutation to succeed.
	"""
	setTeamMemberRole(input: SetTeamMemberRoleInput!): SetTeamMemberRolePayload!
}

"""
The team type represents a team on the [NAIS platform](https://nais.io/).

Learn more about what NAIS teams are and what they can be used for in the [official NAIS documentation](https://docs.nais.io/explanations/team/).

External resources (e.g. azureGroupID, gitHubTeamSlug) are managed by [NAIS API reconcilers](https://github.com/nais/api-reconcilers).
"""
type Team implements Node {
	"The globally unique ID of the team."
	id: ID!

	"Unique slug of the team."
	slug: Slug!

	"Main Slack channel for the team."
	slackChannel: String!

	"Purpose of the team."
	purpose: String!

	"The ID of the Azure AD group for the team. This value is managed by the Azure AD reconciler."
	azureGroupID: String

	"The slug of the GitHub team. This value is managed by the GitHub reconciler."
	gitHubTeamSlug: String

	"The email address of the Google Workspace group for the team. This value is managed by the Google Workspace reconciler."
	googleGroupEmail: String

	"The Google Artifact Registry for the team. This value is managed by the Google Artifact Registry (GAR) reconciler."
	googleArtifactRegistry: String

	"The CDN bucket for the team. This value is managed by the Google CDN reconciler."
	cdnBucket: String

	"Get a specific member of the team."
	member(email: String!): TeamMember!

	"Team members."
	members(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: TeamMemberOrder
	): TeamMemberConnection!

	"Timestamp of the last successful synchronization of the team."
	lastSuccessfulSync: Time

	"Whether or not the team is currently being deleted."
	deletionInProgress: Boolean!

	"Whether or not the viewer is an owner of the team."
	viewerIsOwner: Boolean!

	"Whether or not the viewer is a member of the team."
	viewerIsMember: Boolean!

	"Environments for the team."
	environments: [TeamEnvironment!]!

	"Get a specific environment for the team."
	environment(name: String!): TeamEnvironment!

	"Get a delete key for the team."
	deleteKey(key: String!): TeamDeleteKey!
}

type TeamEnvironment implements Node {
	"The globally unique ID of the team environment."
	id: ID!

	"Name of the team environment."
	name: String!

	"The GCP project ID for the team environment."
	gcpProjectID: String

	"The Slack alerts channel for the team environment."
	slackAlertsChannel: String!

	"The connected team."
	team: Team!
}

type TeamMember {
	"Team instance."
	team: Team!

	"User instance."
	user: User!

	"The role that the user has in the team."
	role: TeamMemberRole!
}

type CreateTeamPayload {
	"The newly created team."
	team: Team
}

type UpdateTeamPayload {
	"The updated team."
	team: Team
}

type UpdateTeamEnvironmentPayload {
	"The updated team environment."
	environment: TeamEnvironment
}

type SynchronizeTeamPayload {
	"The synchronized team."
	team: Team
}

type RequestTeamDeletionPayload {
	"The delete key for the team. This can be used to confirm the deletion of the team."
	key: TeamDeleteKey
}

type ConfirmTeamDeletionPayload {
	"Whether or not the asynchronous deletion process was started."
	deletionStarted: Boolean
}

type AddTeamMemberPayload {
	"The added team member."
	member: TeamMember
}

type RemoveTeamMemberPayload {
	"The user that was removed from the team."
	user: User

	"The team that the member was removed from."
	team: Team
}

type SetTeamMemberRolePayload {
	"The updated team member."
	member: TeamMember
}

type TeamDeleteKey {
	"The unique key used to confirm the deletion of a team."
	key: String!

	"The creation timestamp of the key."
	createdAt: Time!

	"Expiration timestamp of the key."
	expires: Time!

	"The user who created the key."
	createdBy: User!

	"The team the delete key is for."
	team: Team!
}

type TeamConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Team!]!

	"List of edges."
	edges: [TeamEdge!]!
}

type TeamMemberConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [TeamMember!]!

	"List of edges."
	edges: [TeamMemberEdge!]!
}

type TeamEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The team."
	node: Team!
}

type TeamMemberEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The team member."
	node: TeamMember!
}

input CreateTeamInput {
	"""
	Unique team slug.

	After creation, this value can not be changed. Also, after a potential deletion of the team, the slug can not be
	reused, so please choose wisely.
	"""
	slug: Slug!

	"""
	The purpose / description of the team.

	What is the team for? What is the team working on? This value is meant for human consumption, and should be enough
	to give a newcomer an idea of what the team is about.
	"""
	purpose: String!

	"""
	The main Slack channel for the team.

	Where does the team communicate? This value is used to link to the team's main Slack channel.
	"""
	slackChannel: String!
}

input UpdateTeamInput {
	"Slug of the team to update."
	slug: Slug!

	"""
	An optional new purpose / description of the team.

	When omitted the existing value will not be updated.
	"""
	purpose: String

	"""
	An optional new Slack channel for the team.

	When omitted the existing value will not be updated.
	"""
	slackChannel: String
}

input UpdateTeamEnvironmentInput {
	"Slug of the team to update."
	slug: Slug!

	"Name of the environment to update."
	environmentName: String!

	"Slack alerts channel for the environment. Set to an empty string to remove the existing value."
	slackAlertsChannel: String
}

input SynchronizeTeamInput {
	"Slug of the team to synchronize."
	slug: Slug!
}

"Ordering options when fetching teams."
input TeamOrder {
	"The field to order items by."
	field: TeamOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

"Ordering options for team members."
input TeamMemberOrder {
	"The field to order items by."
	field: TeamMemberOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

input RequestTeamDeletionInput {
	"Slug of the team to request a team deletion key for."
	slug: Slug!
}

input ConfirmTeamDeletionInput {
	"Slug of the team to confirm deletion for."
	slug: Slug!

	"Deletion key, acquired using the requestTeamDeletion mutation."
	key: String!
}

input AddTeamMemberInput {
	"Slug of the team that should receive a new member."
	teamSlug: Slug!

	"The email address of the user to add to the team."
	userEmail: String!

	"The role that the user will have in the team."
	role: TeamMemberRole!
}

input RemoveTeamMemberInput {
	"Slug of the team that the member should be removed from."
	teamSlug: Slug!

	"The email address of the user to remove from the team."
	userEmail: String!
}

input SetTeamMemberRoleInput {
	"The slug of the team."
	teamSlug: Slug!

	"The email address of the user."
	userEmail: String!

	"The role to assign."
	role: TeamMemberRole!
}

"Possible fields to order teams by."
enum TeamOrderField {
	"The unique slug of the team."
	TEAM_SLUG
}

"Possible fields to order team members by."
enum TeamMemberOrderField {
	"The name of user."
	NAME

	"The email address of the user."
	EMAIL

	"The role the user has in the team."
	ROLE
}

"Team member roles."
enum TeamMemberRole {
	"Regular member, read only access."
	MEMBER

	"Team owner, full access to the team."
	OWNER
}

extend enum AuditResourceType {
	"All audit entries related to teams will use this resource type."
	TEAM
}

type TeamCreatedAuditEntry implements AuditEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: AuditResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type TeamUpdatedAuditEntry implements AuditEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: AuditResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the update."
	data: TeamUpdatedAuditEntryData
}

type TeamUpdatedAuditEntryData {
	"Fields that were updated."
	updatedFields: [TeamUpdatedAuditEntryDataUpdatedField!]!
}

type TeamUpdatedAuditEntryDataUpdatedField {
	"The name of the field."
	field: String!

	"The old value of the field."
	oldValue: String

	"The new value of the field."
	newValue: String
}

type TeamCreateDeleteKeyAuditEntry implements AuditEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: AuditResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type TeamConfirmDeleteKeyAuditEntry implements AuditEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: AuditResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type TeamMemberAddedAuditEntry implements AuditEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: AuditResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the action."
	data: TeamMemberAddedAuditEntryData!
}

type TeamMemberAddedAuditEntryData {
	"The role that the user was added with."
	role: TeamMemberRole!

	"The ID of the user that was added."
	userID: ID!

	"The email address of the user that was added."
	userEmail: String!

	"The user itself."
	user: User
}

type TeamMemberRemovedAuditEntry implements AuditEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: AuditResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the action."
	data: TeamMemberRemovedAuditEntryData!
}

type TeamMemberRemovedAuditEntryData {
	"The ID of the user that was removed."
	userID: ID!

	"The email address of the user that was removed."
	userEmail: String!

	"The user itself."
	user: User
}

type TeamMemberSetRoleAuditEntry implements AuditEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: AuditResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the action."
	data: TeamMemberSetRoleAuditEntryData!
}

type TeamMemberSetRoleAuditEntryData {
	"The role that the user was assigned."
	role: TeamMemberRole!

	"The ID of the user that was added."
	userID: ID!

	"The email address of the user that was added."
	userEmail: String!

	"The user itself."
	user: User
}

type TeamEnvironmentUpdatedAuditEntry implements AuditEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: AuditResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the action."
	data: TeamEnvironmentUpdatedAuditEntryData!
}

type TeamEnvironmentUpdatedAuditEntryData {
	"The name of the environment that was updated."
	environmentName: String!

	"Fields that were updated."
	updatedFields: [TeamEnvironmentUpdatedAuditEntryDataUpdatedField!]!
}

type TeamEnvironmentUpdatedAuditEntryDataUpdatedField {
	"The name of the field."
	field: String!

	"The old value of the field."
	oldValue: String

	"The new value of the field."
	newValue: String
}
`, BuiltIn: false},
	{Name: "../schema/users.graphqls", Input: `extend type Query {
	"Get a list of users."
	users(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: UserOrder
	): UserConnection!

	"Get a user by its ID."
	user(id: ID!): User!

	"The currently authenticated user."
	me: AuthenticatedUser!
}

"""
The user type represents a user of the NAIS platform and the NAIS GraphQL API.
"""
type User implements Node {
	"The globally unique ID of the user."
	id: ID!

	"The email address of the user."
	email: String!

	"The full name of the user."
	name: String!

	"The external ID of the user. This value is managed by the NAIS API user synchronization."
	externalID: String!

	"List of teams the user is connected to."
	teams(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: UserTeamOrder
	): TeamMemberConnection!
}

type UserConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [User!]!

	"List of edges."
	edges: [UserEdge!]!
}

type UserEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The user."
	node: User!
}

"Ordering options when fetching users."
input UserOrder {
	"The field to order items by."
	field: UserOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

"Ordering options when fetching the teams a user is connected to."
input UserTeamOrder {
	"The field to order items by."
	field: UserTeamOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

"Possible fields to order users by."
enum UserOrderField {
	"The name of user."
	NAME

	"The email address of the user."
	EMAIL
}

"Possible fields to order user teams by."
enum UserTeamOrderField {
	"The unique slug of the team."
	TEAM_SLUG
}

"Authenticated user type. Can be a user or a service account."
union AuthenticatedUser = User #| ServiceAccount
`, BuiltIn: false},
	{Name: "../schema/utilization.graphqls", Input: `extend type Application {
	utilization: WorkloadUtilization!
}

extend type Team {
	workloadUtilization(resourceType: UtilizationResourceType!): [WorkloadUtilizationData]!
}

extend type Query {
	teamsUtilization(resourceType: UtilizationResourceType!): [TeamUtilizationData!]!
}

type WorkloadUtilizationData {
	"The workload."
	workload: Workload!

	"The requested amount of resources"
	requested: Float!

	"The current resource usage."
	used: Float!
}

type TeamUtilizationEnvironmentDataPoint {
	"Value of the used resource at the given timestamp."
	value: Float!

	"The team environment"
	environment: TeamEnvironment!
}

type WorkloadUtilization {
	"Get the current usage for the requested resource type."
	current(resourceType: UtilizationResourceType!): Float!

	"Gets the requested amount of resources for the requested resource type."
	requested(resourceType: UtilizationResourceType!): Float!

	"Usage between start and end with step size for given resource type."
	series(input: WorkloadUtilizationSeriesInput!): [UtilizationDataPoint!]!
}

input WorkloadUtilizationSeriesInput {
	"Fetch resource usage from this timestamp."
	start: Time!

	"Fetch resource usage until this timestamp."
	end: Time!

	"Resource type."
	resourceType: UtilizationResourceType!
}

"Resource type."
enum UtilizationResourceType {
	CPU
	MEMORY
}

"Resource utilization type."
type UtilizationDataPoint {
	"Timestamp of the value."
	timestamp: Time!

	"Value of the used resource at the given timestamp."
	value: Float!
}

type TeamUtilizationData {
	"The team."
	team: Team!

	"The requested amount of resources"
	requested: Float!

	"The current resource usage."
	used: Float!

	"The environment for the utilization data."
	environment: TeamEnvironment!
}
`, BuiltIn: false},
	{Name: "../schema/vulnerability.graphqls", Input: `extend type ContainerImage {
	"Whether the image has a software bill of materials (SBOM) attached to it."
	hasSBOM: Boolean!

	"Get the vulnerabilities of the image."
	vulnerabilities(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: ImageVulnerabilityOrder
	): ImageVulnerabilityConnection!

	"Get the summary of the vulnerabilities of the image."
	vulnerabilitySummary: ImageVulnerabilitySummary

	"Workloads using this container image."
	workloadReferences(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): ContainerImageWorkloadReferenceConnection!
}

extend type Team {
	vulnerabilitySummary: TeamVulnerabilitySummary!
}

type ImageVulnerabilitySummary {
	"Total number of vulnerabilities."
	total: Int!

	"Risk score of the image."
	riskScore: Int!

	"Number of vulnerabilities with severity LOW."
	low: Int!

	"Number of vulnerabilities with severity MEDIUM."
	medium: Int!

	"Number of vulnerabilities with severity HIGH."
	high: Int!

	"Number of vulnerabilities with severity CRITICAL."
	critical: Int!

	"Number of vulnerabilities with severity UNASSIGNED."
	unassigned: Int!
}

type ImageVulnerabilityConnection {
	"Information to aid in pagination."
	pageInfo: PageInfo!

	"List of edges."
	edges: [ImageVulnerabilityEdge!]!

	"List of nodes."
	nodes: [ImageVulnerability!]!
}

type ContainerImageWorkloadReferenceConnection {
	"Information to aid in pagination."
	pageInfo: PageInfo!

	"List of edges."
	edges: [ContainerImageWorkloadReferenceEdge!]!

	"List of nodes."
	nodes: [ContainerImageWorkloadReference!]!
}

type ImageVulnerabilityEdge {
	"A cursor for use in pagination."
	cursor: Cursor!

	"The image vulnerability."
	node: ImageVulnerability!
}

type ContainerImageWorkloadReferenceEdge {
	"A cursor for use in pagination."
	cursor: Cursor!

	"The workload reference."
	node: ContainerImageWorkloadReference!
}

type ContainerImageWorkloadReference {
	"The workload using the container image."
	workload: Workload!
}

type ImageVulnerability implements Node {
	"The globally unique ID of the image vulnerability node."
	id: ID!

	"The unique identifier of the vulnerability. E.g. CVE-****-****."
	identifier: String!

	"Severity of the vulnerability."
	severity: ImageVulnerabilitySeverity!

	"Description of the vulnerability."
	description: String!

	"Package name of the vulnerability."
	package: String!

	"State of the vulnerability."
	state: ImageVulnerabilityState!

	"External URL to the vulnerability."
	url: String!
}

enum ImageVulnerabilitySeverity {
	LOW
	MEDIUM
	HIGH
	CRITICAL
	UNASSIGNED
}

enum ImageVulnerabilityState {
	TRIAGE
	RESOLVED
	FALSE_POSITIVE
	NOT_AFFECTED
}

"Ordering options when fetching teams."
input ImageVulnerabilityOrder {
	"The field to order items by."
	field: ImageVulnerabilityOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

enum ImageVulnerabilityOrderField {
	SEVERITY
	RISK_SCORE
}

type TeamVulnerabilitySummary {
	"Risk score of the team."
	riskScore: Int!
	"Number of vulnerabilities with severity CRITICAL."
	critical: Int!
	"Number of vulnerabilities with severity HIGH."
	high: Int!
	"Number of vulnerabilities with severity MEDIUM."
	medium: Int!
	"Number of vulnerabilities with severity LOW."
	low: Int!
	"Number of vulnerabilities with severity UNASSIGNED."
	unassigned: Int!
	"Number of workloads with a software bill of materials (SBOM) attached."
	bomCount: Int!
	"Coverage of the team."
	coverage: Float!
}
`, BuiltIn: false},
	{Name: "../schema/workloads.graphqls", Input: `extend type Team {
	"NAIS Workloads owned by the team."
	workloads(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: WorkloadOrder
	): WorkloadConnection!
}

interface Workload implements Node {
	"The globally unique ID of the workload."
	id: ID!

	"The name of the workload."
	name: String!

	"The team that owns the workload."
	team: Team!

	"The environment the workload is deployed in."
	environment: TeamEnvironment!

	"The container image of the workload."
	image: ContainerImage!

	"The resources allocated to the workload."
	resources: WorkloadResources!

	"The workload manifest."
	manifest: WorkloadManifest!

	# deployInfo: DeployInfo!
	# status: WorkloadStatus!
	# secrets: [Secret!]!
}

interface WorkloadManifest {
	"The manifest content, serialized as a YAML document."
	content: String!
}

type ContainerImage implements Node {
	"The globally unique ID of the container image node."
	id: ID!

	"Name of the container image."
	name: String!

	"Tag of the container image."
	tag: String!
}

interface WorkloadResources {
	"Instances using resources above this threshold will be killed."
	limits: WorkloadResourceQuantity!

	"Resources requested by the workload."
	requests: WorkloadResourceQuantity!
}

type WorkloadResourceQuantity {
	"The number of CPU cores."
	cpu: Float!

	"The amount of memory in bytes."
	memory: Int!
}

interface AuthIntegration {
	"The name of the integration."
	name: String!
}

type EntraIDAuthIntegration implements AuthIntegration {
	"The name of the integration."
	name: String!
}

type IDPortenAuthIntegration implements AuthIntegration {
	"The name of the integration."
	name: String!
}

type MaskinportenAuthIntegration implements AuthIntegration {
	"The name of the integration."
	name: String!
}

type TokenXAuthIntegration implements AuthIntegration {
	"The name of the integration."
	name: String!
}

type WorkloadConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Workload!]!

	"List of edges."
	edges: [WorkloadEdge!]!
}

type WorkloadEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The Workload."
	node: Workload!
}

"Ordering options when fetching workloads."
input WorkloadOrder {
	"The field to order items by."
	field: WorkloadOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

enum WorkloadOrderField {
	"Order Workloads by name."
	NAME

	"Order Workloads by status."
	STATUS

	"Order Workloads by the name of the environment."
	ENVIRONMENT

	"Order Workloads by the deployment time."
	DEPLOYMENT_TIME
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Application_bigQueryDatasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Application_bigQueryDatasets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Application_bigQueryDatasets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*bigquery.BigQueryDatasetOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *bigquery.BigQueryDatasetOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBigQueryDatasetOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetOrder(ctx, tmp)
	}

	var zeroVal *bigquery.BigQueryDatasetOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Application_buckets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Application_buckets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Application_buckets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*bucket.BucketOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *bucket.BucketOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBucketOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucketOrder(ctx, tmp)
	}

	var zeroVal *bucket.BucketOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Application_kafkaTopicAcls_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Application_kafkaTopicAcls_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Application_kafkaTopicAcls_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*kafkatopic.KafkaTopicACLOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *kafkatopic.KafkaTopicACLOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOKafkaTopicAclOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACLOrder(ctx, tmp)
	}

	var zeroVal *kafkatopic.KafkaTopicACLOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Application_redisInstances_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Application_redisInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Application_redisInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*redis.RedisInstanceOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *redis.RedisInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalORedisInstanceOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceOrder(ctx, tmp)
	}

	var zeroVal *redis.RedisInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Application_sqlInstances_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Application_sqlInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Application_sqlInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*sqlinstance.SQLInstanceOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *sqlinstance.SQLInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOSqlInstanceOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceOrder(ctx, tmp)
	}

	var zeroVal *sqlinstance.SQLInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_BigQueryDataset_access_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_BigQueryDataset_access_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_BigQueryDataset_access_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_BigQueryDataset_access_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_BigQueryDataset_access_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_BigQueryDataset_access_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_BigQueryDataset_access_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_BigQueryDataset_access_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_BigQueryDataset_access_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_BigQueryDataset_access_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_BigQueryDataset_access_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*bigquery.BigQueryDatasetAccessOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *bigquery.BigQueryDatasetAccessOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBigQueryDatasetAccessOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetAccessOrder(ctx, tmp)
	}

	var zeroVal *bigquery.BigQueryDatasetAccessOrder
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_vulnerabilities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_ContainerImage_vulnerabilities_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_ContainerImage_vulnerabilities_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_ContainerImage_vulnerabilities_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_ContainerImage_vulnerabilities_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_ContainerImage_vulnerabilities_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_ContainerImage_vulnerabilities_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_vulnerabilities_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_vulnerabilities_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_vulnerabilities_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_vulnerabilities_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*vulnerability.ImageVulnerabilityOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *vulnerability.ImageVulnerabilityOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOImageVulnerabilityOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilityOrder(ctx, tmp)
	}

	var zeroVal *vulnerability.ImageVulnerabilityOrder
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_workloadReferences_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_ContainerImage_workloadReferences_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_ContainerImage_workloadReferences_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_ContainerImage_workloadReferences_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_ContainerImage_workloadReferences_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_ContainerImage_workloadReferences_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_workloadReferences_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_workloadReferences_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_workloadReferences_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Job_bigQueryDatasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Job_bigQueryDatasets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Job_bigQueryDatasets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*bigquery.BigQueryDatasetOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *bigquery.BigQueryDatasetOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBigQueryDatasetOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetOrder(ctx, tmp)
	}

	var zeroVal *bigquery.BigQueryDatasetOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Job_buckets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Job_buckets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Job_buckets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*bucket.BucketOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *bucket.BucketOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBucketOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucketOrder(ctx, tmp)
	}

	var zeroVal *bucket.BucketOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Job_kafkaTopicAcls_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Job_kafkaTopicAcls_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Job_kafkaTopicAcls_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*kafkatopic.KafkaTopicACLOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *kafkatopic.KafkaTopicACLOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOKafkaTopicAclOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACLOrder(ctx, tmp)
	}

	var zeroVal *kafkatopic.KafkaTopicACLOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Job_redisInstances_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Job_redisInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Job_redisInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*redis.RedisInstanceOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *redis.RedisInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalORedisInstanceOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceOrder(ctx, tmp)
	}

	var zeroVal *redis.RedisInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Job_runs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Job_runs_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Job_runs_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Job_runs_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Job_runs_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Job_runs_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Job_runs_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Job_runs_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Job_runs_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Job_sqlInstances_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Job_sqlInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Job_sqlInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*sqlinstance.SQLInstanceOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *sqlinstance.SQLInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOSqlInstanceOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceOrder(ctx, tmp)
	}

	var zeroVal *sqlinstance.SQLInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_KafkaTopic_acl_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_KafkaTopic_acl_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_KafkaTopic_acl_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_KafkaTopic_acl_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_KafkaTopic_acl_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg4
	arg5, err := ec.field_KafkaTopic_acl_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg5
	return args, nil
}
func (ec *executionContext) field_KafkaTopic_acl_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_argsFilter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*kafkatopic.KafkaTopicACLFilter, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["filter"]
	if !ok {
		var zeroVal *kafkatopic.KafkaTopicACLFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalOKafkaTopicAclFilter2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACLFilter(ctx, tmp)
	}

	var zeroVal *kafkatopic.KafkaTopicACLFilter
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*kafkatopic.KafkaTopicACLOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *kafkatopic.KafkaTopicACLOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOKafkaTopicAclOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACLOrder(ctx, tmp)
	}

	var zeroVal *kafkatopic.KafkaTopicACLOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addRepositoryToTeam_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_addRepositoryToTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addRepositoryToTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (repository.AddRepositoryToTeamInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal repository.AddRepositoryToTeamInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAddRepositoryToTeamInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐAddRepositoryToTeamInput(ctx, tmp)
	}

	var zeroVal repository.AddRepositoryToTeamInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addTeamMember_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_addTeamMember_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addTeamMember_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (team.AddTeamMemberInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal team.AddTeamMemberInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAddTeamMemberInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐAddTeamMemberInput(ctx, tmp)
	}

	var zeroVal team.AddTeamMemberInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_configureReconciler_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_configureReconciler_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	arg1, err := ec.field_Mutation_configureReconciler_argsConfig(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["config"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_configureReconciler_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_configureReconciler_argsConfig(
	ctx context.Context,
	rawArgs map[string]interface{},
) ([]*reconciler.ReconcilerConfigInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["config"]
	if !ok {
		var zeroVal []*reconciler.ReconcilerConfigInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("config"))
	if tmp, ok := rawArgs["config"]; ok {
		return ec.unmarshalNReconcilerConfigInput2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconcilerConfigInputᚄ(ctx, tmp)
	}

	var zeroVal []*reconciler.ReconcilerConfigInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_confirmTeamDeletion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_confirmTeamDeletion_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_confirmTeamDeletion_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (team.ConfirmTeamDeletionInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal team.ConfirmTeamDeletionInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNConfirmTeamDeletionInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐConfirmTeamDeletionInput(ctx, tmp)
	}

	var zeroVal team.ConfirmTeamDeletionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createTeam_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_createTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (team.CreateTeamInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal team.CreateTeamInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCreateTeamInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐCreateTeamInput(ctx, tmp)
	}

	var zeroVal team.CreateTeamInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_deleteApplication_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteApplication_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (application.DeleteApplicationInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal application.DeleteApplicationInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNDeleteApplicationInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐDeleteApplicationInput(ctx, tmp)
	}

	var zeroVal application.DeleteApplicationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteJob_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_deleteJob_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteJob_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (job.DeleteJobInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal job.DeleteJobInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNDeleteJobInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐDeleteJobInput(ctx, tmp)
	}

	var zeroVal job.DeleteJobInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_disableReconciler_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_disableReconciler_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_disableReconciler_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_enableReconciler_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_enableReconciler_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_enableReconciler_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeRepositoryFromTeam_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_removeRepositoryFromTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeRepositoryFromTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (repository.RemoveRepositoryFromTeamInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal repository.RemoveRepositoryFromTeamInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRemoveRepositoryFromTeamInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRemoveRepositoryFromTeamInput(ctx, tmp)
	}

	var zeroVal repository.RemoveRepositoryFromTeamInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeTeamMember_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_removeTeamMember_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeTeamMember_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (team.RemoveTeamMemberInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal team.RemoveTeamMemberInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRemoveTeamMemberInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐRemoveTeamMemberInput(ctx, tmp)
	}

	var zeroVal team.RemoveTeamMemberInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_requestTeamDeletion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_requestTeamDeletion_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_requestTeamDeletion_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (team.RequestTeamDeletionInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal team.RequestTeamDeletionInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRequestTeamDeletionInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐRequestTeamDeletionInput(ctx, tmp)
	}

	var zeroVal team.RequestTeamDeletionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_restartApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_restartApplication_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_restartApplication_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (application.RestartApplicationInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal application.RestartApplicationInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRestartApplicationInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐRestartApplicationInput(ctx, tmp)
	}

	var zeroVal application.RestartApplicationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setTeamMemberRole_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_setTeamMemberRole_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_setTeamMemberRole_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (team.SetTeamMemberRoleInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal team.SetTeamMemberRoleInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSetTeamMemberRoleInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐSetTeamMemberRoleInput(ctx, tmp)
	}

	var zeroVal team.SetTeamMemberRoleInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_synchronizeTeam_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_synchronizeTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_synchronizeTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (team.SynchronizeTeamInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal team.SynchronizeTeamInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSynchronizeTeamInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐSynchronizeTeamInput(ctx, tmp)
	}

	var zeroVal team.SynchronizeTeamInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTeamEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_updateTeamEnvironment_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateTeamEnvironment_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (team.UpdateTeamEnvironmentInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal team.UpdateTeamEnvironmentInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateTeamEnvironmentInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUpdateTeamEnvironmentInput(ctx, tmp)
	}

	var zeroVal team.UpdateTeamEnvironmentInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTeam_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_updateTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (team.UpdateTeamInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal team.UpdateTeamInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateTeamInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUpdateTeamInput(ctx, tmp)
	}

	var zeroVal team.UpdateTeamInput
	return zeroVal, nil
}

func (ec *executionContext) field_OpenSearch_access_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_OpenSearch_access_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_OpenSearch_access_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_OpenSearch_access_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_OpenSearch_access_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_OpenSearch_access_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_OpenSearch_access_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_OpenSearch_access_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_OpenSearch_access_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_OpenSearch_access_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_OpenSearch_access_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*opensearch.OpenSearchAccessOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *opensearch.OpenSearchAccessOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOOpenSearchAccessOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchAccessOrder(ctx, tmp)
	}

	var zeroVal *opensearch.OpenSearchAccessOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_node_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_node_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (ident.Ident, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal ident.Ident
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, tmp)
	}

	var zeroVal ident.Ident
	return zeroVal, nil
}

func (ec *executionContext) field_Query_reconcilers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_reconcilers_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Query_reconcilers_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Query_reconcilers_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Query_reconcilers_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_reconcilers_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_reconcilers_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_reconcilers_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_reconcilers_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_search_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_search_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Query_search_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Query_search_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Query_search_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Query_search_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg4
	return args, nil
}
func (ec *executionContext) field_Query_search_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_search_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_search_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_search_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_search_argsFilter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (searchv1.SearchFilter, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["filter"]
	if !ok {
		var zeroVal searchv1.SearchFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNSearchFilter2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋsearchv1ᚐSearchFilter(ctx, tmp)
	}

	var zeroVal searchv1.SearchFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_team_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_team_argsSlug(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["slug"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_team_argsSlug(
	ctx context.Context,
	rawArgs map[string]interface{},
) (slug.Slug, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["slug"]
	if !ok {
		var zeroVal slug.Slug
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
	if tmp, ok := rawArgs["slug"]; ok {
		return ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, tmp)
	}

	var zeroVal slug.Slug
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teamsUtilization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_teamsUtilization_argsResourceType(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["resourceType"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_teamsUtilization_argsResourceType(
	ctx context.Context,
	rawArgs map[string]interface{},
) (utilization.UtilizationResourceType, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["resourceType"]
	if !ok {
		var zeroVal utilization.UtilizationResourceType
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
	if tmp, ok := rawArgs["resourceType"]; ok {
		return ec.unmarshalNUtilizationResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐUtilizationResourceType(ctx, tmp)
	}

	var zeroVal utilization.UtilizationResourceType
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teams_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_teams_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Query_teams_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Query_teams_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Query_teams_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Query_teams_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Query_teams_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teams_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teams_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teams_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teams_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*team.TeamOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *team.TeamOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOTeamOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamOrder(ctx, tmp)
	}

	var zeroVal *team.TeamOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_user_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_user_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (ident.Ident, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal ident.Ident
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, tmp)
	}

	var zeroVal ident.Ident
	return zeroVal, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_users_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Query_users_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Query_users_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Query_users_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Query_users_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Query_users_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_users_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_users_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_users_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_users_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*user.UserOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *user.UserOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOUserOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUserOrder(ctx, tmp)
	}

	var zeroVal *user.UserOrder
	return zeroVal, nil
}

func (ec *executionContext) field_RedisInstance_access_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_RedisInstance_access_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_RedisInstance_access_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_RedisInstance_access_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_RedisInstance_access_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_RedisInstance_access_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_RedisInstance_access_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_RedisInstance_access_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_RedisInstance_access_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_RedisInstance_access_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_RedisInstance_access_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*redis.RedisInstanceAccessOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *redis.RedisInstanceAccessOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalORedisInstanceAccessOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceAccessOrder(ctx, tmp)
	}

	var zeroVal *redis.RedisInstanceAccessOrder
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_flags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_SqlInstance_flags_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_SqlInstance_flags_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_SqlInstance_flags_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_SqlInstance_flags_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_SqlInstance_flags_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_flags_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_flags_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_flags_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_SqlInstance_users_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_SqlInstance_users_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_SqlInstance_users_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_SqlInstance_users_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_SqlInstance_users_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_SqlInstance_users_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_users_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_users_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_users_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_users_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*sqlinstance.SQLInstanceUserOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *sqlinstance.SQLInstanceUserOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOSqlInstanceUserOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceUserOrder(ctx, tmp)
	}

	var zeroVal *sqlinstance.SQLInstanceUserOrder
	return zeroVal, nil
}

func (ec *executionContext) field_TeamCost_daily_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_TeamCost_daily_argsFrom(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["from"] = arg0
	arg1, err := ec.field_TeamCost_daily_argsTo(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["to"] = arg1
	return args, nil
}
func (ec *executionContext) field_TeamCost_daily_argsFrom(
	ctx context.Context,
	rawArgs map[string]interface{},
) (scalar.Date, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["from"]
	if !ok {
		var zeroVal scalar.Date
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
	if tmp, ok := rawArgs["from"]; ok {
		return ec.unmarshalNDate2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋscalarᚐDate(ctx, tmp)
	}

	var zeroVal scalar.Date
	return zeroVal, nil
}

func (ec *executionContext) field_TeamCost_daily_argsTo(
	ctx context.Context,
	rawArgs map[string]interface{},
) (scalar.Date, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["to"]
	if !ok {
		var zeroVal scalar.Date
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
	if tmp, ok := rawArgs["to"]; ok {
		return ec.unmarshalNDate2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋscalarᚐDate(ctx, tmp)
	}

	var zeroVal scalar.Date
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_application_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_TeamEnvironment_application_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_application_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_bigQueryDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_TeamEnvironment_bigQueryDataset_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_bigQueryDataset_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_bucket_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_TeamEnvironment_bucket_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_bucket_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_job_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_TeamEnvironment_job_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_job_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_kafkaTopic_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_TeamEnvironment_kafkaTopic_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_kafkaTopic_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_openSearchInstance_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_TeamEnvironment_openSearchInstance_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_openSearchInstance_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_redisInstance_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_TeamEnvironment_redisInstance_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_redisInstance_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_sqlInstance_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_TeamEnvironment_sqlInstance_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_sqlInstance_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Team_applications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_applications_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_applications_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_applications_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_applications_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_applications_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_applications_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_applications_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_applications_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_applications_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_applications_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*application.ApplicationOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *application.ApplicationOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOApplicationOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationOrder(ctx, tmp)
	}

	var zeroVal *application.ApplicationOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_auditEntries_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_auditEntries_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_auditEntries_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_auditEntries_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_auditEntries_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Team_auditEntries_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_auditEntries_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_auditEntries_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_auditEntries_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_bigQueryDatasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_bigQueryDatasets_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_bigQueryDatasets_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_bigQueryDatasets_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_bigQueryDatasets_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_bigQueryDatasets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_bigQueryDatasets_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_bigQueryDatasets_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_bigQueryDatasets_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_bigQueryDatasets_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_bigQueryDatasets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*bigquery.BigQueryDatasetOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *bigquery.BigQueryDatasetOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBigQueryDatasetOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetOrder(ctx, tmp)
	}

	var zeroVal *bigquery.BigQueryDatasetOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_buckets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_buckets_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_buckets_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_buckets_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_buckets_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_buckets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_buckets_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_buckets_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_buckets_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_buckets_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_buckets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*bucket.BucketOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *bucket.BucketOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBucketOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucketOrder(ctx, tmp)
	}

	var zeroVal *bucket.BucketOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_deleteKey_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_deleteKey_argsKey(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["key"] = arg0
	return args, nil
}
func (ec *executionContext) field_Team_deleteKey_argsKey(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["key"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
	if tmp, ok := rawArgs["key"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Team_environment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_environment_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Team_environment_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Team_jobs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_jobs_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_jobs_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_jobs_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_jobs_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_jobs_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_jobs_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_jobs_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_jobs_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_jobs_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_jobs_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*job.JobOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *job.JobOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOJobOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobOrder(ctx, tmp)
	}

	var zeroVal *job.JobOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_kafkaTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_kafkaTopics_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_kafkaTopics_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_kafkaTopics_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_kafkaTopics_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_kafkaTopics_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_kafkaTopics_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_kafkaTopics_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_kafkaTopics_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_kafkaTopics_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_kafkaTopics_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*kafkatopic.KafkaTopicOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *kafkatopic.KafkaTopicOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOKafkaTopicOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicOrder(ctx, tmp)
	}

	var zeroVal *kafkatopic.KafkaTopicOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_member_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_member_argsEmail(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["email"] = arg0
	return args, nil
}
func (ec *executionContext) field_Team_member_argsEmail(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["email"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
	if tmp, ok := rawArgs["email"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Team_members_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_members_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_members_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_members_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_members_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_members_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_members_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_members_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_members_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_members_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_members_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*team.TeamMemberOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *team.TeamMemberOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOTeamMemberOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberOrder(ctx, tmp)
	}

	var zeroVal *team.TeamMemberOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_openSearchInstances_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_openSearchInstances_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_openSearchInstances_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_openSearchInstances_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_openSearchInstances_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_openSearchInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_openSearchInstances_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_openSearchInstances_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_openSearchInstances_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_openSearchInstances_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_openSearchInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*opensearch.OpenSearchOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *opensearch.OpenSearchOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOOpenSearchOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchOrder(ctx, tmp)
	}

	var zeroVal *opensearch.OpenSearchOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_redisInstances_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_redisInstances_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_redisInstances_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_redisInstances_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_redisInstances_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_redisInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_redisInstances_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_redisInstances_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_redisInstances_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_redisInstances_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_redisInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*redis.RedisInstanceOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *redis.RedisInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalORedisInstanceOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceOrder(ctx, tmp)
	}

	var zeroVal *redis.RedisInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_repositories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_repositories_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_repositories_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_repositories_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_repositories_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_repositories_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_repositories_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_repositories_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_repositories_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_repositories_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_repositories_argsFilter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*repository.TeamRepositoryFilter, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["filter"]
	if !ok {
		var zeroVal *repository.TeamRepositoryFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalOTeamRepositoryFilter2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐTeamRepositoryFilter(ctx, tmp)
	}

	var zeroVal *repository.TeamRepositoryFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Team_sqlInstances_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_sqlInstances_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_sqlInstances_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_sqlInstances_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_sqlInstances_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_sqlInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_sqlInstances_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_sqlInstances_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_sqlInstances_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_sqlInstances_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_sqlInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*sqlinstance.SQLInstanceOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *sqlinstance.SQLInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOSqlInstanceOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceOrder(ctx, tmp)
	}

	var zeroVal *sqlinstance.SQLInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloadUtilization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_workloadUtilization_argsResourceType(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["resourceType"] = arg0
	return args, nil
}
func (ec *executionContext) field_Team_workloadUtilization_argsResourceType(
	ctx context.Context,
	rawArgs map[string]interface{},
) (utilization.UtilizationResourceType, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["resourceType"]
	if !ok {
		var zeroVal utilization.UtilizationResourceType
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
	if tmp, ok := rawArgs["resourceType"]; ok {
		return ec.unmarshalNUtilizationResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐUtilizationResourceType(ctx, tmp)
	}

	var zeroVal utilization.UtilizationResourceType
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloads_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Team_workloads_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_workloads_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_workloads_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_workloads_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_workloads_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_workloads_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloads_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloads_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloads_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloads_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*workload.WorkloadOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *workload.WorkloadOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOWorkloadOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadOrder(ctx, tmp)
	}

	var zeroVal *workload.WorkloadOrder
	return zeroVal, nil
}

func (ec *executionContext) field_User_teams_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_User_teams_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_User_teams_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_User_teams_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_User_teams_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_User_teams_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_User_teams_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_User_teams_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_User_teams_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_User_teams_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*pagination.Cursor, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_User_teams_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*team.UserTeamOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *team.UserTeamOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOUserTeamOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUserTeamOrder(ctx, tmp)
	}

	var zeroVal *team.UserTeamOrder
	return zeroVal, nil
}

func (ec *executionContext) field_WorkloadCost_daily_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_WorkloadCost_daily_argsFrom(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["from"] = arg0
	arg1, err := ec.field_WorkloadCost_daily_argsTo(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["to"] = arg1
	return args, nil
}
func (ec *executionContext) field_WorkloadCost_daily_argsFrom(
	ctx context.Context,
	rawArgs map[string]interface{},
) (scalar.Date, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["from"]
	if !ok {
		var zeroVal scalar.Date
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
	if tmp, ok := rawArgs["from"]; ok {
		return ec.unmarshalNDate2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋscalarᚐDate(ctx, tmp)
	}

	var zeroVal scalar.Date
	return zeroVal, nil
}

func (ec *executionContext) field_WorkloadCost_daily_argsTo(
	ctx context.Context,
	rawArgs map[string]interface{},
) (scalar.Date, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["to"]
	if !ok {
		var zeroVal scalar.Date
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
	if tmp, ok := rawArgs["to"]; ok {
		return ec.unmarshalNDate2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋscalarᚐDate(ctx, tmp)
	}

	var zeroVal scalar.Date
	return zeroVal, nil
}

func (ec *executionContext) field_WorkloadUtilization_current_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_WorkloadUtilization_current_argsResourceType(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["resourceType"] = arg0
	return args, nil
}
func (ec *executionContext) field_WorkloadUtilization_current_argsResourceType(
	ctx context.Context,
	rawArgs map[string]interface{},
) (utilization.UtilizationResourceType, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["resourceType"]
	if !ok {
		var zeroVal utilization.UtilizationResourceType
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
	if tmp, ok := rawArgs["resourceType"]; ok {
		return ec.unmarshalNUtilizationResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐUtilizationResourceType(ctx, tmp)
	}

	var zeroVal utilization.UtilizationResourceType
	return zeroVal, nil
}

func (ec *executionContext) field_WorkloadUtilization_requested_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_WorkloadUtilization_requested_argsResourceType(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["resourceType"] = arg0
	return args, nil
}
func (ec *executionContext) field_WorkloadUtilization_requested_argsResourceType(
	ctx context.Context,
	rawArgs map[string]interface{},
) (utilization.UtilizationResourceType, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["resourceType"]
	if !ok {
		var zeroVal utilization.UtilizationResourceType
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
	if tmp, ok := rawArgs["resourceType"]; ok {
		return ec.unmarshalNUtilizationResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐUtilizationResourceType(ctx, tmp)
	}

	var zeroVal utilization.UtilizationResourceType
	return zeroVal, nil
}

func (ec *executionContext) field_WorkloadUtilization_series_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_WorkloadUtilization_series_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_WorkloadUtilization_series_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (utilization.WorkloadUtilizationSeriesInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal utilization.WorkloadUtilizationSeriesInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNWorkloadUtilizationSeriesInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐWorkloadUtilizationSeriesInput(ctx, tmp)
	}

	var zeroVal utilization.WorkloadUtilizationSeriesInput
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]interface{},
) (bool, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["includeDeprecated"]
	if !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]interface{},
) (bool, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["includeDeprecated"]
	if !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AddRepositoryToTeamPayload_repository(ctx context.Context, field graphql.CollectedField, obj *repository.AddRepositoryToTeamPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddRepositoryToTeamPayload_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*repository.Repository)
	fc.Result = res
	return ec.marshalORepository2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddRepositoryToTeamPayload_repository(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddRepositoryToTeamPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "team":
				return ec.fieldContext_Repository_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddTeamMemberPayload_member(ctx context.Context, field graphql.CollectedField, obj *team.AddTeamMemberPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddTeamMemberPayload_member(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Member, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamMember)
	fc.Result = res
	return ec.marshalOTeamMember2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddTeamMemberPayload_member(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddTeamMemberPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamMember_team(ctx, field)
			case "user":
				return ec.fieldContext_TeamMember_user(ctx, field)
			case "role":
				return ec.fieldContext_TeamMember_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_id(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_name(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_team(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_environment(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_image(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.ContainerImage)
	fc.Result = res
	return ec.marshalNContainerImage2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐContainerImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerImage_id(ctx, field)
			case "name":
				return ec.fieldContext_ContainerImage_name(ctx, field)
			case "tag":
				return ec.fieldContext_ContainerImage_tag(ctx, field)
			case "hasSBOM":
				return ec.fieldContext_ContainerImage_hasSBOM(ctx, field)
			case "vulnerabilities":
				return ec.fieldContext_ContainerImage_vulnerabilities(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_ContainerImage_vulnerabilitySummary(ctx, field)
			case "workloadReferences":
				return ec.fieldContext_ContainerImage_workloadReferences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_resources(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.ApplicationResources)
	fc.Result = res
	return ec.marshalNApplicationResources2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationResources(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_resources(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "limits":
				return ec.fieldContext_ApplicationResources_limits(ctx, field)
			case "requests":
				return ec.fieldContext_ApplicationResources_requests(ctx, field)
			case "scaling":
				return ec.fieldContext_ApplicationResources_scaling(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_ingresses(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_ingresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ingresses(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_ingresses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_authIntegrations(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_authIntegrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().AuthIntegrations(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]workload.ApplicationAuthIntegrations)
	fc.Result = res
	return ec.marshalNApplicationAuthIntegrations2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐApplicationAuthIntegrationsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_authIntegrations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ApplicationAuthIntegrations does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_manifest(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_manifest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Manifest(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.ApplicationManifest)
	fc.Result = res
	return ec.marshalNApplicationManifest2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationManifest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_manifest(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "content":
				return ec.fieldContext_ApplicationManifest_content(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationManifest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_cost(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.WorkloadCost)
	fc.Result = res
	return ec.marshalNWorkloadCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐWorkloadCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "daily":
				return ec.fieldContext_WorkloadCost_daily(ctx, field)
			case "monthly":
				return ec.fieldContext_WorkloadCost_monthly(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_networkPolicy(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_networkPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().NetworkPolicy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*netpol.NetworkPolicy)
	fc.Result = res
	return ec.marshalNNetworkPolicy2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐNetworkPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_networkPolicy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "inbound":
				return ec.fieldContext_NetworkPolicy_inbound(ctx, field)
			case "outbound":
				return ec.fieldContext_NetworkPolicy_outbound(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_bigQueryDatasets(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_bigQueryDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().BigQueryDatasets(rctx, obj, fc.Args["orderBy"].(*bigquery.BigQueryDatasetOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bigquery.BigQueryDataset])
	fc.Result = res
	return ec.marshalNBigQueryDatasetConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_bigQueryDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BigQueryDatasetConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BigQueryDatasetConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BigQueryDatasetConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_bigQueryDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_redisInstances(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_redisInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().RedisInstances(rctx, obj, fc.Args["orderBy"].(*redis.RedisInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*redis.RedisInstance])
	fc.Result = res
	return ec.marshalNRedisInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_redisInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_RedisInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_RedisInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RedisInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_redisInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_openSearch(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_openSearch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().OpenSearch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearch)
	fc.Result = res
	return ec.marshalOOpenSearch2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_openSearch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "status":
				return ec.fieldContext_OpenSearch_status(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_buckets(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_buckets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Buckets(rctx, obj, fc.Args["orderBy"].(*bucket.BucketOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bucket.Bucket])
	fc.Result = res
	return ec.marshalNBucketConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_buckets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BucketConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BucketConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BucketConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_buckets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_kafkaTopicAcls(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().KafkaTopicAcls(rctx, obj, fc.Args["orderBy"].(*kafkatopic.KafkaTopicACLOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*kafkatopic.KafkaTopicACL])
	fc.Result = res
	return ec.marshalNKafkaTopicAclConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_kafkaTopicAcls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_KafkaTopicAclConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_KafkaTopicAclConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_KafkaTopicAclConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAclConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_kafkaTopicAcls_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_sqlInstances(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_sqlInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().SQLInstances(rctx, obj, fc.Args["orderBy"].(*sqlinstance.SQLInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*sqlinstance.SQLInstance])
	fc.Result = res
	return ec.marshalNSqlInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_sqlInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SqlInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SqlInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SqlInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_sqlInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_utilization(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_utilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Utilization(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*utilization.WorkloadUtilization)
	fc.Result = res
	return ec.marshalNWorkloadUtilization2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐWorkloadUtilization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_utilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_WorkloadUtilization_current(ctx, field)
			case "requested":
				return ec.fieldContext_WorkloadUtilization_requested(ctx, field)
			case "series":
				return ec.fieldContext_WorkloadUtilization_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadUtilization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.Application]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.Application]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*application.Application)
	fc.Result = res
	return ec.marshalNApplication2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Application_redisInstances(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.Application]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*application.Application])
	fc.Result = res
	return ec.marshalNApplicationEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ApplicationEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ApplicationEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*application.Application]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*application.Application]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.Application)
	fc.Result = res
	return ec.marshalNApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Application_redisInstances(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationManifest_content(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationManifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationManifest_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationManifest_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationManifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationResources_limits(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationResources_limits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.WorkloadResourceQuantity)
	fc.Result = res
	return ec.marshalNWorkloadResourceQuantity2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadResourceQuantity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationResources_limits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadResourceQuantity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationResources_requests(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationResources_requests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.WorkloadResourceQuantity)
	fc.Result = res
	return ec.marshalNWorkloadResourceQuantity2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadResourceQuantity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationResources_requests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadResourceQuantity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationResources_scaling(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationResources_scaling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scaling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.ApplicationScaling)
	fc.Result = res
	return ec.marshalNApplicationScaling2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationScaling(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationResources_scaling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "minInstances":
				return ec.fieldContext_ApplicationScaling_minInstances(ctx, field)
			case "maxInstances":
				return ec.fieldContext_ApplicationScaling_maxInstances(ctx, field)
			case "strategies":
				return ec.fieldContext_ApplicationScaling_strategies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationScaling", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaling_minInstances(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaling) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationScaling_minInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinInstances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationScaling_minInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaling",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaling_maxInstances(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaling) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationScaling_maxInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxInstances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationScaling_maxInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaling",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaling_strategies(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaling) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationScaling_strategies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Strategies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]application.ScalingStrategy)
	fc.Result = res
	return ec.marshalNScalingStrategy2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐScalingStrategyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationScaling_strategies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaling",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScalingStrategy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditEntryConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[auditv1.AuditEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditEntryConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditEntryConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditEntryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditEntryConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[auditv1.AuditEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditEntryConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]auditv1.AuditEntry)
	fc.Result = res
	return ec.marshalNAuditEntry2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditEntryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditEntryConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditEntryConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditEntryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[auditv1.AuditEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditEntryConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[auditv1.AuditEntry])
	fc.Result = res
	return ec.marshalNAuditEntryEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditEntryConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditEntryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_AuditEntryEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_AuditEntryEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuditEntryEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditEntryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[auditv1.AuditEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditEntryEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditEntryEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditEntryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditEntryEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[auditv1.AuditEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditEntryEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(auditv1.AuditEntry)
	fc.Result = res
	return ec.marshalNAuditEntry2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditEntryEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditEntryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_id(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_name(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_team(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BigQueryDataset().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_environment(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BigQueryDataset().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_cascadingDelete(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_cascadingDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CascadingDelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_cascadingDelete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_description(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_access(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BigQueryDataset().Access(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*bigquery.BigQueryDatasetAccessOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bigquery.BigQueryDatasetAccess])
	fc.Result = res
	return ec.marshalNBigQueryDatasetAccessConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_access(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BigQueryDatasetAccessConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BigQueryDatasetAccessConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BigQueryDatasetAccessConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetAccessConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_BigQueryDataset_access_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_status(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bigquery.BigQueryDatasetStatus)
	fc.Result = res
	return ec.marshalNBigQueryDatasetStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "creationTime":
				return ec.fieldContext_BigQueryDatasetStatus_creationTime(ctx, field)
			case "lastModifiedTime":
				return ec.fieldContext_BigQueryDatasetStatus_lastModifiedTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_workload(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BigQueryDataset().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_cost(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BigQueryDataset().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.BigQueryDatasetCost)
	fc.Result = res
	return ec.marshalNBigQueryDatasetCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐBigQueryDatasetCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_BigQueryDatasetCost_sum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccess_role(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDatasetAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccess_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccess_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccess_email(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDatasetAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccess_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccess_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccessConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDatasetAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccessConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccessConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccessConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDatasetAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccessConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*bigquery.BigQueryDatasetAccess)
	fc.Result = res
	return ec.marshalNBigQueryDatasetAccess2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetAccessᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccessConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccessConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "role":
				return ec.fieldContext_BigQueryDatasetAccess_role(ctx, field)
			case "email":
				return ec.fieldContext_BigQueryDatasetAccess_email(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccessConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDatasetAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccessConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*bigquery.BigQueryDatasetAccess])
	fc.Result = res
	return ec.marshalNBigQueryDatasetAccessEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccessConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_BigQueryDatasetAccessEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_BigQueryDatasetAccessEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetAccessEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccessEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bigquery.BigQueryDatasetAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccessEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccessEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccessEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bigquery.BigQueryDatasetAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccessEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bigquery.BigQueryDatasetAccess)
	fc.Result = res
	return ec.marshalNBigQueryDatasetAccess2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccessEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "role":
				return ec.fieldContext_BigQueryDatasetAccess_role(ctx, field)
			case "email":
				return ec.fieldContext_BigQueryDatasetAccess_email(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDataset]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDataset]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*bigquery.BigQueryDataset)
	fc.Result = res
	return ec.marshalNBigQueryDataset2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BigQueryDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_BigQueryDataset_name(ctx, field)
			case "team":
				return ec.fieldContext_BigQueryDataset_team(ctx, field)
			case "environment":
				return ec.fieldContext_BigQueryDataset_environment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_BigQueryDataset_cascadingDelete(ctx, field)
			case "description":
				return ec.fieldContext_BigQueryDataset_description(ctx, field)
			case "access":
				return ec.fieldContext_BigQueryDataset_access(ctx, field)
			case "status":
				return ec.fieldContext_BigQueryDataset_status(ctx, field)
			case "workload":
				return ec.fieldContext_BigQueryDataset_workload(ctx, field)
			case "cost":
				return ec.fieldContext_BigQueryDataset_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDataset", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDataset]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*bigquery.BigQueryDataset])
	fc.Result = res
	return ec.marshalNBigQueryDatasetEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_BigQueryDatasetEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_BigQueryDatasetEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetCost_sum(ctx context.Context, field graphql.CollectedField, obj *cost.BigQueryDatasetCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetCost_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetCost_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetCost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bigquery.BigQueryDataset]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bigquery.BigQueryDataset]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bigquery.BigQueryDataset)
	fc.Result = res
	return ec.marshalNBigQueryDataset2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BigQueryDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_BigQueryDataset_name(ctx, field)
			case "team":
				return ec.fieldContext_BigQueryDataset_team(ctx, field)
			case "environment":
				return ec.fieldContext_BigQueryDataset_environment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_BigQueryDataset_cascadingDelete(ctx, field)
			case "description":
				return ec.fieldContext_BigQueryDataset_description(ctx, field)
			case "access":
				return ec.fieldContext_BigQueryDataset_access(ctx, field)
			case "status":
				return ec.fieldContext_BigQueryDataset_status(ctx, field)
			case "workload":
				return ec.fieldContext_BigQueryDataset_workload(ctx, field)
			case "cost":
				return ec.fieldContext_BigQueryDataset_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDataset", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetStatus_creationTime(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDatasetStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetStatus_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetStatus_creationTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetStatus_lastModifiedTime(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDatasetStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetStatus_lastModifiedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastModifiedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetStatus_lastModifiedTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_id(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_name(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_team(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bucket().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_environment(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bucket().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_cascadingDelete(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_cascadingDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CascadingDelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_cascadingDelete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_publicAccessPrevention(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_publicAccessPrevention(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicAccessPrevention, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_publicAccessPrevention(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_uniformBucketLevelAccess(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_uniformBucketLevelAccess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UniformBucketLevelAccess, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_uniformBucketLevelAccess(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_workload(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bucket().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_status(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bucket.BucketStatus)
	fc.Result = res
	return ec.marshalNBucketStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucketStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_BucketStatus_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bucket.Bucket]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bucket.Bucket]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*bucket.Bucket)
	fc.Result = res
	return ec.marshalNBucket2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucketᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bucket_id(ctx, field)
			case "name":
				return ec.fieldContext_Bucket_name(ctx, field)
			case "team":
				return ec.fieldContext_Bucket_team(ctx, field)
			case "environment":
				return ec.fieldContext_Bucket_environment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_Bucket_cascadingDelete(ctx, field)
			case "publicAccessPrevention":
				return ec.fieldContext_Bucket_publicAccessPrevention(ctx, field)
			case "uniformBucketLevelAccess":
				return ec.fieldContext_Bucket_uniformBucketLevelAccess(ctx, field)
			case "workload":
				return ec.fieldContext_Bucket_workload(ctx, field)
			case "status":
				return ec.fieldContext_Bucket_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bucket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bucket.Bucket]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*bucket.Bucket])
	fc.Result = res
	return ec.marshalNBucketEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_BucketEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_BucketEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bucket.Bucket]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bucket.Bucket]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bucket.Bucket)
	fc.Result = res
	return ec.marshalNBucket2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bucket_id(ctx, field)
			case "name":
				return ec.fieldContext_Bucket_name(ctx, field)
			case "team":
				return ec.fieldContext_Bucket_team(ctx, field)
			case "environment":
				return ec.fieldContext_Bucket_environment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_Bucket_cascadingDelete(ctx, field)
			case "publicAccessPrevention":
				return ec.fieldContext_Bucket_publicAccessPrevention(ctx, field)
			case "uniformBucketLevelAccess":
				return ec.fieldContext_Bucket_uniformBucketLevelAccess(ctx, field)
			case "workload":
				return ec.fieldContext_Bucket_workload(ctx, field)
			case "status":
				return ec.fieldContext_Bucket_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bucket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketStatus_state(ctx context.Context, field graphql.CollectedField, obj *bucket.BucketStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CPUScalingStrategy_threshold(ctx context.Context, field graphql.CollectedField, obj *application.CPUScalingStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CPUScalingStrategy_threshold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Threshold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CPUScalingStrategy_threshold(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CPUScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfirmTeamDeletionPayload_deletionStarted(ctx context.Context, field graphql.CollectedField, obj *team.ConfirmTeamDeletionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfirmTeamDeletionPayload_deletionStarted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionStarted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfirmTeamDeletionPayload_deletionStarted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfirmTeamDeletionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_id(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_name(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_tag(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_tag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_hasSBOM(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_hasSBOM(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerImage().HasSbom(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_hasSBOM(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_vulnerabilities(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_vulnerabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerImage().Vulnerabilities(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*vulnerability.ImageVulnerabilityOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*vulnerability.ImageVulnerability])
	fc.Result = res
	return ec.marshalNImageVulnerabilityConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_vulnerabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ImageVulnerabilityConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_ImageVulnerabilityConnection_edges(ctx, field)
			case "nodes":
				return ec.fieldContext_ImageVulnerabilityConnection_nodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilityConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ContainerImage_vulnerabilities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_vulnerabilitySummary(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_vulnerabilitySummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerImage().VulnerabilitySummary(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*vulnerability.ImageVulnerabilitySummary)
	fc.Result = res
	return ec.marshalOImageVulnerabilitySummary2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilitySummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_vulnerabilitySummary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_ImageVulnerabilitySummary_total(ctx, field)
			case "riskScore":
				return ec.fieldContext_ImageVulnerabilitySummary_riskScore(ctx, field)
			case "low":
				return ec.fieldContext_ImageVulnerabilitySummary_low(ctx, field)
			case "medium":
				return ec.fieldContext_ImageVulnerabilitySummary_medium(ctx, field)
			case "high":
				return ec.fieldContext_ImageVulnerabilitySummary_high(ctx, field)
			case "critical":
				return ec.fieldContext_ImageVulnerabilitySummary_critical(ctx, field)
			case "unassigned":
				return ec.fieldContext_ImageVulnerabilitySummary_unassigned(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilitySummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_workloadReferences(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_workloadReferences(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerImage().WorkloadReferences(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*vulnerability.ContainerImageWorkloadReference])
	fc.Result = res
	return ec.marshalNContainerImageWorkloadReferenceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_workloadReferences(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ContainerImageWorkloadReferenceConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_ContainerImageWorkloadReferenceConnection_edges(ctx, field)
			case "nodes":
				return ec.fieldContext_ContainerImageWorkloadReferenceConnection_nodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImageWorkloadReferenceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ContainerImage_workloadReferences_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReference_workload(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ContainerImageWorkloadReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReference_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerImageWorkloadReference().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReference_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReference",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReferenceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReferenceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReferenceConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReferenceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReferenceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReferenceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*vulnerability.ContainerImageWorkloadReference])
	fc.Result = res
	return ec.marshalNContainerImageWorkloadReferenceEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReferenceConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReferenceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ContainerImageWorkloadReferenceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ContainerImageWorkloadReferenceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImageWorkloadReferenceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReferenceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReferenceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*vulnerability.ContainerImageWorkloadReference)
	fc.Result = res
	return ec.marshalNContainerImageWorkloadReference2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐContainerImageWorkloadReferenceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReferenceConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReferenceConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_ContainerImageWorkloadReference_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImageWorkloadReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReferenceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*vulnerability.ContainerImageWorkloadReference]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReferenceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReferenceEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReferenceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReferenceEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*vulnerability.ContainerImageWorkloadReference]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReferenceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*vulnerability.ContainerImageWorkloadReference)
	fc.Result = res
	return ec.marshalNContainerImageWorkloadReference2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐContainerImageWorkloadReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReferenceEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReferenceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_ContainerImageWorkloadReference_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImageWorkloadReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTeamPayload_team(ctx context.Context, field graphql.CollectedField, obj *team.CreateTeamPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTeamPayload_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Team, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTeamPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTeamPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteApplicationPayload_team(ctx context.Context, field graphql.CollectedField, obj *application.DeleteApplicationPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteApplicationPayload_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DeleteApplicationPayload().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteApplicationPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteApplicationPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteJobPayload_team(ctx context.Context, field graphql.CollectedField, obj *job.DeleteJobPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteJobPayload_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DeleteJobPayload().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteJobPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteJobPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntraIDAuthIntegration_name(ctx context.Context, field graphql.CollectedField, obj *workload.EntraIDAuthIntegration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntraIDAuthIntegration_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntraIDAuthIntegration_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntraIDAuthIntegration",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalNetworkPolicyHost_target(ctx context.Context, field graphql.CollectedField, obj *netpol.ExternalNetworkPolicyHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalNetworkPolicyHost_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalNetworkPolicyHost_target(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalNetworkPolicyHost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalNetworkPolicyHost_ports(ctx context.Context, field graphql.CollectedField, obj *netpol.ExternalNetworkPolicyHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalNetworkPolicyHost_ports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2ᚕintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalNetworkPolicyHost_ports(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalNetworkPolicyHost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalNetworkPolicyIpv4_target(ctx context.Context, field graphql.CollectedField, obj *netpol.ExternalNetworkPolicyIpv4) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalNetworkPolicyIpv4_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalNetworkPolicyIpv4_target(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalNetworkPolicyIpv4",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalNetworkPolicyIpv4_ports(ctx context.Context, field graphql.CollectedField, obj *netpol.ExternalNetworkPolicyIpv4) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalNetworkPolicyIpv4_ports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2ᚕintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalNetworkPolicyIpv4_ports(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalNetworkPolicyIpv4",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IDPortenAuthIntegration_name(ctx context.Context, field graphql.CollectedField, obj *workload.IDPortenAuthIntegration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IDPortenAuthIntegration_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IDPortenAuthIntegration_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IDPortenAuthIntegration",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_id(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_identifier(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_identifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Identifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_identifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_severity(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(vulnerability.ImageVulnerabilitySeverity)
	fc.Result = res
	return ec.marshalNImageVulnerabilitySeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilitySeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageVulnerabilitySeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_description(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_package(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_package(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_package(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_state(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(vulnerability.ImageVulnerabilityState)
	fc.Result = res
	return ec.marshalNImageVulnerabilityState2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilityState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageVulnerabilityState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_url(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ImageVulnerability]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ImageVulnerability]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*vulnerability.ImageVulnerability])
	fc.Result = res
	return ec.marshalNImageVulnerabilityEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ImageVulnerabilityEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ImageVulnerabilityEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilityEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ImageVulnerability]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*vulnerability.ImageVulnerability)
	fc.Result = res
	return ec.marshalNImageVulnerability2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilityᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ImageVulnerability_id(ctx, field)
			case "identifier":
				return ec.fieldContext_ImageVulnerability_identifier(ctx, field)
			case "severity":
				return ec.fieldContext_ImageVulnerability_severity(ctx, field)
			case "description":
				return ec.fieldContext_ImageVulnerability_description(ctx, field)
			case "package":
				return ec.fieldContext_ImageVulnerability_package(ctx, field)
			case "state":
				return ec.fieldContext_ImageVulnerability_state(ctx, field)
			case "url":
				return ec.fieldContext_ImageVulnerability_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerability", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*vulnerability.ImageVulnerability]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*vulnerability.ImageVulnerability]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*vulnerability.ImageVulnerability)
	fc.Result = res
	return ec.marshalNImageVulnerability2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerability(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ImageVulnerability_id(ctx, field)
			case "identifier":
				return ec.fieldContext_ImageVulnerability_identifier(ctx, field)
			case "severity":
				return ec.fieldContext_ImageVulnerability_severity(ctx, field)
			case "description":
				return ec.fieldContext_ImageVulnerability_description(ctx, field)
			case "package":
				return ec.fieldContext_ImageVulnerability_package(ctx, field)
			case "state":
				return ec.fieldContext_ImageVulnerability_state(ctx, field)
			case "url":
				return ec.fieldContext_ImageVulnerability_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerability", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_total(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_riskScore(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_riskScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RiskScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_riskScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_low(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_low(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Low, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_low(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_medium(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_medium(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Medium, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_medium(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_high(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_high(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.High, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_high(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_critical(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_critical(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Critical, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_critical(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_unassigned(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_unassigned(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unassigned, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_unassigned(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InboundNetworkPolicy_rules(ctx context.Context, field graphql.CollectedField, obj *netpol.InboundNetworkPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InboundNetworkPolicy_rules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*netpol.NetworkPolicyRule)
	fc.Result = res
	return ec.marshalNNetworkPolicyRule2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐNetworkPolicyRuleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InboundNetworkPolicy_rules(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InboundNetworkPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "targetWorkloadName":
				return ec.fieldContext_NetworkPolicyRule_targetWorkloadName(ctx, field)
			case "targetWorkload":
				return ec.fieldContext_NetworkPolicyRule_targetWorkload(ctx, field)
			case "targetTeamSlug":
				return ec.fieldContext_NetworkPolicyRule_targetTeamSlug(ctx, field)
			case "targetTeam":
				return ec.fieldContext_NetworkPolicyRule_targetTeam(ctx, field)
			case "mutual":
				return ec.fieldContext_NetworkPolicyRule_mutual(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkPolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_id(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_name(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_team(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_environment(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_image(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.ContainerImage)
	fc.Result = res
	return ec.marshalNContainerImage2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐContainerImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerImage_id(ctx, field)
			case "name":
				return ec.fieldContext_ContainerImage_name(ctx, field)
			case "tag":
				return ec.fieldContext_ContainerImage_tag(ctx, field)
			case "hasSBOM":
				return ec.fieldContext_ContainerImage_hasSBOM(ctx, field)
			case "vulnerabilities":
				return ec.fieldContext_ContainerImage_vulnerabilities(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_ContainerImage_vulnerabilitySummary(ctx, field)
			case "workloadReferences":
				return ec.fieldContext_ContainerImage_workloadReferences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_resources(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.JobResources)
	fc.Result = res
	return ec.marshalNJobResources2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobResources(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_resources(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "limits":
				return ec.fieldContext_JobResources_limits(ctx, field)
			case "requests":
				return ec.fieldContext_JobResources_requests(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_authIntegrations(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_authIntegrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().AuthIntegrations(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]workload.JobAuthIntegrations)
	fc.Result = res
	return ec.marshalNJobAuthIntegrations2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐJobAuthIntegrationsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_authIntegrations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobAuthIntegrations does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_schedule(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_schedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schedule(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*job.JobSchedule)
	fc.Result = res
	return ec.marshalOJobSchedule2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobSchedule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_schedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "expression":
				return ec.fieldContext_JobSchedule_expression(ctx, field)
			case "timeZone":
				return ec.fieldContext_JobSchedule_timeZone(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobSchedule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_runs(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_runs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Runs(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*job.JobRun])
	fc.Result = res
	return ec.marshalNJobRunConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_runs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_JobRunConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_JobRunConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_JobRunConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRunConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_runs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_manifest(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_manifest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Manifest(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.JobManifest)
	fc.Result = res
	return ec.marshalNJobManifest2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobManifest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_manifest(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "content":
				return ec.fieldContext_JobManifest_content(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobManifest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_cost(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.WorkloadCost)
	fc.Result = res
	return ec.marshalNWorkloadCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐWorkloadCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "daily":
				return ec.fieldContext_WorkloadCost_daily(ctx, field)
			case "monthly":
				return ec.fieldContext_WorkloadCost_monthly(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_networkPolicy(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_networkPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().NetworkPolicy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*netpol.NetworkPolicy)
	fc.Result = res
	return ec.marshalNNetworkPolicy2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐNetworkPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_networkPolicy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "inbound":
				return ec.fieldContext_NetworkPolicy_inbound(ctx, field)
			case "outbound":
				return ec.fieldContext_NetworkPolicy_outbound(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_bigQueryDatasets(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_bigQueryDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().BigQueryDatasets(rctx, obj, fc.Args["orderBy"].(*bigquery.BigQueryDatasetOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bigquery.BigQueryDataset])
	fc.Result = res
	return ec.marshalNBigQueryDatasetConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_bigQueryDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BigQueryDatasetConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BigQueryDatasetConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BigQueryDatasetConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_bigQueryDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_redisInstances(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_redisInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().RedisInstances(rctx, obj, fc.Args["orderBy"].(*redis.RedisInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*redis.RedisInstance])
	fc.Result = res
	return ec.marshalNRedisInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_redisInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_RedisInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_RedisInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RedisInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_redisInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_openSearch(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_openSearch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().OpenSearch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearch)
	fc.Result = res
	return ec.marshalOOpenSearch2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_openSearch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "status":
				return ec.fieldContext_OpenSearch_status(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_buckets(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_buckets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Buckets(rctx, obj, fc.Args["orderBy"].(*bucket.BucketOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bucket.Bucket])
	fc.Result = res
	return ec.marshalNBucketConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_buckets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BucketConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BucketConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BucketConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_buckets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_kafkaTopicAcls(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_kafkaTopicAcls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().KafkaTopicAcls(rctx, obj, fc.Args["orderBy"].(*kafkatopic.KafkaTopicACLOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*kafkatopic.KafkaTopicACL])
	fc.Result = res
	return ec.marshalNKafkaTopicAclConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_kafkaTopicAcls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_KafkaTopicAclConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_KafkaTopicAclConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_KafkaTopicAclConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAclConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_kafkaTopicAcls_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_sqlInstances(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_sqlInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().SQLInstances(rctx, obj, fc.Args["orderBy"].(*sqlinstance.SQLInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*sqlinstance.SQLInstance])
	fc.Result = res
	return ec.marshalNSqlInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_sqlInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SqlInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SqlInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SqlInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_sqlInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _JobConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.Job]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.Job]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*job.Job)
	fc.Result = res
	return ec.marshalNJob2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "name":
				return ec.fieldContext_Job_name(ctx, field)
			case "team":
				return ec.fieldContext_Job_team(ctx, field)
			case "environment":
				return ec.fieldContext_Job_environment(ctx, field)
			case "image":
				return ec.fieldContext_Job_image(ctx, field)
			case "resources":
				return ec.fieldContext_Job_resources(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Job_authIntegrations(ctx, field)
			case "schedule":
				return ec.fieldContext_Job_schedule(ctx, field)
			case "runs":
				return ec.fieldContext_Job_runs(ctx, field)
			case "manifest":
				return ec.fieldContext_Job_manifest(ctx, field)
			case "cost":
				return ec.fieldContext_Job_cost(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Job_networkPolicy(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Job_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Job_redisInstances(ctx, field)
			case "openSearch":
				return ec.fieldContext_Job_openSearch(ctx, field)
			case "buckets":
				return ec.fieldContext_Job_buckets(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Job_kafkaTopicAcls(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Job_sqlInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.Job]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*job.Job])
	fc.Result = res
	return ec.marshalNJobEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_JobEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_JobEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*job.Job]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*job.Job]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.Job)
	fc.Result = res
	return ec.marshalNJob2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "name":
				return ec.fieldContext_Job_name(ctx, field)
			case "team":
				return ec.fieldContext_Job_team(ctx, field)
			case "environment":
				return ec.fieldContext_Job_environment(ctx, field)
			case "image":
				return ec.fieldContext_Job_image(ctx, field)
			case "resources":
				return ec.fieldContext_Job_resources(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Job_authIntegrations(ctx, field)
			case "schedule":
				return ec.fieldContext_Job_schedule(ctx, field)
			case "runs":
				return ec.fieldContext_Job_runs(ctx, field)
			case "manifest":
				return ec.fieldContext_Job_manifest(ctx, field)
			case "cost":
				return ec.fieldContext_Job_cost(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Job_networkPolicy(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Job_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Job_redisInstances(ctx, field)
			case "openSearch":
				return ec.fieldContext_Job_openSearch(ctx, field)
			case "buckets":
				return ec.fieldContext_Job_buckets(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Job_kafkaTopicAcls(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Job_sqlInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobManifest_content(ctx context.Context, field graphql.CollectedField, obj *job.JobManifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobManifest_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobManifest_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobManifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobResources_limits(ctx context.Context, field graphql.CollectedField, obj *job.JobResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobResources_limits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.WorkloadResourceQuantity)
	fc.Result = res
	return ec.marshalNWorkloadResourceQuantity2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadResourceQuantity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobResources_limits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadResourceQuantity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobResources_requests(ctx context.Context, field graphql.CollectedField, obj *job.JobResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobResources_requests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.WorkloadResourceQuantity)
	fc.Result = res
	return ec.marshalNWorkloadResourceQuantity2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadResourceQuantity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobResources_requests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadResourceQuantity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_id(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_name(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_startTime(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_completionTime(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_completionTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletionTime(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_completionTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_status(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(job.JobRunStatus)
	fc.Result = res
	return ec.marshalNJobRunStatus2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobRunStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobRunStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_image(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.ContainerImage)
	fc.Result = res
	return ec.marshalNContainerImage2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐContainerImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerImage_id(ctx, field)
			case "name":
				return ec.fieldContext_ContainerImage_name(ctx, field)
			case "tag":
				return ec.fieldContext_ContainerImage_tag(ctx, field)
			case "hasSBOM":
				return ec.fieldContext_ContainerImage_hasSBOM(ctx, field)
			case "vulnerabilities":
				return ec.fieldContext_ContainerImage_vulnerabilities(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_ContainerImage_vulnerabilitySummary(ctx, field)
			case "workloadReferences":
				return ec.fieldContext_ContainerImage_workloadReferences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.JobRun]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.JobRun]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*job.JobRun)
	fc.Result = res
	return ec.marshalNJobRun2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobRunᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JobRun_id(ctx, field)
			case "name":
				return ec.fieldContext_JobRun_name(ctx, field)
			case "startTime":
				return ec.fieldContext_JobRun_startTime(ctx, field)
			case "completionTime":
				return ec.fieldContext_JobRun_completionTime(ctx, field)
			case "status":
				return ec.fieldContext_JobRun_status(ctx, field)
			case "image":
				return ec.fieldContext_JobRun_image(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRun", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.JobRun]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*job.JobRun])
	fc.Result = res
	return ec.marshalNJobRunEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_JobRunEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_JobRunEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRunEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*job.JobRun]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*job.JobRun]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.JobRun)
	fc.Result = res
	return ec.marshalNJobRun2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobRun(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JobRun_id(ctx, field)
			case "name":
				return ec.fieldContext_JobRun_name(ctx, field)
			case "startTime":
				return ec.fieldContext_JobRun_startTime(ctx, field)
			case "completionTime":
				return ec.fieldContext_JobRun_completionTime(ctx, field)
			case "status":
				return ec.fieldContext_JobRun_status(ctx, field)
			case "image":
				return ec.fieldContext_JobRun_image(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRun", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobSchedule_expression(ctx context.Context, field graphql.CollectedField, obj *job.JobSchedule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobSchedule_expression(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobSchedule_expression(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobSchedule_timeZone(ctx context.Context, field graphql.CollectedField, obj *job.JobSchedule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobSchedule_timeZone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeZone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobSchedule_timeZone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaLagScalingStrategy_threshold(ctx context.Context, field graphql.CollectedField, obj *application.KafkaLagScalingStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaLagScalingStrategy_threshold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Threshold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaLagScalingStrategy_threshold(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaLagScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaLagScalingStrategy_consumerGroup(ctx context.Context, field graphql.CollectedField, obj *application.KafkaLagScalingStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaLagScalingStrategy_consumerGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConsumerGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaLagScalingStrategy_consumerGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaLagScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaLagScalingStrategy_topicName(ctx context.Context, field graphql.CollectedField, obj *application.KafkaLagScalingStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaLagScalingStrategy_topicName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaLagScalingStrategy_topicName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaLagScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_id(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_name(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_team(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopic().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_environment(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopic().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_acl(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_acl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopic().ACL(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["filter"].(*kafkatopic.KafkaTopicACLFilter), fc.Args["orderBy"].(*kafkatopic.KafkaTopicACLOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*kafkatopic.KafkaTopicACL])
	fc.Result = res
	return ec.marshalNKafkaTopicAclConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_acl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_KafkaTopicAclConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_KafkaTopicAclConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_KafkaTopicAclConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAclConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KafkaTopic_acl_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_configuration(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.KafkaTopicConfiguration)
	fc.Result = res
	return ec.marshalOKafkaTopicConfiguration2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_configuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cleanupPolicy":
				return ec.fieldContext_KafkaTopicConfiguration_cleanupPolicy(ctx, field)
			case "maxMessageBytes":
				return ec.fieldContext_KafkaTopicConfiguration_maxMessageBytes(ctx, field)
			case "minimumInSyncReplicas":
				return ec.fieldContext_KafkaTopicConfiguration_minimumInSyncReplicas(ctx, field)
			case "partitions":
				return ec.fieldContext_KafkaTopicConfiguration_partitions(ctx, field)
			case "replication":
				return ec.fieldContext_KafkaTopicConfiguration_replication(ctx, field)
			case "retentionBytes":
				return ec.fieldContext_KafkaTopicConfiguration_retentionBytes(ctx, field)
			case "retentionHours":
				return ec.fieldContext_KafkaTopicConfiguration_retentionHours(ctx, field)
			case "segmentHours":
				return ec.fieldContext_KafkaTopicConfiguration_segmentHours(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicConfiguration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_pool(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_pool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_pool(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_status(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.KafkaTopicStatus)
	fc.Result = res
	return ec.marshalNKafkaTopicStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_KafkaTopicStatus_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_access(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_access(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_workloadName(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_workloadName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkloadName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_workloadName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_teamName(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_teamName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_teamName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_team(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopicAcl().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_workload(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopicAcl().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_topic(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopicAcl().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.KafkaTopic)
	fc.Result = res
	return ec.marshalNKafkaTopic2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_topic(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KafkaTopic_id(ctx, field)
			case "name":
				return ec.fieldContext_KafkaTopic_name(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopic_team(ctx, field)
			case "environment":
				return ec.fieldContext_KafkaTopic_environment(ctx, field)
			case "acl":
				return ec.fieldContext_KafkaTopic_acl(ctx, field)
			case "configuration":
				return ec.fieldContext_KafkaTopic_configuration(ctx, field)
			case "pool":
				return ec.fieldContext_KafkaTopic_pool(ctx, field)
			case "status":
				return ec.fieldContext_KafkaTopic_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAclConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopicACL]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAclConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAclConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAclConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAclConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopicACL]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAclConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*kafkatopic.KafkaTopicACL)
	fc.Result = res
	return ec.marshalNKafkaTopicAcl2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACLᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAclConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAclConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "access":
				return ec.fieldContext_KafkaTopicAcl_access(ctx, field)
			case "workloadName":
				return ec.fieldContext_KafkaTopicAcl_workloadName(ctx, field)
			case "teamName":
				return ec.fieldContext_KafkaTopicAcl_teamName(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopicAcl_team(ctx, field)
			case "workload":
				return ec.fieldContext_KafkaTopicAcl_workload(ctx, field)
			case "topic":
				return ec.fieldContext_KafkaTopicAcl_topic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAcl", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAclConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopicACL]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAclConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*kafkatopic.KafkaTopicACL])
	fc.Result = res
	return ec.marshalNKafkaTopicAclEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAclConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAclConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_KafkaTopicAclEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_KafkaTopicAclEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAclEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAclEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*kafkatopic.KafkaTopicACL]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAclEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAclEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAclEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAclEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*kafkatopic.KafkaTopicACL]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAclEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.KafkaTopicACL)
	fc.Result = res
	return ec.marshalNKafkaTopicAcl2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAclEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAclEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "access":
				return ec.fieldContext_KafkaTopicAcl_access(ctx, field)
			case "workloadName":
				return ec.fieldContext_KafkaTopicAcl_workloadName(ctx, field)
			case "teamName":
				return ec.fieldContext_KafkaTopicAcl_teamName(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopicAcl_team(ctx, field)
			case "workload":
				return ec.fieldContext_KafkaTopicAcl_workload(ctx, field)
			case "topic":
				return ec.fieldContext_KafkaTopicAcl_topic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAcl", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_cleanupPolicy(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_cleanupPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CleanupPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_cleanupPolicy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_maxMessageBytes(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_maxMessageBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxMessageBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_maxMessageBytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_minimumInSyncReplicas(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_minimumInSyncReplicas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinimumInSyncReplicas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_minimumInSyncReplicas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_partitions(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_partitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Partitions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_partitions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_replication(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_replication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Replication, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_replication(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_retentionBytes(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_retentionBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RetentionBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_retentionBytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_retentionHours(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_retentionHours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RetentionHours, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_retentionHours(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_segmentHours(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_segmentHours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SegmentHours, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_segmentHours(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopic]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopic]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*kafkatopic.KafkaTopic)
	fc.Result = res
	return ec.marshalNKafkaTopic2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KafkaTopic_id(ctx, field)
			case "name":
				return ec.fieldContext_KafkaTopic_name(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopic_team(ctx, field)
			case "environment":
				return ec.fieldContext_KafkaTopic_environment(ctx, field)
			case "acl":
				return ec.fieldContext_KafkaTopic_acl(ctx, field)
			case "configuration":
				return ec.fieldContext_KafkaTopic_configuration(ctx, field)
			case "pool":
				return ec.fieldContext_KafkaTopic_pool(ctx, field)
			case "status":
				return ec.fieldContext_KafkaTopic_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopic]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*kafkatopic.KafkaTopic])
	fc.Result = res
	return ec.marshalNKafkaTopicEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_KafkaTopicEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_KafkaTopicEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*kafkatopic.KafkaTopic]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*kafkatopic.KafkaTopic]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.KafkaTopic)
	fc.Result = res
	return ec.marshalNKafkaTopic2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KafkaTopic_id(ctx, field)
			case "name":
				return ec.fieldContext_KafkaTopic_name(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopic_team(ctx, field)
			case "environment":
				return ec.fieldContext_KafkaTopic_environment(ctx, field)
			case "acl":
				return ec.fieldContext_KafkaTopic_acl(ctx, field)
			case "configuration":
				return ec.fieldContext_KafkaTopic_configuration(ctx, field)
			case "pool":
				return ec.fieldContext_KafkaTopic_pool(ctx, field)
			case "status":
				return ec.fieldContext_KafkaTopic_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicStatus_state(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MaskinportenAuthIntegration_name(ctx context.Context, field graphql.CollectedField, obj *workload.MaskinportenAuthIntegration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MaskinportenAuthIntegration_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MaskinportenAuthIntegration_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MaskinportenAuthIntegration",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteApplication(rctx, fc.Args["input"].(application.DeleteApplicationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.DeleteApplicationPayload)
	fc.Result = res
	return ec.marshalNDeleteApplicationPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐDeleteApplicationPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_DeleteApplicationPayload_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteApplicationPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestartApplication(rctx, fc.Args["input"].(application.RestartApplicationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.RestartApplicationPayload)
	fc.Result = res
	return ec.marshalNRestartApplicationPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐRestartApplicationPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "application":
				return ec.fieldContext_RestartApplicationPayload_application(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RestartApplicationPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteJob(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteJob(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteJob(rctx, fc.Args["input"].(job.DeleteJobInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.DeleteJobPayload)
	fc.Result = res
	return ec.marshalNDeleteJobPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐDeleteJobPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteJob(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_DeleteJobPayload_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteJobPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteJob_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_enableReconciler(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_enableReconciler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EnableReconciler(rctx, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*reconciler.Reconciler)
	fc.Result = res
	return ec.marshalNReconciler2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconciler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_enableReconciler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Reconciler_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Reconciler_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Reconciler_description(ctx, field)
			case "enabled":
				return ec.fieldContext_Reconciler_enabled(ctx, field)
			case "config":
				return ec.fieldContext_Reconciler_config(ctx, field)
			case "configured":
				return ec.fieldContext_Reconciler_configured(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Reconciler", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_enableReconciler_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_disableReconciler(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_disableReconciler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DisableReconciler(rctx, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*reconciler.Reconciler)
	fc.Result = res
	return ec.marshalNReconciler2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconciler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_disableReconciler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Reconciler_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Reconciler_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Reconciler_description(ctx, field)
			case "enabled":
				return ec.fieldContext_Reconciler_enabled(ctx, field)
			case "config":
				return ec.fieldContext_Reconciler_config(ctx, field)
			case "configured":
				return ec.fieldContext_Reconciler_configured(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Reconciler", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_disableReconciler_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_configureReconciler(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_configureReconciler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfigureReconciler(rctx, fc.Args["name"].(string), fc.Args["config"].([]*reconciler.ReconcilerConfigInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*reconciler.Reconciler)
	fc.Result = res
	return ec.marshalNReconciler2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconciler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_configureReconciler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Reconciler_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Reconciler_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Reconciler_description(ctx, field)
			case "enabled":
				return ec.fieldContext_Reconciler_enabled(ctx, field)
			case "config":
				return ec.fieldContext_Reconciler_config(ctx, field)
			case "configured":
				return ec.fieldContext_Reconciler_configured(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Reconciler", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_configureReconciler_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addRepositoryToTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addRepositoryToTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddRepositoryToTeam(rctx, fc.Args["input"].(repository.AddRepositoryToTeamInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*repository.AddRepositoryToTeamPayload)
	fc.Result = res
	return ec.marshalNAddRepositoryToTeamPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐAddRepositoryToTeamPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addRepositoryToTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "repository":
				return ec.fieldContext_AddRepositoryToTeamPayload_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AddRepositoryToTeamPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addRepositoryToTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeRepositoryFromTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeRepositoryFromTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveRepositoryFromTeam(rctx, fc.Args["input"].(repository.RemoveRepositoryFromTeamInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*repository.RemoveRepositoryFromTeamPayload)
	fc.Result = res
	return ec.marshalNRemoveRepositoryFromTeamPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRemoveRepositoryFromTeamPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeRepositoryFromTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_RemoveRepositoryFromTeamPayload_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RemoveRepositoryFromTeamPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeRepositoryFromTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTeam(rctx, fc.Args["input"].(team.CreateTeamInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.CreateTeamPayload)
	fc.Result = res
	return ec.marshalNCreateTeamPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐCreateTeamPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_CreateTeamPayload_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateTeamPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTeam(rctx, fc.Args["input"].(team.UpdateTeamInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.UpdateTeamPayload)
	fc.Result = res
	return ec.marshalNUpdateTeamPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUpdateTeamPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_UpdateTeamPayload_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTeamPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTeamEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTeamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTeamEnvironment(rctx, fc.Args["input"].(team.UpdateTeamEnvironmentInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.UpdateTeamEnvironmentPayload)
	fc.Result = res
	return ec.marshalNUpdateTeamEnvironmentPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUpdateTeamEnvironmentPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTeamEnvironment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "environment":
				return ec.fieldContext_UpdateTeamEnvironmentPayload_environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTeamEnvironmentPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTeamEnvironment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_synchronizeTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_synchronizeTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SynchronizeTeam(rctx, fc.Args["input"].(team.SynchronizeTeamInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.SynchronizeTeamPayload)
	fc.Result = res
	return ec.marshalNSynchronizeTeamPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐSynchronizeTeamPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_synchronizeTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_SynchronizeTeamPayload_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SynchronizeTeamPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_synchronizeTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestTeamDeletion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestTeamDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RequestTeamDeletion(rctx, fc.Args["input"].(team.RequestTeamDeletionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.RequestTeamDeletionPayload)
	fc.Result = res
	return ec.marshalNRequestTeamDeletionPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐRequestTeamDeletionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestTeamDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_RequestTeamDeletionPayload_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RequestTeamDeletionPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestTeamDeletion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_confirmTeamDeletion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_confirmTeamDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmTeamDeletion(rctx, fc.Args["input"].(team.ConfirmTeamDeletionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.ConfirmTeamDeletionPayload)
	fc.Result = res
	return ec.marshalNConfirmTeamDeletionPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐConfirmTeamDeletionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_confirmTeamDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletionStarted":
				return ec.fieldContext_ConfirmTeamDeletionPayload_deletionStarted(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfirmTeamDeletionPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_confirmTeamDeletion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addTeamMember(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addTeamMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddTeamMember(rctx, fc.Args["input"].(team.AddTeamMemberInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.AddTeamMemberPayload)
	fc.Result = res
	return ec.marshalNAddTeamMemberPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐAddTeamMemberPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addTeamMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "member":
				return ec.fieldContext_AddTeamMemberPayload_member(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AddTeamMemberPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addTeamMember_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeTeamMember(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeTeamMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveTeamMember(rctx, fc.Args["input"].(team.RemoveTeamMemberInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.RemoveTeamMemberPayload)
	fc.Result = res
	return ec.marshalNRemoveTeamMemberPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐRemoveTeamMemberPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeTeamMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_RemoveTeamMemberPayload_user(ctx, field)
			case "team":
				return ec.fieldContext_RemoveTeamMemberPayload_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RemoveTeamMemberPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeTeamMember_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setTeamMemberRole(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setTeamMemberRole(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetTeamMemberRole(rctx, fc.Args["input"].(team.SetTeamMemberRoleInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.SetTeamMemberRolePayload)
	fc.Result = res
	return ec.marshalNSetTeamMemberRolePayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐSetTeamMemberRolePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setTeamMemberRole(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "member":
				return ec.fieldContext_SetTeamMemberRolePayload_member(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetTeamMemberRolePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setTeamMemberRole_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicy_inbound(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicy_inbound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inbound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*netpol.InboundNetworkPolicy)
	fc.Result = res
	return ec.marshalNInboundNetworkPolicy2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐInboundNetworkPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicy_inbound(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rules":
				return ec.fieldContext_InboundNetworkPolicy_rules(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InboundNetworkPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicy_outbound(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicy_outbound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Outbound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*netpol.OutboundNetworkPolicy)
	fc.Result = res
	return ec.marshalNOutboundNetworkPolicy2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐOutboundNetworkPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicy_outbound(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rules":
				return ec.fieldContext_OutboundNetworkPolicy_rules(ctx, field)
			case "external":
				return ec.fieldContext_OutboundNetworkPolicy_external(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OutboundNetworkPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicyRule_targetWorkloadName(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicyRule_targetWorkloadName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetWorkloadName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicyRule_targetWorkloadName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicyRule_targetWorkload(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicyRule_targetWorkload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.NetworkPolicyRule().TargetWorkload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicyRule_targetWorkload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicyRule",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicyRule_targetTeamSlug(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicyRule_targetTeamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetTeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicyRule_targetTeamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicyRule_targetTeam(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicyRule_targetTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.NetworkPolicyRule().TargetTeam(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicyRule_targetTeam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicyRule",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicyRule_mutual(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicyRule_mutual(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.NetworkPolicyRule().Mutual(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicyRule_mutual(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicyRule",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_id(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_name(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_team(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearch().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_environment(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearch().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_status(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearchStatus)
	fc.Result = res
	return ec.marshalNOpenSearchStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_OpenSearchStatus_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_workload(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearch().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_access(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearch().Access(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*opensearch.OpenSearchAccessOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*opensearch.OpenSearchAccess])
	fc.Result = res
	return ec.marshalNOpenSearchAccessConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_access(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_OpenSearchAccessConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_OpenSearchAccessConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_OpenSearchAccessConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchAccessConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_OpenSearch_access_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_cost(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearch().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.OpenSearchCost)
	fc.Result = res
	return ec.marshalNOpenSearchCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐOpenSearchCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_OpenSearchCost_sum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccess_workload(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearchAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccess_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearchAccess().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccess_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccess",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccess_access(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearchAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccess_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccess_access(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccessConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearchAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccessConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccessConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccessConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearchAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccessConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*opensearch.OpenSearchAccess)
	fc.Result = res
	return ec.marshalNOpenSearchAccess2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchAccessᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccessConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccessConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_OpenSearchAccess_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearchAccess_access(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccessConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearchAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccessConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*opensearch.OpenSearchAccess])
	fc.Result = res
	return ec.marshalNOpenSearchAccessEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccessConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_OpenSearchAccessEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_OpenSearchAccessEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchAccessEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccessEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*opensearch.OpenSearchAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccessEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccessEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccessEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*opensearch.OpenSearchAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccessEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearchAccess)
	fc.Result = res
	return ec.marshalNOpenSearchAccess2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccessEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_OpenSearchAccess_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearchAccess_access(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearch]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearch]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*opensearch.OpenSearch)
	fc.Result = res
	return ec.marshalNOpenSearch2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "status":
				return ec.fieldContext_OpenSearch_status(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearch]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*opensearch.OpenSearch])
	fc.Result = res
	return ec.marshalNOpenSearchEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_OpenSearchEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_OpenSearchEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchCost_sum(ctx context.Context, field graphql.CollectedField, obj *cost.OpenSearchCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchCost_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchCost_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchCost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*opensearch.OpenSearch]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*opensearch.OpenSearch]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearch)
	fc.Result = res
	return ec.marshalNOpenSearch2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "status":
				return ec.fieldContext_OpenSearch_status(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchStatus_state(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearchStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OutboundNetworkPolicy_rules(ctx context.Context, field graphql.CollectedField, obj *netpol.OutboundNetworkPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OutboundNetworkPolicy_rules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*netpol.NetworkPolicyRule)
	fc.Result = res
	return ec.marshalNNetworkPolicyRule2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐNetworkPolicyRuleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OutboundNetworkPolicy_rules(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OutboundNetworkPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "targetWorkloadName":
				return ec.fieldContext_NetworkPolicyRule_targetWorkloadName(ctx, field)
			case "targetWorkload":
				return ec.fieldContext_NetworkPolicyRule_targetWorkload(ctx, field)
			case "targetTeamSlug":
				return ec.fieldContext_NetworkPolicyRule_targetTeamSlug(ctx, field)
			case "targetTeam":
				return ec.fieldContext_NetworkPolicyRule_targetTeam(ctx, field)
			case "mutual":
				return ec.fieldContext_NetworkPolicyRule_mutual(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkPolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OutboundNetworkPolicy_external(ctx context.Context, field graphql.CollectedField, obj *netpol.OutboundNetworkPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OutboundNetworkPolicy_external(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.External, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]netpol.ExternalNetworkPolicyTarget)
	fc.Result = res
	return ec.marshalNExternalNetworkPolicyTarget2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐExternalNetworkPolicyTargetᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OutboundNetworkPolicy_external(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OutboundNetworkPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*pagination.Cursor)
	fc.Result = res
	return ec.marshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*pagination.Cursor)
	fc.Result = res
	return ec.marshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_totalCount(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_pageStart(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_pageStart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageStart(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_pageStart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_pageEnd(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_pageEnd(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageEnd(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_pageEnd(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(ident.Ident))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(modelv1.Node)
	fc.Result = res
	return ec.marshalONode2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_reconcilers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_reconcilers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Reconcilers(rctx, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*reconciler.Reconciler])
	fc.Result = res
	return ec.marshalNReconcilerConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_reconcilers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ReconcilerConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ReconcilerConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ReconcilerConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconcilerConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_reconcilers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_search(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_search(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Search(rctx, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["filter"].(searchv1.SearchFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[searchv1.SearchNode])
	fc.Result = res
	return ec.marshalNSearchNodeConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_search(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SearchNodeConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SearchNodeConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SearchNodeConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchNodeConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_search_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_teams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_teams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Teams(rctx, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*team.TeamOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*team.Team])
	fc.Result = res
	return ec.marshalNTeamConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_teams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_TeamConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_TeamConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_TeamConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_teams_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_team(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Team(rctx, fc.Args["slug"].(slug.Slug))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_team(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_team_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*user.UserOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*user.User])
	fc.Result = res
	return ec.marshalNUserConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_UserConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_UserConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_UserConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_users_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, fc.Args["id"].(ident.Ident))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Me(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(user.AuthenticatedUser)
	fc.Result = res
	return ec.marshalNAuthenticatedUser2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐAuthenticatedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuthenticatedUser does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_teamsUtilization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_teamsUtilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TeamsUtilization(rctx, fc.Args["resourceType"].(utilization.UtilizationResourceType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*utilization.TeamUtilizationData)
	fc.Result = res
	return ec.marshalNTeamUtilizationData2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐTeamUtilizationDataᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_teamsUtilization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamUtilizationData_team(ctx, field)
			case "requested":
				return ec.fieldContext_TeamUtilizationData_requested(ctx, field)
			case "used":
				return ec.fieldContext_TeamUtilizationData_used(ctx, field)
			case "environment":
				return ec.fieldContext_TeamUtilizationData_environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamUtilizationData", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_teamsUtilization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_name(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_displayName(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_description(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_enabled(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_config(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Reconciler().Config(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*reconciler.ReconcilerConfig)
	fc.Result = res
	return ec.marshalNReconcilerConfig2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconcilerConfigᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_config(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ReconcilerConfig_key(ctx, field)
			case "displayName":
				return ec.fieldContext_ReconcilerConfig_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ReconcilerConfig_description(ctx, field)
			case "configured":
				return ec.fieldContext_ReconcilerConfig_configured(ctx, field)
			case "secret":
				return ec.fieldContext_ReconcilerConfig_secret(ctx, field)
			case "value":
				return ec.fieldContext_ReconcilerConfig_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconcilerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_configured(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_configured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Reconciler().Configured(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_configured(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_key(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_displayName(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_description(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_configured(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_configured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configured, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_configured(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_secret(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_value(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*reconciler.Reconciler]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*reconciler.Reconciler]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*reconciler.Reconciler)
	fc.Result = res
	return ec.marshalNReconciler2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconcilerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Reconciler_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Reconciler_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Reconciler_description(ctx, field)
			case "enabled":
				return ec.fieldContext_Reconciler_enabled(ctx, field)
			case "config":
				return ec.fieldContext_Reconciler_config(ctx, field)
			case "configured":
				return ec.fieldContext_Reconciler_configured(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Reconciler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*reconciler.Reconciler]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*reconciler.Reconciler])
	fc.Result = res
	return ec.marshalNReconcilerEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ReconcilerEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ReconcilerEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconcilerEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*reconciler.Reconciler]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*reconciler.Reconciler]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*reconciler.Reconciler)
	fc.Result = res
	return ec.marshalNReconciler2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconciler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Reconciler_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Reconciler_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Reconciler_description(ctx, field)
			case "enabled":
				return ec.fieldContext_Reconciler_enabled(ctx, field)
			case "config":
				return ec.fieldContext_Reconciler_config(ctx, field)
			case "configured":
				return ec.fieldContext_Reconciler_configured(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Reconciler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_id(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_name(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_team(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstance().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_environment(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstance().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_access(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstance().Access(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*redis.RedisInstanceAccessOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*redis.RedisInstanceAccess])
	fc.Result = res
	return ec.marshalNRedisInstanceAccessConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_access(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_RedisInstanceAccessConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_RedisInstanceAccessConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RedisInstanceAccessConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceAccessConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RedisInstance_access_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_workload(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstance().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_status(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*redis.RedisInstanceStatus)
	fc.Result = res
	return ec.marshalNRedisInstanceStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_RedisInstanceStatus_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_cost(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstance().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.RedisInstanceCost)
	fc.Result = res
	return ec.marshalNRedisInstanceCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐRedisInstanceCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_RedisInstanceCost_sum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccess_workload(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstanceAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccess_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstanceAccess().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccess_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccess",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccess_access(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstanceAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccess_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccess_access(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccessConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccessConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccessConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccessConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccessConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*redis.RedisInstanceAccess)
	fc.Result = res
	return ec.marshalNRedisInstanceAccess2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceAccessᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccessConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccessConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_RedisInstanceAccess_workload(ctx, field)
			case "access":
				return ec.fieldContext_RedisInstanceAccess_access(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccessConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccessConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*redis.RedisInstanceAccess])
	fc.Result = res
	return ec.marshalNRedisInstanceAccessEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccessConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_RedisInstanceAccessEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_RedisInstanceAccessEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceAccessEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccessEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*redis.RedisInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccessEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccessEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccessEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*redis.RedisInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccessEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*redis.RedisInstanceAccess)
	fc.Result = res
	return ec.marshalNRedisInstanceAccess2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccessEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_RedisInstanceAccess_workload(ctx, field)
			case "access":
				return ec.fieldContext_RedisInstanceAccess_access(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*redis.RedisInstance)
	fc.Result = res
	return ec.marshalNRedisInstance2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RedisInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_RedisInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_RedisInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_RedisInstance_environment(ctx, field)
			case "access":
				return ec.fieldContext_RedisInstance_access(ctx, field)
			case "workload":
				return ec.fieldContext_RedisInstance_workload(ctx, field)
			case "status":
				return ec.fieldContext_RedisInstance_status(ctx, field)
			case "cost":
				return ec.fieldContext_RedisInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*redis.RedisInstance])
	fc.Result = res
	return ec.marshalNRedisInstanceEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_RedisInstanceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_RedisInstanceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceCost_sum(ctx context.Context, field graphql.CollectedField, obj *cost.RedisInstanceCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceCost_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceCost_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceCost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*redis.RedisInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*redis.RedisInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*redis.RedisInstance)
	fc.Result = res
	return ec.marshalNRedisInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RedisInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_RedisInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_RedisInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_RedisInstance_environment(ctx, field)
			case "access":
				return ec.fieldContext_RedisInstance_access(ctx, field)
			case "workload":
				return ec.fieldContext_RedisInstance_workload(ctx, field)
			case "status":
				return ec.fieldContext_RedisInstance_status(ctx, field)
			case "cost":
				return ec.fieldContext_RedisInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceStatus_state(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstanceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveRepositoryFromTeamPayload_success(ctx context.Context, field graphql.CollectedField, obj *repository.RemoveRepositoryFromTeamPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveRepositoryFromTeamPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveRepositoryFromTeamPayload_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveRepositoryFromTeamPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveTeamMemberPayload_user(ctx context.Context, field graphql.CollectedField, obj *team.RemoveTeamMemberPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveTeamMemberPayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RemoveTeamMemberPayload().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveTeamMemberPayload_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveTeamMemberPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveTeamMemberPayload_team(ctx context.Context, field graphql.CollectedField, obj *team.RemoveTeamMemberPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveTeamMemberPayload_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RemoveTeamMemberPayload().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveTeamMemberPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveTeamMemberPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_id(ctx context.Context, field graphql.CollectedField, obj *repository.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_name(ctx context.Context, field graphql.CollectedField, obj *repository.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_team(ctx context.Context, field graphql.CollectedField, obj *repository.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*repository.Repository]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*repository.Repository]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*repository.Repository)
	fc.Result = res
	return ec.marshalNRepository2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRepositoryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "team":
				return ec.fieldContext_Repository_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*repository.Repository]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*repository.Repository])
	fc.Result = res
	return ec.marshalNRepositoryEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_RepositoryEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_RepositoryEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*repository.Repository]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*repository.Repository]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*repository.Repository)
	fc.Result = res
	return ec.marshalNRepository2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "team":
				return ec.fieldContext_Repository_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RequestTeamDeletionPayload_key(ctx context.Context, field graphql.CollectedField, obj *team.RequestTeamDeletionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RequestTeamDeletionPayload_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamDeleteKey)
	fc.Result = res
	return ec.marshalOTeamDeleteKey2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamDeleteKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RequestTeamDeletionPayload_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RequestTeamDeletionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_TeamDeleteKey_key(ctx, field)
			case "createdAt":
				return ec.fieldContext_TeamDeleteKey_createdAt(ctx, field)
			case "expires":
				return ec.fieldContext_TeamDeleteKey_expires(ctx, field)
			case "createdBy":
				return ec.fieldContext_TeamDeleteKey_createdBy(ctx, field)
			case "team":
				return ec.fieldContext_TeamDeleteKey_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamDeleteKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RestartApplicationPayload_application(ctx context.Context, field graphql.CollectedField, obj *application.RestartApplicationPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RestartApplicationPayload_application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RestartApplicationPayload().Application(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*application.Application)
	fc.Result = res
	return ec.marshalOApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RestartApplicationPayload_application(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RestartApplicationPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Application_redisInstances(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchNodeConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[searchv1.SearchNode]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchNodeConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchNodeConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchNodeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchNodeConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[searchv1.SearchNode]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchNodeConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]searchv1.SearchNode)
	fc.Result = res
	return ec.marshalNSearchNode2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋsearchv1ᚐSearchNodeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchNodeConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchNodeConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchNode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchNodeConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[searchv1.SearchNode]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchNodeConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[searchv1.SearchNode])
	fc.Result = res
	return ec.marshalNSearchNodeEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchNodeConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchNodeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_SearchNodeEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_SearchNodeEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchNodeEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchNodeEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[searchv1.SearchNode]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchNodeEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchNodeEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchNodeEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchNodeEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[searchv1.SearchNode]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchNodeEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(searchv1.SearchNode)
	fc.Result = res
	return ec.marshalNSearchNode2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋsearchv1ᚐSearchNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchNodeEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchNodeEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchNode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceCost_service(ctx context.Context, field graphql.CollectedField, obj *cost.ServiceCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceCost_service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Service, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceCost_service(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceCost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceCost_cost(ctx context.Context, field graphql.CollectedField, obj *cost.ServiceCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceCost_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceCost_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceCost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceCostSeries_date(ctx context.Context, field graphql.CollectedField, obj *cost.ServiceCostSeries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceCostSeries_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(scalar.Date)
	fc.Result = res
	return ec.marshalNDate2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋscalarᚐDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceCostSeries_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceCostSeries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceCostSeries_sum(ctx context.Context, field graphql.CollectedField, obj *cost.ServiceCostSeries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceCostSeries_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceCostSeries_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceCostSeries",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceCostSeries_services(ctx context.Context, field graphql.CollectedField, obj *cost.ServiceCostSeries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceCostSeries_services(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Services, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*cost.ServiceCost)
	fc.Result = res
	return ec.marshalNServiceCost2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐServiceCostᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceCostSeries_services(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceCostSeries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "service":
				return ec.fieldContext_ServiceCost_service(ctx, field)
			case "cost":
				return ec.fieldContext_ServiceCost_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetTeamMemberRolePayload_member(ctx context.Context, field graphql.CollectedField, obj *team.SetTeamMemberRolePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetTeamMemberRolePayload_member(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Member, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamMember)
	fc.Result = res
	return ec.marshalOTeamMember2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetTeamMemberRolePayload_member(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetTeamMemberRolePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamMember_team(ctx, field)
			case "user":
				return ec.fieldContext_TeamMember_user(ctx, field)
			case "role":
				return ec.fieldContext_TeamMember_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_id(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_name(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_team(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlDatabase().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_environment(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlDatabase().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_charset(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_charset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Charset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_charset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_collation(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_collation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Collation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_collation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_deletionPolicy(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_deletionPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_deletionPolicy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_healthy(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_healthy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Healthy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_healthy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_id(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_name(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_team(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_environment(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_workload(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_cascadingDelete(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_cascadingDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CascadingDelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_cascadingDelete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_connectionName(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_connectionName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_connectionName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_diskAutoresize(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_diskAutoresize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiskAutoresize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_diskAutoresize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_diskAutoresizeLimit(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_diskAutoresizeLimit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiskAutoresizeLimit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2ᚖint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_diskAutoresizeLimit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_highAvailability(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_highAvailability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HighAvailability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_highAvailability(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_healthy(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_healthy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Healthy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_healthy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_maintenanceVersion(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_maintenanceVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaintenanceVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_maintenanceVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_maintenanceWindow(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_maintenanceWindow(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaintenanceWindow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceMaintenanceWindow)
	fc.Result = res
	return ec.marshalOSqlInstanceMaintenanceWindow2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceMaintenanceWindow(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_maintenanceWindow(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "day":
				return ec.fieldContext_SqlInstanceMaintenanceWindow_day(ctx, field)
			case "hour":
				return ec.fieldContext_SqlInstanceMaintenanceWindow_hour(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceMaintenanceWindow", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_backupConfiguration(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_backupConfiguration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackupConfiguration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceBackupConfiguration)
	fc.Result = res
	return ec.marshalOSqlInstanceBackupConfiguration2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceBackupConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_backupConfiguration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_SqlInstanceBackupConfiguration_enabled(ctx, field)
			case "startTime":
				return ec.fieldContext_SqlInstanceBackupConfiguration_startTime(ctx, field)
			case "retainedBackups":
				return ec.fieldContext_SqlInstanceBackupConfiguration_retainedBackups(ctx, field)
			case "pointInTimeRecovery":
				return ec.fieldContext_SqlInstanceBackupConfiguration_pointInTimeRecovery(ctx, field)
			case "transactionLogRetentionDays":
				return ec.fieldContext_SqlInstanceBackupConfiguration_transactionLogRetentionDays(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceBackupConfiguration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_projectID(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_projectID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_projectID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_tier(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_tier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_tier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_version(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_status(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceStatus)
	fc.Result = res
	return ec.marshalNSqlInstanceStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "publicIpAddress":
				return ec.fieldContext_SqlInstanceStatus_publicIpAddress(ctx, field)
			case "privateIpAddress":
				return ec.fieldContext_SqlInstanceStatus_privateIpAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_database(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_database(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Database(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLDatabase)
	fc.Result = res
	return ec.marshalOSqlDatabase2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLDatabase(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_database(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SqlDatabase_id(ctx, field)
			case "name":
				return ec.fieldContext_SqlDatabase_name(ctx, field)
			case "team":
				return ec.fieldContext_SqlDatabase_team(ctx, field)
			case "environment":
				return ec.fieldContext_SqlDatabase_environment(ctx, field)
			case "charset":
				return ec.fieldContext_SqlDatabase_charset(ctx, field)
			case "collation":
				return ec.fieldContext_SqlDatabase_collation(ctx, field)
			case "deletionPolicy":
				return ec.fieldContext_SqlDatabase_deletionPolicy(ctx, field)
			case "healthy":
				return ec.fieldContext_SqlDatabase_healthy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlDatabase", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_flags(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_flags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Flags(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*sqlinstance.SQLInstanceFlag])
	fc.Result = res
	return ec.marshalNSqlInstanceFlagConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_flags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SqlInstanceFlagConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SqlInstanceFlagConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SqlInstanceFlagConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceFlagConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SqlInstance_flags_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_users(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Users(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*sqlinstance.SQLInstanceUserOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*sqlinstance.SQLInstanceUser])
	fc.Result = res
	return ec.marshalNSqlInstanceUserConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SqlInstanceUserConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SqlInstanceUserConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SqlInstanceUserConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceUserConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SqlInstance_users_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceBackupConfiguration_enabled(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceBackupConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceBackupConfiguration_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceBackupConfiguration_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceBackupConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceBackupConfiguration_startTime(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceBackupConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceBackupConfiguration_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceBackupConfiguration_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceBackupConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceBackupConfiguration_retainedBackups(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceBackupConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceBackupConfiguration_retainedBackups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RetainedBackups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2ᚖint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceBackupConfiguration_retainedBackups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceBackupConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceBackupConfiguration_pointInTimeRecovery(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceBackupConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceBackupConfiguration_pointInTimeRecovery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PointInTimeRecovery, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceBackupConfiguration_pointInTimeRecovery(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceBackupConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceBackupConfiguration_transactionLogRetentionDays(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceBackupConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceBackupConfiguration_transactionLogRetentionDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionLogRetentionDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2ᚖint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceBackupConfiguration_transactionLogRetentionDays(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceBackupConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*sqlinstance.SQLInstance)
	fc.Result = res
	return ec.marshalNSqlInstance2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SqlInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_SqlInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_SqlInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_SqlInstance_environment(ctx, field)
			case "workload":
				return ec.fieldContext_SqlInstance_workload(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_SqlInstance_cascadingDelete(ctx, field)
			case "connectionName":
				return ec.fieldContext_SqlInstance_connectionName(ctx, field)
			case "diskAutoresize":
				return ec.fieldContext_SqlInstance_diskAutoresize(ctx, field)
			case "diskAutoresizeLimit":
				return ec.fieldContext_SqlInstance_diskAutoresizeLimit(ctx, field)
			case "highAvailability":
				return ec.fieldContext_SqlInstance_highAvailability(ctx, field)
			case "healthy":
				return ec.fieldContext_SqlInstance_healthy(ctx, field)
			case "maintenanceVersion":
				return ec.fieldContext_SqlInstance_maintenanceVersion(ctx, field)
			case "maintenanceWindow":
				return ec.fieldContext_SqlInstance_maintenanceWindow(ctx, field)
			case "backupConfiguration":
				return ec.fieldContext_SqlInstance_backupConfiguration(ctx, field)
			case "projectID":
				return ec.fieldContext_SqlInstance_projectID(ctx, field)
			case "tier":
				return ec.fieldContext_SqlInstance_tier(ctx, field)
			case "version":
				return ec.fieldContext_SqlInstance_version(ctx, field)
			case "status":
				return ec.fieldContext_SqlInstance_status(ctx, field)
			case "database":
				return ec.fieldContext_SqlInstance_database(ctx, field)
			case "flags":
				return ec.fieldContext_SqlInstance_flags(ctx, field)
			case "users":
				return ec.fieldContext_SqlInstance_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*sqlinstance.SQLInstance])
	fc.Result = res
	return ec.marshalNSqlInstanceEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_SqlInstanceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_SqlInstanceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstance)
	fc.Result = res
	return ec.marshalNSqlInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SqlInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_SqlInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_SqlInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_SqlInstance_environment(ctx, field)
			case "workload":
				return ec.fieldContext_SqlInstance_workload(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_SqlInstance_cascadingDelete(ctx, field)
			case "connectionName":
				return ec.fieldContext_SqlInstance_connectionName(ctx, field)
			case "diskAutoresize":
				return ec.fieldContext_SqlInstance_diskAutoresize(ctx, field)
			case "diskAutoresizeLimit":
				return ec.fieldContext_SqlInstance_diskAutoresizeLimit(ctx, field)
			case "highAvailability":
				return ec.fieldContext_SqlInstance_highAvailability(ctx, field)
			case "healthy":
				return ec.fieldContext_SqlInstance_healthy(ctx, field)
			case "maintenanceVersion":
				return ec.fieldContext_SqlInstance_maintenanceVersion(ctx, field)
			case "maintenanceWindow":
				return ec.fieldContext_SqlInstance_maintenanceWindow(ctx, field)
			case "backupConfiguration":
				return ec.fieldContext_SqlInstance_backupConfiguration(ctx, field)
			case "projectID":
				return ec.fieldContext_SqlInstance_projectID(ctx, field)
			case "tier":
				return ec.fieldContext_SqlInstance_tier(ctx, field)
			case "version":
				return ec.fieldContext_SqlInstance_version(ctx, field)
			case "status":
				return ec.fieldContext_SqlInstance_status(ctx, field)
			case "database":
				return ec.fieldContext_SqlInstance_database(ctx, field)
			case "flags":
				return ec.fieldContext_SqlInstance_flags(ctx, field)
			case "users":
				return ec.fieldContext_SqlInstance_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlag_name(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceFlag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlag_value(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceFlag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlag_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlag_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlagConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceFlag]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlagConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlagConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlagConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlagConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceFlag]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlagConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*sqlinstance.SQLInstanceFlag)
	fc.Result = res
	return ec.marshalNSqlInstanceFlag2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceFlagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlagConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlagConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SqlInstanceFlag_name(ctx, field)
			case "value":
				return ec.fieldContext_SqlInstanceFlag_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceFlag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlagConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceFlag]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlagConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*sqlinstance.SQLInstanceFlag])
	fc.Result = res
	return ec.marshalNSqlInstanceFlagEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlagConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlagConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_SqlInstanceFlagEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_SqlInstanceFlagEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceFlagEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlagEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstanceFlag]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlagEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlagEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlagEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlagEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstanceFlag]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlagEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceFlag)
	fc.Result = res
	return ec.marshalNSqlInstanceFlag2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceFlag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlagEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlagEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SqlInstanceFlag_name(ctx, field)
			case "value":
				return ec.fieldContext_SqlInstanceFlag_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceFlag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceMaintenanceWindow_day(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceMaintenanceWindow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceMaintenanceWindow_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Day, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceMaintenanceWindow_day(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceMaintenanceWindow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceMaintenanceWindow_hour(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceMaintenanceWindow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceMaintenanceWindow_hour(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hour, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceMaintenanceWindow_hour(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceMaintenanceWindow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceStatus_publicIpAddress(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceStatus_publicIpAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicIPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceStatus_publicIpAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceStatus_privateIpAddress(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceStatus_privateIpAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateIPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceStatus_privateIpAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUser_name(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUser_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUser_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUser_authentication(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUser_authentication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Authentication, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUser_authentication(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUserConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceUser]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUserConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUserConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUserConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceUser]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUserConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*sqlinstance.SQLInstanceUser)
	fc.Result = res
	return ec.marshalNSqlInstanceUser2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUserConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUserConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SqlInstanceUser_name(ctx, field)
			case "authentication":
				return ec.fieldContext_SqlInstanceUser_authentication(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUserConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceUser]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUserConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*sqlinstance.SQLInstanceUser])
	fc.Result = res
	return ec.marshalNSqlInstanceUserEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUserConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_SqlInstanceUserEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_SqlInstanceUserEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceUserEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstanceUser]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUserEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUserEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstanceUser]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceUser)
	fc.Result = res
	return ec.marshalNSqlInstanceUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUserEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SqlInstanceUser_name(ctx, field)
			case "authentication":
				return ec.fieldContext_SqlInstanceUser_authentication(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SynchronizeTeamPayload_team(ctx context.Context, field graphql.CollectedField, obj *team.SynchronizeTeamPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SynchronizeTeamPayload_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Team, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SynchronizeTeamPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SynchronizeTeamPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_id(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_slug(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_slug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_slug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_slackChannel(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_slackChannel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackChannel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_slackChannel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_purpose(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_purpose(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Purpose, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_purpose(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_azureGroupID(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_azureGroupID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AzureGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_azureGroupID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_gitHubTeamSlug(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitHubTeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_gitHubTeamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_googleGroupEmail(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_googleGroupEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoogleGroupEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_googleGroupEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_googleArtifactRegistry(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoogleArtifactRegistry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_googleArtifactRegistry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_cdnBucket(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_cdnBucket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CdnBucket, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_cdnBucket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_member(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_member(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Member(rctx, obj, fc.Args["email"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamMember)
	fc.Result = res
	return ec.marshalNTeamMember2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_member(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamMember_team(ctx, field)
			case "user":
				return ec.fieldContext_TeamMember_user(ctx, field)
			case "role":
				return ec.fieldContext_TeamMember_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_member_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_members(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_members(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Members(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*team.TeamMemberOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*team.TeamMember])
	fc.Result = res
	return ec.marshalNTeamMemberConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_members(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_TeamMemberConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_TeamMemberConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_TeamMemberConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_members_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_lastSuccessfulSync(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSuccessfulSync, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_lastSuccessfulSync(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_deletionInProgress(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_deletionInProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionInProgress(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_deletionInProgress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_viewerIsOwner(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_viewerIsOwner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().ViewerIsOwner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_viewerIsOwner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_viewerIsMember(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_viewerIsMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().ViewerIsMember(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_viewerIsMember(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_environments(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Environments(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_environments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_environment(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Environment(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_environment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_deleteKey(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_deleteKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().DeleteKey(rctx, obj, fc.Args["key"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamDeleteKey)
	fc.Result = res
	return ec.marshalNTeamDeleteKey2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamDeleteKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_deleteKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_TeamDeleteKey_key(ctx, field)
			case "createdAt":
				return ec.fieldContext_TeamDeleteKey_createdAt(ctx, field)
			case "expires":
				return ec.fieldContext_TeamDeleteKey_expires(ctx, field)
			case "createdBy":
				return ec.fieldContext_TeamDeleteKey_createdBy(ctx, field)
			case "team":
				return ec.fieldContext_TeamDeleteKey_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamDeleteKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_deleteKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_applications(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_applications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Applications(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*application.ApplicationOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*application.Application])
	fc.Result = res
	return ec.marshalNApplicationConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_applications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ApplicationConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ApplicationConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ApplicationConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_applications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_auditEntries(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_auditEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().AuditEntries(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[auditv1.AuditEntry])
	fc.Result = res
	return ec.marshalNAuditEntryConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_auditEntries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_AuditEntryConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_AuditEntryConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_AuditEntryConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuditEntryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_auditEntries_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_cost(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.TeamCost)
	fc.Result = res
	return ec.marshalNTeamCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "daily":
				return ec.fieldContext_TeamCost_daily(ctx, field)
			case "monthlySummary":
				return ec.fieldContext_TeamCost_monthlySummary(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_jobs(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_jobs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Jobs(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*job.JobOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*job.Job])
	fc.Result = res
	return ec.marshalNJobConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_jobs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_JobConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_JobConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_JobConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_jobs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_bigQueryDatasets(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_bigQueryDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().BigQueryDatasets(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*bigquery.BigQueryDatasetOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bigquery.BigQueryDataset])
	fc.Result = res
	return ec.marshalNBigQueryDatasetConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_bigQueryDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BigQueryDatasetConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BigQueryDatasetConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BigQueryDatasetConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_bigQueryDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_redisInstances(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_redisInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().RedisInstances(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*redis.RedisInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*redis.RedisInstance])
	fc.Result = res
	return ec.marshalNRedisInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_redisInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_RedisInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_RedisInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RedisInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_redisInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_openSearchInstances(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_openSearchInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().OpenSearchInstances(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*opensearch.OpenSearchOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*opensearch.OpenSearch])
	fc.Result = res
	return ec.marshalNOpenSearchConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_openSearchInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_OpenSearchConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_OpenSearchConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_OpenSearchConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_openSearchInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_buckets(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_buckets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Buckets(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*bucket.BucketOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bucket.Bucket])
	fc.Result = res
	return ec.marshalNBucketConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_buckets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BucketConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BucketConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BucketConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_buckets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_kafkaTopics(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_kafkaTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().KafkaTopics(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*kafkatopic.KafkaTopicOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*kafkatopic.KafkaTopic])
	fc.Result = res
	return ec.marshalNKafkaTopicConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_kafkaTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_KafkaTopicConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_KafkaTopicConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_KafkaTopicConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_kafkaTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_sqlInstances(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_sqlInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().SQLInstances(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*sqlinstance.SQLInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*sqlinstance.SQLInstance])
	fc.Result = res
	return ec.marshalNSqlInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_sqlInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SqlInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SqlInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SqlInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_sqlInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_repositories(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Repositories(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["filter"].(*repository.TeamRepositoryFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*repository.Repository])
	fc.Result = res
	return ec.marshalNRepositoryConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_RepositoryConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_RepositoryConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RepositoryConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_repositories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_workloadUtilization(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_workloadUtilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().WorkloadUtilization(rctx, obj, fc.Args["resourceType"].(utilization.UtilizationResourceType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*utilization.WorkloadUtilizationData)
	fc.Result = res
	return ec.marshalNWorkloadUtilizationData2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐWorkloadUtilizationData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_workloadUtilization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_WorkloadUtilizationData_workload(ctx, field)
			case "requested":
				return ec.fieldContext_WorkloadUtilizationData_requested(ctx, field)
			case "used":
				return ec.fieldContext_WorkloadUtilizationData_used(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadUtilizationData", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_workloadUtilization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_vulnerabilitySummary(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().VulnerabilitySummary(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*vulnerability.TeamVulnerabilitySummary)
	fc.Result = res
	return ec.marshalNTeamVulnerabilitySummary2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐTeamVulnerabilitySummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_vulnerabilitySummary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "riskScore":
				return ec.fieldContext_TeamVulnerabilitySummary_riskScore(ctx, field)
			case "critical":
				return ec.fieldContext_TeamVulnerabilitySummary_critical(ctx, field)
			case "high":
				return ec.fieldContext_TeamVulnerabilitySummary_high(ctx, field)
			case "medium":
				return ec.fieldContext_TeamVulnerabilitySummary_medium(ctx, field)
			case "low":
				return ec.fieldContext_TeamVulnerabilitySummary_low(ctx, field)
			case "unassigned":
				return ec.fieldContext_TeamVulnerabilitySummary_unassigned(ctx, field)
			case "bomCount":
				return ec.fieldContext_TeamVulnerabilitySummary_bomCount(ctx, field)
			case "coverage":
				return ec.fieldContext_TeamVulnerabilitySummary_coverage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamVulnerabilitySummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_workloads(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_workloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Workloads(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*workload.WorkloadOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[workload.Workload])
	fc.Result = res
	return ec.marshalNWorkloadConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_workloads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_WorkloadConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_WorkloadConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_WorkloadConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_workloads_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyAuditEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyAuditEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyAuditEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyAuditEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyAuditEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyAuditEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyAuditEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyAuditEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyAuditEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyAuditEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyAuditEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyAuditEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyAuditEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyAuditEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(auditv1.AuditResourceType)
	fc.Result = res
	return ec.marshalNAuditResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyAuditEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuditResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyAuditEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyAuditEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyAuditEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyAuditEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyAuditEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyAuditEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyAuditEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyAuditEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyAuditEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.Team]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.Team]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.Team]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*team.Team])
	fc.Result = res
	return ec.marshalNTeamEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_TeamEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_TeamEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCost_daily(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCost_daily(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamCost().Daily(rctx, obj, fc.Args["from"].(scalar.Date), fc.Args["to"].(scalar.Date))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.TeamCostPeriod)
	fc.Result = res
	return ec.marshalNTeamCostPeriod2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCostPeriod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCost_daily(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_TeamCostPeriod_sum(ctx, field)
			case "series":
				return ec.fieldContext_TeamCostPeriod_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamCostPeriod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamCost_daily_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamCost_monthlySummary(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCost_monthlySummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamCost().MonthlySummary(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.TeamCostMonthlySummary)
	fc.Result = res
	return ec.marshalNTeamCostMonthlySummary2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCostMonthlySummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCost_monthlySummary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_TeamCostMonthlySummary_sum(ctx, field)
			case "series":
				return ec.fieldContext_TeamCostMonthlySummary_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamCostMonthlySummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostMonthlySample_date(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostMonthlySample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostMonthlySample_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(scalar.Date)
	fc.Result = res
	return ec.marshalNDate2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋscalarᚐDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostMonthlySample_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostMonthlySample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostMonthlySample_cost(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostMonthlySample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostMonthlySample_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostMonthlySample_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostMonthlySample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostMonthlySummary_sum(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostMonthlySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostMonthlySummary_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostMonthlySummary_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostMonthlySummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostMonthlySummary_series(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostMonthlySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostMonthlySummary_series(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Series, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*cost.TeamCostMonthlySample)
	fc.Result = res
	return ec.marshalNTeamCostMonthlySample2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCostMonthlySampleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostMonthlySummary_series(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostMonthlySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "date":
				return ec.fieldContext_TeamCostMonthlySample_date(ctx, field)
			case "cost":
				return ec.fieldContext_TeamCostMonthlySample_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamCostMonthlySample", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostPeriod_sum(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostPeriod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostPeriod_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostPeriod_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostPeriod",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostPeriod_series(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostPeriod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostPeriod_series(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Series, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*cost.ServiceCostSeries)
	fc.Result = res
	return ec.marshalNServiceCostSeries2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐServiceCostSeriesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostPeriod_series(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostPeriod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "date":
				return ec.fieldContext_ServiceCostSeries_date(ctx, field)
			case "sum":
				return ec.fieldContext_ServiceCostSeries_sum(ctx, field)
			case "services":
				return ec.fieldContext_ServiceCostSeries_services(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceCostSeries", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyAuditEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyAuditEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyAuditEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyAuditEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyAuditEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyAuditEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyAuditEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyAuditEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyAuditEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyAuditEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyAuditEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyAuditEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyAuditEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyAuditEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(auditv1.AuditResourceType)
	fc.Result = res
	return ec.marshalNAuditResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyAuditEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuditResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyAuditEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyAuditEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyAuditEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyAuditEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyAuditEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyAuditEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyAuditEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyAuditEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyAuditEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedAuditEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedAuditEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedAuditEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedAuditEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedAuditEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedAuditEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedAuditEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedAuditEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedAuditEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedAuditEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedAuditEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedAuditEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedAuditEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedAuditEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedAuditEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(auditv1.AuditResourceType)
	fc.Result = res
	return ec.marshalNAuditResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedAuditEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuditResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedAuditEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedAuditEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedAuditEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedAuditEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedAuditEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedAuditEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedAuditEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedAuditEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedAuditEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeleteKey_key(ctx context.Context, field graphql.CollectedField, obj *team.TeamDeleteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeleteKey_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeleteKey_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeleteKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeleteKey_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamDeleteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeleteKey_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeleteKey_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeleteKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeleteKey_expires(ctx context.Context, field graphql.CollectedField, obj *team.TeamDeleteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeleteKey_expires(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expires(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeleteKey_expires(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeleteKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeleteKey_createdBy(ctx context.Context, field graphql.CollectedField, obj *team.TeamDeleteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeleteKey_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamDeleteKey().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeleteKey_createdBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeleteKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeleteKey_team(ctx context.Context, field graphql.CollectedField, obj *team.TeamDeleteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeleteKey_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamDeleteKey().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeleteKey_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeleteKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*team.Team]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*team.Team]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_name(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_gcpProjectID(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCPProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_gcpProjectID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_slackAlertsChannel(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackAlertsChannel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_slackAlertsChannel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_team(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_application(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Application(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.Application)
	fc.Result = res
	return ec.marshalNApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_application(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Application_redisInstances(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_application_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_job(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_job(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Job(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.Job)
	fc.Result = res
	return ec.marshalNJob2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_job(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "name":
				return ec.fieldContext_Job_name(ctx, field)
			case "team":
				return ec.fieldContext_Job_team(ctx, field)
			case "environment":
				return ec.fieldContext_Job_environment(ctx, field)
			case "image":
				return ec.fieldContext_Job_image(ctx, field)
			case "resources":
				return ec.fieldContext_Job_resources(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Job_authIntegrations(ctx, field)
			case "schedule":
				return ec.fieldContext_Job_schedule(ctx, field)
			case "runs":
				return ec.fieldContext_Job_runs(ctx, field)
			case "manifest":
				return ec.fieldContext_Job_manifest(ctx, field)
			case "cost":
				return ec.fieldContext_Job_cost(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Job_networkPolicy(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Job_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Job_redisInstances(ctx, field)
			case "openSearch":
				return ec.fieldContext_Job_openSearch(ctx, field)
			case "buckets":
				return ec.fieldContext_Job_buckets(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Job_kafkaTopicAcls(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Job_sqlInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_job_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_bigQueryDataset(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().BigQueryDataset(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bigquery.BigQueryDataset)
	fc.Result = res
	return ec.marshalNBigQueryDataset2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_bigQueryDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BigQueryDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_BigQueryDataset_name(ctx, field)
			case "team":
				return ec.fieldContext_BigQueryDataset_team(ctx, field)
			case "environment":
				return ec.fieldContext_BigQueryDataset_environment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_BigQueryDataset_cascadingDelete(ctx, field)
			case "description":
				return ec.fieldContext_BigQueryDataset_description(ctx, field)
			case "access":
				return ec.fieldContext_BigQueryDataset_access(ctx, field)
			case "status":
				return ec.fieldContext_BigQueryDataset_status(ctx, field)
			case "workload":
				return ec.fieldContext_BigQueryDataset_workload(ctx, field)
			case "cost":
				return ec.fieldContext_BigQueryDataset_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_bigQueryDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_bucket(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_bucket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Bucket(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bucket.Bucket)
	fc.Result = res
	return ec.marshalNBucket2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_bucket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bucket_id(ctx, field)
			case "name":
				return ec.fieldContext_Bucket_name(ctx, field)
			case "team":
				return ec.fieldContext_Bucket_team(ctx, field)
			case "environment":
				return ec.fieldContext_Bucket_environment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_Bucket_cascadingDelete(ctx, field)
			case "publicAccessPrevention":
				return ec.fieldContext_Bucket_publicAccessPrevention(ctx, field)
			case "uniformBucketLevelAccess":
				return ec.fieldContext_Bucket_uniformBucketLevelAccess(ctx, field)
			case "workload":
				return ec.fieldContext_Bucket_workload(ctx, field)
			case "status":
				return ec.fieldContext_Bucket_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bucket", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_bucket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_kafkaTopic(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().KafkaTopic(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.KafkaTopic)
	fc.Result = res
	return ec.marshalNKafkaTopic2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_kafkaTopic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KafkaTopic_id(ctx, field)
			case "name":
				return ec.fieldContext_KafkaTopic_name(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopic_team(ctx, field)
			case "environment":
				return ec.fieldContext_KafkaTopic_environment(ctx, field)
			case "acl":
				return ec.fieldContext_KafkaTopic_acl(ctx, field)
			case "configuration":
				return ec.fieldContext_KafkaTopic_configuration(ctx, field)
			case "pool":
				return ec.fieldContext_KafkaTopic_pool(ctx, field)
			case "status":
				return ec.fieldContext_KafkaTopic_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_kafkaTopic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_openSearchInstance(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().OpenSearchInstance(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearch)
	fc.Result = res
	return ec.marshalNOpenSearch2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_openSearchInstance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "status":
				return ec.fieldContext_OpenSearch_status(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_openSearchInstance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_redisInstance(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().RedisInstance(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*redis.RedisInstance)
	fc.Result = res
	return ec.marshalNRedisInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_redisInstance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RedisInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_RedisInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_RedisInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_RedisInstance_environment(ctx, field)
			case "access":
				return ec.fieldContext_RedisInstance_access(ctx, field)
			case "workload":
				return ec.fieldContext_RedisInstance_workload(ctx, field)
			case "status":
				return ec.fieldContext_RedisInstance_status(ctx, field)
			case "cost":
				return ec.fieldContext_RedisInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_redisInstance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_sqlInstance(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().SQLInstance(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstance)
	fc.Result = res
	return ec.marshalNSqlInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_sqlInstance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SqlInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_SqlInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_SqlInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_SqlInstance_environment(ctx, field)
			case "workload":
				return ec.fieldContext_SqlInstance_workload(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_SqlInstance_cascadingDelete(ctx, field)
			case "connectionName":
				return ec.fieldContext_SqlInstance_connectionName(ctx, field)
			case "diskAutoresize":
				return ec.fieldContext_SqlInstance_diskAutoresize(ctx, field)
			case "diskAutoresizeLimit":
				return ec.fieldContext_SqlInstance_diskAutoresizeLimit(ctx, field)
			case "highAvailability":
				return ec.fieldContext_SqlInstance_highAvailability(ctx, field)
			case "healthy":
				return ec.fieldContext_SqlInstance_healthy(ctx, field)
			case "maintenanceVersion":
				return ec.fieldContext_SqlInstance_maintenanceVersion(ctx, field)
			case "maintenanceWindow":
				return ec.fieldContext_SqlInstance_maintenanceWindow(ctx, field)
			case "backupConfiguration":
				return ec.fieldContext_SqlInstance_backupConfiguration(ctx, field)
			case "projectID":
				return ec.fieldContext_SqlInstance_projectID(ctx, field)
			case "tier":
				return ec.fieldContext_SqlInstance_tier(ctx, field)
			case "version":
				return ec.fieldContext_SqlInstance_version(ctx, field)
			case "status":
				return ec.fieldContext_SqlInstance_status(ctx, field)
			case "database":
				return ec.fieldContext_SqlInstance_database(ctx, field)
			case "flags":
				return ec.fieldContext_SqlInstance_flags(ctx, field)
			case "users":
				return ec.fieldContext_SqlInstance_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_sqlInstance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(auditv1.AuditResourceType)
	fc.Result = res
	return ec.marshalNAuditResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuditResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntry_data(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironmentUpdatedAuditEntryData)
	fc.Result = res
	return ec.marshalNTeamEnvironmentUpdatedAuditEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironmentUpdatedAuditEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "environmentName":
				return ec.fieldContext_TeamEnvironmentUpdatedAuditEntryData_environmentName(ctx, field)
			case "updatedFields":
				return ec.fieldContext_TeamEnvironmentUpdatedAuditEntryData_updatedFields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironmentUpdatedAuditEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntryData_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntryData_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntryData_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntryData_updatedFields(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntryData_updatedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*team.TeamEnvironmentUpdatedAuditEntryDataUpdatedField)
	fc.Result = res
	return ec.marshalNTeamEnvironmentUpdatedAuditEntryDataUpdatedField2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironmentUpdatedAuditEntryDataUpdatedFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntryData_updatedFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "field":
				return ec.fieldContext_TeamEnvironmentUpdatedAuditEntryDataUpdatedField_field(ctx, field)
			case "oldValue":
				return ec.fieldContext_TeamEnvironmentUpdatedAuditEntryDataUpdatedField_oldValue(ctx, field)
			case "newValue":
				return ec.fieldContext_TeamEnvironmentUpdatedAuditEntryDataUpdatedField_newValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironmentUpdatedAuditEntryDataUpdatedField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntryDataUpdatedField_field(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntryDataUpdatedField_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntryDataUpdatedField_field(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntryDataUpdatedField_oldValue(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntryDataUpdatedField_oldValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntryDataUpdatedField_oldValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntryDataUpdatedField_newValue(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedAuditEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedAuditEntryDataUpdatedField_newValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedAuditEntryDataUpdatedField_newValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedAuditEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_team(ctx context.Context, field graphql.CollectedField, obj *team.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamMember().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_user(ctx context.Context, field graphql.CollectedField, obj *team.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamMember().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_role(ctx context.Context, field graphql.CollectedField, obj *team.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(team.TeamMemberRole)
	fc.Result = res
	return ec.marshalNTeamMemberRole2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TeamMemberRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(auditv1.AuditResourceType)
	fc.Result = res
	return ec.marshalNAuditResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuditResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntry_data(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamMemberAddedAuditEntryData)
	fc.Result = res
	return ec.marshalNTeamMemberAddedAuditEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberAddedAuditEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "role":
				return ec.fieldContext_TeamMemberAddedAuditEntryData_role(ctx, field)
			case "userID":
				return ec.fieldContext_TeamMemberAddedAuditEntryData_userID(ctx, field)
			case "userEmail":
				return ec.fieldContext_TeamMemberAddedAuditEntryData_userEmail(ctx, field)
			case "user":
				return ec.fieldContext_TeamMemberAddedAuditEntryData_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberAddedAuditEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntryData_role(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntryData_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(team.TeamMemberRole)
	fc.Result = res
	return ec.marshalNTeamMemberRole2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntryData_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TeamMemberRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntryData_userID(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntryData_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntryData_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntryData",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntryData_userEmail(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntryData_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntryData_userEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedAuditEntryData_user(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedAuditEntryData_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamMemberAddedAuditEntryData().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedAuditEntryData_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedAuditEntryData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.TeamMember]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.TeamMember]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*team.TeamMember)
	fc.Result = res
	return ec.marshalNTeamMember2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamMember_team(ctx, field)
			case "user":
				return ec.fieldContext_TeamMember_user(ctx, field)
			case "role":
				return ec.fieldContext_TeamMember_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.TeamMember]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*team.TeamMember])
	fc.Result = res
	return ec.marshalNTeamMemberEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_TeamMemberEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_TeamMemberEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*team.TeamMember]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*team.TeamMember]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamMember)
	fc.Result = res
	return ec.marshalNTeamMember2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamMember_team(ctx, field)
			case "user":
				return ec.fieldContext_TeamMember_user(ctx, field)
			case "role":
				return ec.fieldContext_TeamMember_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(auditv1.AuditResourceType)
	fc.Result = res
	return ec.marshalNAuditResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuditResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntry_data(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamMemberRemovedAuditEntryData)
	fc.Result = res
	return ec.marshalNTeamMemberRemovedAuditEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberRemovedAuditEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userID":
				return ec.fieldContext_TeamMemberRemovedAuditEntryData_userID(ctx, field)
			case "userEmail":
				return ec.fieldContext_TeamMemberRemovedAuditEntryData_userEmail(ctx, field)
			case "user":
				return ec.fieldContext_TeamMemberRemovedAuditEntryData_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberRemovedAuditEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntryData_userID(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntryData_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntryData_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntryData",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntryData_userEmail(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntryData_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntryData_userEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedAuditEntryData_user(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedAuditEntryData_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamMemberRemovedAuditEntryData().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedAuditEntryData_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedAuditEntryData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(auditv1.AuditResourceType)
	fc.Result = res
	return ec.marshalNAuditResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuditResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntry_data(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamMemberSetRoleAuditEntryData)
	fc.Result = res
	return ec.marshalNTeamMemberSetRoleAuditEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberSetRoleAuditEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "role":
				return ec.fieldContext_TeamMemberSetRoleAuditEntryData_role(ctx, field)
			case "userID":
				return ec.fieldContext_TeamMemberSetRoleAuditEntryData_userID(ctx, field)
			case "userEmail":
				return ec.fieldContext_TeamMemberSetRoleAuditEntryData_userEmail(ctx, field)
			case "user":
				return ec.fieldContext_TeamMemberSetRoleAuditEntryData_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberSetRoleAuditEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntryData_role(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntryData_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(team.TeamMemberRole)
	fc.Result = res
	return ec.marshalNTeamMemberRole2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntryData_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TeamMemberRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntryData_userID(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntryData_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntryData_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntryData",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntryData_userEmail(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntryData_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntryData_userEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleAuditEntryData_user(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleAuditEntryData_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamMemberSetRoleAuditEntryData().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleAuditEntryData_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleAuditEntryData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(auditv1.AuditResourceType)
	fc.Result = res
	return ec.marshalNAuditResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuditResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntry_data(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamUpdatedAuditEntryData)
	fc.Result = res
	return ec.marshalOTeamUpdatedAuditEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamUpdatedAuditEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updatedFields":
				return ec.fieldContext_TeamUpdatedAuditEntryData_updatedFields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamUpdatedAuditEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntryData_updatedFields(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntryData_updatedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*team.TeamUpdatedAuditEntryDataUpdatedField)
	fc.Result = res
	return ec.marshalNTeamUpdatedAuditEntryDataUpdatedField2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamUpdatedAuditEntryDataUpdatedFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntryData_updatedFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "field":
				return ec.fieldContext_TeamUpdatedAuditEntryDataUpdatedField_field(ctx, field)
			case "oldValue":
				return ec.fieldContext_TeamUpdatedAuditEntryDataUpdatedField_oldValue(ctx, field)
			case "newValue":
				return ec.fieldContext_TeamUpdatedAuditEntryDataUpdatedField_newValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamUpdatedAuditEntryDataUpdatedField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntryDataUpdatedField_field(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntryDataUpdatedField_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntryDataUpdatedField_field(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntryDataUpdatedField_oldValue(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntryDataUpdatedField_oldValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntryDataUpdatedField_oldValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedAuditEntryDataUpdatedField_newValue(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedAuditEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedAuditEntryDataUpdatedField_newValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedAuditEntryDataUpdatedField_newValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedAuditEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUtilizationData_team(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUtilizationData_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamUtilizationData().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUtilizationData_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUtilizationData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUtilizationData_requested(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUtilizationData_requested(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requested, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUtilizationData_requested(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUtilizationData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUtilizationData_used(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUtilizationData_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUtilizationData_used(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUtilizationData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUtilizationData_environment(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUtilizationData_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamUtilizationData().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUtilizationData_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUtilizationData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUtilizationEnvironmentDataPoint_value(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamUtilizationEnvironmentDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUtilizationEnvironmentDataPoint_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUtilizationEnvironmentDataPoint_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUtilizationEnvironmentDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUtilizationEnvironmentDataPoint_environment(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamUtilizationEnvironmentDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUtilizationEnvironmentDataPoint_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamUtilizationEnvironmentDataPoint().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUtilizationEnvironmentDataPoint_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUtilizationEnvironmentDataPoint",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_riskScore(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_riskScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RiskScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_riskScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_critical(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_critical(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Critical, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_critical(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_high(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_high(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.High, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_high(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_medium(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_medium(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Medium, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_medium(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_low(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_low(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Low, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_low(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_unassigned(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_unassigned(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unassigned, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_unassigned(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_bomCount(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_bomCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BomCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_bomCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_coverage(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_coverage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Coverage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_coverage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenXAuthIntegration_name(ctx context.Context, field graphql.CollectedField, obj *workload.TokenXAuthIntegration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenXAuthIntegration_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenXAuthIntegration_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenXAuthIntegration",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamEnvironmentPayload_environment(ctx context.Context, field graphql.CollectedField, obj *team.UpdateTeamEnvironmentPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamEnvironmentPayload_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalOTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamEnvironmentPayload_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamEnvironmentPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamPayload_team(ctx context.Context, field graphql.CollectedField, obj *team.UpdateTeamPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamPayload_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Team, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "azureGroupID":
				return ec.fieldContext_Team_azureGroupID(ctx, field)
			case "gitHubTeamSlug":
				return ec.fieldContext_Team_gitHubTeamSlug(ctx, field)
			case "googleGroupEmail":
				return ec.fieldContext_Team_googleGroupEmail(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_Team_googleArtifactRegistry(ctx, field)
			case "cdnBucket":
				return ec.fieldContext_Team_cdnBucket(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "auditEntries":
				return ec.fieldContext_Team_auditEntries(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_externalID(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_externalID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_externalID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_teams(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_teams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Teams(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*team.UserTeamOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*team.TeamMember])
	fc.Result = res
	return ec.marshalNTeamMemberConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_teams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_TeamMemberConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_TeamMemberConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_TeamMemberConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_teams_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*user.User]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*user.User]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*user.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*user.User]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*user.User])
	fc.Result = res
	return ec.marshalNUserEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_UserEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_UserEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*user.User]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*user.User]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UtilizationDataPoint_timestamp(ctx context.Context, field graphql.CollectedField, obj *utilization.UtilizationDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UtilizationDataPoint_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UtilizationDataPoint_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UtilizationDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UtilizationDataPoint_value(ctx context.Context, field graphql.CollectedField, obj *utilization.UtilizationDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UtilizationDataPoint_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UtilizationDataPoint_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UtilizationDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[workload.Workload]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[workload.Workload]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[workload.Workload]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[workload.Workload])
	fc.Result = res
	return ec.marshalNWorkloadEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_WorkloadEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_WorkloadEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCost_daily(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCost_daily(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadCost().Daily(rctx, obj, fc.Args["from"].(scalar.Date), fc.Args["to"].(scalar.Date))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.WorkloadCostPeriod)
	fc.Result = res
	return ec.marshalNWorkloadCostPeriod2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐWorkloadCostPeriod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCost_daily(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_WorkloadCostPeriod_sum(ctx, field)
			case "series":
				return ec.fieldContext_WorkloadCostPeriod_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadCostPeriod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkloadCost_daily_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCost_monthly(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCost_monthly(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadCost().Monthly(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.WorkloadCostPeriod)
	fc.Result = res
	return ec.marshalNWorkloadCostPeriod2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐWorkloadCostPeriod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCost_monthly(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_WorkloadCostPeriod_sum(ctx, field)
			case "series":
				return ec.fieldContext_WorkloadCostPeriod_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadCostPeriod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCostPeriod_sum(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCostPeriod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCostPeriod_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCostPeriod_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCostPeriod",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCostPeriod_series(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCostPeriod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCostPeriod_series(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Series, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*cost.ServiceCostSeries)
	fc.Result = res
	return ec.marshalNServiceCostSeries2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐServiceCostSeriesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCostPeriod_series(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCostPeriod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "date":
				return ec.fieldContext_ServiceCostSeries_date(ctx, field)
			case "sum":
				return ec.fieldContext_ServiceCostSeries_sum(ctx, field)
			case "services":
				return ec.fieldContext_ServiceCostSeries_services(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceCostSeries", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[workload.Workload]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[workload.Workload]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadResourceQuantity_cpu(ctx context.Context, field graphql.CollectedField, obj *workload.WorkloadResourceQuantity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadResourceQuantity_cpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadResourceQuantity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadResourceQuantity_memory(ctx context.Context, field graphql.CollectedField, obj *workload.WorkloadResourceQuantity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Memory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadResourceQuantity_memory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadResourceQuantity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilization_current(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilization_current(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadUtilization().Current(rctx, obj, fc.Args["resourceType"].(utilization.UtilizationResourceType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilization_current(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilization",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkloadUtilization_current_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilization_requested(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilization_requested(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadUtilization().Requested(rctx, obj, fc.Args["resourceType"].(utilization.UtilizationResourceType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilization_requested(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilization",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkloadUtilization_requested_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilization_series(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilization_series(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadUtilization().Series(rctx, obj, fc.Args["input"].(utilization.WorkloadUtilizationSeriesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*utilization.UtilizationDataPoint)
	fc.Result = res
	return ec.marshalNUtilizationDataPoint2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐUtilizationDataPointᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilization_series(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilization",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "timestamp":
				return ec.fieldContext_UtilizationDataPoint_timestamp(ctx, field)
			case "value":
				return ec.fieldContext_UtilizationDataPoint_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UtilizationDataPoint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkloadUtilization_series_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilizationData_workload(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilizationData_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadUtilizationData().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilizationData_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilizationData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilizationData_requested(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilizationData_requested(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requested, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilizationData_requested(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilizationData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilizationData_used(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilizationData_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilizationData_used(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilizationData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddRepositoryToTeamInput(ctx context.Context, obj interface{}) (repository.AddRepositoryToTeamInput, error) {
	var it repository.AddRepositoryToTeamInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "repositoryName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "repositoryName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repositoryName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepositoryName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddTeamMemberInput(ctx context.Context, obj interface{}) (team.AddTeamMemberInput, error) {
	var it team.AddTeamMemberInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "userEmail", "role"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "userEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userEmail"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserEmail = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalNTeamMemberRole2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationOrder(ctx context.Context, obj interface{}) (application.ApplicationOrder, error) {
	var it application.ApplicationOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNApplicationOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBigQueryDatasetAccessOrder(ctx context.Context, obj interface{}) (bigquery.BigQueryDatasetAccessOrder, error) {
	var it bigquery.BigQueryDatasetAccessOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNBigQueryDatasetAccessOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetAccessOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBigQueryDatasetOrder(ctx context.Context, obj interface{}) (bigquery.BigQueryDatasetOrder, error) {
	var it bigquery.BigQueryDatasetOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNBigQueryDatasetOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBucketOrder(ctx context.Context, obj interface{}) (bucket.BucketOrder, error) {
	var it bucket.BucketOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNBucketOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucketOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputConfirmTeamDeletionInput(ctx context.Context, obj interface{}) (team.ConfirmTeamDeletionInput, error) {
	var it team.ConfirmTeamDeletionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"slug", "key"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "slug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slug = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTeamInput(ctx context.Context, obj interface{}) (team.CreateTeamInput, error) {
	var it team.CreateTeamInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"slug", "purpose", "slackChannel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "slug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slug = data
		case "purpose":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("purpose"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Purpose = data
		case "slackChannel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackChannel"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackChannel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteApplicationInput(ctx context.Context, obj interface{}) (application.DeleteApplicationInput, error) {
	var it application.DeleteApplicationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "teamSlug", "environmentName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "environmentName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environmentName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnvironmentName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteJobInput(ctx context.Context, obj interface{}) (job.DeleteJobInput, error) {
	var it job.DeleteJobInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "teamSlug", "environmentName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "environmentName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environmentName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnvironmentName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageVulnerabilityOrder(ctx context.Context, obj interface{}) (vulnerability.ImageVulnerabilityOrder, error) {
	var it vulnerability.ImageVulnerabilityOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNImageVulnerabilityOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilityOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJobOrder(ctx context.Context, obj interface{}) (job.JobOrder, error) {
	var it job.JobOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNJobOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKafkaTopicAclFilter(ctx context.Context, obj interface{}) (kafkatopic.KafkaTopicACLFilter, error) {
	var it kafkatopic.KafkaTopicACLFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"team", "workload"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			data, err := ec.unmarshalOSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Team = data
		case "workload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workload"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Workload = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKafkaTopicAclOrder(ctx context.Context, obj interface{}) (kafkatopic.KafkaTopicACLOrder, error) {
	var it kafkatopic.KafkaTopicACLOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNKafkaTopicAclOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACLOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKafkaTopicOrder(ctx context.Context, obj interface{}) (kafkatopic.KafkaTopicOrder, error) {
	var it kafkatopic.KafkaTopicOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNKafkaTopicOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOpenSearchAccessOrder(ctx context.Context, obj interface{}) (opensearch.OpenSearchAccessOrder, error) {
	var it opensearch.OpenSearchAccessOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNOpenSearchAccessOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchAccessOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOpenSearchOrder(ctx context.Context, obj interface{}) (opensearch.OpenSearchOrder, error) {
	var it opensearch.OpenSearchOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNOpenSearchOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputReconcilerConfigInput(ctx context.Context, obj interface{}) (reconciler.ReconcilerConfigInput, error) {
	var it reconciler.ReconcilerConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRedisInstanceAccessOrder(ctx context.Context, obj interface{}) (redis.RedisInstanceAccessOrder, error) {
	var it redis.RedisInstanceAccessOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNRedisInstanceAccessOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceAccessOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRedisInstanceOrder(ctx context.Context, obj interface{}) (redis.RedisInstanceOrder, error) {
	var it redis.RedisInstanceOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNRedisInstanceOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveRepositoryFromTeamInput(ctx context.Context, obj interface{}) (repository.RemoveRepositoryFromTeamInput, error) {
	var it repository.RemoveRepositoryFromTeamInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "repositoryName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "repositoryName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repositoryName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepositoryName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveTeamMemberInput(ctx context.Context, obj interface{}) (team.RemoveTeamMemberInput, error) {
	var it team.RemoveTeamMemberInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "userEmail"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "userEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userEmail"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserEmail = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRequestTeamDeletionInput(ctx context.Context, obj interface{}) (team.RequestTeamDeletionInput, error) {
	var it team.RequestTeamDeletionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"slug"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "slug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slug = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRestartApplicationInput(ctx context.Context, obj interface{}) (application.RestartApplicationInput, error) {
	var it application.RestartApplicationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "teamSlug", "environmentName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "environmentName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environmentName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnvironmentName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchFilter(ctx context.Context, obj interface{}) (searchv1.SearchFilter, error) {
	var it searchv1.SearchFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"query", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "query":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Query = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOSearchType2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋsearchv1ᚐSearchType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetTeamMemberRoleInput(ctx context.Context, obj interface{}) (team.SetTeamMemberRoleInput, error) {
	var it team.SetTeamMemberRoleInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "userEmail", "role"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "userEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userEmail"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserEmail = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalNTeamMemberRole2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSqlInstanceOrder(ctx context.Context, obj interface{}) (sqlinstance.SQLInstanceOrder, error) {
	var it sqlinstance.SQLInstanceOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNSqlInstanceOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSqlInstanceUserOrder(ctx context.Context, obj interface{}) (sqlinstance.SQLInstanceUserOrder, error) {
	var it sqlinstance.SQLInstanceUserOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNSqlInstanceUserOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceUserOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSynchronizeTeamInput(ctx context.Context, obj interface{}) (team.SynchronizeTeamInput, error) {
	var it team.SynchronizeTeamInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"slug"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "slug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slug = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamMemberOrder(ctx context.Context, obj interface{}) (team.TeamMemberOrder, error) {
	var it team.TeamMemberOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNTeamMemberOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamOrder(ctx context.Context, obj interface{}) (team.TeamOrder, error) {
	var it team.TeamOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNTeamOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamRepositoryFilter(ctx context.Context, obj interface{}) (repository.TeamRepositoryFilter, error) {
	var it repository.TeamRepositoryFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamEnvironmentInput(ctx context.Context, obj interface{}) (team.UpdateTeamEnvironmentInput, error) {
	var it team.UpdateTeamEnvironmentInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"slug", "environmentName", "slackAlertsChannel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "slug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slug = data
		case "environmentName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environmentName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnvironmentName = data
		case "slackAlertsChannel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackAlertsChannel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackAlertsChannel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamInput(ctx context.Context, obj interface{}) (team.UpdateTeamInput, error) {
	var it team.UpdateTeamInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"slug", "purpose", "slackChannel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "slug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slug = data
		case "purpose":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("purpose"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Purpose = data
		case "slackChannel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackChannel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackChannel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserOrder(ctx context.Context, obj interface{}) (user.UserOrder, error) {
	var it user.UserOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNUserOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUserOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserTeamOrder(ctx context.Context, obj interface{}) (team.UserTeamOrder, error) {
	var it team.UserTeamOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNUserTeamOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUserTeamOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkloadOrder(ctx context.Context, obj interface{}) (workload.WorkloadOrder, error) {
	var it workload.WorkloadOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNWorkloadOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkloadUtilizationSeriesInput(ctx context.Context, obj interface{}) (utilization.WorkloadUtilizationSeriesInput, error) {
	var it utilization.WorkloadUtilizationSeriesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"start", "end", "resourceType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "start":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Start = data
		case "end":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.End = data
		case "resourceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
			data, err := ec.unmarshalNUtilizationResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐUtilizationResourceType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _ApplicationAuthIntegrations(ctx context.Context, sel ast.SelectionSet, obj workload.ApplicationAuthIntegrations) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case workload.EntraIDAuthIntegration:
		return ec._EntraIDAuthIntegration(ctx, sel, &obj)
	case *workload.EntraIDAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._EntraIDAuthIntegration(ctx, sel, obj)
	case workload.IDPortenAuthIntegration:
		return ec._IDPortenAuthIntegration(ctx, sel, &obj)
	case *workload.IDPortenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._IDPortenAuthIntegration(ctx, sel, obj)
	case workload.MaskinportenAuthIntegration:
		return ec._MaskinportenAuthIntegration(ctx, sel, &obj)
	case *workload.MaskinportenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._MaskinportenAuthIntegration(ctx, sel, obj)
	case workload.TokenXAuthIntegration:
		return ec._TokenXAuthIntegration(ctx, sel, &obj)
	case *workload.TokenXAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._TokenXAuthIntegration(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AuditEntry(ctx context.Context, sel ast.SelectionSet, obj auditv1.AuditEntry) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case team.TeamCreatedAuditEntry:
		return ec._TeamCreatedAuditEntry(ctx, sel, &obj)
	case *team.TeamCreatedAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamCreatedAuditEntry(ctx, sel, obj)
	case team.TeamUpdatedAuditEntry:
		return ec._TeamUpdatedAuditEntry(ctx, sel, &obj)
	case *team.TeamUpdatedAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamUpdatedAuditEntry(ctx, sel, obj)
	case team.TeamCreateDeleteKeyAuditEntry:
		return ec._TeamCreateDeleteKeyAuditEntry(ctx, sel, &obj)
	case *team.TeamCreateDeleteKeyAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamCreateDeleteKeyAuditEntry(ctx, sel, obj)
	case team.TeamConfirmDeleteKeyAuditEntry:
		return ec._TeamConfirmDeleteKeyAuditEntry(ctx, sel, &obj)
	case *team.TeamConfirmDeleteKeyAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamConfirmDeleteKeyAuditEntry(ctx, sel, obj)
	case team.TeamMemberAddedAuditEntry:
		return ec._TeamMemberAddedAuditEntry(ctx, sel, &obj)
	case *team.TeamMemberAddedAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberAddedAuditEntry(ctx, sel, obj)
	case team.TeamMemberRemovedAuditEntry:
		return ec._TeamMemberRemovedAuditEntry(ctx, sel, &obj)
	case *team.TeamMemberRemovedAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberRemovedAuditEntry(ctx, sel, obj)
	case team.TeamMemberSetRoleAuditEntry:
		return ec._TeamMemberSetRoleAuditEntry(ctx, sel, &obj)
	case *team.TeamMemberSetRoleAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberSetRoleAuditEntry(ctx, sel, obj)
	case team.TeamEnvironmentUpdatedAuditEntry:
		return ec._TeamEnvironmentUpdatedAuditEntry(ctx, sel, &obj)
	case *team.TeamEnvironmentUpdatedAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamEnvironmentUpdatedAuditEntry(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AuthIntegration(ctx context.Context, sel ast.SelectionSet, obj workload.AuthIntegration) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case workload.EntraIDAuthIntegration:
		return ec._EntraIDAuthIntegration(ctx, sel, &obj)
	case *workload.EntraIDAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._EntraIDAuthIntegration(ctx, sel, obj)
	case workload.IDPortenAuthIntegration:
		return ec._IDPortenAuthIntegration(ctx, sel, &obj)
	case *workload.IDPortenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._IDPortenAuthIntegration(ctx, sel, obj)
	case workload.MaskinportenAuthIntegration:
		return ec._MaskinportenAuthIntegration(ctx, sel, &obj)
	case *workload.MaskinportenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._MaskinportenAuthIntegration(ctx, sel, obj)
	case workload.TokenXAuthIntegration:
		return ec._TokenXAuthIntegration(ctx, sel, &obj)
	case *workload.TokenXAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._TokenXAuthIntegration(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AuthenticatedUser(ctx context.Context, sel ast.SelectionSet, obj user.AuthenticatedUser) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *user.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ExternalNetworkPolicyTarget(ctx context.Context, sel ast.SelectionSet, obj netpol.ExternalNetworkPolicyTarget) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case netpol.ExternalNetworkPolicyHost:
		return ec._ExternalNetworkPolicyHost(ctx, sel, &obj)
	case *netpol.ExternalNetworkPolicyHost:
		if obj == nil {
			return graphql.Null
		}
		return ec._ExternalNetworkPolicyHost(ctx, sel, obj)
	case netpol.ExternalNetworkPolicyIpv4:
		return ec._ExternalNetworkPolicyIpv4(ctx, sel, &obj)
	case *netpol.ExternalNetworkPolicyIpv4:
		if obj == nil {
			return graphql.Null
		}
		return ec._ExternalNetworkPolicyIpv4(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _JobAuthIntegrations(ctx context.Context, sel ast.SelectionSet, obj workload.JobAuthIntegrations) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case workload.EntraIDAuthIntegration:
		return ec._EntraIDAuthIntegration(ctx, sel, &obj)
	case *workload.EntraIDAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._EntraIDAuthIntegration(ctx, sel, obj)
	case workload.MaskinportenAuthIntegration:
		return ec._MaskinportenAuthIntegration(ctx, sel, &obj)
	case *workload.MaskinportenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._MaskinportenAuthIntegration(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj modelv1.Node) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case team.TeamConfirmDeleteKeyAuditEntry:
		return ec._TeamConfirmDeleteKeyAuditEntry(ctx, sel, &obj)
	case *team.TeamConfirmDeleteKeyAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamConfirmDeleteKeyAuditEntry(ctx, sel, obj)
	case team.TeamMemberAddedAuditEntry:
		return ec._TeamMemberAddedAuditEntry(ctx, sel, &obj)
	case *team.TeamMemberAddedAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberAddedAuditEntry(ctx, sel, obj)
	case team.TeamEnvironmentUpdatedAuditEntry:
		return ec._TeamEnvironmentUpdatedAuditEntry(ctx, sel, &obj)
	case *team.TeamEnvironmentUpdatedAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamEnvironmentUpdatedAuditEntry(ctx, sel, obj)
	case team.TeamMemberRemovedAuditEntry:
		return ec._TeamMemberRemovedAuditEntry(ctx, sel, &obj)
	case *team.TeamMemberRemovedAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberRemovedAuditEntry(ctx, sel, obj)
	case application.Application:
		return ec._Application(ctx, sel, &obj)
	case *application.Application:
		if obj == nil {
			return graphql.Null
		}
		return ec._Application(ctx, sel, obj)
	case bigquery.BigQueryDataset:
		return ec._BigQueryDataset(ctx, sel, &obj)
	case *bigquery.BigQueryDataset:
		if obj == nil {
			return graphql.Null
		}
		return ec._BigQueryDataset(ctx, sel, obj)
	case bucket.Bucket:
		return ec._Bucket(ctx, sel, &obj)
	case *bucket.Bucket:
		if obj == nil {
			return graphql.Null
		}
		return ec._Bucket(ctx, sel, obj)
	case kafkatopic.KafkaTopic:
		return ec._KafkaTopic(ctx, sel, &obj)
	case *kafkatopic.KafkaTopic:
		if obj == nil {
			return graphql.Null
		}
		return ec._KafkaTopic(ctx, sel, obj)
	case opensearch.OpenSearch:
		return ec._OpenSearch(ctx, sel, &obj)
	case *opensearch.OpenSearch:
		if obj == nil {
			return graphql.Null
		}
		return ec._OpenSearch(ctx, sel, obj)
	case redis.RedisInstance:
		return ec._RedisInstance(ctx, sel, &obj)
	case *redis.RedisInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._RedisInstance(ctx, sel, obj)
	case sqlinstance.SQLDatabase:
		return ec._SqlDatabase(ctx, sel, &obj)
	case *sqlinstance.SQLDatabase:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlDatabase(ctx, sel, obj)
	case sqlinstance.SQLInstance:
		return ec._SqlInstance(ctx, sel, &obj)
	case *sqlinstance.SQLInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlInstance(ctx, sel, obj)
	case job.Job:
		return ec._Job(ctx, sel, &obj)
	case *job.Job:
		if obj == nil {
			return graphql.Null
		}
		return ec._Job(ctx, sel, obj)
	case team.TeamCreateDeleteKeyAuditEntry:
		return ec._TeamCreateDeleteKeyAuditEntry(ctx, sel, &obj)
	case *team.TeamCreateDeleteKeyAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamCreateDeleteKeyAuditEntry(ctx, sel, obj)
	case team.TeamMemberSetRoleAuditEntry:
		return ec._TeamMemberSetRoleAuditEntry(ctx, sel, &obj)
	case *team.TeamMemberSetRoleAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberSetRoleAuditEntry(ctx, sel, obj)
	case team.TeamCreatedAuditEntry:
		return ec._TeamCreatedAuditEntry(ctx, sel, &obj)
	case *team.TeamCreatedAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamCreatedAuditEntry(ctx, sel, obj)
	case team.TeamUpdatedAuditEntry:
		return ec._TeamUpdatedAuditEntry(ctx, sel, &obj)
	case *team.TeamUpdatedAuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamUpdatedAuditEntry(ctx, sel, obj)
	case workload.ContainerImage:
		return ec._ContainerImage(ctx, sel, &obj)
	case *workload.ContainerImage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ContainerImage(ctx, sel, obj)
	case persistence.Persistence:
		if obj == nil {
			return graphql.Null
		}
		return ec._Persistence(ctx, sel, obj)
	case auditv1.AuditEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._AuditEntry(ctx, sel, obj)
	case job.JobRun:
		return ec._JobRun(ctx, sel, &obj)
	case *job.JobRun:
		if obj == nil {
			return graphql.Null
		}
		return ec._JobRun(ctx, sel, obj)
	case team.TeamEnvironment:
		return ec._TeamEnvironment(ctx, sel, &obj)
	case *team.TeamEnvironment:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamEnvironment(ctx, sel, obj)
	case repository.Repository:
		return ec._Repository(ctx, sel, &obj)
	case *repository.Repository:
		if obj == nil {
			return graphql.Null
		}
		return ec._Repository(ctx, sel, obj)
	case user.User:
		return ec._User(ctx, sel, &obj)
	case *user.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case vulnerability.ImageVulnerability:
		return ec._ImageVulnerability(ctx, sel, &obj)
	case *vulnerability.ImageVulnerability:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageVulnerability(ctx, sel, obj)
	case workload.Workload:
		if obj == nil {
			return graphql.Null
		}
		return ec._Workload(ctx, sel, obj)
	case team.Team:
		return ec._Team(ctx, sel, &obj)
	case *team.Team:
		if obj == nil {
			return graphql.Null
		}
		return ec._Team(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Persistence(ctx context.Context, sel ast.SelectionSet, obj persistence.Persistence) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case bigquery.BigQueryDataset:
		return ec._BigQueryDataset(ctx, sel, &obj)
	case *bigquery.BigQueryDataset:
		if obj == nil {
			return graphql.Null
		}
		return ec._BigQueryDataset(ctx, sel, obj)
	case bucket.Bucket:
		return ec._Bucket(ctx, sel, &obj)
	case *bucket.Bucket:
		if obj == nil {
			return graphql.Null
		}
		return ec._Bucket(ctx, sel, obj)
	case kafkatopic.KafkaTopic:
		return ec._KafkaTopic(ctx, sel, &obj)
	case *kafkatopic.KafkaTopic:
		if obj == nil {
			return graphql.Null
		}
		return ec._KafkaTopic(ctx, sel, obj)
	case opensearch.OpenSearch:
		return ec._OpenSearch(ctx, sel, &obj)
	case *opensearch.OpenSearch:
		if obj == nil {
			return graphql.Null
		}
		return ec._OpenSearch(ctx, sel, obj)
	case redis.RedisInstance:
		return ec._RedisInstance(ctx, sel, &obj)
	case *redis.RedisInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._RedisInstance(ctx, sel, obj)
	case sqlinstance.SQLDatabase:
		return ec._SqlDatabase(ctx, sel, &obj)
	case *sqlinstance.SQLDatabase:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlDatabase(ctx, sel, obj)
	case sqlinstance.SQLInstance:
		return ec._SqlInstance(ctx, sel, &obj)
	case *sqlinstance.SQLInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlInstance(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ScalingStrategy(ctx context.Context, sel ast.SelectionSet, obj application.ScalingStrategy) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case application.CPUScalingStrategy:
		return ec._CPUScalingStrategy(ctx, sel, &obj)
	case *application.CPUScalingStrategy:
		if obj == nil {
			return graphql.Null
		}
		return ec._CPUScalingStrategy(ctx, sel, obj)
	case application.KafkaLagScalingStrategy:
		return ec._KafkaLagScalingStrategy(ctx, sel, &obj)
	case *application.KafkaLagScalingStrategy:
		if obj == nil {
			return graphql.Null
		}
		return ec._KafkaLagScalingStrategy(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SearchNode(ctx context.Context, sel ast.SelectionSet, obj searchv1.SearchNode) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case application.Application:
		return ec._Application(ctx, sel, &obj)
	case *application.Application:
		if obj == nil {
			return graphql.Null
		}
		return ec._Application(ctx, sel, obj)
	case job.Job:
		return ec._Job(ctx, sel, &obj)
	case *job.Job:
		if obj == nil {
			return graphql.Null
		}
		return ec._Job(ctx, sel, obj)
	case sqlinstance.SQLInstance:
		return ec._SqlInstance(ctx, sel, &obj)
	case *sqlinstance.SQLInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlInstance(ctx, sel, obj)
	case redis.RedisInstance:
		return ec._RedisInstance(ctx, sel, &obj)
	case *redis.RedisInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._RedisInstance(ctx, sel, obj)
	case opensearch.OpenSearch:
		return ec._OpenSearch(ctx, sel, &obj)
	case *opensearch.OpenSearch:
		if obj == nil {
			return graphql.Null
		}
		return ec._OpenSearch(ctx, sel, obj)
	case kafkatopic.KafkaTopic:
		return ec._KafkaTopic(ctx, sel, &obj)
	case *kafkatopic.KafkaTopic:
		if obj == nil {
			return graphql.Null
		}
		return ec._KafkaTopic(ctx, sel, obj)
	case bucket.Bucket:
		return ec._Bucket(ctx, sel, &obj)
	case *bucket.Bucket:
		if obj == nil {
			return graphql.Null
		}
		return ec._Bucket(ctx, sel, obj)
	case bigquery.BigQueryDataset:
		return ec._BigQueryDataset(ctx, sel, &obj)
	case *bigquery.BigQueryDataset:
		if obj == nil {
			return graphql.Null
		}
		return ec._BigQueryDataset(ctx, sel, obj)
	case team.Team:
		return ec._Team(ctx, sel, &obj)
	case *team.Team:
		if obj == nil {
			return graphql.Null
		}
		return ec._Team(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Workload(ctx context.Context, sel ast.SelectionSet, obj workload.Workload) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case application.Application:
		return ec._Application(ctx, sel, &obj)
	case *application.Application:
		if obj == nil {
			return graphql.Null
		}
		return ec._Application(ctx, sel, obj)
	case job.Job:
		return ec._Job(ctx, sel, &obj)
	case *job.Job:
		if obj == nil {
			return graphql.Null
		}
		return ec._Job(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _WorkloadManifest(ctx context.Context, sel ast.SelectionSet, obj workload.WorkloadManifest) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case application.ApplicationManifest:
		return ec._ApplicationManifest(ctx, sel, &obj)
	case *application.ApplicationManifest:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationManifest(ctx, sel, obj)
	case job.JobManifest:
		return ec._JobManifest(ctx, sel, &obj)
	case *job.JobManifest:
		if obj == nil {
			return graphql.Null
		}
		return ec._JobManifest(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _WorkloadResources(ctx context.Context, sel ast.SelectionSet, obj workload.WorkloadResources) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case application.ApplicationResources:
		return ec._ApplicationResources(ctx, sel, &obj)
	case *application.ApplicationResources:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationResources(ctx, sel, obj)
	case job.JobResources:
		return ec._JobResources(ctx, sel, &obj)
	case *job.JobResources:
		if obj == nil {
			return graphql.Null
		}
		return ec._JobResources(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var addRepositoryToTeamPayloadImplementors = []string{"AddRepositoryToTeamPayload"}

func (ec *executionContext) _AddRepositoryToTeamPayload(ctx context.Context, sel ast.SelectionSet, obj *repository.AddRepositoryToTeamPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addRepositoryToTeamPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddRepositoryToTeamPayload")
		case "repository":
			out.Values[i] = ec._AddRepositoryToTeamPayload_repository(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var addTeamMemberPayloadImplementors = []string{"AddTeamMemberPayload"}

func (ec *executionContext) _AddTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, obj *team.AddTeamMemberPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addTeamMemberPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddTeamMemberPayload")
		case "member":
			out.Values[i] = ec._AddTeamMemberPayload_member(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationImplementors = []string{"Application", "Node", "Workload", "SearchNode"}

func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *application.Application) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "id":
			out.Values[i] = ec._Application_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Application_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "image":
			out.Values[i] = ec._Application_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resources":
			out.Values[i] = ec._Application_resources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ingresses":
			out.Values[i] = ec._Application_ingresses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authIntegrations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_authIntegrations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "manifest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_manifest(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "networkPolicy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_networkPolicy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bigQueryDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_bigQueryDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "redisInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_redisInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "openSearch":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_openSearch(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buckets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_buckets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "kafkaTopicAcls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_kafkaTopicAcls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sqlInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_sqlInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "utilization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_utilization(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationConnectionImplementors = []string{"ApplicationConnection"}

func (ec *executionContext) _ApplicationConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*application.Application]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationConnection")
		case "pageInfo":
			out.Values[i] = ec._ApplicationConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ApplicationConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ApplicationConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationEdgeImplementors = []string{"ApplicationEdge"}

func (ec *executionContext) _ApplicationEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*application.Application]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationEdge")
		case "cursor":
			out.Values[i] = ec._ApplicationEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ApplicationEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationManifestImplementors = []string{"ApplicationManifest", "WorkloadManifest"}

func (ec *executionContext) _ApplicationManifest(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationManifest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationManifestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationManifest")
		case "content":
			out.Values[i] = ec._ApplicationManifest_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationResourcesImplementors = []string{"ApplicationResources", "WorkloadResources"}

func (ec *executionContext) _ApplicationResources(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationResourcesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationResources")
		case "limits":
			out.Values[i] = ec._ApplicationResources_limits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requests":
			out.Values[i] = ec._ApplicationResources_requests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scaling":
			out.Values[i] = ec._ApplicationResources_scaling(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationScalingImplementors = []string{"ApplicationScaling"}

func (ec *executionContext) _ApplicationScaling(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationScaling) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationScalingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationScaling")
		case "minInstances":
			out.Values[i] = ec._ApplicationScaling_minInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxInstances":
			out.Values[i] = ec._ApplicationScaling_maxInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "strategies":
			out.Values[i] = ec._ApplicationScaling_strategies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var auditEntryConnectionImplementors = []string{"AuditEntryConnection"}

func (ec *executionContext) _AuditEntryConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[auditv1.AuditEntry]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, auditEntryConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuditEntryConnection")
		case "pageInfo":
			out.Values[i] = ec._AuditEntryConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._AuditEntryConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._AuditEntryConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var auditEntryEdgeImplementors = []string{"AuditEntryEdge"}

func (ec *executionContext) _AuditEntryEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[auditv1.AuditEntry]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, auditEntryEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuditEntryEdge")
		case "cursor":
			out.Values[i] = ec._AuditEntryEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._AuditEntryEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetImplementors = []string{"BigQueryDataset", "Persistence", "Node", "SearchNode"}

func (ec *executionContext) _BigQueryDataset(ctx context.Context, sel ast.SelectionSet, obj *bigquery.BigQueryDataset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDataset")
		case "id":
			out.Values[i] = ec._BigQueryDataset_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._BigQueryDataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BigQueryDataset_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BigQueryDataset_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cascadingDelete":
			out.Values[i] = ec._BigQueryDataset_cascadingDelete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._BigQueryDataset_description(ctx, field, obj)
		case "access":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BigQueryDataset_access(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._BigQueryDataset_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BigQueryDataset_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BigQueryDataset_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetAccessImplementors = []string{"BigQueryDatasetAccess"}

func (ec *executionContext) _BigQueryDatasetAccess(ctx context.Context, sel ast.SelectionSet, obj *bigquery.BigQueryDatasetAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetAccessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetAccess")
		case "role":
			out.Values[i] = ec._BigQueryDatasetAccess_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "email":
			out.Values[i] = ec._BigQueryDatasetAccess_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetAccessConnectionImplementors = []string{"BigQueryDatasetAccessConnection"}

func (ec *executionContext) _BigQueryDatasetAccessConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetAccessConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetAccessConnection")
		case "pageInfo":
			out.Values[i] = ec._BigQueryDatasetAccessConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._BigQueryDatasetAccessConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._BigQueryDatasetAccessConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetAccessEdgeImplementors = []string{"BigQueryDatasetAccessEdge"}

func (ec *executionContext) _BigQueryDatasetAccessEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetAccessEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetAccessEdge")
		case "cursor":
			out.Values[i] = ec._BigQueryDatasetAccessEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._BigQueryDatasetAccessEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetConnectionImplementors = []string{"BigQueryDatasetConnection"}

func (ec *executionContext) _BigQueryDatasetConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*bigquery.BigQueryDataset]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetConnection")
		case "pageInfo":
			out.Values[i] = ec._BigQueryDatasetConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._BigQueryDatasetConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._BigQueryDatasetConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetCostImplementors = []string{"BigQueryDatasetCost"}

func (ec *executionContext) _BigQueryDatasetCost(ctx context.Context, sel ast.SelectionSet, obj *cost.BigQueryDatasetCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetCost")
		case "sum":
			out.Values[i] = ec._BigQueryDatasetCost_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetEdgeImplementors = []string{"BigQueryDatasetEdge"}

func (ec *executionContext) _BigQueryDatasetEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*bigquery.BigQueryDataset]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetEdge")
		case "cursor":
			out.Values[i] = ec._BigQueryDatasetEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._BigQueryDatasetEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetStatusImplementors = []string{"BigQueryDatasetStatus"}

func (ec *executionContext) _BigQueryDatasetStatus(ctx context.Context, sel ast.SelectionSet, obj *bigquery.BigQueryDatasetStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetStatus")
		case "creationTime":
			out.Values[i] = ec._BigQueryDatasetStatus_creationTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastModifiedTime":
			out.Values[i] = ec._BigQueryDatasetStatus_lastModifiedTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bucketImplementors = []string{"Bucket", "Persistence", "Node", "SearchNode"}

func (ec *executionContext) _Bucket(ctx context.Context, sel ast.SelectionSet, obj *bucket.Bucket) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bucketImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bucket")
		case "id":
			out.Values[i] = ec._Bucket_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Bucket_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bucket_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bucket_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cascadingDelete":
			out.Values[i] = ec._Bucket_cascadingDelete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "publicAccessPrevention":
			out.Values[i] = ec._Bucket_publicAccessPrevention(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "uniformBucketLevelAccess":
			out.Values[i] = ec._Bucket_uniformBucketLevelAccess(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bucket_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._Bucket_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bucketConnectionImplementors = []string{"BucketConnection"}

func (ec *executionContext) _BucketConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*bucket.Bucket]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bucketConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BucketConnection")
		case "pageInfo":
			out.Values[i] = ec._BucketConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._BucketConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._BucketConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bucketEdgeImplementors = []string{"BucketEdge"}

func (ec *executionContext) _BucketEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*bucket.Bucket]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bucketEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BucketEdge")
		case "cursor":
			out.Values[i] = ec._BucketEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._BucketEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bucketStatusImplementors = []string{"BucketStatus"}

func (ec *executionContext) _BucketStatus(ctx context.Context, sel ast.SelectionSet, obj *bucket.BucketStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bucketStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BucketStatus")
		case "state":
			out.Values[i] = ec._BucketStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cPUScalingStrategyImplementors = []string{"CPUScalingStrategy", "ScalingStrategy"}

func (ec *executionContext) _CPUScalingStrategy(ctx context.Context, sel ast.SelectionSet, obj *application.CPUScalingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cPUScalingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CPUScalingStrategy")
		case "threshold":
			out.Values[i] = ec._CPUScalingStrategy_threshold(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var confirmTeamDeletionPayloadImplementors = []string{"ConfirmTeamDeletionPayload"}

func (ec *executionContext) _ConfirmTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, obj *team.ConfirmTeamDeletionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, confirmTeamDeletionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfirmTeamDeletionPayload")
		case "deletionStarted":
			out.Values[i] = ec._ConfirmTeamDeletionPayload_deletionStarted(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerImageImplementors = []string{"ContainerImage", "Node"}

func (ec *executionContext) _ContainerImage(ctx context.Context, sel ast.SelectionSet, obj *workload.ContainerImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerImage")
		case "id":
			out.Values[i] = ec._ContainerImage_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._ContainerImage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tag":
			out.Values[i] = ec._ContainerImage_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hasSBOM":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerImage_hasSBOM(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vulnerabilities":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerImage_vulnerabilities(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vulnerabilitySummary":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerImage_vulnerabilitySummary(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workloadReferences":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerImage_workloadReferences(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerImageWorkloadReferenceImplementors = []string{"ContainerImageWorkloadReference"}

func (ec *executionContext) _ContainerImageWorkloadReference(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.ContainerImageWorkloadReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerImageWorkloadReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerImageWorkloadReference")
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerImageWorkloadReference_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerImageWorkloadReferenceConnectionImplementors = []string{"ContainerImageWorkloadReferenceConnection"}

func (ec *executionContext) _ContainerImageWorkloadReferenceConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerImageWorkloadReferenceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerImageWorkloadReferenceConnection")
		case "pageInfo":
			out.Values[i] = ec._ContainerImageWorkloadReferenceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ContainerImageWorkloadReferenceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ContainerImageWorkloadReferenceConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerImageWorkloadReferenceEdgeImplementors = []string{"ContainerImageWorkloadReferenceEdge"}

func (ec *executionContext) _ContainerImageWorkloadReferenceEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerImageWorkloadReferenceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerImageWorkloadReferenceEdge")
		case "cursor":
			out.Values[i] = ec._ContainerImageWorkloadReferenceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ContainerImageWorkloadReferenceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createTeamPayloadImplementors = []string{"CreateTeamPayload"}

func (ec *executionContext) _CreateTeamPayload(ctx context.Context, sel ast.SelectionSet, obj *team.CreateTeamPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createTeamPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateTeamPayload")
		case "team":
			out.Values[i] = ec._CreateTeamPayload_team(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteApplicationPayloadImplementors = []string{"DeleteApplicationPayload"}

func (ec *executionContext) _DeleteApplicationPayload(ctx context.Context, sel ast.SelectionSet, obj *application.DeleteApplicationPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteApplicationPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteApplicationPayload")
		case "team":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteApplicationPayload_team(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteJobPayloadImplementors = []string{"DeleteJobPayload"}

func (ec *executionContext) _DeleteJobPayload(ctx context.Context, sel ast.SelectionSet, obj *job.DeleteJobPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteJobPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteJobPayload")
		case "team":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteJobPayload_team(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var entraIDAuthIntegrationImplementors = []string{"EntraIDAuthIntegration", "ApplicationAuthIntegrations", "JobAuthIntegrations", "AuthIntegration"}

func (ec *executionContext) _EntraIDAuthIntegration(ctx context.Context, sel ast.SelectionSet, obj *workload.EntraIDAuthIntegration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entraIDAuthIntegrationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EntraIDAuthIntegration")
		case "name":
			out.Values[i] = ec._EntraIDAuthIntegration_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var externalNetworkPolicyHostImplementors = []string{"ExternalNetworkPolicyHost", "ExternalNetworkPolicyTarget"}

func (ec *executionContext) _ExternalNetworkPolicyHost(ctx context.Context, sel ast.SelectionSet, obj *netpol.ExternalNetworkPolicyHost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalNetworkPolicyHostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalNetworkPolicyHost")
		case "target":
			out.Values[i] = ec._ExternalNetworkPolicyHost_target(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ports":
			out.Values[i] = ec._ExternalNetworkPolicyHost_ports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var externalNetworkPolicyIpv4Implementors = []string{"ExternalNetworkPolicyIpv4", "ExternalNetworkPolicyTarget"}

func (ec *executionContext) _ExternalNetworkPolicyIpv4(ctx context.Context, sel ast.SelectionSet, obj *netpol.ExternalNetworkPolicyIpv4) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalNetworkPolicyIpv4Implementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalNetworkPolicyIpv4")
		case "target":
			out.Values[i] = ec._ExternalNetworkPolicyIpv4_target(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ports":
			out.Values[i] = ec._ExternalNetworkPolicyIpv4_ports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iDPortenAuthIntegrationImplementors = []string{"IDPortenAuthIntegration", "ApplicationAuthIntegrations", "AuthIntegration"}

func (ec *executionContext) _IDPortenAuthIntegration(ctx context.Context, sel ast.SelectionSet, obj *workload.IDPortenAuthIntegration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iDPortenAuthIntegrationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IDPortenAuthIntegration")
		case "name":
			out.Values[i] = ec._IDPortenAuthIntegration_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilityImplementors = []string{"ImageVulnerability", "Node"}

func (ec *executionContext) _ImageVulnerability(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.ImageVulnerability) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerability")
		case "id":
			out.Values[i] = ec._ImageVulnerability_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "identifier":
			out.Values[i] = ec._ImageVulnerability_identifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "severity":
			out.Values[i] = ec._ImageVulnerability_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ImageVulnerability_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "package":
			out.Values[i] = ec._ImageVulnerability_package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "state":
			out.Values[i] = ec._ImageVulnerability_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._ImageVulnerability_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilityConnectionImplementors = []string{"ImageVulnerabilityConnection"}

func (ec *executionContext) _ImageVulnerabilityConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilityConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerabilityConnection")
		case "pageInfo":
			out.Values[i] = ec._ImageVulnerabilityConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ImageVulnerabilityConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ImageVulnerabilityConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilityEdgeImplementors = []string{"ImageVulnerabilityEdge"}

func (ec *executionContext) _ImageVulnerabilityEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilityEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerabilityEdge")
		case "cursor":
			out.Values[i] = ec._ImageVulnerabilityEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ImageVulnerabilityEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilitySummaryImplementors = []string{"ImageVulnerabilitySummary"}

func (ec *executionContext) _ImageVulnerabilitySummary(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.ImageVulnerabilitySummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilitySummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerabilitySummary")
		case "total":
			out.Values[i] = ec._ImageVulnerabilitySummary_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "riskScore":
			out.Values[i] = ec._ImageVulnerabilitySummary_riskScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "low":
			out.Values[i] = ec._ImageVulnerabilitySummary_low(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "medium":
			out.Values[i] = ec._ImageVulnerabilitySummary_medium(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "high":
			out.Values[i] = ec._ImageVulnerabilitySummary_high(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "critical":
			out.Values[i] = ec._ImageVulnerabilitySummary_critical(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unassigned":
			out.Values[i] = ec._ImageVulnerabilitySummary_unassigned(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inboundNetworkPolicyImplementors = []string{"InboundNetworkPolicy"}

func (ec *executionContext) _InboundNetworkPolicy(ctx context.Context, sel ast.SelectionSet, obj *netpol.InboundNetworkPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inboundNetworkPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InboundNetworkPolicy")
		case "rules":
			out.Values[i] = ec._InboundNetworkPolicy_rules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobImplementors = []string{"Job", "Node", "Workload", "SearchNode"}

func (ec *executionContext) _Job(ctx context.Context, sel ast.SelectionSet, obj *job.Job) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Job")
		case "id":
			out.Values[i] = ec._Job_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Job_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "image":
			out.Values[i] = ec._Job_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resources":
			out.Values[i] = ec._Job_resources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authIntegrations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_authIntegrations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "schedule":
			out.Values[i] = ec._Job_schedule(ctx, field, obj)
		case "runs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_runs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "manifest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_manifest(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "networkPolicy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_networkPolicy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bigQueryDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_bigQueryDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "redisInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_redisInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "openSearch":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_openSearch(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buckets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_buckets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "kafkaTopicAcls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_kafkaTopicAcls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sqlInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_sqlInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobConnectionImplementors = []string{"JobConnection"}

func (ec *executionContext) _JobConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*job.Job]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobConnection")
		case "pageInfo":
			out.Values[i] = ec._JobConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._JobConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._JobConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobEdgeImplementors = []string{"JobEdge"}

func (ec *executionContext) _JobEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*job.Job]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobEdge")
		case "cursor":
			out.Values[i] = ec._JobEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._JobEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobManifestImplementors = []string{"JobManifest", "WorkloadManifest"}

func (ec *executionContext) _JobManifest(ctx context.Context, sel ast.SelectionSet, obj *job.JobManifest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobManifestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobManifest")
		case "content":
			out.Values[i] = ec._JobManifest_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobResourcesImplementors = []string{"JobResources", "WorkloadResources"}

func (ec *executionContext) _JobResources(ctx context.Context, sel ast.SelectionSet, obj *job.JobResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobResourcesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobResources")
		case "limits":
			out.Values[i] = ec._JobResources_limits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requests":
			out.Values[i] = ec._JobResources_requests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRunImplementors = []string{"JobRun", "Node"}

func (ec *executionContext) _JobRun(ctx context.Context, sel ast.SelectionSet, obj *job.JobRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRunImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRun")
		case "id":
			out.Values[i] = ec._JobRun_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._JobRun_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startTime":
			out.Values[i] = ec._JobRun_startTime(ctx, field, obj)
		case "completionTime":
			out.Values[i] = ec._JobRun_completionTime(ctx, field, obj)
		case "status":
			out.Values[i] = ec._JobRun_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "image":
			out.Values[i] = ec._JobRun_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRunConnectionImplementors = []string{"JobRunConnection"}

func (ec *executionContext) _JobRunConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*job.JobRun]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRunConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRunConnection")
		case "pageInfo":
			out.Values[i] = ec._JobRunConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._JobRunConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._JobRunConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRunEdgeImplementors = []string{"JobRunEdge"}

func (ec *executionContext) _JobRunEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*job.JobRun]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRunEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRunEdge")
		case "cursor":
			out.Values[i] = ec._JobRunEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._JobRunEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobScheduleImplementors = []string{"JobSchedule"}

func (ec *executionContext) _JobSchedule(ctx context.Context, sel ast.SelectionSet, obj *job.JobSchedule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobScheduleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobSchedule")
		case "expression":
			out.Values[i] = ec._JobSchedule_expression(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timeZone":
			out.Values[i] = ec._JobSchedule_timeZone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaLagScalingStrategyImplementors = []string{"KafkaLagScalingStrategy", "ScalingStrategy"}

func (ec *executionContext) _KafkaLagScalingStrategy(ctx context.Context, sel ast.SelectionSet, obj *application.KafkaLagScalingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaLagScalingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaLagScalingStrategy")
		case "threshold":
			out.Values[i] = ec._KafkaLagScalingStrategy_threshold(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consumerGroup":
			out.Values[i] = ec._KafkaLagScalingStrategy_consumerGroup(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "topicName":
			out.Values[i] = ec._KafkaLagScalingStrategy_topicName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicImplementors = []string{"KafkaTopic", "Persistence", "Node", "SearchNode"}

func (ec *executionContext) _KafkaTopic(ctx context.Context, sel ast.SelectionSet, obj *kafkatopic.KafkaTopic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopic")
		case "id":
			out.Values[i] = ec._KafkaTopic_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._KafkaTopic_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopic_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopic_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "acl":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopic_acl(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "configuration":
			out.Values[i] = ec._KafkaTopic_configuration(ctx, field, obj)
		case "pool":
			out.Values[i] = ec._KafkaTopic_pool(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._KafkaTopic_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicAclImplementors = []string{"KafkaTopicAcl"}

func (ec *executionContext) _KafkaTopicAcl(ctx context.Context, sel ast.SelectionSet, obj *kafkatopic.KafkaTopicACL) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicAclImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicAcl")
		case "access":
			out.Values[i] = ec._KafkaTopicAcl_access(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workloadName":
			out.Values[i] = ec._KafkaTopicAcl_workloadName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamName":
			out.Values[i] = ec._KafkaTopicAcl_teamName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopicAcl_team(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopicAcl_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopicAcl_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicAclConnectionImplementors = []string{"KafkaTopicAclConnection"}

func (ec *executionContext) _KafkaTopicAclConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicAclConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicAclConnection")
		case "pageInfo":
			out.Values[i] = ec._KafkaTopicAclConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._KafkaTopicAclConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._KafkaTopicAclConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicAclEdgeImplementors = []string{"KafkaTopicAclEdge"}

func (ec *executionContext) _KafkaTopicAclEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicAclEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicAclEdge")
		case "cursor":
			out.Values[i] = ec._KafkaTopicAclEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._KafkaTopicAclEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicConfigurationImplementors = []string{"KafkaTopicConfiguration"}

func (ec *executionContext) _KafkaTopicConfiguration(ctx context.Context, sel ast.SelectionSet, obj *kafkatopic.KafkaTopicConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicConfigurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicConfiguration")
		case "cleanupPolicy":
			out.Values[i] = ec._KafkaTopicConfiguration_cleanupPolicy(ctx, field, obj)
		case "maxMessageBytes":
			out.Values[i] = ec._KafkaTopicConfiguration_maxMessageBytes(ctx, field, obj)
		case "minimumInSyncReplicas":
			out.Values[i] = ec._KafkaTopicConfiguration_minimumInSyncReplicas(ctx, field, obj)
		case "partitions":
			out.Values[i] = ec._KafkaTopicConfiguration_partitions(ctx, field, obj)
		case "replication":
			out.Values[i] = ec._KafkaTopicConfiguration_replication(ctx, field, obj)
		case "retentionBytes":
			out.Values[i] = ec._KafkaTopicConfiguration_retentionBytes(ctx, field, obj)
		case "retentionHours":
			out.Values[i] = ec._KafkaTopicConfiguration_retentionHours(ctx, field, obj)
		case "segmentHours":
			out.Values[i] = ec._KafkaTopicConfiguration_segmentHours(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicConnectionImplementors = []string{"KafkaTopicConnection"}

func (ec *executionContext) _KafkaTopicConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicConnection")
		case "pageInfo":
			out.Values[i] = ec._KafkaTopicConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._KafkaTopicConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._KafkaTopicConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicEdgeImplementors = []string{"KafkaTopicEdge"}

func (ec *executionContext) _KafkaTopicEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicEdge")
		case "cursor":
			out.Values[i] = ec._KafkaTopicEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._KafkaTopicEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicStatusImplementors = []string{"KafkaTopicStatus"}

func (ec *executionContext) _KafkaTopicStatus(ctx context.Context, sel ast.SelectionSet, obj *kafkatopic.KafkaTopicStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicStatus")
		case "state":
			out.Values[i] = ec._KafkaTopicStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var maskinportenAuthIntegrationImplementors = []string{"MaskinportenAuthIntegration", "ApplicationAuthIntegrations", "JobAuthIntegrations", "AuthIntegration"}

func (ec *executionContext) _MaskinportenAuthIntegration(ctx context.Context, sel ast.SelectionSet, obj *workload.MaskinportenAuthIntegration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maskinportenAuthIntegrationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MaskinportenAuthIntegration")
		case "name":
			out.Values[i] = ec._MaskinportenAuthIntegration_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "deleteApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteJob":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteJob(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enableReconciler":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_enableReconciler(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disableReconciler":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_disableReconciler(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configureReconciler":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_configureReconciler(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addRepositoryToTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addRepositoryToTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeRepositoryFromTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeRepositoryFromTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTeamEnvironment":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTeamEnvironment(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "synchronizeTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_synchronizeTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestTeamDeletion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestTeamDeletion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "confirmTeamDeletion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_confirmTeamDeletion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addTeamMember":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addTeamMember(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeTeamMember":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeTeamMember(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setTeamMemberRole":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setTeamMemberRole(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var networkPolicyImplementors = []string{"NetworkPolicy"}

func (ec *executionContext) _NetworkPolicy(ctx context.Context, sel ast.SelectionSet, obj *netpol.NetworkPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkPolicy")
		case "inbound":
			out.Values[i] = ec._NetworkPolicy_inbound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "outbound":
			out.Values[i] = ec._NetworkPolicy_outbound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var networkPolicyRuleImplementors = []string{"NetworkPolicyRule"}

func (ec *executionContext) _NetworkPolicyRule(ctx context.Context, sel ast.SelectionSet, obj *netpol.NetworkPolicyRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkPolicyRuleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkPolicyRule")
		case "targetWorkloadName":
			out.Values[i] = ec._NetworkPolicyRule_targetWorkloadName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetWorkload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._NetworkPolicyRule_targetWorkload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "targetTeamSlug":
			out.Values[i] = ec._NetworkPolicyRule_targetTeamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetTeam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._NetworkPolicyRule_targetTeam(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mutual":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._NetworkPolicyRule_mutual(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchImplementors = []string{"OpenSearch", "Persistence", "Node", "SearchNode"}

func (ec *executionContext) _OpenSearch(ctx context.Context, sel ast.SelectionSet, obj *opensearch.OpenSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearch")
		case "id":
			out.Values[i] = ec._OpenSearch_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._OpenSearch_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearch_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearch_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._OpenSearch_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearch_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "access":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearch_access(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearch_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchAccessImplementors = []string{"OpenSearchAccess"}

func (ec *executionContext) _OpenSearchAccess(ctx context.Context, sel ast.SelectionSet, obj *opensearch.OpenSearchAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchAccessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchAccess")
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearchAccess_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "access":
			out.Values[i] = ec._OpenSearchAccess_access(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchAccessConnectionImplementors = []string{"OpenSearchAccessConnection"}

func (ec *executionContext) _OpenSearchAccessConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchAccessConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchAccessConnection")
		case "pageInfo":
			out.Values[i] = ec._OpenSearchAccessConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._OpenSearchAccessConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._OpenSearchAccessConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchAccessEdgeImplementors = []string{"OpenSearchAccessEdge"}

func (ec *executionContext) _OpenSearchAccessEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchAccessEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchAccessEdge")
		case "cursor":
			out.Values[i] = ec._OpenSearchAccessEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._OpenSearchAccessEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchConnectionImplementors = []string{"OpenSearchConnection"}

func (ec *executionContext) _OpenSearchConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*opensearch.OpenSearch]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchConnection")
		case "pageInfo":
			out.Values[i] = ec._OpenSearchConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._OpenSearchConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._OpenSearchConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchCostImplementors = []string{"OpenSearchCost"}

func (ec *executionContext) _OpenSearchCost(ctx context.Context, sel ast.SelectionSet, obj *cost.OpenSearchCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchCost")
		case "sum":
			out.Values[i] = ec._OpenSearchCost_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchEdgeImplementors = []string{"OpenSearchEdge"}

func (ec *executionContext) _OpenSearchEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*opensearch.OpenSearch]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchEdge")
		case "cursor":
			out.Values[i] = ec._OpenSearchEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._OpenSearchEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchStatusImplementors = []string{"OpenSearchStatus"}

func (ec *executionContext) _OpenSearchStatus(ctx context.Context, sel ast.SelectionSet, obj *opensearch.OpenSearchStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchStatus")
		case "state":
			out.Values[i] = ec._OpenSearchStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var outboundNetworkPolicyImplementors = []string{"OutboundNetworkPolicy"}

func (ec *executionContext) _OutboundNetworkPolicy(ctx context.Context, sel ast.SelectionSet, obj *netpol.OutboundNetworkPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, outboundNetworkPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OutboundNetworkPolicy")
		case "rules":
			out.Values[i] = ec._OutboundNetworkPolicy_rules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "external":
			out.Values[i] = ec._OutboundNetworkPolicy_external(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *pagination.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._PageInfo_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageStart":
			out.Values[i] = ec._PageInfo_pageStart(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageEnd":
			out.Values[i] = ec._PageInfo_pageEnd(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "reconcilers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_reconcilers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "search":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_search(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "teams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_teams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_team(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "me":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "teamsUtilization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_teamsUtilization(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerImplementors = []string{"Reconciler"}

func (ec *executionContext) _Reconciler(ctx context.Context, sel ast.SelectionSet, obj *reconciler.Reconciler) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Reconciler")
		case "name":
			out.Values[i] = ec._Reconciler_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._Reconciler_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Reconciler_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "enabled":
			out.Values[i] = ec._Reconciler_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "config":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Reconciler_config(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "configured":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Reconciler_configured(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerConfigImplementors = []string{"ReconcilerConfig"}

func (ec *executionContext) _ReconcilerConfig(ctx context.Context, sel ast.SelectionSet, obj *reconciler.ReconcilerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerConfig")
		case "key":
			out.Values[i] = ec._ReconcilerConfig_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._ReconcilerConfig_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ReconcilerConfig_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configured":
			out.Values[i] = ec._ReconcilerConfig_configured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secret":
			out.Values[i] = ec._ReconcilerConfig_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._ReconcilerConfig_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerConnectionImplementors = []string{"ReconcilerConnection"}

func (ec *executionContext) _ReconcilerConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*reconciler.Reconciler]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerConnection")
		case "pageInfo":
			out.Values[i] = ec._ReconcilerConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ReconcilerConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ReconcilerConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerEdgeImplementors = []string{"ReconcilerEdge"}

func (ec *executionContext) _ReconcilerEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*reconciler.Reconciler]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerEdge")
		case "cursor":
			out.Values[i] = ec._ReconcilerEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ReconcilerEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceImplementors = []string{"RedisInstance", "Persistence", "Node", "SearchNode"}

func (ec *executionContext) _RedisInstance(ctx context.Context, sel ast.SelectionSet, obj *redis.RedisInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstance")
		case "id":
			out.Values[i] = ec._RedisInstance_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._RedisInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstance_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstance_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "access":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstance_access(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstance_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._RedisInstance_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstance_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceAccessImplementors = []string{"RedisInstanceAccess"}

func (ec *executionContext) _RedisInstanceAccess(ctx context.Context, sel ast.SelectionSet, obj *redis.RedisInstanceAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceAccessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceAccess")
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstanceAccess_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "access":
			out.Values[i] = ec._RedisInstanceAccess_access(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceAccessConnectionImplementors = []string{"RedisInstanceAccessConnection"}

func (ec *executionContext) _RedisInstanceAccessConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*redis.RedisInstanceAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceAccessConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceAccessConnection")
		case "pageInfo":
			out.Values[i] = ec._RedisInstanceAccessConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._RedisInstanceAccessConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._RedisInstanceAccessConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceAccessEdgeImplementors = []string{"RedisInstanceAccessEdge"}

func (ec *executionContext) _RedisInstanceAccessEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*redis.RedisInstanceAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceAccessEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceAccessEdge")
		case "cursor":
			out.Values[i] = ec._RedisInstanceAccessEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._RedisInstanceAccessEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceConnectionImplementors = []string{"RedisInstanceConnection"}

func (ec *executionContext) _RedisInstanceConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*redis.RedisInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceConnection")
		case "pageInfo":
			out.Values[i] = ec._RedisInstanceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._RedisInstanceConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._RedisInstanceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceCostImplementors = []string{"RedisInstanceCost"}

func (ec *executionContext) _RedisInstanceCost(ctx context.Context, sel ast.SelectionSet, obj *cost.RedisInstanceCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceCost")
		case "sum":
			out.Values[i] = ec._RedisInstanceCost_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceEdgeImplementors = []string{"RedisInstanceEdge"}

func (ec *executionContext) _RedisInstanceEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*redis.RedisInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceEdge")
		case "cursor":
			out.Values[i] = ec._RedisInstanceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._RedisInstanceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceStatusImplementors = []string{"RedisInstanceStatus"}

func (ec *executionContext) _RedisInstanceStatus(ctx context.Context, sel ast.SelectionSet, obj *redis.RedisInstanceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceStatus")
		case "state":
			out.Values[i] = ec._RedisInstanceStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var removeRepositoryFromTeamPayloadImplementors = []string{"RemoveRepositoryFromTeamPayload"}

func (ec *executionContext) _RemoveRepositoryFromTeamPayload(ctx context.Context, sel ast.SelectionSet, obj *repository.RemoveRepositoryFromTeamPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, removeRepositoryFromTeamPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RemoveRepositoryFromTeamPayload")
		case "success":
			out.Values[i] = ec._RemoveRepositoryFromTeamPayload_success(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var removeTeamMemberPayloadImplementors = []string{"RemoveTeamMemberPayload"}

func (ec *executionContext) _RemoveTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, obj *team.RemoveTeamMemberPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, removeTeamMemberPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RemoveTeamMemberPayload")
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RemoveTeamMemberPayload_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "team":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RemoveTeamMemberPayload_team(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repositoryImplementors = []string{"Repository", "Node"}

func (ec *executionContext) _Repository(ctx context.Context, sel ast.SelectionSet, obj *repository.Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "id":
			out.Values[i] = ec._Repository_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Repository_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repositoryConnectionImplementors = []string{"RepositoryConnection"}

func (ec *executionContext) _RepositoryConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*repository.Repository]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryConnection")
		case "pageInfo":
			out.Values[i] = ec._RepositoryConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._RepositoryConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._RepositoryConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repositoryEdgeImplementors = []string{"RepositoryEdge"}

func (ec *executionContext) _RepositoryEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*repository.Repository]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryEdge")
		case "cursor":
			out.Values[i] = ec._RepositoryEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._RepositoryEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var requestTeamDeletionPayloadImplementors = []string{"RequestTeamDeletionPayload"}

func (ec *executionContext) _RequestTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, obj *team.RequestTeamDeletionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, requestTeamDeletionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RequestTeamDeletionPayload")
		case "key":
			out.Values[i] = ec._RequestTeamDeletionPayload_key(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var restartApplicationPayloadImplementors = []string{"RestartApplicationPayload"}

func (ec *executionContext) _RestartApplicationPayload(ctx context.Context, sel ast.SelectionSet, obj *application.RestartApplicationPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, restartApplicationPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestartApplicationPayload")
		case "application":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RestartApplicationPayload_application(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchNodeConnectionImplementors = []string{"SearchNodeConnection"}

func (ec *executionContext) _SearchNodeConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[searchv1.SearchNode]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchNodeConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchNodeConnection")
		case "pageInfo":
			out.Values[i] = ec._SearchNodeConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._SearchNodeConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._SearchNodeConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchNodeEdgeImplementors = []string{"SearchNodeEdge"}

func (ec *executionContext) _SearchNodeEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[searchv1.SearchNode]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchNodeEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchNodeEdge")
		case "cursor":
			out.Values[i] = ec._SearchNodeEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._SearchNodeEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceCostImplementors = []string{"ServiceCost"}

func (ec *executionContext) _ServiceCost(ctx context.Context, sel ast.SelectionSet, obj *cost.ServiceCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceCost")
		case "service":
			out.Values[i] = ec._ServiceCost_service(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cost":
			out.Values[i] = ec._ServiceCost_cost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceCostSeriesImplementors = []string{"ServiceCostSeries"}

func (ec *executionContext) _ServiceCostSeries(ctx context.Context, sel ast.SelectionSet, obj *cost.ServiceCostSeries) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceCostSeriesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceCostSeries")
		case "date":
			out.Values[i] = ec._ServiceCostSeries_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sum":
			out.Values[i] = ec._ServiceCostSeries_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "services":
			out.Values[i] = ec._ServiceCostSeries_services(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var setTeamMemberRolePayloadImplementors = []string{"SetTeamMemberRolePayload"}

func (ec *executionContext) _SetTeamMemberRolePayload(ctx context.Context, sel ast.SelectionSet, obj *team.SetTeamMemberRolePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setTeamMemberRolePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetTeamMemberRolePayload")
		case "member":
			out.Values[i] = ec._SetTeamMemberRolePayload_member(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlDatabaseImplementors = []string{"SqlDatabase", "Persistence", "Node"}

func (ec *executionContext) _SqlDatabase(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLDatabase) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlDatabaseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlDatabase")
		case "id":
			out.Values[i] = ec._SqlDatabase_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._SqlDatabase_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlDatabase_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlDatabase_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "charset":
			out.Values[i] = ec._SqlDatabase_charset(ctx, field, obj)
		case "collation":
			out.Values[i] = ec._SqlDatabase_collation(ctx, field, obj)
		case "deletionPolicy":
			out.Values[i] = ec._SqlDatabase_deletionPolicy(ctx, field, obj)
		case "healthy":
			out.Values[i] = ec._SqlDatabase_healthy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceImplementors = []string{"SqlInstance", "Persistence", "Node", "SearchNode"}

func (ec *executionContext) _SqlInstance(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstance")
		case "id":
			out.Values[i] = ec._SqlInstance_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._SqlInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cascadingDelete":
			out.Values[i] = ec._SqlInstance_cascadingDelete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "connectionName":
			out.Values[i] = ec._SqlInstance_connectionName(ctx, field, obj)
		case "diskAutoresize":
			out.Values[i] = ec._SqlInstance_diskAutoresize(ctx, field, obj)
		case "diskAutoresizeLimit":
			out.Values[i] = ec._SqlInstance_diskAutoresizeLimit(ctx, field, obj)
		case "highAvailability":
			out.Values[i] = ec._SqlInstance_highAvailability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "healthy":
			out.Values[i] = ec._SqlInstance_healthy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "maintenanceVersion":
			out.Values[i] = ec._SqlInstance_maintenanceVersion(ctx, field, obj)
		case "maintenanceWindow":
			out.Values[i] = ec._SqlInstance_maintenanceWindow(ctx, field, obj)
		case "backupConfiguration":
			out.Values[i] = ec._SqlInstance_backupConfiguration(ctx, field, obj)
		case "projectID":
			out.Values[i] = ec._SqlInstance_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tier":
			out.Values[i] = ec._SqlInstance_tier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._SqlInstance_version(ctx, field, obj)
		case "status":
			out.Values[i] = ec._SqlInstance_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "database":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_database(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "flags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_flags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceBackupConfigurationImplementors = []string{"SqlInstanceBackupConfiguration"}

func (ec *executionContext) _SqlInstanceBackupConfiguration(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceBackupConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceBackupConfigurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceBackupConfiguration")
		case "enabled":
			out.Values[i] = ec._SqlInstanceBackupConfiguration_enabled(ctx, field, obj)
		case "startTime":
			out.Values[i] = ec._SqlInstanceBackupConfiguration_startTime(ctx, field, obj)
		case "retainedBackups":
			out.Values[i] = ec._SqlInstanceBackupConfiguration_retainedBackups(ctx, field, obj)
		case "pointInTimeRecovery":
			out.Values[i] = ec._SqlInstanceBackupConfiguration_pointInTimeRecovery(ctx, field, obj)
		case "transactionLogRetentionDays":
			out.Values[i] = ec._SqlInstanceBackupConfiguration_transactionLogRetentionDays(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceConnectionImplementors = []string{"SqlInstanceConnection"}

func (ec *executionContext) _SqlInstanceConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*sqlinstance.SQLInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceConnection")
		case "pageInfo":
			out.Values[i] = ec._SqlInstanceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._SqlInstanceConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._SqlInstanceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceEdgeImplementors = []string{"SqlInstanceEdge"}

func (ec *executionContext) _SqlInstanceEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*sqlinstance.SQLInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceEdge")
		case "cursor":
			out.Values[i] = ec._SqlInstanceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._SqlInstanceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceFlagImplementors = []string{"SqlInstanceFlag"}

func (ec *executionContext) _SqlInstanceFlag(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceFlag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceFlagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceFlag")
		case "name":
			out.Values[i] = ec._SqlInstanceFlag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._SqlInstanceFlag_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceFlagConnectionImplementors = []string{"SqlInstanceFlagConnection"}

func (ec *executionContext) _SqlInstanceFlagConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceFlagConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceFlagConnection")
		case "pageInfo":
			out.Values[i] = ec._SqlInstanceFlagConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._SqlInstanceFlagConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._SqlInstanceFlagConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceFlagEdgeImplementors = []string{"SqlInstanceFlagEdge"}

func (ec *executionContext) _SqlInstanceFlagEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceFlagEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceFlagEdge")
		case "cursor":
			out.Values[i] = ec._SqlInstanceFlagEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._SqlInstanceFlagEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceMaintenanceWindowImplementors = []string{"SqlInstanceMaintenanceWindow"}

func (ec *executionContext) _SqlInstanceMaintenanceWindow(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceMaintenanceWindow) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceMaintenanceWindowImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceMaintenanceWindow")
		case "day":
			out.Values[i] = ec._SqlInstanceMaintenanceWindow_day(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hour":
			out.Values[i] = ec._SqlInstanceMaintenanceWindow_hour(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceStatusImplementors = []string{"SqlInstanceStatus"}

func (ec *executionContext) _SqlInstanceStatus(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceStatus")
		case "publicIpAddress":
			out.Values[i] = ec._SqlInstanceStatus_publicIpAddress(ctx, field, obj)
		case "privateIpAddress":
			out.Values[i] = ec._SqlInstanceStatus_privateIpAddress(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceUserImplementors = []string{"SqlInstanceUser"}

func (ec *executionContext) _SqlInstanceUser(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceUser")
		case "name":
			out.Values[i] = ec._SqlInstanceUser_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "authentication":
			out.Values[i] = ec._SqlInstanceUser_authentication(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceUserConnectionImplementors = []string{"SqlInstanceUserConnection"}

func (ec *executionContext) _SqlInstanceUserConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceUserConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceUserConnection")
		case "pageInfo":
			out.Values[i] = ec._SqlInstanceUserConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._SqlInstanceUserConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._SqlInstanceUserConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceUserEdgeImplementors = []string{"SqlInstanceUserEdge"}

func (ec *executionContext) _SqlInstanceUserEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceUserEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceUserEdge")
		case "cursor":
			out.Values[i] = ec._SqlInstanceUserEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._SqlInstanceUserEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var synchronizeTeamPayloadImplementors = []string{"SynchronizeTeamPayload"}

func (ec *executionContext) _SynchronizeTeamPayload(ctx context.Context, sel ast.SelectionSet, obj *team.SynchronizeTeamPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, synchronizeTeamPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SynchronizeTeamPayload")
		case "team":
			out.Values[i] = ec._SynchronizeTeamPayload_team(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamImplementors = []string{"Team", "SearchNode", "Node"}

func (ec *executionContext) _Team(ctx context.Context, sel ast.SelectionSet, obj *team.Team) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Team")
		case "id":
			out.Values[i] = ec._Team_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "slug":
			out.Values[i] = ec._Team_slug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "slackChannel":
			out.Values[i] = ec._Team_slackChannel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "purpose":
			out.Values[i] = ec._Team_purpose(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "azureGroupID":
			out.Values[i] = ec._Team_azureGroupID(ctx, field, obj)
		case "gitHubTeamSlug":
			out.Values[i] = ec._Team_gitHubTeamSlug(ctx, field, obj)
		case "googleGroupEmail":
			out.Values[i] = ec._Team_googleGroupEmail(ctx, field, obj)
		case "googleArtifactRegistry":
			out.Values[i] = ec._Team_googleArtifactRegistry(ctx, field, obj)
		case "cdnBucket":
			out.Values[i] = ec._Team_cdnBucket(ctx, field, obj)
		case "member":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_member(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "members":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_members(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lastSuccessfulSync":
			out.Values[i] = ec._Team_lastSuccessfulSync(ctx, field, obj)
		case "deletionInProgress":
			out.Values[i] = ec._Team_deletionInProgress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "viewerIsOwner":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_viewerIsOwner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "viewerIsMember":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_viewerIsMember(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_environments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteKey":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_deleteKey(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "applications":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_applications(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "auditEntries":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_auditEntries(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "jobs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_jobs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bigQueryDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_bigQueryDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "redisInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_redisInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "openSearchInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_openSearchInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buckets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_buckets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "kafkaTopics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_kafkaTopics(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sqlInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_sqlInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "repositories":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_repositories(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workloadUtilization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_workloadUtilization(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vulnerabilitySummary":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_vulnerabilitySummary(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workloads":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_workloads(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamConfirmDeleteKeyAuditEntryImplementors = []string{"TeamConfirmDeleteKeyAuditEntry", "AuditEntry", "Node"}

func (ec *executionContext) _TeamConfirmDeleteKeyAuditEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamConfirmDeleteKeyAuditEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamConfirmDeleteKeyAuditEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamConfirmDeleteKeyAuditEntry")
		case "id":
			out.Values[i] = ec._TeamConfirmDeleteKeyAuditEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamConfirmDeleteKeyAuditEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamConfirmDeleteKeyAuditEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamConfirmDeleteKeyAuditEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamConfirmDeleteKeyAuditEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamConfirmDeleteKeyAuditEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamConfirmDeleteKeyAuditEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamConfirmDeleteKeyAuditEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamConnectionImplementors = []string{"TeamConnection"}

func (ec *executionContext) _TeamConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*team.Team]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamConnection")
		case "pageInfo":
			out.Values[i] = ec._TeamConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._TeamConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._TeamConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCostImplementors = []string{"TeamCost"}

func (ec *executionContext) _TeamCost(ctx context.Context, sel ast.SelectionSet, obj *cost.TeamCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCost")
		case "daily":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamCost_daily(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "monthlySummary":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamCost_monthlySummary(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCostMonthlySampleImplementors = []string{"TeamCostMonthlySample"}

func (ec *executionContext) _TeamCostMonthlySample(ctx context.Context, sel ast.SelectionSet, obj *cost.TeamCostMonthlySample) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCostMonthlySampleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCostMonthlySample")
		case "date":
			out.Values[i] = ec._TeamCostMonthlySample_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cost":
			out.Values[i] = ec._TeamCostMonthlySample_cost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCostMonthlySummaryImplementors = []string{"TeamCostMonthlySummary"}

func (ec *executionContext) _TeamCostMonthlySummary(ctx context.Context, sel ast.SelectionSet, obj *cost.TeamCostMonthlySummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCostMonthlySummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCostMonthlySummary")
		case "sum":
			out.Values[i] = ec._TeamCostMonthlySummary_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "series":
			out.Values[i] = ec._TeamCostMonthlySummary_series(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCostPeriodImplementors = []string{"TeamCostPeriod"}

func (ec *executionContext) _TeamCostPeriod(ctx context.Context, sel ast.SelectionSet, obj *cost.TeamCostPeriod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCostPeriodImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCostPeriod")
		case "sum":
			out.Values[i] = ec._TeamCostPeriod_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "series":
			out.Values[i] = ec._TeamCostPeriod_series(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCreateDeleteKeyAuditEntryImplementors = []string{"TeamCreateDeleteKeyAuditEntry", "AuditEntry", "Node"}

func (ec *executionContext) _TeamCreateDeleteKeyAuditEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamCreateDeleteKeyAuditEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCreateDeleteKeyAuditEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCreateDeleteKeyAuditEntry")
		case "id":
			out.Values[i] = ec._TeamCreateDeleteKeyAuditEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamCreateDeleteKeyAuditEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamCreateDeleteKeyAuditEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamCreateDeleteKeyAuditEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamCreateDeleteKeyAuditEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamCreateDeleteKeyAuditEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamCreateDeleteKeyAuditEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamCreateDeleteKeyAuditEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCreatedAuditEntryImplementors = []string{"TeamCreatedAuditEntry", "AuditEntry", "Node"}

func (ec *executionContext) _TeamCreatedAuditEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamCreatedAuditEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCreatedAuditEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCreatedAuditEntry")
		case "id":
			out.Values[i] = ec._TeamCreatedAuditEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamCreatedAuditEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamCreatedAuditEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamCreatedAuditEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamCreatedAuditEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamCreatedAuditEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamCreatedAuditEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamCreatedAuditEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamDeleteKeyImplementors = []string{"TeamDeleteKey"}

func (ec *executionContext) _TeamDeleteKey(ctx context.Context, sel ast.SelectionSet, obj *team.TeamDeleteKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamDeleteKeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamDeleteKey")
		case "key":
			out.Values[i] = ec._TeamDeleteKey_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._TeamDeleteKey_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expires":
			out.Values[i] = ec._TeamDeleteKey_expires(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamDeleteKey_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamDeleteKey_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEdgeImplementors = []string{"TeamEdge"}

func (ec *executionContext) _TeamEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*team.Team]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEdge")
		case "cursor":
			out.Values[i] = ec._TeamEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._TeamEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEnvironmentImplementors = []string{"TeamEnvironment", "Node"}

func (ec *executionContext) _TeamEnvironment(ctx context.Context, sel ast.SelectionSet, obj *team.TeamEnvironment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEnvironmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEnvironment")
		case "id":
			out.Values[i] = ec._TeamEnvironment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._TeamEnvironment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "gcpProjectID":
			out.Values[i] = ec._TeamEnvironment_gcpProjectID(ctx, field, obj)
		case "slackAlertsChannel":
			out.Values[i] = ec._TeamEnvironment_slackAlertsChannel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "application":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_application(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "job":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_job(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bigQueryDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_bigQueryDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bucket":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_bucket(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "kafkaTopic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_kafkaTopic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "openSearchInstance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_openSearchInstance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "redisInstance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_redisInstance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sqlInstance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_sqlInstance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEnvironmentUpdatedAuditEntryImplementors = []string{"TeamEnvironmentUpdatedAuditEntry", "AuditEntry", "Node"}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamEnvironmentUpdatedAuditEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEnvironmentUpdatedAuditEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEnvironmentUpdatedAuditEntry")
		case "id":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEnvironmentUpdatedAuditEntryDataImplementors = []string{"TeamEnvironmentUpdatedAuditEntryData"}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntryData(ctx context.Context, sel ast.SelectionSet, obj *team.TeamEnvironmentUpdatedAuditEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEnvironmentUpdatedAuditEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEnvironmentUpdatedAuditEntryData")
		case "environmentName":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntryData_environmentName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedFields":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntryData_updatedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEnvironmentUpdatedAuditEntryDataUpdatedFieldImplementors = []string{"TeamEnvironmentUpdatedAuditEntryDataUpdatedField"}

func (ec *executionContext) _TeamEnvironmentUpdatedAuditEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, obj *team.TeamEnvironmentUpdatedAuditEntryDataUpdatedField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEnvironmentUpdatedAuditEntryDataUpdatedFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEnvironmentUpdatedAuditEntryDataUpdatedField")
		case "field":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntryDataUpdatedField_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldValue":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntryDataUpdatedField_oldValue(ctx, field, obj)
		case "newValue":
			out.Values[i] = ec._TeamEnvironmentUpdatedAuditEntryDataUpdatedField_newValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberImplementors = []string{"TeamMember"}

func (ec *executionContext) _TeamMember(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMember) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMember")
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamMember_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamMember_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "role":
			out.Values[i] = ec._TeamMember_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberAddedAuditEntryImplementors = []string{"TeamMemberAddedAuditEntry", "AuditEntry", "Node"}

func (ec *executionContext) _TeamMemberAddedAuditEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberAddedAuditEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberAddedAuditEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberAddedAuditEntry")
		case "id":
			out.Values[i] = ec._TeamMemberAddedAuditEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamMemberAddedAuditEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamMemberAddedAuditEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamMemberAddedAuditEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamMemberAddedAuditEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamMemberAddedAuditEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamMemberAddedAuditEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamMemberAddedAuditEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._TeamMemberAddedAuditEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberAddedAuditEntryDataImplementors = []string{"TeamMemberAddedAuditEntryData"}

func (ec *executionContext) _TeamMemberAddedAuditEntryData(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberAddedAuditEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberAddedAuditEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberAddedAuditEntryData")
		case "role":
			out.Values[i] = ec._TeamMemberAddedAuditEntryData_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userID":
			out.Values[i] = ec._TeamMemberAddedAuditEntryData_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userEmail":
			out.Values[i] = ec._TeamMemberAddedAuditEntryData_userEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamMemberAddedAuditEntryData_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberConnectionImplementors = []string{"TeamMemberConnection"}

func (ec *executionContext) _TeamMemberConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*team.TeamMember]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberConnection")
		case "pageInfo":
			out.Values[i] = ec._TeamMemberConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._TeamMemberConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._TeamMemberConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberEdgeImplementors = []string{"TeamMemberEdge"}

func (ec *executionContext) _TeamMemberEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*team.TeamMember]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberEdge")
		case "cursor":
			out.Values[i] = ec._TeamMemberEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._TeamMemberEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberRemovedAuditEntryImplementors = []string{"TeamMemberRemovedAuditEntry", "AuditEntry", "Node"}

func (ec *executionContext) _TeamMemberRemovedAuditEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberRemovedAuditEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberRemovedAuditEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberRemovedAuditEntry")
		case "id":
			out.Values[i] = ec._TeamMemberRemovedAuditEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamMemberRemovedAuditEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamMemberRemovedAuditEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamMemberRemovedAuditEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamMemberRemovedAuditEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamMemberRemovedAuditEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamMemberRemovedAuditEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamMemberRemovedAuditEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._TeamMemberRemovedAuditEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberRemovedAuditEntryDataImplementors = []string{"TeamMemberRemovedAuditEntryData"}

func (ec *executionContext) _TeamMemberRemovedAuditEntryData(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberRemovedAuditEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberRemovedAuditEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberRemovedAuditEntryData")
		case "userID":
			out.Values[i] = ec._TeamMemberRemovedAuditEntryData_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userEmail":
			out.Values[i] = ec._TeamMemberRemovedAuditEntryData_userEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamMemberRemovedAuditEntryData_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberSetRoleAuditEntryImplementors = []string{"TeamMemberSetRoleAuditEntry", "AuditEntry", "Node"}

func (ec *executionContext) _TeamMemberSetRoleAuditEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberSetRoleAuditEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberSetRoleAuditEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberSetRoleAuditEntry")
		case "id":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberSetRoleAuditEntryDataImplementors = []string{"TeamMemberSetRoleAuditEntryData"}

func (ec *executionContext) _TeamMemberSetRoleAuditEntryData(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberSetRoleAuditEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberSetRoleAuditEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberSetRoleAuditEntryData")
		case "role":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntryData_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userID":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntryData_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userEmail":
			out.Values[i] = ec._TeamMemberSetRoleAuditEntryData_userEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamMemberSetRoleAuditEntryData_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamUpdatedAuditEntryImplementors = []string{"TeamUpdatedAuditEntry", "AuditEntry", "Node"}

func (ec *executionContext) _TeamUpdatedAuditEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamUpdatedAuditEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamUpdatedAuditEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamUpdatedAuditEntry")
		case "id":
			out.Values[i] = ec._TeamUpdatedAuditEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamUpdatedAuditEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamUpdatedAuditEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamUpdatedAuditEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamUpdatedAuditEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamUpdatedAuditEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamUpdatedAuditEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamUpdatedAuditEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._TeamUpdatedAuditEntry_data(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamUpdatedAuditEntryDataImplementors = []string{"TeamUpdatedAuditEntryData"}

func (ec *executionContext) _TeamUpdatedAuditEntryData(ctx context.Context, sel ast.SelectionSet, obj *team.TeamUpdatedAuditEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamUpdatedAuditEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamUpdatedAuditEntryData")
		case "updatedFields":
			out.Values[i] = ec._TeamUpdatedAuditEntryData_updatedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamUpdatedAuditEntryDataUpdatedFieldImplementors = []string{"TeamUpdatedAuditEntryDataUpdatedField"}

func (ec *executionContext) _TeamUpdatedAuditEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, obj *team.TeamUpdatedAuditEntryDataUpdatedField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamUpdatedAuditEntryDataUpdatedFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamUpdatedAuditEntryDataUpdatedField")
		case "field":
			out.Values[i] = ec._TeamUpdatedAuditEntryDataUpdatedField_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldValue":
			out.Values[i] = ec._TeamUpdatedAuditEntryDataUpdatedField_oldValue(ctx, field, obj)
		case "newValue":
			out.Values[i] = ec._TeamUpdatedAuditEntryDataUpdatedField_newValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamUtilizationDataImplementors = []string{"TeamUtilizationData"}

func (ec *executionContext) _TeamUtilizationData(ctx context.Context, sel ast.SelectionSet, obj *utilization.TeamUtilizationData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamUtilizationDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamUtilizationData")
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamUtilizationData_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "requested":
			out.Values[i] = ec._TeamUtilizationData_requested(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "used":
			out.Values[i] = ec._TeamUtilizationData_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamUtilizationData_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamUtilizationEnvironmentDataPointImplementors = []string{"TeamUtilizationEnvironmentDataPoint"}

func (ec *executionContext) _TeamUtilizationEnvironmentDataPoint(ctx context.Context, sel ast.SelectionSet, obj *utilization.TeamUtilizationEnvironmentDataPoint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamUtilizationEnvironmentDataPointImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamUtilizationEnvironmentDataPoint")
		case "value":
			out.Values[i] = ec._TeamUtilizationEnvironmentDataPoint_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamUtilizationEnvironmentDataPoint_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamVulnerabilitySummaryImplementors = []string{"TeamVulnerabilitySummary"}

func (ec *executionContext) _TeamVulnerabilitySummary(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.TeamVulnerabilitySummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamVulnerabilitySummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamVulnerabilitySummary")
		case "riskScore":
			out.Values[i] = ec._TeamVulnerabilitySummary_riskScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "critical":
			out.Values[i] = ec._TeamVulnerabilitySummary_critical(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "high":
			out.Values[i] = ec._TeamVulnerabilitySummary_high(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "medium":
			out.Values[i] = ec._TeamVulnerabilitySummary_medium(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "low":
			out.Values[i] = ec._TeamVulnerabilitySummary_low(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unassigned":
			out.Values[i] = ec._TeamVulnerabilitySummary_unassigned(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bomCount":
			out.Values[i] = ec._TeamVulnerabilitySummary_bomCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "coverage":
			out.Values[i] = ec._TeamVulnerabilitySummary_coverage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tokenXAuthIntegrationImplementors = []string{"TokenXAuthIntegration", "ApplicationAuthIntegrations", "AuthIntegration"}

func (ec *executionContext) _TokenXAuthIntegration(ctx context.Context, sel ast.SelectionSet, obj *workload.TokenXAuthIntegration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tokenXAuthIntegrationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TokenXAuthIntegration")
		case "name":
			out.Values[i] = ec._TokenXAuthIntegration_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTeamEnvironmentPayloadImplementors = []string{"UpdateTeamEnvironmentPayload"}

func (ec *executionContext) _UpdateTeamEnvironmentPayload(ctx context.Context, sel ast.SelectionSet, obj *team.UpdateTeamEnvironmentPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTeamEnvironmentPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTeamEnvironmentPayload")
		case "environment":
			out.Values[i] = ec._UpdateTeamEnvironmentPayload_environment(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTeamPayloadImplementors = []string{"UpdateTeamPayload"}

func (ec *executionContext) _UpdateTeamPayload(ctx context.Context, sel ast.SelectionSet, obj *team.UpdateTeamPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTeamPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTeamPayload")
		case "team":
			out.Values[i] = ec._UpdateTeamPayload_team(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User", "Node", "AuthenticatedUser"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *user.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "externalID":
			out.Values[i] = ec._User_externalID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_teams(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userConnectionImplementors = []string{"UserConnection"}

func (ec *executionContext) _UserConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*user.User]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConnection")
		case "pageInfo":
			out.Values[i] = ec._UserConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._UserConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._UserConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userEdgeImplementors = []string{"UserEdge"}

func (ec *executionContext) _UserEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*user.User]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserEdge")
		case "cursor":
			out.Values[i] = ec._UserEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._UserEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var utilizationDataPointImplementors = []string{"UtilizationDataPoint"}

func (ec *executionContext) _UtilizationDataPoint(ctx context.Context, sel ast.SelectionSet, obj *utilization.UtilizationDataPoint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, utilizationDataPointImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UtilizationDataPoint")
		case "timestamp":
			out.Values[i] = ec._UtilizationDataPoint_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._UtilizationDataPoint_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadConnectionImplementors = []string{"WorkloadConnection"}

func (ec *executionContext) _WorkloadConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[workload.Workload]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadConnection")
		case "pageInfo":
			out.Values[i] = ec._WorkloadConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._WorkloadConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._WorkloadConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadCostImplementors = []string{"WorkloadCost"}

func (ec *executionContext) _WorkloadCost(ctx context.Context, sel ast.SelectionSet, obj *cost.WorkloadCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadCost")
		case "daily":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadCost_daily(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "monthly":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadCost_monthly(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadCostPeriodImplementors = []string{"WorkloadCostPeriod"}

func (ec *executionContext) _WorkloadCostPeriod(ctx context.Context, sel ast.SelectionSet, obj *cost.WorkloadCostPeriod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadCostPeriodImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadCostPeriod")
		case "sum":
			out.Values[i] = ec._WorkloadCostPeriod_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "series":
			out.Values[i] = ec._WorkloadCostPeriod_series(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadEdgeImplementors = []string{"WorkloadEdge"}

func (ec *executionContext) _WorkloadEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[workload.Workload]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadEdge")
		case "cursor":
			out.Values[i] = ec._WorkloadEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._WorkloadEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadResourceQuantityImplementors = []string{"WorkloadResourceQuantity"}

func (ec *executionContext) _WorkloadResourceQuantity(ctx context.Context, sel ast.SelectionSet, obj *workload.WorkloadResourceQuantity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadResourceQuantityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadResourceQuantity")
		case "cpu":
			out.Values[i] = ec._WorkloadResourceQuantity_cpu(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "memory":
			out.Values[i] = ec._WorkloadResourceQuantity_memory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadUtilizationImplementors = []string{"WorkloadUtilization"}

func (ec *executionContext) _WorkloadUtilization(ctx context.Context, sel ast.SelectionSet, obj *utilization.WorkloadUtilization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadUtilizationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadUtilization")
		case "current":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadUtilization_current(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "requested":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadUtilization_requested(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "series":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadUtilization_series(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadUtilizationDataImplementors = []string{"WorkloadUtilizationData"}

func (ec *executionContext) _WorkloadUtilizationData(ctx context.Context, sel ast.SelectionSet, obj *utilization.WorkloadUtilizationData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadUtilizationDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadUtilizationData")
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadUtilizationData_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "requested":
			out.Values[i] = ec._WorkloadUtilizationData_requested(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "used":
			out.Values[i] = ec._WorkloadUtilizationData_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddRepositoryToTeamInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐAddRepositoryToTeamInput(ctx context.Context, v interface{}) (repository.AddRepositoryToTeamInput, error) {
	res, err := ec.unmarshalInputAddRepositoryToTeamInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddRepositoryToTeamPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐAddRepositoryToTeamPayload(ctx context.Context, sel ast.SelectionSet, v repository.AddRepositoryToTeamPayload) graphql.Marshaler {
	return ec._AddRepositoryToTeamPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAddRepositoryToTeamPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐAddRepositoryToTeamPayload(ctx context.Context, sel ast.SelectionSet, v *repository.AddRepositoryToTeamPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AddRepositoryToTeamPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAddTeamMemberInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐAddTeamMemberInput(ctx context.Context, v interface{}) (team.AddTeamMemberInput, error) {
	res, err := ec.unmarshalInputAddTeamMemberInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddTeamMemberPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐAddTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, v team.AddTeamMemberPayload) graphql.Marshaler {
	return ec._AddTeamMemberPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAddTeamMemberPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐAddTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, v *team.AddTeamMemberPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AddTeamMemberPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNApplication2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplication(ctx context.Context, sel ast.SelectionSet, v application.Application) graphql.Marshaler {
	return ec._Application(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplication2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationᚄ(ctx context.Context, sel ast.SelectionSet, v []*application.Application) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplication(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplication(ctx context.Context, sel ast.SelectionSet, v *application.Application) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationAuthIntegrations2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐApplicationAuthIntegrations(ctx context.Context, sel ast.SelectionSet, v workload.ApplicationAuthIntegrations) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationAuthIntegrations(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationAuthIntegrations2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐApplicationAuthIntegrationsᚄ(ctx context.Context, sel ast.SelectionSet, v []workload.ApplicationAuthIntegrations) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationAuthIntegrations2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐApplicationAuthIntegrations(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*application.Application]) graphql.Marshaler {
	return ec._ApplicationConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*application.Application]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*application.Application]) graphql.Marshaler {
	return ec._ApplicationEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*application.Application]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationManifest2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationManifest(ctx context.Context, sel ast.SelectionSet, v application.ApplicationManifest) graphql.Marshaler {
	return ec._ApplicationManifest(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationManifest2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationManifest(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationManifest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationManifest(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationOrderField(ctx context.Context, v interface{}) (application.ApplicationOrderField, error) {
	var res application.ApplicationOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationOrderField(ctx context.Context, sel ast.SelectionSet, v application.ApplicationOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNApplicationResources2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationResources(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationResources) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationResources(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationScaling2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationScaling(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationScaling) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationScaling(ctx, sel, v)
}

func (ec *executionContext) marshalNAuditEntry2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditEntry(ctx context.Context, sel ast.SelectionSet, v auditv1.AuditEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuditEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNAuditEntry2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []auditv1.AuditEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAuditEntry2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAuditEntryConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[auditv1.AuditEntry]) graphql.Marshaler {
	return ec._AuditEntryConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNAuditEntryConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[auditv1.AuditEntry]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuditEntryConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNAuditEntryEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[auditv1.AuditEntry]) graphql.Marshaler {
	return ec._AuditEntryEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNAuditEntryEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[auditv1.AuditEntry]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAuditEntryEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNAuditResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditResourceType(ctx context.Context, v interface{}) (auditv1.AuditResourceType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := auditv1.AuditResourceType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAuditResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋauditv1ᚐAuditResourceType(ctx context.Context, sel ast.SelectionSet, v auditv1.AuditResourceType) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNAuthenticatedUser2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐAuthenticatedUser(ctx context.Context, sel ast.SelectionSet, v user.AuthenticatedUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthenticatedUser(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDataset2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDataset(ctx context.Context, sel ast.SelectionSet, v bigquery.BigQueryDataset) graphql.Marshaler {
	return ec._BigQueryDataset(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDataset2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetᚄ(ctx context.Context, sel ast.SelectionSet, v []*bigquery.BigQueryDataset) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBigQueryDataset2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDataset(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBigQueryDataset2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDataset(ctx context.Context, sel ast.SelectionSet, v *bigquery.BigQueryDataset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDataset(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDatasetAccess2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetAccessᚄ(ctx context.Context, sel ast.SelectionSet, v []*bigquery.BigQueryDatasetAccess) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBigQueryDatasetAccess2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBigQueryDatasetAccess2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetAccess(ctx context.Context, sel ast.SelectionSet, v *bigquery.BigQueryDatasetAccess) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDatasetAccess(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDatasetAccessConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	return ec._BigQueryDatasetAccessConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDatasetAccessConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDatasetAccessConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDatasetAccessEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	return ec._BigQueryDatasetAccessEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDatasetAccessEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBigQueryDatasetAccessEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNBigQueryDatasetAccessOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetAccessOrderField(ctx context.Context, v interface{}) (bigquery.BigQueryDatasetAccessOrderField, error) {
	var res bigquery.BigQueryDatasetAccessOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBigQueryDatasetAccessOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetAccessOrderField(ctx context.Context, sel ast.SelectionSet, v bigquery.BigQueryDatasetAccessOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBigQueryDatasetConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*bigquery.BigQueryDataset]) graphql.Marshaler {
	return ec._BigQueryDatasetConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDatasetConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*bigquery.BigQueryDataset]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDatasetConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDatasetCost2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐBigQueryDatasetCost(ctx context.Context, sel ast.SelectionSet, v cost.BigQueryDatasetCost) graphql.Marshaler {
	return ec._BigQueryDatasetCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDatasetCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐBigQueryDatasetCost(ctx context.Context, sel ast.SelectionSet, v *cost.BigQueryDatasetCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDatasetCost(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDatasetEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*bigquery.BigQueryDataset]) graphql.Marshaler {
	return ec._BigQueryDatasetEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDatasetEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*bigquery.BigQueryDataset]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBigQueryDatasetEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNBigQueryDatasetOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetOrderField(ctx context.Context, v interface{}) (bigquery.BigQueryDatasetOrderField, error) {
	var res bigquery.BigQueryDatasetOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBigQueryDatasetOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetOrderField(ctx context.Context, sel ast.SelectionSet, v bigquery.BigQueryDatasetOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBigQueryDatasetStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetStatus(ctx context.Context, sel ast.SelectionSet, v *bigquery.BigQueryDatasetStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDatasetStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBucket2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucket(ctx context.Context, sel ast.SelectionSet, v bucket.Bucket) graphql.Marshaler {
	return ec._Bucket(ctx, sel, &v)
}

func (ec *executionContext) marshalNBucket2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucketᚄ(ctx context.Context, sel ast.SelectionSet, v []*bucket.Bucket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBucket2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBucket2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucket(ctx context.Context, sel ast.SelectionSet, v *bucket.Bucket) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Bucket(ctx, sel, v)
}

func (ec *executionContext) marshalNBucketConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*bucket.Bucket]) graphql.Marshaler {
	return ec._BucketConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNBucketConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*bucket.Bucket]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BucketConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNBucketEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*bucket.Bucket]) graphql.Marshaler {
	return ec._BucketEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNBucketEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*bucket.Bucket]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBucketEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNBucketOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucketOrderField(ctx context.Context, v interface{}) (bucket.BucketOrderField, error) {
	var res bucket.BucketOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBucketOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucketOrderField(ctx context.Context, sel ast.SelectionSet, v bucket.BucketOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBucketStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucketStatus(ctx context.Context, sel ast.SelectionSet, v *bucket.BucketStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BucketStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConfirmTeamDeletionInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐConfirmTeamDeletionInput(ctx context.Context, v interface{}) (team.ConfirmTeamDeletionInput, error) {
	res, err := ec.unmarshalInputConfirmTeamDeletionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConfirmTeamDeletionPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐConfirmTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, v team.ConfirmTeamDeletionPayload) graphql.Marshaler {
	return ec._ConfirmTeamDeletionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfirmTeamDeletionPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐConfirmTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, v *team.ConfirmTeamDeletionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConfirmTeamDeletionPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNContainerImage2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐContainerImage(ctx context.Context, sel ast.SelectionSet, v *workload.ContainerImage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ContainerImage(ctx, sel, v)
}

func (ec *executionContext) marshalNContainerImageWorkloadReference2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐContainerImageWorkloadReferenceᚄ(ctx context.Context, sel ast.SelectionSet, v []*vulnerability.ContainerImageWorkloadReference) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContainerImageWorkloadReference2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐContainerImageWorkloadReference(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNContainerImageWorkloadReference2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐContainerImageWorkloadReference(ctx context.Context, sel ast.SelectionSet, v *vulnerability.ContainerImageWorkloadReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ContainerImageWorkloadReference(ctx, sel, v)
}

func (ec *executionContext) marshalNContainerImageWorkloadReferenceConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	return ec._ContainerImageWorkloadReferenceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNContainerImageWorkloadReferenceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ContainerImageWorkloadReferenceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNContainerImageWorkloadReferenceEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	return ec._ContainerImageWorkloadReferenceEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNContainerImageWorkloadReferenceEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContainerImageWorkloadReferenceEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNCreateTeamInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐCreateTeamInput(ctx context.Context, v interface{}) (team.CreateTeamInput, error) {
	res, err := ec.unmarshalInputCreateTeamInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateTeamPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐCreateTeamPayload(ctx context.Context, sel ast.SelectionSet, v team.CreateTeamPayload) graphql.Marshaler {
	return ec._CreateTeamPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateTeamPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐCreateTeamPayload(ctx context.Context, sel ast.SelectionSet, v *team.CreateTeamPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateTeamPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx context.Context, v interface{}) (pagination.Cursor, error) {
	var res pagination.Cursor
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx context.Context, sel ast.SelectionSet, v pagination.Cursor) graphql.Marshaler {
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) unmarshalNDate2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋscalarᚐDate(ctx context.Context, v interface{}) (scalar.Date, error) {
	var res scalar.Date
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋscalarᚐDate(ctx context.Context, sel ast.SelectionSet, v scalar.Date) graphql.Marshaler {
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) unmarshalNDeleteApplicationInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐDeleteApplicationInput(ctx context.Context, v interface{}) (application.DeleteApplicationInput, error) {
	res, err := ec.unmarshalInputDeleteApplicationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteApplicationPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐDeleteApplicationPayload(ctx context.Context, sel ast.SelectionSet, v application.DeleteApplicationPayload) graphql.Marshaler {
	return ec._DeleteApplicationPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteApplicationPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐDeleteApplicationPayload(ctx context.Context, sel ast.SelectionSet, v *application.DeleteApplicationPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteApplicationPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteJobInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐDeleteJobInput(ctx context.Context, v interface{}) (job.DeleteJobInput, error) {
	res, err := ec.unmarshalInputDeleteJobInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteJobPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐDeleteJobPayload(ctx context.Context, sel ast.SelectionSet, v job.DeleteJobPayload) graphql.Marshaler {
	return ec._DeleteJobPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteJobPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐDeleteJobPayload(ctx context.Context, sel ast.SelectionSet, v *job.DeleteJobPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteJobPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNExternalNetworkPolicyTarget2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐExternalNetworkPolicyTarget(ctx context.Context, sel ast.SelectionSet, v netpol.ExternalNetworkPolicyTarget) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExternalNetworkPolicyTarget(ctx, sel, v)
}

func (ec *executionContext) marshalNExternalNetworkPolicyTarget2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐExternalNetworkPolicyTargetᚄ(ctx context.Context, sel ast.SelectionSet, v []netpol.ExternalNetworkPolicyTarget) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExternalNetworkPolicyTarget2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐExternalNetworkPolicyTarget(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx context.Context, v interface{}) (ident.Ident, error) {
	var res ident.Ident
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋidentᚐIdent(ctx context.Context, sel ast.SelectionSet, v ident.Ident) graphql.Marshaler {
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) marshalNImageVulnerability2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilityᚄ(ctx context.Context, sel ast.SelectionSet, v []*vulnerability.ImageVulnerability) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageVulnerability2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerability(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNImageVulnerability2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerability(ctx context.Context, sel ast.SelectionSet, v *vulnerability.ImageVulnerability) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageVulnerability(ctx, sel, v)
}

func (ec *executionContext) marshalNImageVulnerabilityConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	return ec._ImageVulnerabilityConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageVulnerabilityConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageVulnerabilityConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNImageVulnerabilityEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	return ec._ImageVulnerabilityEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageVulnerabilityEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageVulnerabilityEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNImageVulnerabilityOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilityOrderField(ctx context.Context, v interface{}) (vulnerability.ImageVulnerabilityOrderField, error) {
	var res vulnerability.ImageVulnerabilityOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageVulnerabilityOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilityOrderField(ctx context.Context, sel ast.SelectionSet, v vulnerability.ImageVulnerabilityOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNImageVulnerabilitySeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilitySeverity(ctx context.Context, v interface{}) (vulnerability.ImageVulnerabilitySeverity, error) {
	var res vulnerability.ImageVulnerabilitySeverity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageVulnerabilitySeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilitySeverity(ctx context.Context, sel ast.SelectionSet, v vulnerability.ImageVulnerabilitySeverity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNImageVulnerabilityState2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilityState(ctx context.Context, v interface{}) (vulnerability.ImageVulnerabilityState, error) {
	var res vulnerability.ImageVulnerabilityState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageVulnerabilityState2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilityState(ctx context.Context, sel ast.SelectionSet, v vulnerability.ImageVulnerabilityState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNInboundNetworkPolicy2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐInboundNetworkPolicy(ctx context.Context, sel ast.SelectionSet, v *netpol.InboundNetworkPolicy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InboundNetworkPolicy(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int32(ctx context.Context, v interface{}) (int32, error) {
	res, err := graphql.UnmarshalInt32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	res := graphql.MarshalInt32(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJob2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJob(ctx context.Context, sel ast.SelectionSet, v job.Job) graphql.Marshaler {
	return ec._Job(ctx, sel, &v)
}

func (ec *executionContext) marshalNJob2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobᚄ(ctx context.Context, sel ast.SelectionSet, v []*job.Job) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJob2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJob(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJob2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJob(ctx context.Context, sel ast.SelectionSet, v *job.Job) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Job(ctx, sel, v)
}

func (ec *executionContext) marshalNJobAuthIntegrations2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐJobAuthIntegrations(ctx context.Context, sel ast.SelectionSet, v workload.JobAuthIntegrations) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobAuthIntegrations(ctx, sel, v)
}

func (ec *executionContext) marshalNJobAuthIntegrations2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐJobAuthIntegrationsᚄ(ctx context.Context, sel ast.SelectionSet, v []workload.JobAuthIntegrations) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobAuthIntegrations2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐJobAuthIntegrations(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJobConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*job.Job]) graphql.Marshaler {
	return ec._JobConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*job.Job]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNJobEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*job.Job]) graphql.Marshaler {
	return ec._JobEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*job.Job]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJobManifest2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobManifest(ctx context.Context, sel ast.SelectionSet, v job.JobManifest) graphql.Marshaler {
	return ec._JobManifest(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobManifest2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobManifest(ctx context.Context, sel ast.SelectionSet, v *job.JobManifest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobManifest(ctx, sel, v)
}

func (ec *executionContext) unmarshalNJobOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobOrderField(ctx context.Context, v interface{}) (job.JobOrderField, error) {
	var res job.JobOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobOrderField(ctx context.Context, sel ast.SelectionSet, v job.JobOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNJobResources2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobResources(ctx context.Context, sel ast.SelectionSet, v *job.JobResources) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobResources(ctx, sel, v)
}

func (ec *executionContext) marshalNJobRun2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobRunᚄ(ctx context.Context, sel ast.SelectionSet, v []*job.JobRun) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobRun2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobRun(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJobRun2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobRun(ctx context.Context, sel ast.SelectionSet, v *job.JobRun) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobRun(ctx, sel, v)
}

func (ec *executionContext) marshalNJobRunConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*job.JobRun]) graphql.Marshaler {
	return ec._JobRunConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobRunConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*job.JobRun]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobRunConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNJobRunEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*job.JobRun]) graphql.Marshaler {
	return ec._JobRunEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobRunEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*job.JobRun]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobRunEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNJobRunStatus2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobRunStatus(ctx context.Context, v interface{}) (job.JobRunStatus, error) {
	var res job.JobRunStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobRunStatus2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobRunStatus(ctx context.Context, sel ast.SelectionSet, v job.JobRunStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNKafkaTopic2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopic(ctx context.Context, sel ast.SelectionSet, v kafkatopic.KafkaTopic) graphql.Marshaler {
	return ec._KafkaTopic(ctx, sel, &v)
}

func (ec *executionContext) marshalNKafkaTopic2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicᚄ(ctx context.Context, sel ast.SelectionSet, v []*kafkatopic.KafkaTopic) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKafkaTopic2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopic(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNKafkaTopic2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopic(ctx context.Context, sel ast.SelectionSet, v *kafkatopic.KafkaTopic) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KafkaTopic(ctx, sel, v)
}

func (ec *executionContext) marshalNKafkaTopicAcl2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACLᚄ(ctx context.Context, sel ast.SelectionSet, v []*kafkatopic.KafkaTopicACL) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKafkaTopicAcl2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACL(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNKafkaTopicAcl2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACL(ctx context.Context, sel ast.SelectionSet, v *kafkatopic.KafkaTopicACL) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KafkaTopicAcl(ctx, sel, v)
}

func (ec *executionContext) marshalNKafkaTopicAclConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	return ec._KafkaTopicAclConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNKafkaTopicAclConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KafkaTopicAclConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNKafkaTopicAclEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	return ec._KafkaTopicAclEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNKafkaTopicAclEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKafkaTopicAclEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNKafkaTopicAclOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACLOrderField(ctx context.Context, v interface{}) (kafkatopic.KafkaTopicACLOrderField, error) {
	var res kafkatopic.KafkaTopicACLOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKafkaTopicAclOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACLOrderField(ctx context.Context, sel ast.SelectionSet, v kafkatopic.KafkaTopicACLOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNKafkaTopicConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	return ec._KafkaTopicConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNKafkaTopicConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KafkaTopicConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNKafkaTopicEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	return ec._KafkaTopicEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNKafkaTopicEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKafkaTopicEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNKafkaTopicOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicOrderField(ctx context.Context, v interface{}) (kafkatopic.KafkaTopicOrderField, error) {
	var res kafkatopic.KafkaTopicOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKafkaTopicOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicOrderField(ctx context.Context, sel ast.SelectionSet, v kafkatopic.KafkaTopicOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNKafkaTopicStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicStatus(ctx context.Context, sel ast.SelectionSet, v *kafkatopic.KafkaTopicStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KafkaTopicStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNNetworkPolicy2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐNetworkPolicy(ctx context.Context, sel ast.SelectionSet, v netpol.NetworkPolicy) graphql.Marshaler {
	return ec._NetworkPolicy(ctx, sel, &v)
}

func (ec *executionContext) marshalNNetworkPolicy2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐNetworkPolicy(ctx context.Context, sel ast.SelectionSet, v *netpol.NetworkPolicy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NetworkPolicy(ctx, sel, v)
}

func (ec *executionContext) marshalNNetworkPolicyRule2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐNetworkPolicyRuleᚄ(ctx context.Context, sel ast.SelectionSet, v []*netpol.NetworkPolicyRule) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNetworkPolicyRule2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐNetworkPolicyRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNetworkPolicyRule2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐNetworkPolicyRule(ctx context.Context, sel ast.SelectionSet, v *netpol.NetworkPolicyRule) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NetworkPolicyRule(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearch2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearch(ctx context.Context, sel ast.SelectionSet, v opensearch.OpenSearch) graphql.Marshaler {
	return ec._OpenSearch(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearch2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchᚄ(ctx context.Context, sel ast.SelectionSet, v []*opensearch.OpenSearch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOpenSearch2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOpenSearch2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearch(ctx context.Context, sel ast.SelectionSet, v *opensearch.OpenSearch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearch(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearchAccess2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchAccessᚄ(ctx context.Context, sel ast.SelectionSet, v []*opensearch.OpenSearchAccess) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOpenSearchAccess2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOpenSearchAccess2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchAccess(ctx context.Context, sel ast.SelectionSet, v *opensearch.OpenSearchAccess) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearchAccess(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearchAccessConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	return ec._OpenSearchAccessConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearchAccessConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearchAccessConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearchAccessEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	return ec._OpenSearchAccessEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearchAccessEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOpenSearchAccessEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNOpenSearchAccessOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchAccessOrderField(ctx context.Context, v interface{}) (opensearch.OpenSearchAccessOrderField, error) {
	var res opensearch.OpenSearchAccessOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOpenSearchAccessOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchAccessOrderField(ctx context.Context, sel ast.SelectionSet, v opensearch.OpenSearchAccessOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOpenSearchConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*opensearch.OpenSearch]) graphql.Marshaler {
	return ec._OpenSearchConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearchConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*opensearch.OpenSearch]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearchConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearchCost2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐOpenSearchCost(ctx context.Context, sel ast.SelectionSet, v cost.OpenSearchCost) graphql.Marshaler {
	return ec._OpenSearchCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearchCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐOpenSearchCost(ctx context.Context, sel ast.SelectionSet, v *cost.OpenSearchCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearchCost(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearchEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*opensearch.OpenSearch]) graphql.Marshaler {
	return ec._OpenSearchEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearchEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*opensearch.OpenSearch]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOpenSearchEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNOpenSearchOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchOrderField(ctx context.Context, v interface{}) (opensearch.OpenSearchOrderField, error) {
	var res opensearch.OpenSearchOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOpenSearchOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchOrderField(ctx context.Context, sel ast.SelectionSet, v opensearch.OpenSearchOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOpenSearchStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchStatus(ctx context.Context, sel ast.SelectionSet, v *opensearch.OpenSearchStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearchStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx context.Context, v interface{}) (modelv1.OrderDirection, error) {
	var res modelv1.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐOrderDirection(ctx context.Context, sel ast.SelectionSet, v modelv1.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOutboundNetworkPolicy2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋnetpolᚐOutboundNetworkPolicy(ctx context.Context, sel ast.SelectionSet, v *netpol.OutboundNetworkPolicy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OutboundNetworkPolicy(ctx, sel, v)
}

func (ec *executionContext) marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v pagination.PageInfo) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconciler2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconciler(ctx context.Context, sel ast.SelectionSet, v reconciler.Reconciler) graphql.Marshaler {
	return ec._Reconciler(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconciler2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconcilerᚄ(ctx context.Context, sel ast.SelectionSet, v []*reconciler.Reconciler) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReconciler2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconciler(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNReconciler2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconciler(ctx context.Context, sel ast.SelectionSet, v *reconciler.Reconciler) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Reconciler(ctx, sel, v)
}

func (ec *executionContext) marshalNReconcilerConfig2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconcilerConfigᚄ(ctx context.Context, sel ast.SelectionSet, v []*reconciler.ReconcilerConfig) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReconcilerConfig2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconcilerConfig(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNReconcilerConfig2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconcilerConfig(ctx context.Context, sel ast.SelectionSet, v *reconciler.ReconcilerConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ReconcilerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNReconcilerConfigInput2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconcilerConfigInputᚄ(ctx context.Context, v interface{}) ([]*reconciler.ReconcilerConfigInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*reconciler.ReconcilerConfigInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNReconcilerConfigInput2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconcilerConfigInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNReconcilerConfigInput2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋreconcilerᚐReconcilerConfigInput(ctx context.Context, v interface{}) (*reconciler.ReconcilerConfigInput, error) {
	res, err := ec.unmarshalInputReconcilerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNReconcilerConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*reconciler.Reconciler]) graphql.Marshaler {
	return ec._ReconcilerConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconcilerConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*reconciler.Reconciler]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ReconcilerConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNReconcilerEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*reconciler.Reconciler]) graphql.Marshaler {
	return ec._ReconcilerEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconcilerEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*reconciler.Reconciler]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReconcilerEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRedisInstance2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstance(ctx context.Context, sel ast.SelectionSet, v redis.RedisInstance) graphql.Marshaler {
	return ec._RedisInstance(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstance2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceᚄ(ctx context.Context, sel ast.SelectionSet, v []*redis.RedisInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRedisInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRedisInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstance(ctx context.Context, sel ast.SelectionSet, v *redis.RedisInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNRedisInstanceAccess2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceAccessᚄ(ctx context.Context, sel ast.SelectionSet, v []*redis.RedisInstanceAccess) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRedisInstanceAccess2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRedisInstanceAccess2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceAccess(ctx context.Context, sel ast.SelectionSet, v *redis.RedisInstanceAccess) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstanceAccess(ctx, sel, v)
}

func (ec *executionContext) marshalNRedisInstanceAccessConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*redis.RedisInstanceAccess]) graphql.Marshaler {
	return ec._RedisInstanceAccessConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstanceAccessConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*redis.RedisInstanceAccess]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstanceAccessConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNRedisInstanceAccessEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*redis.RedisInstanceAccess]) graphql.Marshaler {
	return ec._RedisInstanceAccessEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstanceAccessEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*redis.RedisInstanceAccess]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRedisInstanceAccessEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNRedisInstanceAccessOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceAccessOrderField(ctx context.Context, v interface{}) (redis.RedisInstanceAccessOrderField, error) {
	var res redis.RedisInstanceAccessOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRedisInstanceAccessOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceAccessOrderField(ctx context.Context, sel ast.SelectionSet, v redis.RedisInstanceAccessOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRedisInstanceConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*redis.RedisInstance]) graphql.Marshaler {
	return ec._RedisInstanceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*redis.RedisInstance]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstanceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNRedisInstanceCost2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐRedisInstanceCost(ctx context.Context, sel ast.SelectionSet, v cost.RedisInstanceCost) graphql.Marshaler {
	return ec._RedisInstanceCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstanceCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐRedisInstanceCost(ctx context.Context, sel ast.SelectionSet, v *cost.RedisInstanceCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstanceCost(ctx, sel, v)
}

func (ec *executionContext) marshalNRedisInstanceEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*redis.RedisInstance]) graphql.Marshaler {
	return ec._RedisInstanceEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstanceEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*redis.RedisInstance]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRedisInstanceEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNRedisInstanceOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceOrderField(ctx context.Context, v interface{}) (redis.RedisInstanceOrderField, error) {
	var res redis.RedisInstanceOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRedisInstanceOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceOrderField(ctx context.Context, sel ast.SelectionSet, v redis.RedisInstanceOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRedisInstanceStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceStatus(ctx context.Context, sel ast.SelectionSet, v *redis.RedisInstanceStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstanceStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRemoveRepositoryFromTeamInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRemoveRepositoryFromTeamInput(ctx context.Context, v interface{}) (repository.RemoveRepositoryFromTeamInput, error) {
	res, err := ec.unmarshalInputRemoveRepositoryFromTeamInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRemoveRepositoryFromTeamPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRemoveRepositoryFromTeamPayload(ctx context.Context, sel ast.SelectionSet, v repository.RemoveRepositoryFromTeamPayload) graphql.Marshaler {
	return ec._RemoveRepositoryFromTeamPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRemoveRepositoryFromTeamPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRemoveRepositoryFromTeamPayload(ctx context.Context, sel ast.SelectionSet, v *repository.RemoveRepositoryFromTeamPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RemoveRepositoryFromTeamPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRemoveTeamMemberInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐRemoveTeamMemberInput(ctx context.Context, v interface{}) (team.RemoveTeamMemberInput, error) {
	res, err := ec.unmarshalInputRemoveTeamMemberInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRemoveTeamMemberPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐRemoveTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, v team.RemoveTeamMemberPayload) graphql.Marshaler {
	return ec._RemoveTeamMemberPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRemoveTeamMemberPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐRemoveTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, v *team.RemoveTeamMemberPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RemoveTeamMemberPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNRepository2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRepositoryᚄ(ctx context.Context, sel ast.SelectionSet, v []*repository.Repository) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepository2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRepository(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRepository2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRepository(ctx context.Context, sel ast.SelectionSet, v *repository.Repository) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositoryConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*repository.Repository]) graphql.Marshaler {
	return ec._RepositoryConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepositoryConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*repository.Repository]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepositoryConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositoryEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*repository.Repository]) graphql.Marshaler {
	return ec._RepositoryEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepositoryEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*repository.Repository]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepositoryEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNRequestTeamDeletionInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐRequestTeamDeletionInput(ctx context.Context, v interface{}) (team.RequestTeamDeletionInput, error) {
	res, err := ec.unmarshalInputRequestTeamDeletionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRequestTeamDeletionPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐRequestTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, v team.RequestTeamDeletionPayload) graphql.Marshaler {
	return ec._RequestTeamDeletionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRequestTeamDeletionPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐRequestTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, v *team.RequestTeamDeletionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RequestTeamDeletionPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRestartApplicationInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐRestartApplicationInput(ctx context.Context, v interface{}) (application.RestartApplicationInput, error) {
	res, err := ec.unmarshalInputRestartApplicationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRestartApplicationPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐRestartApplicationPayload(ctx context.Context, sel ast.SelectionSet, v application.RestartApplicationPayload) graphql.Marshaler {
	return ec._RestartApplicationPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRestartApplicationPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐRestartApplicationPayload(ctx context.Context, sel ast.SelectionSet, v *application.RestartApplicationPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RestartApplicationPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNScalingStrategy2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐScalingStrategy(ctx context.Context, sel ast.SelectionSet, v application.ScalingStrategy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScalingStrategy(ctx, sel, v)
}

func (ec *executionContext) marshalNScalingStrategy2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐScalingStrategyᚄ(ctx context.Context, sel ast.SelectionSet, v []application.ScalingStrategy) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNScalingStrategy2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐScalingStrategy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSearchFilter2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋsearchv1ᚐSearchFilter(ctx context.Context, v interface{}) (searchv1.SearchFilter, error) {
	res, err := ec.unmarshalInputSearchFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSearchNode2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋsearchv1ᚐSearchNode(ctx context.Context, sel ast.SelectionSet, v searchv1.SearchNode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchNode(ctx, sel, v)
}

func (ec *executionContext) marshalNSearchNode2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋsearchv1ᚐSearchNodeᚄ(ctx context.Context, sel ast.SelectionSet, v []searchv1.SearchNode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSearchNode2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋsearchv1ᚐSearchNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSearchNodeConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[searchv1.SearchNode]) graphql.Marshaler {
	return ec._SearchNodeConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchNodeConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[searchv1.SearchNode]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchNodeConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNSearchNodeEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[searchv1.SearchNode]) graphql.Marshaler {
	return ec._SearchNodeEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchNodeEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[searchv1.SearchNode]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSearchNodeEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServiceCost2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐServiceCostᚄ(ctx context.Context, sel ast.SelectionSet, v []*cost.ServiceCost) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServiceCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐServiceCost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServiceCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐServiceCost(ctx context.Context, sel ast.SelectionSet, v *cost.ServiceCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceCost(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceCostSeries2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐServiceCostSeriesᚄ(ctx context.Context, sel ast.SelectionSet, v []*cost.ServiceCostSeries) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServiceCostSeries2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐServiceCostSeries(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServiceCostSeries2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐServiceCostSeries(ctx context.Context, sel ast.SelectionSet, v *cost.ServiceCostSeries) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceCostSeries(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSetTeamMemberRoleInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐSetTeamMemberRoleInput(ctx context.Context, v interface{}) (team.SetTeamMemberRoleInput, error) {
	res, err := ec.unmarshalInputSetTeamMemberRoleInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSetTeamMemberRolePayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐSetTeamMemberRolePayload(ctx context.Context, sel ast.SelectionSet, v team.SetTeamMemberRolePayload) graphql.Marshaler {
	return ec._SetTeamMemberRolePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetTeamMemberRolePayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐSetTeamMemberRolePayload(ctx context.Context, sel ast.SelectionSet, v *team.SetTeamMemberRolePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SetTeamMemberRolePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx context.Context, v interface{}) (slug.Slug, error) {
	var res slug.Slug
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx context.Context, sel ast.SelectionSet, v slug.Slug) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx context.Context, v interface{}) (*slug.Slug, error) {
	var res = new(slug.Slug)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx context.Context, sel ast.SelectionSet, v *slug.Slug) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNSqlInstance2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstance(ctx context.Context, sel ast.SelectionSet, v sqlinstance.SQLInstance) graphql.Marshaler {
	return ec._SqlInstance(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstance2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceᚄ(ctx context.Context, sel ast.SelectionSet, v []*sqlinstance.SQLInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSqlInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstance(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*sqlinstance.SQLInstance]) graphql.Marshaler {
	return ec._SqlInstanceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*sqlinstance.SQLInstance]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*sqlinstance.SQLInstance]) graphql.Marshaler {
	return ec._SqlInstanceEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*sqlinstance.SQLInstance]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstanceEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSqlInstanceFlag2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceFlagᚄ(ctx context.Context, sel ast.SelectionSet, v []*sqlinstance.SQLInstanceFlag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstanceFlag2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceFlag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSqlInstanceFlag2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceFlag(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceFlag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceFlag(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceFlagConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	return ec._SqlInstanceFlagConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceFlagConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceFlagConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceFlagEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	return ec._SqlInstanceFlagEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceFlagEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstanceFlagEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSqlInstanceOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceOrderField(ctx context.Context, v interface{}) (sqlinstance.SQLInstanceOrderField, error) {
	var res sqlinstance.SQLInstanceOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSqlInstanceOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceOrderField(ctx context.Context, sel ast.SelectionSet, v sqlinstance.SQLInstanceOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSqlInstanceStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceStatus(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceUser2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*sqlinstance.SQLInstanceUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstanceUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSqlInstanceUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceUser(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceUser(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceUserConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	return ec._SqlInstanceUserConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceUserConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceUserConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceUserEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	return ec._SqlInstanceUserEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceUserEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstanceUserEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSqlInstanceUserOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceUserOrderField(ctx context.Context, v interface{}) (sqlinstance.SQLInstanceUserOrderField, error) {
	var res sqlinstance.SQLInstanceUserOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSqlInstanceUserOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceUserOrderField(ctx context.Context, sel ast.SelectionSet, v sqlinstance.SQLInstanceUserOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSynchronizeTeamInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐSynchronizeTeamInput(ctx context.Context, v interface{}) (team.SynchronizeTeamInput, error) {
	res, err := ec.unmarshalInputSynchronizeTeamInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSynchronizeTeamPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐSynchronizeTeamPayload(ctx context.Context, sel ast.SelectionSet, v team.SynchronizeTeamPayload) graphql.Marshaler {
	return ec._SynchronizeTeamPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSynchronizeTeamPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐSynchronizeTeamPayload(ctx context.Context, sel ast.SelectionSet, v *team.SynchronizeTeamPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SynchronizeTeamPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNTeam2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx context.Context, sel ast.SelectionSet, v team.Team) graphql.Marshaler {
	return ec._Team(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeam2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamᚄ(ctx context.Context, sel ast.SelectionSet, v []*team.Team) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx context.Context, sel ast.SelectionSet, v *team.Team) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Team(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*team.Team]) graphql.Marshaler {
	return ec._TeamConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*team.Team]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamCost2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCost(ctx context.Context, sel ast.SelectionSet, v cost.TeamCost) graphql.Marshaler {
	return ec._TeamCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCost(ctx context.Context, sel ast.SelectionSet, v *cost.TeamCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamCost(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamCostMonthlySample2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCostMonthlySampleᚄ(ctx context.Context, sel ast.SelectionSet, v []*cost.TeamCostMonthlySample) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamCostMonthlySample2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCostMonthlySample(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamCostMonthlySample2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCostMonthlySample(ctx context.Context, sel ast.SelectionSet, v *cost.TeamCostMonthlySample) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamCostMonthlySample(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamCostMonthlySummary2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCostMonthlySummary(ctx context.Context, sel ast.SelectionSet, v cost.TeamCostMonthlySummary) graphql.Marshaler {
	return ec._TeamCostMonthlySummary(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamCostMonthlySummary2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCostMonthlySummary(ctx context.Context, sel ast.SelectionSet, v *cost.TeamCostMonthlySummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamCostMonthlySummary(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamCostPeriod2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCostPeriod(ctx context.Context, sel ast.SelectionSet, v cost.TeamCostPeriod) graphql.Marshaler {
	return ec._TeamCostPeriod(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamCostPeriod2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐTeamCostPeriod(ctx context.Context, sel ast.SelectionSet, v *cost.TeamCostPeriod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamCostPeriod(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamDeleteKey2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamDeleteKey(ctx context.Context, sel ast.SelectionSet, v team.TeamDeleteKey) graphql.Marshaler {
	return ec._TeamDeleteKey(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamDeleteKey2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamDeleteKey(ctx context.Context, sel ast.SelectionSet, v *team.TeamDeleteKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamDeleteKey(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*team.Team]) graphql.Marshaler {
	return ec._TeamEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*team.Team]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamEnvironment2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx context.Context, sel ast.SelectionSet, v team.TeamEnvironment) graphql.Marshaler {
	return ec._TeamEnvironment(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamEnvironment2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironmentᚄ(ctx context.Context, sel ast.SelectionSet, v []*team.TeamEnvironment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx context.Context, sel ast.SelectionSet, v *team.TeamEnvironment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamEnvironment(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamEnvironmentUpdatedAuditEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironmentUpdatedAuditEntryData(ctx context.Context, sel ast.SelectionSet, v *team.TeamEnvironmentUpdatedAuditEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamEnvironmentUpdatedAuditEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamEnvironmentUpdatedAuditEntryDataUpdatedField2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironmentUpdatedAuditEntryDataUpdatedFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []*team.TeamEnvironmentUpdatedAuditEntryDataUpdatedField) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamEnvironmentUpdatedAuditEntryDataUpdatedField2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironmentUpdatedAuditEntryDataUpdatedField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamEnvironmentUpdatedAuditEntryDataUpdatedField2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironmentUpdatedAuditEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, v *team.TeamEnvironmentUpdatedAuditEntryDataUpdatedField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamEnvironmentUpdatedAuditEntryDataUpdatedField(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamMember2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMember(ctx context.Context, sel ast.SelectionSet, v team.TeamMember) graphql.Marshaler {
	return ec._TeamMember(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamMember2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberᚄ(ctx context.Context, sel ast.SelectionSet, v []*team.TeamMember) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamMember2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMember(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamMember2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMember(ctx context.Context, sel ast.SelectionSet, v *team.TeamMember) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamMember(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamMemberAddedAuditEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberAddedAuditEntryData(ctx context.Context, sel ast.SelectionSet, v *team.TeamMemberAddedAuditEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamMemberAddedAuditEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamMemberConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*team.TeamMember]) graphql.Marshaler {
	return ec._TeamMemberConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamMemberConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*team.TeamMember]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamMemberConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamMemberEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*team.TeamMember]) graphql.Marshaler {
	return ec._TeamMemberEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamMemberEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*team.TeamMember]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamMemberEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTeamMemberOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberOrderField(ctx context.Context, v interface{}) (team.TeamMemberOrderField, error) {
	var res team.TeamMemberOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamMemberOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberOrderField(ctx context.Context, sel ast.SelectionSet, v team.TeamMemberOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTeamMemberRemovedAuditEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberRemovedAuditEntryData(ctx context.Context, sel ast.SelectionSet, v *team.TeamMemberRemovedAuditEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamMemberRemovedAuditEntryData(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTeamMemberRole2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberRole(ctx context.Context, v interface{}) (team.TeamMemberRole, error) {
	var res team.TeamMemberRole
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamMemberRole2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberRole(ctx context.Context, sel ast.SelectionSet, v team.TeamMemberRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTeamMemberSetRoleAuditEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberSetRoleAuditEntryData(ctx context.Context, sel ast.SelectionSet, v *team.TeamMemberSetRoleAuditEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamMemberSetRoleAuditEntryData(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTeamOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamOrderField(ctx context.Context, v interface{}) (team.TeamOrderField, error) {
	var res team.TeamOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamOrderField(ctx context.Context, sel ast.SelectionSet, v team.TeamOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTeamUpdatedAuditEntryDataUpdatedField2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamUpdatedAuditEntryDataUpdatedFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []*team.TeamUpdatedAuditEntryDataUpdatedField) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamUpdatedAuditEntryDataUpdatedField2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamUpdatedAuditEntryDataUpdatedField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamUpdatedAuditEntryDataUpdatedField2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamUpdatedAuditEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, v *team.TeamUpdatedAuditEntryDataUpdatedField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamUpdatedAuditEntryDataUpdatedField(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamUtilizationData2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐTeamUtilizationDataᚄ(ctx context.Context, sel ast.SelectionSet, v []*utilization.TeamUtilizationData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamUtilizationData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐTeamUtilizationData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamUtilizationData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐTeamUtilizationData(ctx context.Context, sel ast.SelectionSet, v *utilization.TeamUtilizationData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamUtilizationData(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamVulnerabilitySummary2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐTeamVulnerabilitySummary(ctx context.Context, sel ast.SelectionSet, v vulnerability.TeamVulnerabilitySummary) graphql.Marshaler {
	return ec._TeamVulnerabilitySummary(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamVulnerabilitySummary2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐTeamVulnerabilitySummary(ctx context.Context, sel ast.SelectionSet, v *vulnerability.TeamVulnerabilitySummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamVulnerabilitySummary(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdateTeamEnvironmentInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUpdateTeamEnvironmentInput(ctx context.Context, v interface{}) (team.UpdateTeamEnvironmentInput, error) {
	res, err := ec.unmarshalInputUpdateTeamEnvironmentInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTeamEnvironmentPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUpdateTeamEnvironmentPayload(ctx context.Context, sel ast.SelectionSet, v team.UpdateTeamEnvironmentPayload) graphql.Marshaler {
	return ec._UpdateTeamEnvironmentPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTeamEnvironmentPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUpdateTeamEnvironmentPayload(ctx context.Context, sel ast.SelectionSet, v *team.UpdateTeamEnvironmentPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTeamEnvironmentPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateTeamInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUpdateTeamInput(ctx context.Context, v interface{}) (team.UpdateTeamInput, error) {
	res, err := ec.unmarshalInputUpdateTeamInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTeamPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUpdateTeamPayload(ctx context.Context, sel ast.SelectionSet, v team.UpdateTeamPayload) graphql.Marshaler {
	return ec._UpdateTeamPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTeamPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUpdateTeamPayload(ctx context.Context, sel ast.SelectionSet, v *team.UpdateTeamPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTeamPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx context.Context, sel ast.SelectionSet, v user.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*user.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx context.Context, sel ast.SelectionSet, v *user.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*user.User]) graphql.Marshaler {
	return ec._UserConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*user.User]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNUserEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*user.User]) graphql.Marshaler {
	return ec._UserEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*user.User]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNUserOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUserOrderField(ctx context.Context, v interface{}) (user.UserOrderField, error) {
	var res user.UserOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUserOrderField(ctx context.Context, sel ast.SelectionSet, v user.UserOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserTeamOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUserTeamOrderField(ctx context.Context, v interface{}) (team.UserTeamOrderField, error) {
	var res team.UserTeamOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserTeamOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUserTeamOrderField(ctx context.Context, sel ast.SelectionSet, v team.UserTeamOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUtilizationDataPoint2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐUtilizationDataPointᚄ(ctx context.Context, sel ast.SelectionSet, v []*utilization.UtilizationDataPoint) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUtilizationDataPoint2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐUtilizationDataPoint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUtilizationDataPoint2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐUtilizationDataPoint(ctx context.Context, sel ast.SelectionSet, v *utilization.UtilizationDataPoint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UtilizationDataPoint(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUtilizationResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐUtilizationResourceType(ctx context.Context, v interface{}) (utilization.UtilizationResourceType, error) {
	var res utilization.UtilizationResourceType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUtilizationResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐUtilizationResourceType(ctx context.Context, sel ast.SelectionSet, v utilization.UtilizationResourceType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx context.Context, sel ast.SelectionSet, v workload.Workload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Workload(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkload2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadᚄ(ctx context.Context, sel ast.SelectionSet, v []workload.Workload) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorkloadConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[workload.Workload]) graphql.Marshaler {
	return ec._WorkloadConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[workload.Workload]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadCost2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐWorkloadCost(ctx context.Context, sel ast.SelectionSet, v cost.WorkloadCost) graphql.Marshaler {
	return ec._WorkloadCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐWorkloadCost(ctx context.Context, sel ast.SelectionSet, v *cost.WorkloadCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadCost(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadCostPeriod2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐWorkloadCostPeriod(ctx context.Context, sel ast.SelectionSet, v cost.WorkloadCostPeriod) graphql.Marshaler {
	return ec._WorkloadCostPeriod(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadCostPeriod2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋcostᚐWorkloadCostPeriod(ctx context.Context, sel ast.SelectionSet, v *cost.WorkloadCostPeriod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadCostPeriod(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[workload.Workload]) graphql.Marshaler {
	return ec._WorkloadEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[workload.Workload]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkloadEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNWorkloadOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadOrderField(ctx context.Context, v interface{}) (workload.WorkloadOrderField, error) {
	var res workload.WorkloadOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorkloadOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadOrderField(ctx context.Context, sel ast.SelectionSet, v workload.WorkloadOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWorkloadResourceQuantity2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadResourceQuantity(ctx context.Context, sel ast.SelectionSet, v *workload.WorkloadResourceQuantity) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadResourceQuantity(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadUtilization2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐWorkloadUtilization(ctx context.Context, sel ast.SelectionSet, v utilization.WorkloadUtilization) graphql.Marshaler {
	return ec._WorkloadUtilization(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadUtilization2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐWorkloadUtilization(ctx context.Context, sel ast.SelectionSet, v *utilization.WorkloadUtilization) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadUtilization(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadUtilizationData2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐWorkloadUtilizationData(ctx context.Context, sel ast.SelectionSet, v []*utilization.WorkloadUtilizationData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkloadUtilizationData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐWorkloadUtilizationData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNWorkloadUtilizationSeriesInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐWorkloadUtilizationSeriesInput(ctx context.Context, v interface{}) (utilization.WorkloadUtilizationSeriesInput, error) {
	res, err := ec.unmarshalInputWorkloadUtilizationSeriesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplication(ctx context.Context, sel ast.SelectionSet, v *application.Application) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) unmarshalOApplicationOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋapplicationᚐApplicationOrder(ctx context.Context, v interface{}) (*application.ApplicationOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputApplicationOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBigQueryDatasetAccessOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetAccessOrder(ctx context.Context, v interface{}) (*bigquery.BigQueryDatasetAccessOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBigQueryDatasetAccessOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBigQueryDatasetOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbigqueryᚐBigQueryDatasetOrder(ctx context.Context, v interface{}) (*bigquery.BigQueryDatasetOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBigQueryDatasetOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOBucketOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋbucketᚐBucketOrder(ctx context.Context, v interface{}) (*bucket.BucketOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBucketOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx context.Context, v interface{}) (*pagination.Cursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(pagination.Cursor)
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋpaginationᚐCursor(ctx context.Context, sel ast.SelectionSet, v *pagination.Cursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) unmarshalOImageVulnerabilityOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilityOrder(ctx context.Context, v interface{}) (*vulnerability.ImageVulnerabilityOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputImageVulnerabilityOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOImageVulnerabilitySummary2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋvulnerabilityᚐImageVulnerabilitySummary(ctx context.Context, sel ast.SelectionSet, v *vulnerability.ImageVulnerabilitySummary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImageVulnerabilitySummary(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint64(ctx context.Context, v interface{}) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) unmarshalOJobOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobOrder(ctx context.Context, v interface{}) (*job.JobOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJobOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJobSchedule2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚋjobᚐJobSchedule(ctx context.Context, sel ast.SelectionSet, v *job.JobSchedule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JobSchedule(ctx, sel, v)
}

func (ec *executionContext) unmarshalOKafkaTopicAclFilter2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACLFilter(ctx context.Context, v interface{}) (*kafkatopic.KafkaTopicACLFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputKafkaTopicAclFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOKafkaTopicAclOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicACLOrder(ctx context.Context, v interface{}) (*kafkatopic.KafkaTopicACLOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputKafkaTopicAclOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOKafkaTopicConfiguration2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicConfiguration(ctx context.Context, sel ast.SelectionSet, v *kafkatopic.KafkaTopicConfiguration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KafkaTopicConfiguration(ctx, sel, v)
}

func (ec *executionContext) unmarshalOKafkaTopicOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋkafkatopicᚐKafkaTopicOrder(ctx context.Context, v interface{}) (*kafkatopic.KafkaTopicOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputKafkaTopicOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgraphv1ᚋmodelv1ᚐNode(ctx context.Context, sel ast.SelectionSet, v modelv1.Node) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOOpenSearch2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearch(ctx context.Context, sel ast.SelectionSet, v *opensearch.OpenSearch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OpenSearch(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOpenSearchAccessOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchAccessOrder(ctx context.Context, v interface{}) (*opensearch.OpenSearchAccessOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOpenSearchAccessOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOOpenSearchOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋopensearchᚐOpenSearchOrder(ctx context.Context, v interface{}) (*opensearch.OpenSearchOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOpenSearchOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORedisInstanceAccessOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceAccessOrder(ctx context.Context, v interface{}) (*redis.RedisInstanceAccessOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRedisInstanceAccessOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORedisInstanceOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋredisᚐRedisInstanceOrder(ctx context.Context, v interface{}) (*redis.RedisInstanceOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRedisInstanceOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepository2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐRepository(ctx context.Context, sel ast.SelectionSet, v *repository.Repository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSearchType2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋsearchv1ᚐSearchType(ctx context.Context, v interface{}) (*searchv1.SearchType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(searchv1.SearchType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSearchType2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋsearchv1ᚐSearchType(ctx context.Context, sel ast.SelectionSet, v *searchv1.SearchType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx context.Context, v interface{}) (*slug.Slug, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(slug.Slug)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx context.Context, sel ast.SelectionSet, v *slug.Slug) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSqlDatabase2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLDatabase(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLDatabase) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SqlDatabase(ctx, sel, v)
}

func (ec *executionContext) marshalOSqlInstanceBackupConfiguration2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceBackupConfiguration(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceBackupConfiguration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SqlInstanceBackupConfiguration(ctx, sel, v)
}

func (ec *executionContext) marshalOSqlInstanceMaintenanceWindow2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceMaintenanceWindow(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceMaintenanceWindow) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SqlInstanceMaintenanceWindow(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSqlInstanceOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceOrder(ctx context.Context, v interface{}) (*sqlinstance.SQLInstanceOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSqlInstanceOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSqlInstanceUserOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋpersistenceᚋsqlinstanceᚐSQLInstanceUserOrder(ctx context.Context, v interface{}) (*sqlinstance.SQLInstanceUserOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSqlInstanceUserOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeam(ctx context.Context, sel ast.SelectionSet, v *team.Team) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Team(ctx, sel, v)
}

func (ec *executionContext) marshalOTeamDeleteKey2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamDeleteKey(ctx context.Context, sel ast.SelectionSet, v *team.TeamDeleteKey) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamDeleteKey(ctx, sel, v)
}

func (ec *executionContext) marshalOTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamEnvironment(ctx context.Context, sel ast.SelectionSet, v *team.TeamEnvironment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamEnvironment(ctx, sel, v)
}

func (ec *executionContext) marshalOTeamMember2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMember(ctx context.Context, sel ast.SelectionSet, v *team.TeamMember) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamMember(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTeamMemberOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamMemberOrder(ctx context.Context, v interface{}) (*team.TeamMemberOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamMemberOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTeamOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamOrder(ctx context.Context, v interface{}) (*team.TeamOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTeamRepositoryFilter2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋgithubᚋrepositoryᚐTeamRepositoryFilter(ctx context.Context, v interface{}) (*repository.TeamRepositoryFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamRepositoryFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTeamUpdatedAuditEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐTeamUpdatedAuditEntryData(ctx context.Context, sel ast.SelectionSet, v *team.TeamUpdatedAuditEntryData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamUpdatedAuditEntryData(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOUser2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUser(ctx context.Context, sel ast.SelectionSet, v *user.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋuserᚐUserOrder(ctx context.Context, v interface{}) (*user.UserOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserTeamOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋteamᚐUserTeamOrder(ctx context.Context, v interface{}) (*team.UserTeamOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserTeamOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkload(ctx context.Context, sel ast.SelectionSet, v workload.Workload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Workload(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorkloadOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋworkloadᚐWorkloadOrder(ctx context.Context, v interface{}) (*workload.WorkloadOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWorkloadOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWorkloadUtilizationData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋv1ᚋutilizationᚐWorkloadUtilizationData(ctx context.Context, sel ast.SelectionSet, v *utilization.WorkloadUtilizationData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkloadUtilizationData(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************

// Code generated by sqlc. DO NOT EDIT.
// source: cost.sql

package costsql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/api/internal/slug"
)

const costForInstance = `-- name: CostForInstance :one
SELECT
	COALESCE(SUM(daily_cost), 0)::REAL
FROM
	cost
WHERE
	team_slug = $1
	AND cost_type = $2
	AND app = $3
	AND date >= $4
	AND date <= $5
	AND environment = $6::TEXT
`

type CostForInstanceParams struct {
	TeamSlug    slug.Slug
	CostType    string
	Workload    string
	FromDate    pgtype.Date
	ToDate      pgtype.Date
	Environment string
}

func (q *Queries) CostForInstance(ctx context.Context, arg CostForInstanceParams) (float32, error) {
	row := q.db.QueryRow(ctx, costForInstance,
		arg.TeamSlug,
		arg.CostType,
		arg.Workload,
		arg.FromDate,
		arg.ToDate,
		arg.Environment,
	)
	var column_1 float32
	err := row.Scan(&column_1)
	return column_1, err
}

const costForTeam = `-- name: CostForTeam :one
SELECT
	COALESCE(SUM(daily_cost), 0)::REAL
FROM
	cost
WHERE
	team_slug = $1
	AND cost_type = $2
	AND date >= $3
	AND date <= $4
`

type CostForTeamParams struct {
	TeamSlug slug.Slug
	CostType string
	FromDate pgtype.Date
	ToDate   pgtype.Date
}

func (q *Queries) CostForTeam(ctx context.Context, arg CostForTeamParams) (float32, error) {
	row := q.db.QueryRow(ctx, costForTeam,
		arg.TeamSlug,
		arg.CostType,
		arg.FromDate,
		arg.ToDate,
	)
	var column_1 float32
	err := row.Scan(&column_1)
	return column_1, err
}

const dailyCostForTeam = `-- name: DailyCostForTeam :many
WITH
	date_range AS (
		SELECT
			date
		FROM
			GENERATE_SERIES(
				$2::date,
				$3::date,
				'1 day'::INTERVAL
			) AS date
	)
SELECT
	date_range.date::date AS date,
	cost.cost_type AS service,
	COALESCE(SUM(cost.daily_cost), 0)::REAL AS cost
FROM
	date_range
	LEFT OUTER JOIN cost ON cost.date = date_range.date
WHERE
	team_slug IS NULL
	OR team_slug = $1::slug
GROUP BY
	date_range.date,
	service
ORDER BY
	date_range.date,
	service ASC
`

type DailyCostForTeamParams struct {
	TeamSlug slug.Slug
	FromDate pgtype.Date
	ToDate   pgtype.Date
}

type DailyCostForTeamRow struct {
	Date    pgtype.Date
	Service *string
	Cost    float32
}

// DailyCostForTeam will fetch the daily cost for a specific team across all apps and envs in a date range.
func (q *Queries) DailyCostForTeam(ctx context.Context, arg DailyCostForTeamParams) ([]*DailyCostForTeamRow, error) {
	rows, err := q.db.Query(ctx, dailyCostForTeam, arg.TeamSlug, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyCostForTeamRow{}
	for rows.Next() {
		var i DailyCostForTeamRow
		if err := rows.Scan(&i.Date, &i.Service, &i.Cost); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dailyCostForWorkload = `-- name: DailyCostForWorkload :many
WITH
	date_range AS (
		SELECT
			date
		FROM
			GENERATE_SERIES(
				$4::date,
				$5::date,
				'1 day'::INTERVAL
			) AS date
	)
SELECT
	date_range.date::date AS date,
	cost.environment,
	cost.team_slug,
	cost.cost_type AS service,
	cost.daily_cost
FROM
	date_range
	LEFT OUTER JOIN cost ON cost.date = date_range.date
WHERE
	environment IS NULL
	OR (
		environment = $1::TEXT
		AND team_slug = $2::slug
		AND app = $3
	)
ORDER BY
	date_range.date,
	service ASC
`

type DailyCostForWorkloadParams struct {
	Environment string
	TeamSlug    slug.Slug
	Workload    string
	FromDate    pgtype.Date
	ToDate      pgtype.Date
}

type DailyCostForWorkloadRow struct {
	Date        pgtype.Date
	Environment *string
	TeamSlug    *slug.Slug
	Service     *string
	DailyCost   *float32
}

// DailyCostForWorkload will fetch the daily cost for a specific workload in an environment, across all cost types in a
// date range.
func (q *Queries) DailyCostForWorkload(ctx context.Context, arg DailyCostForWorkloadParams) ([]*DailyCostForWorkloadRow, error) {
	rows, err := q.db.Query(ctx, dailyCostForWorkload,
		arg.Environment,
		arg.TeamSlug,
		arg.Workload,
		arg.FromDate,
		arg.ToDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyCostForWorkloadRow{}
	for rows.Next() {
		var i DailyCostForWorkloadRow
		if err := rows.Scan(
			&i.Date,
			&i.Environment,
			&i.TeamSlug,
			&i.Service,
			&i.DailyCost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dailyEnvCostForTeam = `-- name: DailyEnvCostForTeam :many
SELECT
	team_slug,
	app AS workload,
	date,
	SUM(daily_cost)::REAL AS daily_cost
FROM
	cost
WHERE
	date >= $1::date
	AND date <= $2::date
	AND environment = $3
	AND team_slug = $4::slug
GROUP BY
	team_slug,
	app,
	date
ORDER BY
	date,
	app ASC
`

type DailyEnvCostForTeamParams struct {
	FromDate    pgtype.Date
	ToDate      pgtype.Date
	Environment *string
	TeamSlug    slug.Slug
}

type DailyEnvCostForTeamRow struct {
	TeamSlug  slug.Slug
	Workload  string
	Date      pgtype.Date
	DailyCost float32
}

// DailyEnvCostForTeam will fetch the daily cost for a specific team and environment across all apps in a date range.
func (q *Queries) DailyEnvCostForTeam(ctx context.Context, arg DailyEnvCostForTeamParams) ([]*DailyEnvCostForTeamRow, error) {
	rows, err := q.db.Query(ctx, dailyEnvCostForTeam,
		arg.FromDate,
		arg.ToDate,
		arg.Environment,
		arg.TeamSlug,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyEnvCostForTeamRow{}
	for rows.Next() {
		var i DailyEnvCostForTeamRow
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Workload,
			&i.Date,
			&i.DailyCost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lastCostDate = `-- name: LastCostDate :one
SELECT
	MAX(date)::date AS date
FROM
	cost
`

// LastCostDate will return the last date that has a cost.
func (q *Queries) LastCostDate(ctx context.Context) (pgtype.Date, error) {
	row := q.db.QueryRow(ctx, lastCostDate)
	var date pgtype.Date
	err := row.Scan(&date)
	return date, err
}

const monthlyCostForTeam = `-- name: MonthlyCostForTeam :many
SELECT
	team_slug, month, last_recorded_date, daily_cost
FROM
	cost_monthly_team
WHERE
	team_slug = $1::slug
ORDER BY
	MONTH DESC
LIMIT
	12
`

func (q *Queries) MonthlyCostForTeam(ctx context.Context, teamSlug slug.Slug) ([]*CostMonthlyTeam, error) {
	rows, err := q.db.Query(ctx, monthlyCostForTeam, teamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CostMonthlyTeam{}
	for rows.Next() {
		var i CostMonthlyTeam
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Month,
			&i.LastRecordedDate,
			&i.DailyCost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monthlyCostForWorkload = `-- name: MonthlyCostForWorkload :many
WITH
	last_run AS (
		SELECT
			MAX(date)::date AS "last_run"
		FROM
			cost
	)
SELECT
	team_slug,
	app AS workload,
	environment,
	DATE_TRUNC('month', date)::date AS MONTH,
	cost_type AS service,
	-- Extract last day of known cost samples for the month, or the last recorded date
	-- This helps with estimation etc
	MAX(
		CASE
			WHEN DATE_TRUNC('month', date) < DATE_TRUNC('month', last_run) THEN DATE_TRUNC('month', date) + INTERVAL '1 month' - INTERVAL '1 day'
			ELSE DATE_TRUNC('day', last_run)
		END
	)::date AS last_recorded_date,
	SUM(daily_cost)::REAL AS daily_cost
FROM
	cost c
	LEFT JOIN last_run ON TRUE
WHERE
	c.team_slug = $1::slug
	AND c.app = $2
	AND c.environment = $3::TEXT
GROUP BY
	team_slug,
	app,
	environment,
	service,
	MONTH
ORDER BY
	MONTH DESC
LIMIT
	12
`

type MonthlyCostForWorkloadParams struct {
	TeamSlug    slug.Slug
	Workload    string
	Environment string
}

type MonthlyCostForWorkloadRow struct {
	TeamSlug         slug.Slug
	Workload         string
	Environment      *string
	Month            pgtype.Date
	Service          string
	LastRecordedDate pgtype.Date
	DailyCost        float32
}

func (q *Queries) MonthlyCostForWorkload(ctx context.Context, arg MonthlyCostForWorkloadParams) ([]*MonthlyCostForWorkloadRow, error) {
	rows, err := q.db.Query(ctx, monthlyCostForWorkload, arg.TeamSlug, arg.Workload, arg.Environment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MonthlyCostForWorkloadRow{}
	for rows.Next() {
		var i MonthlyCostForWorkloadRow
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Workload,
			&i.Environment,
			&i.Month,
			&i.Service,
			&i.LastRecordedDate,
			&i.DailyCost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshCostMonthlyTeam = `-- name: RefreshCostMonthlyTeam :exec
REFRESH MATERIALIZED VIEW CONCURRENTLY cost_monthly_team
`

func (q *Queries) RefreshCostMonthlyTeam(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshCostMonthlyTeam)
	return err
}

package vulnerability

import (
	"context"
	"fmt"
	"sort"
	"time"

	promapi "github.com/prometheus/client_golang/api"
	prom "github.com/prometheus/client_golang/api/prometheus/v1"
	prom_model "github.com/prometheus/common/model"
)

const (
	PrometheusMetricTeamLabel = "workload_namespace"
)

type PrometheusConfig struct {
	EnableFakes bool
	Tenant      string
	Clusters    []string
}

type PrometheusClients struct {
	cfg     *PrometheusConfig
	clients map[string]Prometheus
}

type (
	clusterPrometheusClients map[string]Prometheus
)

type Prometheus interface {
	Query(ctx context.Context, query string, ts time.Time, opts ...prom.Option) (prom_model.Value, prom.Warnings, error)
}

func NewPrometheusClients(cfg *PrometheusConfig) (*PrometheusClients, error) {
	clients, err := cfg.prometheusClients()
	if err != nil {
		return nil, err
	}

	return &PrometheusClients{
		cfg:     cfg,
		clients: clients,
	}, nil
}

func (c *PrometheusConfig) prometheusClients() (clusterPrometheusClients, error) {
	clients := clusterPrometheusClients{}
	for _, cluster := range c.Clusters {
		if c.EnableFakes {
			clients[cluster] = NewFakePrometheusClient()
			continue
		}
		prometheusURL := fmt.Sprintf("https://nais-prometheus.%s.%s.cloud.nais.io", cluster, c.Tenant)
		promClient, err := promapi.NewClient(promapi.Config{
			Address: prometheusURL,
		})
		if err != nil {
			return nil, err
		}
		clients[cluster] = prom.NewAPI(promClient)
	}

	return clients, nil
}

func (p *PrometheusClients) promQuery(ctx context.Context, q, cluster string, time time.Time) (prom_model.Vector, error) {
	if p.clients == nil {
		return nil, fmt.Errorf("no prometheus clients configured")
	}

	prometheusClient, ok := p.clients[cluster]
	if !ok {
		return nil, fmt.Errorf("no prometheus client configured for cluster: %s", cluster)
	}

	val, _, err := prometheusClient.Query(ctx, q, time)
	if err != nil {
		return nil, err
	}

	if val.Type() != prom_model.ValVector {
		return nil, fmt.Errorf("unexpected PromQuery result type: %s", val.Type())
	}

	if len(val.(prom_model.Vector)) == 0 {
		return nil, nil
	}

	return val.(prom_model.Vector), nil
}

func (p *PrometheusClients) riskScoreTotal(ctx context.Context, team string, time time.Time) (float64, error) {
	total := 0.0
	for _, e := range p.cfg.Clusters {
		query := fmt.Sprintf(`sum(slsa_workload_riskscore{workload_namespace="%s"})`, team)
		res, err := p.promQuery(ctx, query, e, time)
		if err != nil {
			return 0, fmt.Errorf("getting prometheus query result: %w", err)
		}

		for _, s := range res {
			total += float64(s.Value)
		}
	}

	return total, nil
}

func (p *PrometheusClients) ranking(ctx context.Context, team string, time time.Time) (int, error) {
	samples := make(prom_model.Vector, 0)
	for _, e := range p.cfg.Clusters {
		query := "sum(slsa_workload_riskscore) by (workload_namespace)"
		res, err := p.promQuery(ctx, query, e, time)
		if err != nil {
			return 0, fmt.Errorf("getting prometheus query result: %w", err)
		}
		samples = append(samples, res...)
	}

	sort.SliceStable(samples, func(i, j int) bool {
		return samples[i].Value > samples[j].Value
	})

	rank := 0
	for i, s := range samples {
		namespace := string(s.Metric[PrometheusMetricTeamLabel])
		if namespace != team {
			continue
		}

		if rank == 0 {
			rank = i + 1
		}
	}

	return rank, nil
}

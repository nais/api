package vulnerability

import (
	"context"
	"fmt"

	"github.com/sirupsen/logrus"
	"github.com/sourcegraph/conc/pool"
	"github.com/vikstrous/dataloadgen"
)

type ctxKey int

const loadersKey ctxKey = iota

func NewLoaderContext(ctx context.Context, dpClient Client, tenantName string, clusters []string, useFake bool, logger logrus.FieldLogger, defaultOpts []dataloadgen.Option) context.Context {
	promClients, err := NewPrometheusClients(&PrometheusConfig{
		EnableFakes: useFake,
		Tenant:      tenantName,
		Clusters:    clusters,
	})
	if err != nil {
		panic(fmt.Sprintf("create prometheus clients: %v", err))
	}

	return context.WithValue(ctx, loadersKey, newLoaders(dpClient, promClients, logger, defaultOpts))
}

func fromContext(ctx context.Context) *loaders {
	return ctx.Value(loadersKey).(*loaders)
}

type loaders struct {
	imageLoader *dataloadgen.Loader[string, *ImageDetails]
	dpClient    Client
	promClients *PrometheusClients
}

func newLoaders(dpClient Client, promClients *PrometheusClients, logger logrus.FieldLogger, opts []dataloadgen.Option) *loaders {
	loader := &dataloader{client: dpClient, log: logger}

	return &loaders{
		imageLoader: dataloadgen.NewLoader(loader.list, opts...),
		dpClient:    dpClient,
		promClients: promClients,
	}
}

type dataloader struct {
	client Client
	log    logrus.FieldLogger
}

func (l dataloader) list(ctx context.Context, imageRef []string) ([]*ImageDetails, []error) {
	wg := pool.New().WithContext(ctx)

	ret := make([]*ImageDetails, len(imageRef))
	errs := make([]error, len(imageRef))

	for i, ref := range imageRef {
		wg.Go(func(ctx context.Context) error {
			m, err := l.client.GetMetadataForImage(ctx, ref)
			if err != nil {
				errs[i] = err
			} else {
				ret[i] = m
			}
			return nil
		})
	}

	if err := wg.Wait(); err != nil {
		l.log.WithError(err).Error("error waiting for dataloader")
	}

	return ret, errs
}

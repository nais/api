package vulnerability

import (
	"context"
	"fmt"
	"time"

	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/v1/graphv1/pagination"
	"github.com/nais/api/internal/v1/team"
)

func GetImageMetadata(ctx context.Context, imageRef string) (*ImageDetails, error) {
	return fromContext(ctx).imageLoader.Load(ctx, imageRef)
}

func GetTeamMetadata(ctx context.Context, teamSlug slug.Slug) ([]*ImageDetails, error) {
	c := fromContext(ctx).dpClient
	projects, err := c.GetMetadataForTeam(ctx, teamSlug.String())
	if err != nil {
		return nil, fmt.Errorf("getting projects by team %s: %w", teamSlug, err)
	}

	if projects == nil {
		return nil, nil
	}

	images := make([]*ImageDetails, 0)
	for _, p := range projects {
		if p == nil {
			continue
		}

		// TODO: Find a better way to filter out these images
		if p.Name == "europe-north1-docker.pkg.dev/nais-io/nais/images/wonderwall" {
			continue
		}

		if p.Name == "europe-north1-docker.pkg.dev/nais-io/nais/images/elector" {
			continue
		}

		image, err := c.GetMetadataForImage(ctx, p.Name)
		if err != nil {
			return nil, fmt.Errorf("getting metadata for image %q: %w", p.Name, err)
		}
		images = append(images, image)
	}

	return images, nil
}

func ListWorkloadReferences(ctx context.Context, image string, page *pagination.Pagination) (*pagination.Connection[*ContainerImageWorkloadReference], error) {
	metadata, err := fromContext(ctx).imageLoader.Load(ctx, image)
	if err != nil {
		return nil, err
	}

	all := metadata.WorkloadReferences
	slice := pagination.Slice(all, page)
	return pagination.NewConvertConnection(slice, page, int32(len(all)), toGraphWorkloadReference), nil
}

func GetTeamRanking(ctx context.Context, teamSlug slug.Slug) (TeamVulnerabilityRanking, error) {
	totalTeams, err := team.Count(ctx)
	if err != nil {
		return TeamVulnerabilityRankingUnknown, fmt.Errorf("counting teams: %w", err)
	}

	currentRank, err := fromContext(ctx).promClients.ranking(ctx, teamSlug.String(), time.Now())
	if err != nil {
		return "", fmt.Errorf("getting team ranking: %w", err)
	}

	// Divide teams into three parts
	upperLimit := int(totalTeams) / 3        // Upper third
	middleLimit := 2 * (int(totalTeams) / 3) // Middle third (everything before bottom third)

	// Determine vulnerability score based on rank
	switch {
	case currentRank == 0:
		return TeamVulnerabilityRankingUnknown, nil
	case currentRank <= upperLimit: // Top third
		return TeamVulnerabilityRankingMostVulnerable, nil
	case currentRank > upperLimit && currentRank <= middleLimit: // Middle third
		return TeamVulnerabilityRankingMiddle, nil
	default: // Bottom third
		return TeamVulnerabilityRankingLeastVulnerable, nil
	}
}

func GetTeamRiskScoreTrend(ctx context.Context, teamSlug slug.Slug) (TeamVulnerabilityRiskScoreTrend, error) {
	current, err := fromContext(ctx).promClients.riskScoreTotal(ctx, teamSlug.String(), time.Now())
	if err != nil {
		return "", fmt.Errorf("getting team risk score: %w", err)
	}
	previous, err := fromContext(ctx).promClients.riskScoreTotal(ctx, teamSlug.String(), time.Now().AddDate(0, 0, -30))
	if err != nil {
		return "", fmt.Errorf("getting team risk score: %w", err)
	}
	switch {
	case current > previous:
		return TeamVulnerabilityRiskScoreTrendUp, nil
	case current < previous:
		return TeamVulnerabilityRiskScoreTrendDown, nil
	default:
		return TeamVulnerabilityRiskScoreTrendFlat, nil
	}
}

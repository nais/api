package vulnerability

import (
	"fmt"
	"io"
	"strconv"

	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/v1/graphv1/ident"
	"github.com/nais/api/internal/v1/graphv1/modelv1"
	"github.com/nais/api/internal/v1/graphv1/pagination"
	"github.com/nais/api/internal/v1/workload"
)

type (
	ImageVulnerabilityConnection              = pagination.Connection[*ImageVulnerability]
	ImageVulnerabilityEdge                    = pagination.Edge[*ImageVulnerability]
	ContainerImageWorkloadReferenceConnection = pagination.Connection[*ContainerImageWorkloadReference]
	ContainerImageWorkloadReferenceEdge       = pagination.Edge[*ContainerImageWorkloadReference]
)

type ContainerImageWorkloadReference struct {
	Reference       *workload.Reference `json:"-"`
	TeamSlug        slug.Slug           `json:"-"`
	EnvironmentName string              `json:"-"`
}

type ImageVulnerability struct {
	ID          ident.Ident                `json:"id"`
	Identifier  string                     `json:"identifier"`
	Severity    ImageVulnerabilitySeverity `json:"severity"`
	Description string                     `json:"description"`
	Package     string                     `json:"package"`
	State       ImageVulnerabilityState    `json:"state"`
	URL         string                     `json:"url"`
}

func (ImageVulnerability) IsNode() {}

type ImageVulnerabilityOrder struct {
	Field     ImageVulnerabilityOrderField `json:"field"`
	Direction modelv1.OrderDirection       `json:"direction"`
}

type ImageVulnerabilitySummary struct {
	Total      int `json:"total"`
	RiskScore  int `json:"riskScore"`
	Low        int `json:"low"`
	Medium     int `json:"medium"`
	High       int `json:"high"`
	Critical   int `json:"critical"`
	Unassigned int `json:"unassigned"`
}

type ImageVulnerabilityOrderField string

const (
	// Order by the field
	ImageVulnerabilityOrderFieldSeverity  ImageVulnerabilityOrderField = "SEVERITY"
	ImageVulnerabilityOrderFieldRiskScore ImageVulnerabilityOrderField = "RISK_SCORE"
)

var AllImageVulnerabilityOrderField = []ImageVulnerabilityOrderField{
	ImageVulnerabilityOrderFieldSeverity,
	ImageVulnerabilityOrderFieldRiskScore,
}

func (e ImageVulnerabilityOrderField) IsValid() bool {
	switch e {
	case ImageVulnerabilityOrderFieldSeverity, ImageVulnerabilityOrderFieldRiskScore:
		return true
	}
	return false
}

func (e ImageVulnerabilityOrderField) String() string {
	return string(e)
}

func (e *ImageVulnerabilityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageVulnerabilityOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageVulnerabilityOrderField", str)
	}
	return nil
}

func (e ImageVulnerabilityOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImageVulnerabilitySeverity string

const (
	ImageVulnerabilitySeverityLow        ImageVulnerabilitySeverity = "LOW"
	ImageVulnerabilitySeverityMedium     ImageVulnerabilitySeverity = "MEDIUM"
	ImageVulnerabilitySeverityHigh       ImageVulnerabilitySeverity = "HIGH"
	ImageVulnerabilitySeverityCritical   ImageVulnerabilitySeverity = "CRITICAL"
	ImageVulnerabilitySeverityUnassigned ImageVulnerabilitySeverity = "UNASSIGNED"
)

var AllImageVulnerabilitySeverity = []ImageVulnerabilitySeverity{
	ImageVulnerabilitySeverityLow,
	ImageVulnerabilitySeverityMedium,
	ImageVulnerabilitySeverityHigh,
	ImageVulnerabilitySeverityCritical,
	ImageVulnerabilitySeverityUnassigned,
}

func (e ImageVulnerabilitySeverity) IsValid() bool {
	switch e {
	case ImageVulnerabilitySeverityLow, ImageVulnerabilitySeverityMedium, ImageVulnerabilitySeverityHigh, ImageVulnerabilitySeverityCritical, ImageVulnerabilitySeverityUnassigned:
		return true
	}
	return false
}

func (e ImageVulnerabilitySeverity) String() string {
	return string(e)
}

func (e *ImageVulnerabilitySeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageVulnerabilitySeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageVulnerabilitySeverity", str)
	}
	return nil
}

func (e ImageVulnerabilitySeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImageVulnerabilityState string

const (
	ImageVulnerabilityStateTriage        ImageVulnerabilityState = "TRIAGE"
	ImageVulnerabilityStateResolved      ImageVulnerabilityState = "RESOLVED"
	ImageVulnerabilityStateFalsePositive ImageVulnerabilityState = "FALSE_POSITIVE"
	ImageVulnerabilityStateNotAffected   ImageVulnerabilityState = "NOT_AFFECTED"
)

var AllImageVulnerabilityState = []ImageVulnerabilityState{
	ImageVulnerabilityStateTriage,
	ImageVulnerabilityStateResolved,
	ImageVulnerabilityStateFalsePositive,
	ImageVulnerabilityStateNotAffected,
}

func (e ImageVulnerabilityState) IsValid() bool {
	switch e {
	case ImageVulnerabilityStateTriage, ImageVulnerabilityStateResolved, ImageVulnerabilityStateFalsePositive, ImageVulnerabilityStateNotAffected:
		return true
	}
	return false
}

func (e ImageVulnerabilityState) String() string {
	return string(e)
}

func (e *ImageVulnerabilityState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageVulnerabilityState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageVulnerabilityState", str)
	}
	return nil
}

func (e ImageVulnerabilityState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImageDetails struct {
	ProjectID          string                     `json:"projectId"`
	Name               string                     `json:"name"`
	Version            string                     `json:"version"`
	Summary            *ImageVulnerabilitySummary `json:"summary"`
	HasSBOM            bool                       `json:"hasSbom"`
	ProjectURL         string                     `json:"projectUrl"`
	WorkloadReferences []*WorkloadReference       `json:"-"`
}

type WorkloadReference struct {
	Environment  string
	Team         string
	WorkloadType string
	Name         string
}

func toGraphWorkloadReference(r *WorkloadReference) *ContainerImageWorkloadReference {
	workloadType := workload.TypeApplication

	if r.WorkloadType == "job" {
		workloadType = workload.TypeJob
	}

	return &ContainerImageWorkloadReference{
		Reference: &workload.Reference{
			Name: r.Name,
			Type: workloadType,
		},
		TeamSlug:        slug.Slug(r.Team),
		EnvironmentName: r.Environment,
	}
}

// Code generated by sqlc. DO NOT EDIT.
// source: teams.sql

package teamsql

import (
	"context"

	"github.com/google/uuid"
	"github.com/nais/api/internal/slug"
)

const confirmDeleteKey = `-- name: ConfirmDeleteKey :exec
UPDATE team_delete_keys
SET
	confirmed_at = NOW()
WHERE
	key = $1
`

func (q *Queries) ConfirmDeleteKey(ctx context.Context, key uuid.UUID) error {
	_, err := q.db.Exec(ctx, confirmDeleteKey, key)
	return err
}

const count = `-- name: Count :one
SELECT
	COUNT(*)
FROM
	teams
`

func (q *Queries) Count(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, count)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const create = `-- name: Create :one
INSERT INTO
	teams (slug, purpose, slack_channel)
VALUES
	($1, $2, $3)
RETURNING
	slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, cdn_bucket, delete_key_confirmed_at
`

type CreateParams struct {
	Slug         slug.Slug
	Purpose      string
	SlackChannel string
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (*Team, error) {
	row := q.db.QueryRow(ctx, create, arg.Slug, arg.Purpose, arg.SlackChannel)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.CdnBucket,
		&i.DeleteKeyConfirmedAt,
	)
	return &i, err
}

const createDeleteKey = `-- name: CreateDeleteKey :one
INSERT INTO
	team_delete_keys (team_slug, created_by)
VALUES
	($1, $2)
RETURNING
	key, team_slug, created_at, created_by, confirmed_at
`

type CreateDeleteKeyParams struct {
	TeamSlug  slug.Slug
	CreatedBy uuid.UUID
}

func (q *Queries) CreateDeleteKey(ctx context.Context, arg CreateDeleteKeyParams) (*TeamDeleteKey, error) {
	row := q.db.QueryRow(ctx, createDeleteKey, arg.TeamSlug, arg.CreatedBy)
	var i TeamDeleteKey
	err := row.Scan(
		&i.Key,
		&i.TeamSlug,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ConfirmedAt,
	)
	return &i, err
}

const get = `-- name: Get :one
SELECT
	slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, cdn_bucket, delete_key_confirmed_at
FROM
	teams
WHERE
	slug = $1
`

func (q *Queries) Get(ctx context.Context, argSlug slug.Slug) (*Team, error) {
	row := q.db.QueryRow(ctx, get, argSlug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.CdnBucket,
		&i.DeleteKeyConfirmedAt,
	)
	return &i, err
}

const getDeleteKey = `-- name: GetDeleteKey :one
SELECT
	key, team_slug, created_at, created_by, confirmed_at
FROM
	team_delete_keys
WHERE
	key = $1
	AND team_slug = $2::slug
`

type GetDeleteKeyParams struct {
	Key  uuid.UUID
	Slug slug.Slug
}

func (q *Queries) GetDeleteKey(ctx context.Context, arg GetDeleteKeyParams) (*TeamDeleteKey, error) {
	row := q.db.QueryRow(ctx, getDeleteKey, arg.Key, arg.Slug)
	var i TeamDeleteKey
	err := row.Scan(
		&i.Key,
		&i.TeamSlug,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ConfirmedAt,
	)
	return &i, err
}

const getEnvironment = `-- name: GetEnvironment :one
SELECT
	team_slug, environment, gcp, gcp_project_id, id, slack_alerts_channel
FROM
	team_all_environments
WHERE
	team_slug = $1
	AND environment = $2
`

type GetEnvironmentParams struct {
	Slug        slug.Slug
	Environment string
}

func (q *Queries) GetEnvironment(ctx context.Context, arg GetEnvironmentParams) (*TeamAllEnvironment, error) {
	row := q.db.QueryRow(ctx, getEnvironment, arg.Slug, arg.Environment)
	var i TeamAllEnvironment
	err := row.Scan(
		&i.TeamSlug,
		&i.Environment,
		&i.Gcp,
		&i.GcpProjectID,
		&i.ID,
		&i.SlackAlertsChannel,
	)
	return &i, err
}

const list = `-- name: List :many
SELECT
	slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, cdn_bucket, delete_key_confirmed_at
FROM
	teams
ORDER BY
	CASE
		WHEN $1::TEXT = 'slug:asc' THEN slug
	END ASC,
	CASE
		WHEN $1::TEXT = 'slug:desc' THEN slug
	END DESC,
	slug ASC
LIMIT
	$3
OFFSET
	$2
`

type ListParams struct {
	OrderBy string
	Offset  int32
	Limit   int32
}

func (q *Queries) List(ctx context.Context, arg ListParams) ([]*Team, error) {
	rows, err := q.db.Query(ctx, list, arg.OrderBy, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
			&i.GarRepository,
			&i.CdnBucket,
			&i.DeleteKeyConfirmedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBySlugs = `-- name: ListBySlugs :many
SELECT
	slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, cdn_bucket, delete_key_confirmed_at
FROM
	teams
WHERE
	slug = ANY ($1::slug[])
ORDER BY
	slug ASC
`

func (q *Queries) ListBySlugs(ctx context.Context, slugs []slug.Slug) ([]*Team, error) {
	rows, err := q.db.Query(ctx, listBySlugs, slugs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
			&i.GarRepository,
			&i.CdnBucket,
			&i.DeleteKeyConfirmedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnvironmentsBySlug = `-- name: ListEnvironmentsBySlug :many
SELECT
	team_slug, environment, gcp, gcp_project_id, id, slack_alerts_channel
FROM
	team_all_environments
WHERE
	team_slug = $1
ORDER BY
	environment ASC
`

func (q *Queries) ListEnvironmentsBySlug(ctx context.Context, argSlug slug.Slug) ([]*TeamAllEnvironment, error) {
	rows, err := q.db.Query(ctx, listEnvironmentsBySlug, argSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TeamAllEnvironment{}
	for rows.Next() {
		var i TeamAllEnvironment
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Environment,
			&i.Gcp,
			&i.GcpProjectID,
			&i.ID,
			&i.SlackAlertsChannel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnvironmentsBySlugsAndEnvNames = `-- name: ListEnvironmentsBySlugsAndEnvNames :many
WITH
	input AS (
		SELECT
			UNNEST($1::slug[]) AS team_slug,
			UNNEST($2::TEXT[]) AS environment
	)
SELECT
	team_all_environments.team_slug, team_all_environments.environment, team_all_environments.gcp, team_all_environments.gcp_project_id, team_all_environments.id, team_all_environments.slack_alerts_channel
FROM
	team_all_environments
	JOIN input ON input.team_slug = team_all_environments.team_slug
	JOIN teams ON teams.slug = team_all_environments.team_slug
WHERE
	team_all_environments.environment = input.environment
ORDER BY
	team_all_environments.environment ASC
`

type ListEnvironmentsBySlugsAndEnvNamesParams struct {
	TeamSlugs    []slug.Slug
	Environments []string
}

// ListEnvironmentsBySlugsAndEnvNames returns a slice of team environments for a list of teams/envs, excluding
// deleted teams.
// Input is two arrays of equal length, one for slugs and one for names
func (q *Queries) ListEnvironmentsBySlugsAndEnvNames(ctx context.Context, arg ListEnvironmentsBySlugsAndEnvNamesParams) ([]*TeamAllEnvironment, error) {
	rows, err := q.db.Query(ctx, listEnvironmentsBySlugsAndEnvNames, arg.TeamSlugs, arg.Environments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TeamAllEnvironment{}
	for rows.Next() {
		var i TeamAllEnvironment
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Environment,
			&i.Gcp,
			&i.GcpProjectID,
			&i.ID,
			&i.SlackAlertsChannel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeSlackAlertsChannel = `-- name: RemoveSlackAlertsChannel :exec
UPDATE team_environments
SET
	slack_alerts_channel = NULL
WHERE
	team_slug = $1
	AND environment = $2
`

type RemoveSlackAlertsChannelParams struct {
	TeamSlug    slug.Slug
	Environment string
}

func (q *Queries) RemoveSlackAlertsChannel(ctx context.Context, arg RemoveSlackAlertsChannelParams) error {
	_, err := q.db.Exec(ctx, removeSlackAlertsChannel, arg.TeamSlug, arg.Environment)
	return err
}

const search = `-- name: Search :many
WITH
	result AS (
		SELECT
			slug,
			levenshtein ($1, slug) AS RANK
		FROM
			teams
		ORDER BY
			RANK ASC
		LIMIT
			10
	)
SELECT
	teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug, teams.gar_repository, teams.cdn_bucket, teams.delete_key_confirmed_at,
	RANK
FROM
	teams
	JOIN result ON teams.slug = result.slug
ORDER BY
	result.rank ASC
`

type SearchRow struct {
	Team Team
	Rank int32
}

func (q *Queries) Search(ctx context.Context, query string) ([]*SearchRow, error) {
	rows, err := q.db.Query(ctx, search, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchRow{}
	for rows.Next() {
		var i SearchRow
		if err := rows.Scan(
			&i.Team.Slug,
			&i.Team.Purpose,
			&i.Team.LastSuccessfulSync,
			&i.Team.SlackChannel,
			&i.Team.GoogleGroupEmail,
			&i.Team.AzureGroupID,
			&i.Team.GithubTeamSlug,
			&i.Team.GarRepository,
			&i.Team.CdnBucket,
			&i.Team.DeleteKeyConfirmedAt,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDeleteKeyConfirmedAt = `-- name: SetDeleteKeyConfirmedAt :exec
UPDATE teams
SET
	delete_key_confirmed_at = NOW()
WHERE
	slug = $1
`

func (q *Queries) SetDeleteKeyConfirmedAt(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, setDeleteKeyConfirmedAt, argSlug)
	return err
}

const slugAvailable = `-- name: SlugAvailable :one
SELECT
	EXISTS (
		SELECT
			slug
		FROM
			team_slugs
		WHERE
			slug = $1
	)
`

func (q *Queries) SlugAvailable(ctx context.Context, argSlug slug.Slug) (bool, error) {
	row := q.db.QueryRow(ctx, slugAvailable, argSlug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const update = `-- name: Update :one
UPDATE teams
SET
	purpose = COALESCE($1, purpose),
	slack_channel = COALESCE($2, slack_channel)
WHERE
	teams.slug = $3
RETURNING
	slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, cdn_bucket, delete_key_confirmed_at
`

type UpdateParams struct {
	Purpose      *string
	SlackChannel *string
	Slug         slug.Slug
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (*Team, error) {
	row := q.db.QueryRow(ctx, update, arg.Purpose, arg.SlackChannel, arg.Slug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.CdnBucket,
		&i.DeleteKeyConfirmedAt,
	)
	return &i, err
}

const upsertEnvironment = `-- name: UpsertEnvironment :exec
INSERT INTO
	team_environments (
		team_slug,
		environment,
		slack_alerts_channel,
		gcp_project_id
	)
VALUES
	(
		$1,
		$2,
		$3,
		$4
	)
ON CONFLICT (team_slug, environment) DO
UPDATE
SET
	slack_alerts_channel = COALESCE(
		EXCLUDED.slack_alerts_channel,
		team_environments.slack_alerts_channel
	),
	gcp_project_id = COALESCE(
		EXCLUDED.gcp_project_id,
		team_environments.gcp_project_id
	)
`

type UpsertEnvironmentParams struct {
	TeamSlug           slug.Slug
	Environment        string
	SlackAlertsChannel *string
	GcpProjectID       *string
}

func (q *Queries) UpsertEnvironment(ctx context.Context, arg UpsertEnvironmentParams) error {
	_, err := q.db.Exec(ctx, upsertEnvironment,
		arg.TeamSlug,
		arg.Environment,
		arg.SlackAlertsChannel,
		arg.GcpProjectID,
	)
	return err
}

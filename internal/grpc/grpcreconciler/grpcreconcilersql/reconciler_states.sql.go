// Code generated by sqlc. DO NOT EDIT.
// source: reconciler_states.sql

package grpcreconcilersql

import (
	"context"

	"github.com/nais/api/internal/slug"
)

const deleteStateForTeam = `-- name: DeleteStateForTeam :exec
DELETE FROM reconciler_states
WHERE
	reconciler_name = $1
	AND team_slug = $2
`

type DeleteStateForTeamParams struct {
	ReconcilerName string
	TeamSlug       slug.Slug
}

func (q *Queries) DeleteStateForTeam(ctx context.Context, arg DeleteStateForTeamParams) error {
	_, err := q.db.Exec(ctx, deleteStateForTeam, arg.ReconcilerName, arg.TeamSlug)
	return err
}

const getStateForTeam = `-- name: GetStateForTeam :one
SELECT
	id, reconciler_name, team_slug, value, created_at, updated_at
FROM
	reconciler_states
WHERE
	reconciler_name = $1
	AND team_slug = $2
`

type GetStateForTeamParams struct {
	ReconcilerName string
	TeamSlug       slug.Slug
}

func (q *Queries) GetStateForTeam(ctx context.Context, arg GetStateForTeamParams) (*ReconcilerState, error) {
	row := q.db.QueryRow(ctx, getStateForTeam, arg.ReconcilerName, arg.TeamSlug)
	var i ReconcilerState
	err := row.Scan(
		&i.ID,
		&i.ReconcilerName,
		&i.TeamSlug,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const upsertState = `-- name: UpsertState :one
INSERT INTO
	reconciler_states (reconciler_name, team_slug, value)
VALUES
	($1, $2, $3)
ON CONFLICT (reconciler_name, team_slug) DO
UPDATE
SET
	value = EXCLUDED.value
RETURNING
	id, reconciler_name, team_slug, value, created_at, updated_at
`

type UpsertStateParams struct {
	ReconcilerName string
	TeamSlug       slug.Slug
	Value          []byte
}

func (q *Queries) UpsertState(ctx context.Context, arg UpsertStateParams) (*ReconcilerState, error) {
	row := q.db.QueryRow(ctx, upsertState, arg.ReconcilerName, arg.TeamSlug, arg.Value)
	var i ReconcilerState
	err := row.Scan(
		&i.ID,
		&i.ReconcilerName,
		&i.TeamSlug,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

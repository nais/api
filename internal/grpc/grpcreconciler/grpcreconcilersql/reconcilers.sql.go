// Code generated by sqlc. DO NOT EDIT.
// source: reconcilers.sql

package grpcreconcilersql

import (
	"context"

	"github.com/nais/api/internal/slug"
)

const count = `-- name: Count :one
SELECT
	COUNT(*) AS total
FROM
	reconcilers
`

func (q *Queries) Count(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, count)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const deleteConfig = `-- name: DeleteConfig :exec
DELETE FROM reconciler_config
WHERE
	reconciler = $1
	AND key = ANY ($2::TEXT[])
`

type DeleteConfigParams struct {
	Reconciler string
	Keys       []string
}

func (q *Queries) DeleteConfig(ctx context.Context, arg DeleteConfigParams) error {
	_, err := q.db.Exec(ctx, deleteConfig, arg.Reconciler, arg.Keys)
	return err
}

const get = `-- name: Get :one
SELECT
	name, display_name, description, enabled, member_aware
FROM
	reconcilers
WHERE
	name = $1
`

func (q *Queries) Get(ctx context.Context, name string) (*Reconciler, error) {
	row := q.db.QueryRow(ctx, get, name)
	var i Reconciler
	err := row.Scan(
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Enabled,
		&i.MemberAware,
	)
	return &i, err
}

const getConfig = `-- name: GetConfig :many
SELECT
	rc.reconciler,
	rc.key,
	rc.display_name,
	rc.description,
	(rc.value IS NOT NULL)::BOOL AS configured,
	rc2.value,
	rc.secret
FROM
	reconciler_config rc
	LEFT JOIN reconciler_config rc2 ON rc2.reconciler = rc.reconciler
	AND rc2.key = rc.key
	AND (
		rc2.secret = FALSE
		OR $1::BOOL = TRUE
	)
WHERE
	rc.reconciler = $2
ORDER BY
	rc.display_name ASC
`

type GetConfigParams struct {
	IncludeSecret  bool
	ReconcilerName string
}

type GetConfigRow struct {
	Reconciler  string
	Key         string
	DisplayName string
	Description string
	Configured  bool
	Value       *string
	Secret      bool
}

func (q *Queries) GetConfig(ctx context.Context, arg GetConfigParams) ([]*GetConfigRow, error) {
	rows, err := q.db.Query(ctx, getConfig, arg.IncludeSecret, arg.ReconcilerName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetConfigRow{}
	for rows.Next() {
		var i GetConfigRow
		if err := rows.Scan(
			&i.Reconciler,
			&i.Key,
			&i.DisplayName,
			&i.Description,
			&i.Configured,
			&i.Value,
			&i.Secret,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const list = `-- name: List :many
SELECT
	name, display_name, description, enabled, member_aware
FROM
	reconcilers
ORDER BY
	display_name ASC
LIMIT
	$2
OFFSET
	$1
`

type ListParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) List(ctx context.Context, arg ListParams) ([]*Reconciler, error) {
	rows, err := q.db.Query(ctx, list, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Reconciler{}
	for rows.Next() {
		var i Reconciler
		if err := rows.Scan(
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.Enabled,
			&i.MemberAware,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setLastSuccessfulSyncForTeam = `-- name: SetLastSuccessfulSyncForTeam :exec
UPDATE teams
SET
	last_successful_sync = NOW()
WHERE
	teams.slug = $1
`

func (q *Queries) SetLastSuccessfulSyncForTeam(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, setLastSuccessfulSyncForTeam, argSlug)
	return err
}

const upsert = `-- name: Upsert :one
INSERT INTO
	reconcilers (
		name,
		display_name,
		description,
		member_aware,
		enabled
	)
VALUES
	(
		$1,
		$2,
		$3,
		$4,
		$5
	)
ON CONFLICT (name) DO UPDATE
SET
	display_name = EXCLUDED.display_name,
	description = EXCLUDED.description,
	member_aware = EXCLUDED.member_aware
RETURNING
	name, display_name, description, enabled, member_aware
`

type UpsertParams struct {
	Name         string
	DisplayName  string
	Description  string
	MemberAware  bool
	EnabledIfNew bool
}

func (q *Queries) Upsert(ctx context.Context, arg UpsertParams) (*Reconciler, error) {
	row := q.db.QueryRow(ctx, upsert,
		arg.Name,
		arg.DisplayName,
		arg.Description,
		arg.MemberAware,
		arg.EnabledIfNew,
	)
	var i Reconciler
	err := row.Scan(
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Enabled,
		&i.MemberAware,
	)
	return &i, err
}

const upsertConfig = `-- name: UpsertConfig :exec
INSERT INTO
	reconciler_config (
		reconciler,
		key,
		display_name,
		description,
		secret
	)
VALUES
	(
		$1,
		$2,
		$3,
		$4,
		$5
	)
ON CONFLICT (reconciler, key) DO UPDATE
SET
	display_name = EXCLUDED.display_name,
	description = EXCLUDED.description,
	secret = EXCLUDED.secret
`

type UpsertConfigParams struct {
	Reconciler  string
	Key         string
	DisplayName string
	Description string
	Secret      bool
}

func (q *Queries) UpsertConfig(ctx context.Context, arg UpsertConfigParams) error {
	_, err := q.db.Exec(ctx, upsertConfig,
		arg.Reconciler,
		arg.Key,
		arg.DisplayName,
		arg.Description,
		arg.Secret,
	)
	return err
}

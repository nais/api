// Code generated by sqlc. DO NOT EDIT.
// source: agent.sql

package grpcagentsql

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const conversationExists = `-- name: ConversationExists :one
SELECT
	EXISTS (
		SELECT
			1
		FROM
			agent_conversations
		WHERE
			id = $1
			AND user_id = $2
	)
`

type ConversationExistsParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) ConversationExists(ctx context.Context, arg ConversationExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, conversationExists, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countConversations = `-- name: CountConversations :one
SELECT
	COUNT(*)
FROM
	agent_conversations
WHERE
	user_id = $1
`

func (q *Queries) CountConversations(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countConversations, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createConversation = `-- name: CreateConversation :one
INSERT INTO
	agent_conversations (user_id, title)
VALUES
	($1, $2)
RETURNING
	id
`

type CreateConversationParams struct {
	UserID uuid.UUID
	Title  string
}

func (q *Queries) CreateConversation(ctx context.Context, arg CreateConversationParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createConversation, arg.UserID, arg.Title)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteConversation = `-- name: DeleteConversation :execrows
DELETE FROM agent_conversations
WHERE
	id = $1
	AND user_id = $2
`

type DeleteConversationParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteConversation(ctx context.Context, arg DeleteConversationParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteConversation, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOldestConversations = `-- name: DeleteOldestConversations :exec
DELETE FROM agent_conversations
WHERE
	id IN (
		SELECT
			agent_conversations.id
		FROM
			agent_conversations
		WHERE
			agent_conversations.user_id = $1
		ORDER BY
			agent_conversations.created_at ASC
		LIMIT
			$2
	)
`

type DeleteOldestConversationsParams struct {
	UserID     uuid.UUID
	LimitCount int32
}

func (q *Queries) DeleteOldestConversations(ctx context.Context, arg DeleteOldestConversationsParams) error {
	_, err := q.db.Exec(ctx, deleteOldestConversations, arg.UserID, arg.LimitCount)
	return err
}

const getConversation = `-- name: GetConversation :one
SELECT
	id,
	title,
	created_at,
	updated_at
FROM
	agent_conversations
WHERE
	id = $1
	AND user_id = $2
`

type GetConversationParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type GetConversationRow struct {
	ID        uuid.UUID
	Title     string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) GetConversation(ctx context.Context, arg GetConversationParams) (*GetConversationRow, error) {
	row := q.db.QueryRow(ctx, getConversation, arg.ID, arg.UserID)
	var i GetConversationRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getConversationHistory = `-- name: GetConversationHistory :many
SELECT
	role,
	content,
	tool_calls,
	tool_call_id
FROM
	agent_messages
WHERE
	conversation_id = $1
ORDER BY
	created_at ASC
`

type GetConversationHistoryRow struct {
	Role       string
	Content    string
	ToolCalls  []byte
	ToolCallID *string
}

func (q *Queries) GetConversationHistory(ctx context.Context, conversationID uuid.UUID) ([]*GetConversationHistoryRow, error) {
	rows, err := q.db.Query(ctx, getConversationHistory, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetConversationHistoryRow{}
	for rows.Next() {
		var i GetConversationHistoryRow
		if err := rows.Scan(
			&i.Role,
			&i.Content,
			&i.ToolCalls,
			&i.ToolCallID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationMessages = `-- name: GetConversationMessages :many
SELECT
	id,
	role,
	content,
	tool_calls,
	created_at
FROM
	agent_messages
WHERE
	conversation_id = $1
ORDER BY
	created_at ASC
`

type GetConversationMessagesRow struct {
	ID        uuid.UUID
	Role      string
	Content   string
	ToolCalls []byte
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) GetConversationMessages(ctx context.Context, conversationID uuid.UUID) ([]*GetConversationMessagesRow, error) {
	rows, err := q.db.Query(ctx, getConversationMessages, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetConversationMessagesRow{}
	for rows.Next() {
		var i GetConversationMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.Content,
			&i.ToolCalls,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMessage = `-- name: InsertMessage :exec
INSERT INTO
	agent_messages (conversation_id, role, content, tool_calls)
VALUES
	($1, $2, $3, $4)
`

type InsertMessageParams struct {
	ConversationID uuid.UUID
	Role           string
	Content        string
	ToolCalls      []byte
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) error {
	_, err := q.db.Exec(ctx, insertMessage,
		arg.ConversationID,
		arg.Role,
		arg.Content,
		arg.ToolCalls,
	)
	return err
}

const listConversations = `-- name: ListConversations :many
SELECT
	id,
	title,
	updated_at
FROM
	agent_conversations
WHERE
	user_id = $1
ORDER BY
	updated_at DESC
`

type ListConversationsRow struct {
	ID        uuid.UUID
	Title     string
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) ListConversations(ctx context.Context, userID uuid.UUID) ([]*ListConversationsRow, error) {
	rows, err := q.db.Query(ctx, listConversations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListConversationsRow{}
	for rows.Next() {
		var i ListConversationsRow
		if err := rows.Scan(&i.ID, &i.Title, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const touchConversation = `-- name: TouchConversation :exec
UPDATE agent_conversations
SET
	updated_at = NOW()
WHERE
	id = $1
`

func (q *Queries) TouchConversation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, touchConversation, id)
	return err
}

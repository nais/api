// Code generated by sqlc. DO NOT EDIT.
// source: teams.sql

package grpcteamsql

import (
	"context"

	"github.com/google/uuid"
	"github.com/nais/api/internal/slug"
)

const count = `-- name: Count :one
SELECT
	COUNT(*) AS total
FROM
	teams
`

func (q *Queries) Count(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, count)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countEnvironments = `-- name: CountEnvironments :one
SELECT
	COUNT(team_all_environments.*) AS total
FROM
	team_all_environments
	JOIN teams ON teams.slug = team_all_environments.team_slug
WHERE
	team_all_environments.team_slug = $1
`

func (q *Queries) CountEnvironments(ctx context.Context, teamSlug slug.Slug) (int64, error) {
	row := q.db.QueryRow(ctx, countEnvironments, teamSlug)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countMembers = `-- name: CountMembers :one
SELECT
	COUNT(user_roles.*) AS total
FROM
	user_roles
	JOIN teams ON teams.slug = user_roles.target_team_slug
WHERE
	user_roles.target_team_slug = $1::slug
`

func (q *Queries) CountMembers(ctx context.Context, teamSlug slug.Slug) (int64, error) {
	row := q.db.QueryRow(ctx, countMembers, teamSlug)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const delete = `-- name: Delete :exec
DELETE FROM teams
WHERE
	slug = $1
	AND delete_key_confirmed_at IS NOT NULL
`

func (q *Queries) Delete(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, delete, argSlug)
	return err
}

const get = `-- name: Get :one
SELECT
	slug, purpose, last_successful_sync, slack_channel, google_group_email, entra_id_group_id, github_team_slug, gar_repository, cdn_bucket, delete_key_confirmed_at
FROM
	teams
WHERE
	slug = $1
`

func (q *Queries) Get(ctx context.Context, argSlug slug.Slug) (*Team, error) {
	row := q.db.QueryRow(ctx, get, argSlug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.EntraIDGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.CdnBucket,
		&i.DeleteKeyConfirmedAt,
	)
	return &i, err
}

const list = `-- name: List :many
SELECT
	slug, purpose, last_successful_sync, slack_channel, google_group_email, entra_id_group_id, github_team_slug, gar_repository, cdn_bucket, delete_key_confirmed_at
FROM
	teams
ORDER BY
	slug ASC
LIMIT
	$2
OFFSET
	$1
`

type ListParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) List(ctx context.Context, arg ListParams) ([]*Team, error) {
	rows, err := q.db.Query(ctx, list, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.EntraIDGroupID,
			&i.GithubTeamSlug,
			&i.GarRepository,
			&i.CdnBucket,
			&i.DeleteKeyConfirmedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnvironments = `-- name: ListEnvironments :many
SELECT
	team_all_environments.team_slug, team_all_environments.environment, team_all_environments.gcp, team_all_environments.gcp_project_id, team_all_environments.id, team_all_environments.slack_alerts_channel
FROM
	team_all_environments
	JOIN teams ON teams.slug = team_all_environments.team_slug
WHERE
	team_all_environments.team_slug = $1
ORDER BY
	team_all_environments.environment ASC
LIMIT
	$3
OFFSET
	$2
`

type ListEnvironmentsParams struct {
	TeamSlug slug.Slug
	Offset   int32
	Limit    int32
}

func (q *Queries) ListEnvironments(ctx context.Context, arg ListEnvironmentsParams) ([]*TeamAllEnvironment, error) {
	rows, err := q.db.Query(ctx, listEnvironments, arg.TeamSlug, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TeamAllEnvironment{}
	for rows.Next() {
		var i TeamAllEnvironment
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Environment,
			&i.Gcp,
			&i.GcpProjectID,
			&i.ID,
			&i.SlackAlertsChannel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembers = `-- name: ListMembers :many
SELECT
	users.id, users.email, users.name, users.external_id
FROM
	user_roles
	JOIN teams ON teams.slug = user_roles.target_team_slug
	JOIN users ON users.id = user_roles.user_id
WHERE
	user_roles.target_team_slug = $1::slug
ORDER BY
	users.name ASC
LIMIT
	$3
OFFSET
	$2
`

type ListMembersParams struct {
	TeamSlug slug.Slug
	Offset   int32
	Limit    int32
}

func (q *Queries) ListMembers(ctx context.Context, arg ListMembersParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, listMembers, arg.TeamSlug, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setLastSuccessfulSync = `-- name: SetLastSuccessfulSync :exec
UPDATE teams
SET
	last_successful_sync = NOW()
WHERE
	teams.slug = $1
`

func (q *Queries) SetLastSuccessfulSync(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, setLastSuccessfulSync, argSlug)
	return err
}

const updateExternalReferences = `-- name: UpdateExternalReferences :exec
UPDATE teams
SET
	google_group_email = COALESCE($1, google_group_email),
	entra_id_group_id = COALESCE($2, entra_id_group_id),
	github_team_slug = COALESCE($3, github_team_slug),
	gar_repository = COALESCE($4, gar_repository),
	cdn_bucket = COALESCE($5, cdn_bucket)
WHERE
	teams.slug = $6
`

type UpdateExternalReferencesParams struct {
	GoogleGroupEmail *string
	EntraIDGroupID   *uuid.UUID
	GithubTeamSlug   *string
	GarRepository    *string
	CdnBucket        *string
	Slug             slug.Slug
}

func (q *Queries) UpdateExternalReferences(ctx context.Context, arg UpdateExternalReferencesParams) error {
	_, err := q.db.Exec(ctx, updateExternalReferences,
		arg.GoogleGroupEmail,
		arg.EntraIDGroupID,
		arg.GithubTeamSlug,
		arg.GarRepository,
		arg.CdnBucket,
		arg.Slug,
	)
	return err
}

const upsertEnvironment = `-- name: UpsertEnvironment :exec
INSERT INTO
	team_environments (
		team_slug,
		environment,
		slack_alerts_channel,
		gcp_project_id
	)
VALUES
	(
		$1,
		$2,
		$3,
		$4
	)
ON CONFLICT (team_slug, environment) DO
UPDATE
SET
	slack_alerts_channel = COALESCE(
		EXCLUDED.slack_alerts_channel,
		team_environments.slack_alerts_channel
	),
	gcp_project_id = COALESCE(
		EXCLUDED.gcp_project_id,
		team_environments.gcp_project_id
	)
`

type UpsertEnvironmentParams struct {
	TeamSlug           slug.Slug
	Environment        string
	SlackAlertsChannel *string
	GcpProjectID       *string
}

func (q *Queries) UpsertEnvironment(ctx context.Context, arg UpsertEnvironmentParams) error {
	_, err := q.db.Exec(ctx, upsertEnvironment,
		arg.TeamSlug,
		arg.Environment,
		arg.SlackAlertsChannel,
		arg.GcpProjectID,
	)
	return err
}

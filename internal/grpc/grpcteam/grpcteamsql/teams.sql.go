// Code generated by sqlc. DO NOT EDIT.
// source: teams.sql

package grpcteamsql

import (
	"context"

	"github.com/google/uuid"
	"github.com/nais/api/internal/slug"
)

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM teams
WHERE
	slug = $1
	AND delete_key_confirmed_at IS NOT NULL
`

func (q *Queries) DeleteTeam(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, deleteTeam, argSlug)
	return err
}

const getTeamBySlug = `-- name: GetTeamBySlug :one
SELECT
	slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, cdn_bucket, delete_key_confirmed_at
FROM
	teams
WHERE
	slug = $1
`

func (q *Queries) GetTeamBySlug(ctx context.Context, argSlug slug.Slug) (*Team, error) {
	row := q.db.QueryRow(ctx, getTeamBySlug, argSlug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.CdnBucket,
		&i.DeleteKeyConfirmedAt,
	)
	return &i, err
}

const getTeamEnvironments = `-- name: GetTeamEnvironments :many
SELECT
	team_all_environments.team_slug, team_all_environments.environment, team_all_environments.gcp, team_all_environments.gcp_project_id, team_all_environments.id, team_all_environments.slack_alerts_channel
FROM
	team_all_environments
	JOIN teams ON teams.slug = team_all_environments.team_slug
WHERE
	team_all_environments.team_slug = $1
ORDER BY
	team_all_environments.environment ASC
LIMIT
	$3
OFFSET
	$2
`

type GetTeamEnvironmentsParams struct {
	TeamSlug slug.Slug
	Offset   int32
	Limit    int32
}

func (q *Queries) GetTeamEnvironments(ctx context.Context, arg GetTeamEnvironmentsParams) ([]*TeamAllEnvironment, error) {
	rows, err := q.db.Query(ctx, getTeamEnvironments, arg.TeamSlug, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TeamAllEnvironment{}
	for rows.Next() {
		var i TeamAllEnvironment
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Environment,
			&i.Gcp,
			&i.GcpProjectID,
			&i.ID,
			&i.SlackAlertsChannel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamEnvironmentsCount = `-- name: GetTeamEnvironmentsCount :one
SELECT
	COUNT(team_all_environments.*) AS total
FROM
	team_all_environments
	JOIN teams ON teams.slug = team_all_environments.team_slug
WHERE
	team_all_environments.team_slug = $1
`

func (q *Queries) GetTeamEnvironmentsCount(ctx context.Context, teamSlug slug.Slug) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamEnvironmentsCount, teamSlug)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT
	users.id, users.email, users.name, users.external_id
FROM
	user_roles
	JOIN teams ON teams.slug = user_roles.target_team_slug
	JOIN users ON users.id = user_roles.user_id
WHERE
	user_roles.target_team_slug = $1::slug
ORDER BY
	users.name ASC
LIMIT
	$3
OFFSET
	$2
`

type GetTeamMembersParams struct {
	TeamSlug slug.Slug
	Offset   int32
	Limit    int32
}

func (q *Queries) GetTeamMembers(ctx context.Context, arg GetTeamMembersParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, getTeamMembers, arg.TeamSlug, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembersCount = `-- name: GetTeamMembersCount :one
SELECT
	COUNT(user_roles.*) AS total
FROM
	user_roles
	JOIN teams ON teams.slug = user_roles.target_team_slug
WHERE
	user_roles.target_team_slug = $1::slug
`

func (q *Queries) GetTeamMembersCount(ctx context.Context, teamSlug slug.Slug) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamMembersCount, teamSlug)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTeams = `-- name: GetTeams :many
SELECT
	slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, cdn_bucket, delete_key_confirmed_at
FROM
	teams
ORDER BY
	slug ASC
LIMIT
	$2
OFFSET
	$1
`

type GetTeamsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetTeams(ctx context.Context, arg GetTeamsParams) ([]*Team, error) {
	rows, err := q.db.Query(ctx, getTeams, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
			&i.GarRepository,
			&i.CdnBucket,
			&i.DeleteKeyConfirmedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsCount = `-- name: GetTeamsCount :one
SELECT
	COUNT(*) AS total
FROM
	teams
`

func (q *Queries) GetTeamsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamsCount)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const setLastSuccessfulSyncForTeam = `-- name: SetLastSuccessfulSyncForTeam :exec
UPDATE teams
SET
	last_successful_sync = NOW()
WHERE
	teams.slug = $1
`

func (q *Queries) SetLastSuccessfulSyncForTeam(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, setLastSuccessfulSyncForTeam, argSlug)
	return err
}

const updateTeamExternalReferences = `-- name: UpdateTeamExternalReferences :exec
UPDATE teams
SET
	google_group_email = COALESCE($1, google_group_email),
	azure_group_id = COALESCE($2, azure_group_id),
	github_team_slug = COALESCE($3, github_team_slug),
	gar_repository = COALESCE($4, gar_repository),
	cdn_bucket = COALESCE($5, cdn_bucket)
WHERE
	teams.slug = $6
`

type UpdateTeamExternalReferencesParams struct {
	GoogleGroupEmail *string
	AzureGroupID     *uuid.UUID
	GithubTeamSlug   *string
	GarRepository    *string
	CdnBucket        *string
	Slug             slug.Slug
}

func (q *Queries) UpdateTeamExternalReferences(ctx context.Context, arg UpdateTeamExternalReferencesParams) error {
	_, err := q.db.Exec(ctx, updateTeamExternalReferences,
		arg.GoogleGroupEmail,
		arg.AzureGroupID,
		arg.GithubTeamSlug,
		arg.GarRepository,
		arg.CdnBucket,
		arg.Slug,
	)
	return err
}

const upsertTeamEnvironment = `-- name: UpsertTeamEnvironment :exec
INSERT INTO
	team_environments (
		team_slug,
		environment,
		slack_alerts_channel,
		gcp_project_id
	)
VALUES
	(
		$1,
		$2,
		$3,
		$4
	)
ON CONFLICT (team_slug, environment) DO
UPDATE
SET
	slack_alerts_channel = COALESCE(
		EXCLUDED.slack_alerts_channel,
		team_environments.slack_alerts_channel
	),
	gcp_project_id = COALESCE(
		EXCLUDED.gcp_project_id,
		team_environments.gcp_project_id
	)
`

type UpsertTeamEnvironmentParams struct {
	TeamSlug           slug.Slug
	Environment        string
	SlackAlertsChannel *string
	GcpProjectID       *string
}

func (q *Queries) UpsertTeamEnvironment(ctx context.Context, arg UpsertTeamEnvironmentParams) error {
	_, err := q.db.Exec(ctx, upsertTeamEnvironment,
		arg.TeamSlug,
		arg.Environment,
		arg.SlackAlertsChannel,
		arg.GcpProjectID,
	)
	return err
}

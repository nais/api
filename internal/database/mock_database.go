// Code generated by mockery. DO NOT EDIT.

package database

import (
	audittype "github.com/nais/api/internal/auditlogger/audittype"
	authz "github.com/nais/api/internal/auth/authz"

	context "context"

	gensql "github.com/nais/api/internal/database/gensql"

	logger "github.com/nais/api/internal/logger"

	mock "github.com/stretchr/testify/mock"

	pgtype "github.com/jackc/pgx/v5/pgtype"

	protoapi "github.com/nais/api/pkg/protoapi"

	slug "github.com/nais/api/internal/slug"

	uuid "github.com/google/uuid"
)

// MockDatabase is an autogenerated mock type for the Database type
type MockDatabase struct {
	mock.Mock
}

type MockDatabase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDatabase) EXPECT() *MockDatabase_Expecter {
	return &MockDatabase_Expecter{mock: &_m.Mock}
}

// AddReconcilerOptOut provides a mock function with given fields: ctx, userID, teamSlug, reconcilerName
func (_m *MockDatabase) AddReconcilerOptOut(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug, reconcilerName string) error {
	ret := _m.Called(ctx, userID, teamSlug, reconcilerName)

	if len(ret) == 0 {
		panic("no return value specified for AddReconcilerOptOut")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, slug.Slug, string) error); ok {
		r0 = rf(ctx, userID, teamSlug, reconcilerName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_AddReconcilerOptOut_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddReconcilerOptOut'
type MockDatabase_AddReconcilerOptOut_Call struct {
	*mock.Call
}

// AddReconcilerOptOut is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - teamSlug slug.Slug
//   - reconcilerName string
func (_e *MockDatabase_Expecter) AddReconcilerOptOut(ctx interface{}, userID interface{}, teamSlug interface{}, reconcilerName interface{}) *MockDatabase_AddReconcilerOptOut_Call {
	return &MockDatabase_AddReconcilerOptOut_Call{Call: _e.mock.On("AddReconcilerOptOut", ctx, userID, teamSlug, reconcilerName)}
}

func (_c *MockDatabase_AddReconcilerOptOut_Call) Run(run func(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug, reconcilerName string)) *MockDatabase_AddReconcilerOptOut_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(slug.Slug), args[3].(string))
	})
	return _c
}

func (_c *MockDatabase_AddReconcilerOptOut_Call) Return(_a0 error) *MockDatabase_AddReconcilerOptOut_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_AddReconcilerOptOut_Call) RunAndReturn(run func(context.Context, uuid.UUID, slug.Slug, string) error) *MockDatabase_AddReconcilerOptOut_Call {
	_c.Call.Return(run)
	return _c
}

// AssignGlobalRoleToServiceAccount provides a mock function with given fields: ctx, serviceAccountID, roleName
func (_m *MockDatabase) AssignGlobalRoleToServiceAccount(ctx context.Context, serviceAccountID uuid.UUID, roleName gensql.RoleName) error {
	ret := _m.Called(ctx, serviceAccountID, roleName)

	if len(ret) == 0 {
		panic("no return value specified for AssignGlobalRoleToServiceAccount")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, gensql.RoleName) error); ok {
		r0 = rf(ctx, serviceAccountID, roleName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_AssignGlobalRoleToServiceAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignGlobalRoleToServiceAccount'
type MockDatabase_AssignGlobalRoleToServiceAccount_Call struct {
	*mock.Call
}

// AssignGlobalRoleToServiceAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceAccountID uuid.UUID
//   - roleName gensql.RoleName
func (_e *MockDatabase_Expecter) AssignGlobalRoleToServiceAccount(ctx interface{}, serviceAccountID interface{}, roleName interface{}) *MockDatabase_AssignGlobalRoleToServiceAccount_Call {
	return &MockDatabase_AssignGlobalRoleToServiceAccount_Call{Call: _e.mock.On("AssignGlobalRoleToServiceAccount", ctx, serviceAccountID, roleName)}
}

func (_c *MockDatabase_AssignGlobalRoleToServiceAccount_Call) Run(run func(ctx context.Context, serviceAccountID uuid.UUID, roleName gensql.RoleName)) *MockDatabase_AssignGlobalRoleToServiceAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(gensql.RoleName))
	})
	return _c
}

func (_c *MockDatabase_AssignGlobalRoleToServiceAccount_Call) Return(_a0 error) *MockDatabase_AssignGlobalRoleToServiceAccount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_AssignGlobalRoleToServiceAccount_Call) RunAndReturn(run func(context.Context, uuid.UUID, gensql.RoleName) error) *MockDatabase_AssignGlobalRoleToServiceAccount_Call {
	_c.Call.Return(run)
	return _c
}

// AssignGlobalRoleToUser provides a mock function with given fields: ctx, userID, roleName
func (_m *MockDatabase) AssignGlobalRoleToUser(ctx context.Context, userID uuid.UUID, roleName gensql.RoleName) error {
	ret := _m.Called(ctx, userID, roleName)

	if len(ret) == 0 {
		panic("no return value specified for AssignGlobalRoleToUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, gensql.RoleName) error); ok {
		r0 = rf(ctx, userID, roleName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_AssignGlobalRoleToUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignGlobalRoleToUser'
type MockDatabase_AssignGlobalRoleToUser_Call struct {
	*mock.Call
}

// AssignGlobalRoleToUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - roleName gensql.RoleName
func (_e *MockDatabase_Expecter) AssignGlobalRoleToUser(ctx interface{}, userID interface{}, roleName interface{}) *MockDatabase_AssignGlobalRoleToUser_Call {
	return &MockDatabase_AssignGlobalRoleToUser_Call{Call: _e.mock.On("AssignGlobalRoleToUser", ctx, userID, roleName)}
}

func (_c *MockDatabase_AssignGlobalRoleToUser_Call) Run(run func(ctx context.Context, userID uuid.UUID, roleName gensql.RoleName)) *MockDatabase_AssignGlobalRoleToUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(gensql.RoleName))
	})
	return _c
}

func (_c *MockDatabase_AssignGlobalRoleToUser_Call) Return(_a0 error) *MockDatabase_AssignGlobalRoleToUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_AssignGlobalRoleToUser_Call) RunAndReturn(run func(context.Context, uuid.UUID, gensql.RoleName) error) *MockDatabase_AssignGlobalRoleToUser_Call {
	_c.Call.Return(run)
	return _c
}

// AssignTeamRoleToServiceAccount provides a mock function with given fields: ctx, serviceAccountID, roleName, teamSlug
func (_m *MockDatabase) AssignTeamRoleToServiceAccount(ctx context.Context, serviceAccountID uuid.UUID, roleName gensql.RoleName, teamSlug slug.Slug) error {
	ret := _m.Called(ctx, serviceAccountID, roleName, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for AssignTeamRoleToServiceAccount")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, gensql.RoleName, slug.Slug) error); ok {
		r0 = rf(ctx, serviceAccountID, roleName, teamSlug)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_AssignTeamRoleToServiceAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignTeamRoleToServiceAccount'
type MockDatabase_AssignTeamRoleToServiceAccount_Call struct {
	*mock.Call
}

// AssignTeamRoleToServiceAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceAccountID uuid.UUID
//   - roleName gensql.RoleName
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) AssignTeamRoleToServiceAccount(ctx interface{}, serviceAccountID interface{}, roleName interface{}, teamSlug interface{}) *MockDatabase_AssignTeamRoleToServiceAccount_Call {
	return &MockDatabase_AssignTeamRoleToServiceAccount_Call{Call: _e.mock.On("AssignTeamRoleToServiceAccount", ctx, serviceAccountID, roleName, teamSlug)}
}

func (_c *MockDatabase_AssignTeamRoleToServiceAccount_Call) Run(run func(ctx context.Context, serviceAccountID uuid.UUID, roleName gensql.RoleName, teamSlug slug.Slug)) *MockDatabase_AssignTeamRoleToServiceAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(gensql.RoleName), args[3].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_AssignTeamRoleToServiceAccount_Call) Return(_a0 error) *MockDatabase_AssignTeamRoleToServiceAccount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_AssignTeamRoleToServiceAccount_Call) RunAndReturn(run func(context.Context, uuid.UUID, gensql.RoleName, slug.Slug) error) *MockDatabase_AssignTeamRoleToServiceAccount_Call {
	_c.Call.Return(run)
	return _c
}

// AverageResourceUtilizationForTeam provides a mock function with given fields: ctx, teamSlug, resourceType, timestamp
func (_m *MockDatabase) AverageResourceUtilizationForTeam(ctx context.Context, teamSlug slug.Slug, resourceType gensql.ResourceType, timestamp pgtype.Timestamptz) (*gensql.AverageResourceUtilizationForTeamRow, error) {
	ret := _m.Called(ctx, teamSlug, resourceType, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for AverageResourceUtilizationForTeam")
	}

	var r0 *gensql.AverageResourceUtilizationForTeamRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, gensql.ResourceType, pgtype.Timestamptz) (*gensql.AverageResourceUtilizationForTeamRow, error)); ok {
		return rf(ctx, teamSlug, resourceType, timestamp)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, gensql.ResourceType, pgtype.Timestamptz) *gensql.AverageResourceUtilizationForTeamRow); ok {
		r0 = rf(ctx, teamSlug, resourceType, timestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gensql.AverageResourceUtilizationForTeamRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, gensql.ResourceType, pgtype.Timestamptz) error); ok {
		r1 = rf(ctx, teamSlug, resourceType, timestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_AverageResourceUtilizationForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AverageResourceUtilizationForTeam'
type MockDatabase_AverageResourceUtilizationForTeam_Call struct {
	*mock.Call
}

// AverageResourceUtilizationForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - resourceType gensql.ResourceType
//   - timestamp pgtype.Timestamptz
func (_e *MockDatabase_Expecter) AverageResourceUtilizationForTeam(ctx interface{}, teamSlug interface{}, resourceType interface{}, timestamp interface{}) *MockDatabase_AverageResourceUtilizationForTeam_Call {
	return &MockDatabase_AverageResourceUtilizationForTeam_Call{Call: _e.mock.On("AverageResourceUtilizationForTeam", ctx, teamSlug, resourceType, timestamp)}
}

func (_c *MockDatabase_AverageResourceUtilizationForTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, resourceType gensql.ResourceType, timestamp pgtype.Timestamptz)) *MockDatabase_AverageResourceUtilizationForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(gensql.ResourceType), args[3].(pgtype.Timestamptz))
	})
	return _c
}

func (_c *MockDatabase_AverageResourceUtilizationForTeam_Call) Return(_a0 *gensql.AverageResourceUtilizationForTeamRow, _a1 error) *MockDatabase_AverageResourceUtilizationForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_AverageResourceUtilizationForTeam_Call) RunAndReturn(run func(context.Context, slug.Slug, gensql.ResourceType, pgtype.Timestamptz) (*gensql.AverageResourceUtilizationForTeamRow, error)) *MockDatabase_AverageResourceUtilizationForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// ClearReconcilerErrorsForTeam provides a mock function with given fields: ctx, teamSlug, reconcilerName
func (_m *MockDatabase) ClearReconcilerErrorsForTeam(ctx context.Context, teamSlug slug.Slug, reconcilerName string) error {
	ret := _m.Called(ctx, teamSlug, reconcilerName)

	if len(ret) == 0 {
		panic("no return value specified for ClearReconcilerErrorsForTeam")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string) error); ok {
		r0 = rf(ctx, teamSlug, reconcilerName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_ClearReconcilerErrorsForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClearReconcilerErrorsForTeam'
type MockDatabase_ClearReconcilerErrorsForTeam_Call struct {
	*mock.Call
}

// ClearReconcilerErrorsForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - reconcilerName string
func (_e *MockDatabase_Expecter) ClearReconcilerErrorsForTeam(ctx interface{}, teamSlug interface{}, reconcilerName interface{}) *MockDatabase_ClearReconcilerErrorsForTeam_Call {
	return &MockDatabase_ClearReconcilerErrorsForTeam_Call{Call: _e.mock.On("ClearReconcilerErrorsForTeam", ctx, teamSlug, reconcilerName)}
}

func (_c *MockDatabase_ClearReconcilerErrorsForTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, reconcilerName string)) *MockDatabase_ClearReconcilerErrorsForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(string))
	})
	return _c
}

func (_c *MockDatabase_ClearReconcilerErrorsForTeam_Call) Return(_a0 error) *MockDatabase_ClearReconcilerErrorsForTeam_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_ClearReconcilerErrorsForTeam_Call) RunAndReturn(run func(context.Context, slug.Slug, string) error) *MockDatabase_ClearReconcilerErrorsForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigureReconciler provides a mock function with given fields: ctx, reconcilerName, key, value
func (_m *MockDatabase) ConfigureReconciler(ctx context.Context, reconcilerName string, key string, value string) error {
	ret := _m.Called(ctx, reconcilerName, key, value)

	if len(ret) == 0 {
		panic("no return value specified for ConfigureReconciler")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, reconcilerName, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_ConfigureReconciler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigureReconciler'
type MockDatabase_ConfigureReconciler_Call struct {
	*mock.Call
}

// ConfigureReconciler is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
//   - key string
//   - value string
func (_e *MockDatabase_Expecter) ConfigureReconciler(ctx interface{}, reconcilerName interface{}, key interface{}, value interface{}) *MockDatabase_ConfigureReconciler_Call {
	return &MockDatabase_ConfigureReconciler_Call{Call: _e.mock.On("ConfigureReconciler", ctx, reconcilerName, key, value)}
}

func (_c *MockDatabase_ConfigureReconciler_Call) Run(run func(ctx context.Context, reconcilerName string, key string, value string)) *MockDatabase_ConfigureReconciler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockDatabase_ConfigureReconciler_Call) Return(_a0 error) *MockDatabase_ConfigureReconciler_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_ConfigureReconciler_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockDatabase_ConfigureReconciler_Call {
	_c.Call.Return(run)
	return _c
}

// ConfirmTeamDeleteKey provides a mock function with given fields: ctx, key
func (_m *MockDatabase) ConfirmTeamDeleteKey(ctx context.Context, key uuid.UUID) error {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ConfirmTeamDeleteKey")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_ConfirmTeamDeleteKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfirmTeamDeleteKey'
type MockDatabase_ConfirmTeamDeleteKey_Call struct {
	*mock.Call
}

// ConfirmTeamDeleteKey is a helper method to define mock.On call
//   - ctx context.Context
//   - key uuid.UUID
func (_e *MockDatabase_Expecter) ConfirmTeamDeleteKey(ctx interface{}, key interface{}) *MockDatabase_ConfirmTeamDeleteKey_Call {
	return &MockDatabase_ConfirmTeamDeleteKey_Call{Call: _e.mock.On("ConfirmTeamDeleteKey", ctx, key)}
}

func (_c *MockDatabase_ConfirmTeamDeleteKey_Call) Run(run func(ctx context.Context, key uuid.UUID)) *MockDatabase_ConfirmTeamDeleteKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_ConfirmTeamDeleteKey_Call) Return(_a0 error) *MockDatabase_ConfirmTeamDeleteKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_ConfirmTeamDeleteKey_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockDatabase_ConfirmTeamDeleteKey_Call {
	_c.Call.Return(run)
	return _c
}

// CostUpsert provides a mock function with given fields: ctx, arg
func (_m *MockDatabase) CostUpsert(ctx context.Context, arg []gensql.CostUpsertParams) *gensql.CostUpsertBatchResults {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CostUpsert")
	}

	var r0 *gensql.CostUpsertBatchResults
	if rf, ok := ret.Get(0).(func(context.Context, []gensql.CostUpsertParams) *gensql.CostUpsertBatchResults); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gensql.CostUpsertBatchResults)
		}
	}

	return r0
}

// MockDatabase_CostUpsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CostUpsert'
type MockDatabase_CostUpsert_Call struct {
	*mock.Call
}

// CostUpsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg []gensql.CostUpsertParams
func (_e *MockDatabase_Expecter) CostUpsert(ctx interface{}, arg interface{}) *MockDatabase_CostUpsert_Call {
	return &MockDatabase_CostUpsert_Call{Call: _e.mock.On("CostUpsert", ctx, arg)}
}

func (_c *MockDatabase_CostUpsert_Call) Run(run func(ctx context.Context, arg []gensql.CostUpsertParams)) *MockDatabase_CostUpsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]gensql.CostUpsertParams))
	})
	return _c
}

func (_c *MockDatabase_CostUpsert_Call) Return(_a0 *gensql.CostUpsertBatchResults) *MockDatabase_CostUpsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_CostUpsert_Call) RunAndReturn(run func(context.Context, []gensql.CostUpsertParams) *gensql.CostUpsertBatchResults) *MockDatabase_CostUpsert_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAPIKey provides a mock function with given fields: ctx, apiKey, serviceAccountID
func (_m *MockDatabase) CreateAPIKey(ctx context.Context, apiKey string, serviceAccountID uuid.UUID) error {
	ret := _m.Called(ctx, apiKey, serviceAccountID)

	if len(ret) == 0 {
		panic("no return value specified for CreateAPIKey")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uuid.UUID) error); ok {
		r0 = rf(ctx, apiKey, serviceAccountID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_CreateAPIKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAPIKey'
type MockDatabase_CreateAPIKey_Call struct {
	*mock.Call
}

// CreateAPIKey is a helper method to define mock.On call
//   - ctx context.Context
//   - apiKey string
//   - serviceAccountID uuid.UUID
func (_e *MockDatabase_Expecter) CreateAPIKey(ctx interface{}, apiKey interface{}, serviceAccountID interface{}) *MockDatabase_CreateAPIKey_Call {
	return &MockDatabase_CreateAPIKey_Call{Call: _e.mock.On("CreateAPIKey", ctx, apiKey, serviceAccountID)}
}

func (_c *MockDatabase_CreateAPIKey_Call) Run(run func(ctx context.Context, apiKey string, serviceAccountID uuid.UUID)) *MockDatabase_CreateAPIKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_CreateAPIKey_Call) Return(_a0 error) *MockDatabase_CreateAPIKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_CreateAPIKey_Call) RunAndReturn(run func(context.Context, string, uuid.UUID) error) *MockDatabase_CreateAPIKey_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAuditLogEntry provides a mock function with given fields: ctx, correlationID, componentName, actor, targetType, targetIdentifier, action, message
func (_m *MockDatabase) CreateAuditLogEntry(ctx context.Context, correlationID uuid.UUID, componentName logger.ComponentName, actor *string, targetType audittype.AuditLogsTargetType, targetIdentifier string, action audittype.AuditAction, message string) error {
	ret := _m.Called(ctx, correlationID, componentName, actor, targetType, targetIdentifier, action, message)

	if len(ret) == 0 {
		panic("no return value specified for CreateAuditLogEntry")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, logger.ComponentName, *string, audittype.AuditLogsTargetType, string, audittype.AuditAction, string) error); ok {
		r0 = rf(ctx, correlationID, componentName, actor, targetType, targetIdentifier, action, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_CreateAuditLogEntry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAuditLogEntry'
type MockDatabase_CreateAuditLogEntry_Call struct {
	*mock.Call
}

// CreateAuditLogEntry is a helper method to define mock.On call
//   - ctx context.Context
//   - correlationID uuid.UUID
//   - componentName logger.ComponentName
//   - actor *string
//   - targetType audittype.AuditLogsTargetType
//   - targetIdentifier string
//   - action audittype.AuditAction
//   - message string
func (_e *MockDatabase_Expecter) CreateAuditLogEntry(ctx interface{}, correlationID interface{}, componentName interface{}, actor interface{}, targetType interface{}, targetIdentifier interface{}, action interface{}, message interface{}) *MockDatabase_CreateAuditLogEntry_Call {
	return &MockDatabase_CreateAuditLogEntry_Call{Call: _e.mock.On("CreateAuditLogEntry", ctx, correlationID, componentName, actor, targetType, targetIdentifier, action, message)}
}

func (_c *MockDatabase_CreateAuditLogEntry_Call) Run(run func(ctx context.Context, correlationID uuid.UUID, componentName logger.ComponentName, actor *string, targetType audittype.AuditLogsTargetType, targetIdentifier string, action audittype.AuditAction, message string)) *MockDatabase_CreateAuditLogEntry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(logger.ComponentName), args[3].(*string), args[4].(audittype.AuditLogsTargetType), args[5].(string), args[6].(audittype.AuditAction), args[7].(string))
	})
	return _c
}

func (_c *MockDatabase_CreateAuditLogEntry_Call) Return(_a0 error) *MockDatabase_CreateAuditLogEntry_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_CreateAuditLogEntry_Call) RunAndReturn(run func(context.Context, uuid.UUID, logger.ComponentName, *string, audittype.AuditLogsTargetType, string, audittype.AuditAction, string) error) *MockDatabase_CreateAuditLogEntry_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDependencytrackProject provides a mock function with given fields: ctx, arg
func (_m *MockDatabase) CreateDependencytrackProject(ctx context.Context, arg gensql.CreateDependencytrackProjectParams) error {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateDependencytrackProject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, gensql.CreateDependencytrackProjectParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_CreateDependencytrackProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDependencytrackProject'
type MockDatabase_CreateDependencytrackProject_Call struct {
	*mock.Call
}

// CreateDependencytrackProject is a helper method to define mock.On call
//   - ctx context.Context
//   - arg gensql.CreateDependencytrackProjectParams
func (_e *MockDatabase_Expecter) CreateDependencytrackProject(ctx interface{}, arg interface{}) *MockDatabase_CreateDependencytrackProject_Call {
	return &MockDatabase_CreateDependencytrackProject_Call{Call: _e.mock.On("CreateDependencytrackProject", ctx, arg)}
}

func (_c *MockDatabase_CreateDependencytrackProject_Call) Run(run func(ctx context.Context, arg gensql.CreateDependencytrackProjectParams)) *MockDatabase_CreateDependencytrackProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gensql.CreateDependencytrackProjectParams))
	})
	return _c
}

func (_c *MockDatabase_CreateDependencytrackProject_Call) Return(_a0 error) *MockDatabase_CreateDependencytrackProject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_CreateDependencytrackProject_Call) RunAndReturn(run func(context.Context, gensql.CreateDependencytrackProjectParams) error) *MockDatabase_CreateDependencytrackProject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRepositoryAuthorization provides a mock function with given fields: ctx, teamSlug, repoName, authorization
func (_m *MockDatabase) CreateRepositoryAuthorization(ctx context.Context, teamSlug slug.Slug, repoName string, authorization gensql.RepositoryAuthorizationEnum) error {
	ret := _m.Called(ctx, teamSlug, repoName, authorization)

	if len(ret) == 0 {
		panic("no return value specified for CreateRepositoryAuthorization")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string, gensql.RepositoryAuthorizationEnum) error); ok {
		r0 = rf(ctx, teamSlug, repoName, authorization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_CreateRepositoryAuthorization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRepositoryAuthorization'
type MockDatabase_CreateRepositoryAuthorization_Call struct {
	*mock.Call
}

// CreateRepositoryAuthorization is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - repoName string
//   - authorization gensql.RepositoryAuthorizationEnum
func (_e *MockDatabase_Expecter) CreateRepositoryAuthorization(ctx interface{}, teamSlug interface{}, repoName interface{}, authorization interface{}) *MockDatabase_CreateRepositoryAuthorization_Call {
	return &MockDatabase_CreateRepositoryAuthorization_Call{Call: _e.mock.On("CreateRepositoryAuthorization", ctx, teamSlug, repoName, authorization)}
}

func (_c *MockDatabase_CreateRepositoryAuthorization_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, repoName string, authorization gensql.RepositoryAuthorizationEnum)) *MockDatabase_CreateRepositoryAuthorization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(string), args[3].(gensql.RepositoryAuthorizationEnum))
	})
	return _c
}

func (_c *MockDatabase_CreateRepositoryAuthorization_Call) Return(_a0 error) *MockDatabase_CreateRepositoryAuthorization_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_CreateRepositoryAuthorization_Call) RunAndReturn(run func(context.Context, slug.Slug, string, gensql.RepositoryAuthorizationEnum) error) *MockDatabase_CreateRepositoryAuthorization_Call {
	_c.Call.Return(run)
	return _c
}

// CreateServiceAccount provides a mock function with given fields: ctx, name
func (_m *MockDatabase) CreateServiceAccount(ctx context.Context, name string) (*ServiceAccount, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for CreateServiceAccount")
	}

	var r0 *ServiceAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*ServiceAccount, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *ServiceAccount); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ServiceAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_CreateServiceAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateServiceAccount'
type MockDatabase_CreateServiceAccount_Call struct {
	*mock.Call
}

// CreateServiceAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockDatabase_Expecter) CreateServiceAccount(ctx interface{}, name interface{}) *MockDatabase_CreateServiceAccount_Call {
	return &MockDatabase_CreateServiceAccount_Call{Call: _e.mock.On("CreateServiceAccount", ctx, name)}
}

func (_c *MockDatabase_CreateServiceAccount_Call) Run(run func(ctx context.Context, name string)) *MockDatabase_CreateServiceAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDatabase_CreateServiceAccount_Call) Return(_a0 *ServiceAccount, _a1 error) *MockDatabase_CreateServiceAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_CreateServiceAccount_Call) RunAndReturn(run func(context.Context, string) (*ServiceAccount, error)) *MockDatabase_CreateServiceAccount_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSession provides a mock function with given fields: ctx, userID
func (_m *MockDatabase) CreateSession(ctx context.Context, userID uuid.UUID) (*Session, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for CreateSession")
	}

	var r0 *Session
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*Session, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *Session); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Session)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_CreateSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSession'
type MockDatabase_CreateSession_Call struct {
	*mock.Call
}

// CreateSession is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockDatabase_Expecter) CreateSession(ctx interface{}, userID interface{}) *MockDatabase_CreateSession_Call {
	return &MockDatabase_CreateSession_Call{Call: _e.mock.On("CreateSession", ctx, userID)}
}

func (_c *MockDatabase_CreateSession_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockDatabase_CreateSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_CreateSession_Call) Return(_a0 *Session, _a1 error) *MockDatabase_CreateSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_CreateSession_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*Session, error)) *MockDatabase_CreateSession_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTeam provides a mock function with given fields: ctx, teamSlug, purpose, slackChannel
func (_m *MockDatabase) CreateTeam(ctx context.Context, teamSlug slug.Slug, purpose string, slackChannel string) (*Team, error) {
	ret := _m.Called(ctx, teamSlug, purpose, slackChannel)

	if len(ret) == 0 {
		panic("no return value specified for CreateTeam")
	}

	var r0 *Team
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string, string) (*Team, error)); ok {
		return rf(ctx, teamSlug, purpose, slackChannel)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string, string) *Team); ok {
		r0 = rf(ctx, teamSlug, purpose, slackChannel)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, string, string) error); ok {
		r1 = rf(ctx, teamSlug, purpose, slackChannel)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_CreateTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTeam'
type MockDatabase_CreateTeam_Call struct {
	*mock.Call
}

// CreateTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - purpose string
//   - slackChannel string
func (_e *MockDatabase_Expecter) CreateTeam(ctx interface{}, teamSlug interface{}, purpose interface{}, slackChannel interface{}) *MockDatabase_CreateTeam_Call {
	return &MockDatabase_CreateTeam_Call{Call: _e.mock.On("CreateTeam", ctx, teamSlug, purpose, slackChannel)}
}

func (_c *MockDatabase_CreateTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, purpose string, slackChannel string)) *MockDatabase_CreateTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockDatabase_CreateTeam_Call) Return(_a0 *Team, _a1 error) *MockDatabase_CreateTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_CreateTeam_Call) RunAndReturn(run func(context.Context, slug.Slug, string, string) (*Team, error)) *MockDatabase_CreateTeam_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTeamDeleteKey provides a mock function with given fields: ctx, teamSlug, userID
func (_m *MockDatabase) CreateTeamDeleteKey(ctx context.Context, teamSlug slug.Slug, userID uuid.UUID) (*TeamDeleteKey, error) {
	ret := _m.Called(ctx, teamSlug, userID)

	if len(ret) == 0 {
		panic("no return value specified for CreateTeamDeleteKey")
	}

	var r0 *TeamDeleteKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, uuid.UUID) (*TeamDeleteKey, error)); ok {
		return rf(ctx, teamSlug, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, uuid.UUID) *TeamDeleteKey); ok {
		r0 = rf(ctx, teamSlug, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TeamDeleteKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, uuid.UUID) error); ok {
		r1 = rf(ctx, teamSlug, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_CreateTeamDeleteKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTeamDeleteKey'
type MockDatabase_CreateTeamDeleteKey_Call struct {
	*mock.Call
}

// CreateTeamDeleteKey is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - userID uuid.UUID
func (_e *MockDatabase_Expecter) CreateTeamDeleteKey(ctx interface{}, teamSlug interface{}, userID interface{}) *MockDatabase_CreateTeamDeleteKey_Call {
	return &MockDatabase_CreateTeamDeleteKey_Call{Call: _e.mock.On("CreateTeamDeleteKey", ctx, teamSlug, userID)}
}

func (_c *MockDatabase_CreateTeamDeleteKey_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, userID uuid.UUID)) *MockDatabase_CreateTeamDeleteKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_CreateTeamDeleteKey_Call) Return(_a0 *TeamDeleteKey, _a1 error) *MockDatabase_CreateTeamDeleteKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_CreateTeamDeleteKey_Call) RunAndReturn(run func(context.Context, slug.Slug, uuid.UUID) (*TeamDeleteKey, error)) *MockDatabase_CreateTeamDeleteKey_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: ctx, name, email, externalID
func (_m *MockDatabase) CreateUser(ctx context.Context, name string, email string, externalID string) (*User, error) {
	ret := _m.Called(ctx, name, email, externalID)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (*User, error)); ok {
		return rf(ctx, name, email, externalID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *User); ok {
		r0 = rf(ctx, name, email, externalID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, name, email, externalID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockDatabase_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - email string
//   - externalID string
func (_e *MockDatabase_Expecter) CreateUser(ctx interface{}, name interface{}, email interface{}, externalID interface{}) *MockDatabase_CreateUser_Call {
	return &MockDatabase_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, name, email, externalID)}
}

func (_c *MockDatabase_CreateUser_Call) Run(run func(ctx context.Context, name string, email string, externalID string)) *MockDatabase_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockDatabase_CreateUser_Call) Return(_a0 *User, _a1 error) *MockDatabase_CreateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_CreateUser_Call) RunAndReturn(run func(context.Context, string, string, string) (*User, error)) *MockDatabase_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DailyCostForApp provides a mock function with given fields: ctx, fromDate, toDate, environment, teamSlug, app
func (_m *MockDatabase) DailyCostForApp(ctx context.Context, fromDate pgtype.Date, toDate pgtype.Date, environment string, teamSlug slug.Slug, app string) ([]*gensql.Cost, error) {
	ret := _m.Called(ctx, fromDate, toDate, environment, teamSlug, app)

	if len(ret) == 0 {
		panic("no return value specified for DailyCostForApp")
	}

	var r0 []*gensql.Cost
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Date, pgtype.Date, string, slug.Slug, string) ([]*gensql.Cost, error)); ok {
		return rf(ctx, fromDate, toDate, environment, teamSlug, app)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Date, pgtype.Date, string, slug.Slug, string) []*gensql.Cost); ok {
		r0 = rf(ctx, fromDate, toDate, environment, teamSlug, app)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gensql.Cost)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgtype.Date, pgtype.Date, string, slug.Slug, string) error); ok {
		r1 = rf(ctx, fromDate, toDate, environment, teamSlug, app)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_DailyCostForApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DailyCostForApp'
type MockDatabase_DailyCostForApp_Call struct {
	*mock.Call
}

// DailyCostForApp is a helper method to define mock.On call
//   - ctx context.Context
//   - fromDate pgtype.Date
//   - toDate pgtype.Date
//   - environment string
//   - teamSlug slug.Slug
//   - app string
func (_e *MockDatabase_Expecter) DailyCostForApp(ctx interface{}, fromDate interface{}, toDate interface{}, environment interface{}, teamSlug interface{}, app interface{}) *MockDatabase_DailyCostForApp_Call {
	return &MockDatabase_DailyCostForApp_Call{Call: _e.mock.On("DailyCostForApp", ctx, fromDate, toDate, environment, teamSlug, app)}
}

func (_c *MockDatabase_DailyCostForApp_Call) Run(run func(ctx context.Context, fromDate pgtype.Date, toDate pgtype.Date, environment string, teamSlug slug.Slug, app string)) *MockDatabase_DailyCostForApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgtype.Date), args[2].(pgtype.Date), args[3].(string), args[4].(slug.Slug), args[5].(string))
	})
	return _c
}

func (_c *MockDatabase_DailyCostForApp_Call) Return(_a0 []*gensql.Cost, _a1 error) *MockDatabase_DailyCostForApp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_DailyCostForApp_Call) RunAndReturn(run func(context.Context, pgtype.Date, pgtype.Date, string, slug.Slug, string) ([]*gensql.Cost, error)) *MockDatabase_DailyCostForApp_Call {
	_c.Call.Return(run)
	return _c
}

// DailyCostForTeam provides a mock function with given fields: ctx, fromDate, toDate, teamSlug
func (_m *MockDatabase) DailyCostForTeam(ctx context.Context, fromDate pgtype.Date, toDate pgtype.Date, teamSlug slug.Slug) ([]*gensql.Cost, error) {
	ret := _m.Called(ctx, fromDate, toDate, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for DailyCostForTeam")
	}

	var r0 []*gensql.Cost
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Date, pgtype.Date, slug.Slug) ([]*gensql.Cost, error)); ok {
		return rf(ctx, fromDate, toDate, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Date, pgtype.Date, slug.Slug) []*gensql.Cost); ok {
		r0 = rf(ctx, fromDate, toDate, teamSlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gensql.Cost)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgtype.Date, pgtype.Date, slug.Slug) error); ok {
		r1 = rf(ctx, fromDate, toDate, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_DailyCostForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DailyCostForTeam'
type MockDatabase_DailyCostForTeam_Call struct {
	*mock.Call
}

// DailyCostForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - fromDate pgtype.Date
//   - toDate pgtype.Date
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) DailyCostForTeam(ctx interface{}, fromDate interface{}, toDate interface{}, teamSlug interface{}) *MockDatabase_DailyCostForTeam_Call {
	return &MockDatabase_DailyCostForTeam_Call{Call: _e.mock.On("DailyCostForTeam", ctx, fromDate, toDate, teamSlug)}
}

func (_c *MockDatabase_DailyCostForTeam_Call) Run(run func(ctx context.Context, fromDate pgtype.Date, toDate pgtype.Date, teamSlug slug.Slug)) *MockDatabase_DailyCostForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgtype.Date), args[2].(pgtype.Date), args[3].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_DailyCostForTeam_Call) Return(_a0 []*gensql.Cost, _a1 error) *MockDatabase_DailyCostForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_DailyCostForTeam_Call) RunAndReturn(run func(context.Context, pgtype.Date, pgtype.Date, slug.Slug) ([]*gensql.Cost, error)) *MockDatabase_DailyCostForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// DailyEnvCostForTeam provides a mock function with given fields: ctx, fromDate, toDate, environment, teamSlug
func (_m *MockDatabase) DailyEnvCostForTeam(ctx context.Context, fromDate pgtype.Date, toDate pgtype.Date, environment *string, teamSlug slug.Slug) ([]*gensql.DailyEnvCostForTeamRow, error) {
	ret := _m.Called(ctx, fromDate, toDate, environment, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for DailyEnvCostForTeam")
	}

	var r0 []*gensql.DailyEnvCostForTeamRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Date, pgtype.Date, *string, slug.Slug) ([]*gensql.DailyEnvCostForTeamRow, error)); ok {
		return rf(ctx, fromDate, toDate, environment, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Date, pgtype.Date, *string, slug.Slug) []*gensql.DailyEnvCostForTeamRow); ok {
		r0 = rf(ctx, fromDate, toDate, environment, teamSlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gensql.DailyEnvCostForTeamRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgtype.Date, pgtype.Date, *string, slug.Slug) error); ok {
		r1 = rf(ctx, fromDate, toDate, environment, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_DailyEnvCostForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DailyEnvCostForTeam'
type MockDatabase_DailyEnvCostForTeam_Call struct {
	*mock.Call
}

// DailyEnvCostForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - fromDate pgtype.Date
//   - toDate pgtype.Date
//   - environment *string
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) DailyEnvCostForTeam(ctx interface{}, fromDate interface{}, toDate interface{}, environment interface{}, teamSlug interface{}) *MockDatabase_DailyEnvCostForTeam_Call {
	return &MockDatabase_DailyEnvCostForTeam_Call{Call: _e.mock.On("DailyEnvCostForTeam", ctx, fromDate, toDate, environment, teamSlug)}
}

func (_c *MockDatabase_DailyEnvCostForTeam_Call) Run(run func(ctx context.Context, fromDate pgtype.Date, toDate pgtype.Date, environment *string, teamSlug slug.Slug)) *MockDatabase_DailyEnvCostForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgtype.Date), args[2].(pgtype.Date), args[3].(*string), args[4].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_DailyEnvCostForTeam_Call) Return(_a0 []*gensql.DailyEnvCostForTeamRow, _a1 error) *MockDatabase_DailyEnvCostForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_DailyEnvCostForTeam_Call) RunAndReturn(run func(context.Context, pgtype.Date, pgtype.Date, *string, slug.Slug) ([]*gensql.DailyEnvCostForTeamRow, error)) *MockDatabase_DailyEnvCostForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// DailyVulnerabilityForTeam provides a mock function with given fields: ctx, fromDate, toDate, teamSlug
func (_m *MockDatabase) DailyVulnerabilityForTeam(ctx context.Context, fromDate pgtype.Date, toDate pgtype.Date, teamSlug slug.Slug) ([]*gensql.DailyVulnerabilityForTeamRow, error) {
	ret := _m.Called(ctx, fromDate, toDate, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for DailyVulnerabilityForTeam")
	}

	var r0 []*gensql.DailyVulnerabilityForTeamRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Date, pgtype.Date, slug.Slug) ([]*gensql.DailyVulnerabilityForTeamRow, error)); ok {
		return rf(ctx, fromDate, toDate, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Date, pgtype.Date, slug.Slug) []*gensql.DailyVulnerabilityForTeamRow); ok {
		r0 = rf(ctx, fromDate, toDate, teamSlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gensql.DailyVulnerabilityForTeamRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgtype.Date, pgtype.Date, slug.Slug) error); ok {
		r1 = rf(ctx, fromDate, toDate, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_DailyVulnerabilityForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DailyVulnerabilityForTeam'
type MockDatabase_DailyVulnerabilityForTeam_Call struct {
	*mock.Call
}

// DailyVulnerabilityForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - fromDate pgtype.Date
//   - toDate pgtype.Date
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) DailyVulnerabilityForTeam(ctx interface{}, fromDate interface{}, toDate interface{}, teamSlug interface{}) *MockDatabase_DailyVulnerabilityForTeam_Call {
	return &MockDatabase_DailyVulnerabilityForTeam_Call{Call: _e.mock.On("DailyVulnerabilityForTeam", ctx, fromDate, toDate, teamSlug)}
}

func (_c *MockDatabase_DailyVulnerabilityForTeam_Call) Run(run func(ctx context.Context, fromDate pgtype.Date, toDate pgtype.Date, teamSlug slug.Slug)) *MockDatabase_DailyVulnerabilityForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgtype.Date), args[2].(pgtype.Date), args[3].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_DailyVulnerabilityForTeam_Call) Return(_a0 []*gensql.DailyVulnerabilityForTeamRow, _a1 error) *MockDatabase_DailyVulnerabilityForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_DailyVulnerabilityForTeam_Call) RunAndReturn(run func(context.Context, pgtype.Date, pgtype.Date, slug.Slug) ([]*gensql.DailyVulnerabilityForTeamRow, error)) *MockDatabase_DailyVulnerabilityForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// DangerousGetReconcilerConfigValues provides a mock function with given fields: ctx, reconcilerName
func (_m *MockDatabase) DangerousGetReconcilerConfigValues(ctx context.Context, reconcilerName string) (*ReconcilerConfigValues, error) {
	ret := _m.Called(ctx, reconcilerName)

	if len(ret) == 0 {
		panic("no return value specified for DangerousGetReconcilerConfigValues")
	}

	var r0 *ReconcilerConfigValues
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*ReconcilerConfigValues, error)); ok {
		return rf(ctx, reconcilerName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *ReconcilerConfigValues); ok {
		r0 = rf(ctx, reconcilerName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ReconcilerConfigValues)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, reconcilerName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_DangerousGetReconcilerConfigValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DangerousGetReconcilerConfigValues'
type MockDatabase_DangerousGetReconcilerConfigValues_Call struct {
	*mock.Call
}

// DangerousGetReconcilerConfigValues is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
func (_e *MockDatabase_Expecter) DangerousGetReconcilerConfigValues(ctx interface{}, reconcilerName interface{}) *MockDatabase_DangerousGetReconcilerConfigValues_Call {
	return &MockDatabase_DangerousGetReconcilerConfigValues_Call{Call: _e.mock.On("DangerousGetReconcilerConfigValues", ctx, reconcilerName)}
}

func (_c *MockDatabase_DangerousGetReconcilerConfigValues_Call) Run(run func(ctx context.Context, reconcilerName string)) *MockDatabase_DangerousGetReconcilerConfigValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDatabase_DangerousGetReconcilerConfigValues_Call) Return(_a0 *ReconcilerConfigValues, _a1 error) *MockDatabase_DangerousGetReconcilerConfigValues_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_DangerousGetReconcilerConfigValues_Call) RunAndReturn(run func(context.Context, string) (*ReconcilerConfigValues, error)) *MockDatabase_DangerousGetReconcilerConfigValues_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAllEnvironments provides a mock function with given fields: ctx
func (_m *MockDatabase) DeleteAllEnvironments(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAllEnvironments")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_DeleteAllEnvironments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAllEnvironments'
type MockDatabase_DeleteAllEnvironments_Call struct {
	*mock.Call
}

// DeleteAllEnvironments is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDatabase_Expecter) DeleteAllEnvironments(ctx interface{}) *MockDatabase_DeleteAllEnvironments_Call {
	return &MockDatabase_DeleteAllEnvironments_Call{Call: _e.mock.On("DeleteAllEnvironments", ctx)}
}

func (_c *MockDatabase_DeleteAllEnvironments_Call) Run(run func(ctx context.Context)) *MockDatabase_DeleteAllEnvironments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDatabase_DeleteAllEnvironments_Call) Return(_a0 error) *MockDatabase_DeleteAllEnvironments_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_DeleteAllEnvironments_Call) RunAndReturn(run func(context.Context) error) *MockDatabase_DeleteAllEnvironments_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAllReconcilerResources provides a mock function with given fields: ctx, reconcilerName, teamSlug
func (_m *MockDatabase) DeleteAllReconcilerResources(ctx context.Context, reconcilerName string, teamSlug slug.Slug) error {
	ret := _m.Called(ctx, reconcilerName, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAllReconcilerResources")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug) error); ok {
		r0 = rf(ctx, reconcilerName, teamSlug)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_DeleteAllReconcilerResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAllReconcilerResources'
type MockDatabase_DeleteAllReconcilerResources_Call struct {
	*mock.Call
}

// DeleteAllReconcilerResources is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) DeleteAllReconcilerResources(ctx interface{}, reconcilerName interface{}, teamSlug interface{}) *MockDatabase_DeleteAllReconcilerResources_Call {
	return &MockDatabase_DeleteAllReconcilerResources_Call{Call: _e.mock.On("DeleteAllReconcilerResources", ctx, reconcilerName, teamSlug)}
}

func (_c *MockDatabase_DeleteAllReconcilerResources_Call) Run(run func(ctx context.Context, reconcilerName string, teamSlug slug.Slug)) *MockDatabase_DeleteAllReconcilerResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_DeleteAllReconcilerResources_Call) Return(_a0 error) *MockDatabase_DeleteAllReconcilerResources_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_DeleteAllReconcilerResources_Call) RunAndReturn(run func(context.Context, string, slug.Slug) error) *MockDatabase_DeleteAllReconcilerResources_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteReconcilerConfig provides a mock function with given fields: ctx, reconcilerName, keysToDelete
func (_m *MockDatabase) DeleteReconcilerConfig(ctx context.Context, reconcilerName string, keysToDelete []string) error {
	ret := _m.Called(ctx, reconcilerName, keysToDelete)

	if len(ret) == 0 {
		panic("no return value specified for DeleteReconcilerConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) error); ok {
		r0 = rf(ctx, reconcilerName, keysToDelete)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_DeleteReconcilerConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteReconcilerConfig'
type MockDatabase_DeleteReconcilerConfig_Call struct {
	*mock.Call
}

// DeleteReconcilerConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
//   - keysToDelete []string
func (_e *MockDatabase_Expecter) DeleteReconcilerConfig(ctx interface{}, reconcilerName interface{}, keysToDelete interface{}) *MockDatabase_DeleteReconcilerConfig_Call {
	return &MockDatabase_DeleteReconcilerConfig_Call{Call: _e.mock.On("DeleteReconcilerConfig", ctx, reconcilerName, keysToDelete)}
}

func (_c *MockDatabase_DeleteReconcilerConfig_Call) Run(run func(ctx context.Context, reconcilerName string, keysToDelete []string)) *MockDatabase_DeleteReconcilerConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *MockDatabase_DeleteReconcilerConfig_Call) Return(_a0 error) *MockDatabase_DeleteReconcilerConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_DeleteReconcilerConfig_Call) RunAndReturn(run func(context.Context, string, []string) error) *MockDatabase_DeleteReconcilerConfig_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteServiceAccount provides a mock function with given fields: ctx, serviceAccountID
func (_m *MockDatabase) DeleteServiceAccount(ctx context.Context, serviceAccountID uuid.UUID) error {
	ret := _m.Called(ctx, serviceAccountID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteServiceAccount")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, serviceAccountID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_DeleteServiceAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteServiceAccount'
type MockDatabase_DeleteServiceAccount_Call struct {
	*mock.Call
}

// DeleteServiceAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceAccountID uuid.UUID
func (_e *MockDatabase_Expecter) DeleteServiceAccount(ctx interface{}, serviceAccountID interface{}) *MockDatabase_DeleteServiceAccount_Call {
	return &MockDatabase_DeleteServiceAccount_Call{Call: _e.mock.On("DeleteServiceAccount", ctx, serviceAccountID)}
}

func (_c *MockDatabase_DeleteServiceAccount_Call) Run(run func(ctx context.Context, serviceAccountID uuid.UUID)) *MockDatabase_DeleteServiceAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_DeleteServiceAccount_Call) Return(_a0 error) *MockDatabase_DeleteServiceAccount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_DeleteServiceAccount_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockDatabase_DeleteServiceAccount_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSession provides a mock function with given fields: ctx, sessionID
func (_m *MockDatabase) DeleteSession(ctx context.Context, sessionID uuid.UUID) error {
	ret := _m.Called(ctx, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSession")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, sessionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_DeleteSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSession'
type MockDatabase_DeleteSession_Call struct {
	*mock.Call
}

// DeleteSession is a helper method to define mock.On call
//   - ctx context.Context
//   - sessionID uuid.UUID
func (_e *MockDatabase_Expecter) DeleteSession(ctx interface{}, sessionID interface{}) *MockDatabase_DeleteSession_Call {
	return &MockDatabase_DeleteSession_Call{Call: _e.mock.On("DeleteSession", ctx, sessionID)}
}

func (_c *MockDatabase_DeleteSession_Call) Run(run func(ctx context.Context, sessionID uuid.UUID)) *MockDatabase_DeleteSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_DeleteSession_Call) Return(_a0 error) *MockDatabase_DeleteSession_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_DeleteSession_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockDatabase_DeleteSession_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTeam provides a mock function with given fields: ctx, teamSlug
func (_m *MockDatabase) DeleteTeam(ctx context.Context, teamSlug slug.Slug) error {
	ret := _m.Called(ctx, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTeam")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) error); ok {
		r0 = rf(ctx, teamSlug)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_DeleteTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTeam'
type MockDatabase_DeleteTeam_Call struct {
	*mock.Call
}

// DeleteTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) DeleteTeam(ctx interface{}, teamSlug interface{}) *MockDatabase_DeleteTeam_Call {
	return &MockDatabase_DeleteTeam_Call{Call: _e.mock.On("DeleteTeam", ctx, teamSlug)}
}

func (_c *MockDatabase_DeleteTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug)) *MockDatabase_DeleteTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_DeleteTeam_Call) Return(_a0 error) *MockDatabase_DeleteTeam_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_DeleteTeam_Call) RunAndReturn(run func(context.Context, slug.Slug) error) *MockDatabase_DeleteTeam_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function with given fields: ctx, userID
func (_m *MockDatabase) DeleteUser(ctx context.Context, userID uuid.UUID) error {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type MockDatabase_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockDatabase_Expecter) DeleteUser(ctx interface{}, userID interface{}) *MockDatabase_DeleteUser_Call {
	return &MockDatabase_DeleteUser_Call{Call: _e.mock.On("DeleteUser", ctx, userID)}
}

func (_c *MockDatabase_DeleteUser_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockDatabase_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_DeleteUser_Call) Return(_a0 error) *MockDatabase_DeleteUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_DeleteUser_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockDatabase_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// DisableReconciler provides a mock function with given fields: ctx, reconcilerName
func (_m *MockDatabase) DisableReconciler(ctx context.Context, reconcilerName string) (*Reconciler, error) {
	ret := _m.Called(ctx, reconcilerName)

	if len(ret) == 0 {
		panic("no return value specified for DisableReconciler")
	}

	var r0 *Reconciler
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Reconciler, error)); ok {
		return rf(ctx, reconcilerName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Reconciler); ok {
		r0 = rf(ctx, reconcilerName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Reconciler)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, reconcilerName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_DisableReconciler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableReconciler'
type MockDatabase_DisableReconciler_Call struct {
	*mock.Call
}

// DisableReconciler is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
func (_e *MockDatabase_Expecter) DisableReconciler(ctx interface{}, reconcilerName interface{}) *MockDatabase_DisableReconciler_Call {
	return &MockDatabase_DisableReconciler_Call{Call: _e.mock.On("DisableReconciler", ctx, reconcilerName)}
}

func (_c *MockDatabase_DisableReconciler_Call) Run(run func(ctx context.Context, reconcilerName string)) *MockDatabase_DisableReconciler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDatabase_DisableReconciler_Call) Return(_a0 *Reconciler, _a1 error) *MockDatabase_DisableReconciler_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_DisableReconciler_Call) RunAndReturn(run func(context.Context, string) (*Reconciler, error)) *MockDatabase_DisableReconciler_Call {
	_c.Call.Return(run)
	return _c
}

// EnableReconciler provides a mock function with given fields: ctx, reconcilerName
func (_m *MockDatabase) EnableReconciler(ctx context.Context, reconcilerName string) (*Reconciler, error) {
	ret := _m.Called(ctx, reconcilerName)

	if len(ret) == 0 {
		panic("no return value specified for EnableReconciler")
	}

	var r0 *Reconciler
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Reconciler, error)); ok {
		return rf(ctx, reconcilerName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Reconciler); ok {
		r0 = rf(ctx, reconcilerName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Reconciler)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, reconcilerName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_EnableReconciler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableReconciler'
type MockDatabase_EnableReconciler_Call struct {
	*mock.Call
}

// EnableReconciler is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
func (_e *MockDatabase_Expecter) EnableReconciler(ctx interface{}, reconcilerName interface{}) *MockDatabase_EnableReconciler_Call {
	return &MockDatabase_EnableReconciler_Call{Call: _e.mock.On("EnableReconciler", ctx, reconcilerName)}
}

func (_c *MockDatabase_EnableReconciler_Call) Run(run func(ctx context.Context, reconcilerName string)) *MockDatabase_EnableReconciler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDatabase_EnableReconciler_Call) Return(_a0 *Reconciler, _a1 error) *MockDatabase_EnableReconciler_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_EnableReconciler_Call) RunAndReturn(run func(context.Context, string) (*Reconciler, error)) *MockDatabase_EnableReconciler_Call {
	_c.Call.Return(run)
	return _c
}

// ExtendSession provides a mock function with given fields: ctx, sessionID
func (_m *MockDatabase) ExtendSession(ctx context.Context, sessionID uuid.UUID) (*Session, error) {
	ret := _m.Called(ctx, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for ExtendSession")
	}

	var r0 *Session
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*Session, error)); ok {
		return rf(ctx, sessionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *Session); ok {
		r0 = rf(ctx, sessionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Session)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, sessionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_ExtendSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExtendSession'
type MockDatabase_ExtendSession_Call struct {
	*mock.Call
}

// ExtendSession is a helper method to define mock.On call
//   - ctx context.Context
//   - sessionID uuid.UUID
func (_e *MockDatabase_Expecter) ExtendSession(ctx interface{}, sessionID interface{}) *MockDatabase_ExtendSession_Call {
	return &MockDatabase_ExtendSession_Call{Call: _e.mock.On("ExtendSession", ctx, sessionID)}
}

func (_c *MockDatabase_ExtendSession_Call) Run(run func(ctx context.Context, sessionID uuid.UUID)) *MockDatabase_ExtendSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_ExtendSession_Call) Return(_a0 *Session, _a1 error) *MockDatabase_ExtendSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_ExtendSession_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*Session, error)) *MockDatabase_ExtendSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveTeamBySlug provides a mock function with given fields: ctx, teamSlug
func (_m *MockDatabase) GetActiveTeamBySlug(ctx context.Context, teamSlug slug.Slug) (*Team, error) {
	ret := _m.Called(ctx, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveTeamBySlug")
	}

	var r0 *Team
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) (*Team, error)); ok {
		return rf(ctx, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) *Team); ok {
		r0 = rf(ctx, teamSlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug) error); ok {
		r1 = rf(ctx, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetActiveTeamBySlug_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveTeamBySlug'
type MockDatabase_GetActiveTeamBySlug_Call struct {
	*mock.Call
}

// GetActiveTeamBySlug is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) GetActiveTeamBySlug(ctx interface{}, teamSlug interface{}) *MockDatabase_GetActiveTeamBySlug_Call {
	return &MockDatabase_GetActiveTeamBySlug_Call{Call: _e.mock.On("GetActiveTeamBySlug", ctx, teamSlug)}
}

func (_c *MockDatabase_GetActiveTeamBySlug_Call) Run(run func(ctx context.Context, teamSlug slug.Slug)) *MockDatabase_GetActiveTeamBySlug_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_GetActiveTeamBySlug_Call) Return(_a0 *Team, _a1 error) *MockDatabase_GetActiveTeamBySlug_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetActiveTeamBySlug_Call) RunAndReturn(run func(context.Context, slug.Slug) (*Team, error)) *MockDatabase_GetActiveTeamBySlug_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveTeams provides a mock function with given fields: ctx
func (_m *MockDatabase) GetActiveTeams(ctx context.Context) ([]*Team, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveTeams")
	}

	var r0 []*Team
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*Team, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*Team); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetActiveTeams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveTeams'
type MockDatabase_GetActiveTeams_Call struct {
	*mock.Call
}

// GetActiveTeams is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDatabase_Expecter) GetActiveTeams(ctx interface{}) *MockDatabase_GetActiveTeams_Call {
	return &MockDatabase_GetActiveTeams_Call{Call: _e.mock.On("GetActiveTeams", ctx)}
}

func (_c *MockDatabase_GetActiveTeams_Call) Run(run func(ctx context.Context)) *MockDatabase_GetActiveTeams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDatabase_GetActiveTeams_Call) Return(_a0 []*Team, _a1 error) *MockDatabase_GetActiveTeams_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetActiveTeams_Call) RunAndReturn(run func(context.Context) ([]*Team, error)) *MockDatabase_GetActiveTeams_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllTeamMembers provides a mock function with given fields: ctx, teamSlug
func (_m *MockDatabase) GetAllTeamMembers(ctx context.Context, teamSlug slug.Slug) ([]*User, error) {
	ret := _m.Called(ctx, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for GetAllTeamMembers")
	}

	var r0 []*User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) ([]*User, error)); ok {
		return rf(ctx, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) []*User); ok {
		r0 = rf(ctx, teamSlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug) error); ok {
		r1 = rf(ctx, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetAllTeamMembers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllTeamMembers'
type MockDatabase_GetAllTeamMembers_Call struct {
	*mock.Call
}

// GetAllTeamMembers is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) GetAllTeamMembers(ctx interface{}, teamSlug interface{}) *MockDatabase_GetAllTeamMembers_Call {
	return &MockDatabase_GetAllTeamMembers_Call{Call: _e.mock.On("GetAllTeamMembers", ctx, teamSlug)}
}

func (_c *MockDatabase_GetAllTeamMembers_Call) Run(run func(ctx context.Context, teamSlug slug.Slug)) *MockDatabase_GetAllTeamMembers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_GetAllTeamMembers_Call) Return(_a0 []*User, _a1 error) *MockDatabase_GetAllTeamMembers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetAllTeamMembers_Call) RunAndReturn(run func(context.Context, slug.Slug) ([]*User, error)) *MockDatabase_GetAllTeamMembers_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllUserRoles provides a mock function with given fields: ctx
func (_m *MockDatabase) GetAllUserRoles(ctx context.Context) ([]*UserRole, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllUserRoles")
	}

	var r0 []*UserRole
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*UserRole, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*UserRole); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*UserRole)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetAllUserRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllUserRoles'
type MockDatabase_GetAllUserRoles_Call struct {
	*mock.Call
}

// GetAllUserRoles is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDatabase_Expecter) GetAllUserRoles(ctx interface{}) *MockDatabase_GetAllUserRoles_Call {
	return &MockDatabase_GetAllUserRoles_Call{Call: _e.mock.On("GetAllUserRoles", ctx)}
}

func (_c *MockDatabase_GetAllUserRoles_Call) Run(run func(ctx context.Context)) *MockDatabase_GetAllUserRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDatabase_GetAllUserRoles_Call) Return(_a0 []*UserRole, _a1 error) *MockDatabase_GetAllUserRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetAllUserRoles_Call) RunAndReturn(run func(context.Context) ([]*UserRole, error)) *MockDatabase_GetAllUserRoles_Call {
	_c.Call.Return(run)
	return _c
}

// GetAuditLogsForCorrelationID provides a mock function with given fields: ctx, correlationID, p
func (_m *MockDatabase) GetAuditLogsForCorrelationID(ctx context.Context, correlationID uuid.UUID, p Page) ([]*AuditLog, int, error) {
	ret := _m.Called(ctx, correlationID, p)

	if len(ret) == 0 {
		panic("no return value specified for GetAuditLogsForCorrelationID")
	}

	var r0 []*AuditLog
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, Page) ([]*AuditLog, int, error)); ok {
		return rf(ctx, correlationID, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, Page) []*AuditLog); ok {
		r0 = rf(ctx, correlationID, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*AuditLog)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, Page) int); ok {
		r1 = rf(ctx, correlationID, p)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, uuid.UUID, Page) error); ok {
		r2 = rf(ctx, correlationID, p)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDatabase_GetAuditLogsForCorrelationID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAuditLogsForCorrelationID'
type MockDatabase_GetAuditLogsForCorrelationID_Call struct {
	*mock.Call
}

// GetAuditLogsForCorrelationID is a helper method to define mock.On call
//   - ctx context.Context
//   - correlationID uuid.UUID
//   - p Page
func (_e *MockDatabase_Expecter) GetAuditLogsForCorrelationID(ctx interface{}, correlationID interface{}, p interface{}) *MockDatabase_GetAuditLogsForCorrelationID_Call {
	return &MockDatabase_GetAuditLogsForCorrelationID_Call{Call: _e.mock.On("GetAuditLogsForCorrelationID", ctx, correlationID, p)}
}

func (_c *MockDatabase_GetAuditLogsForCorrelationID_Call) Run(run func(ctx context.Context, correlationID uuid.UUID, p Page)) *MockDatabase_GetAuditLogsForCorrelationID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetAuditLogsForCorrelationID_Call) Return(_a0 []*AuditLog, _a1 int, _a2 error) *MockDatabase_GetAuditLogsForCorrelationID_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDatabase_GetAuditLogsForCorrelationID_Call) RunAndReturn(run func(context.Context, uuid.UUID, Page) ([]*AuditLog, int, error)) *MockDatabase_GetAuditLogsForCorrelationID_Call {
	_c.Call.Return(run)
	return _c
}

// GetAuditLogsForReconciler provides a mock function with given fields: ctx, reconcilerName, p
func (_m *MockDatabase) GetAuditLogsForReconciler(ctx context.Context, reconcilerName string, p Page) ([]*AuditLog, int, error) {
	ret := _m.Called(ctx, reconcilerName, p)

	if len(ret) == 0 {
		panic("no return value specified for GetAuditLogsForReconciler")
	}

	var r0 []*AuditLog
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, Page) ([]*AuditLog, int, error)); ok {
		return rf(ctx, reconcilerName, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, Page) []*AuditLog); ok {
		r0 = rf(ctx, reconcilerName, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*AuditLog)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, Page) int); ok {
		r1 = rf(ctx, reconcilerName, p)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, Page) error); ok {
		r2 = rf(ctx, reconcilerName, p)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDatabase_GetAuditLogsForReconciler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAuditLogsForReconciler'
type MockDatabase_GetAuditLogsForReconciler_Call struct {
	*mock.Call
}

// GetAuditLogsForReconciler is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
//   - p Page
func (_e *MockDatabase_Expecter) GetAuditLogsForReconciler(ctx interface{}, reconcilerName interface{}, p interface{}) *MockDatabase_GetAuditLogsForReconciler_Call {
	return &MockDatabase_GetAuditLogsForReconciler_Call{Call: _e.mock.On("GetAuditLogsForReconciler", ctx, reconcilerName, p)}
}

func (_c *MockDatabase_GetAuditLogsForReconciler_Call) Run(run func(ctx context.Context, reconcilerName string, p Page)) *MockDatabase_GetAuditLogsForReconciler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetAuditLogsForReconciler_Call) Return(_a0 []*AuditLog, _a1 int, _a2 error) *MockDatabase_GetAuditLogsForReconciler_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDatabase_GetAuditLogsForReconciler_Call) RunAndReturn(run func(context.Context, string, Page) ([]*AuditLog, int, error)) *MockDatabase_GetAuditLogsForReconciler_Call {
	_c.Call.Return(run)
	return _c
}

// GetAuditLogsForTeam provides a mock function with given fields: ctx, teamSlug, p
func (_m *MockDatabase) GetAuditLogsForTeam(ctx context.Context, teamSlug slug.Slug, p Page) ([]*AuditLog, int, error) {
	ret := _m.Called(ctx, teamSlug, p)

	if len(ret) == 0 {
		panic("no return value specified for GetAuditLogsForTeam")
	}

	var r0 []*AuditLog
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, Page) ([]*AuditLog, int, error)); ok {
		return rf(ctx, teamSlug, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, Page) []*AuditLog); ok {
		r0 = rf(ctx, teamSlug, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*AuditLog)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, Page) int); ok {
		r1 = rf(ctx, teamSlug, p)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, slug.Slug, Page) error); ok {
		r2 = rf(ctx, teamSlug, p)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDatabase_GetAuditLogsForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAuditLogsForTeam'
type MockDatabase_GetAuditLogsForTeam_Call struct {
	*mock.Call
}

// GetAuditLogsForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - p Page
func (_e *MockDatabase_Expecter) GetAuditLogsForTeam(ctx interface{}, teamSlug interface{}, p interface{}) *MockDatabase_GetAuditLogsForTeam_Call {
	return &MockDatabase_GetAuditLogsForTeam_Call{Call: _e.mock.On("GetAuditLogsForTeam", ctx, teamSlug, p)}
}

func (_c *MockDatabase_GetAuditLogsForTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, p Page)) *MockDatabase_GetAuditLogsForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetAuditLogsForTeam_Call) Return(_a0 []*AuditLog, _a1 int, _a2 error) *MockDatabase_GetAuditLogsForTeam_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDatabase_GetAuditLogsForTeam_Call) RunAndReturn(run func(context.Context, slug.Slug, Page) ([]*AuditLog, int, error)) *MockDatabase_GetAuditLogsForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// GetEnabledReconcilers provides a mock function with given fields: ctx
func (_m *MockDatabase) GetEnabledReconcilers(ctx context.Context) ([]*Reconciler, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetEnabledReconcilers")
	}

	var r0 []*Reconciler
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*Reconciler, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*Reconciler); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Reconciler)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetEnabledReconcilers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEnabledReconcilers'
type MockDatabase_GetEnabledReconcilers_Call struct {
	*mock.Call
}

// GetEnabledReconcilers is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDatabase_Expecter) GetEnabledReconcilers(ctx interface{}) *MockDatabase_GetEnabledReconcilers_Call {
	return &MockDatabase_GetEnabledReconcilers_Call{Call: _e.mock.On("GetEnabledReconcilers", ctx)}
}

func (_c *MockDatabase_GetEnabledReconcilers_Call) Run(run func(ctx context.Context)) *MockDatabase_GetEnabledReconcilers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDatabase_GetEnabledReconcilers_Call) Return(_a0 []*Reconciler, _a1 error) *MockDatabase_GetEnabledReconcilers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetEnabledReconcilers_Call) RunAndReturn(run func(context.Context) ([]*Reconciler, error)) *MockDatabase_GetEnabledReconcilers_Call {
	_c.Call.Return(run)
	return _c
}

// GetReconciler provides a mock function with given fields: ctx, reconcilerName
func (_m *MockDatabase) GetReconciler(ctx context.Context, reconcilerName string) (*Reconciler, error) {
	ret := _m.Called(ctx, reconcilerName)

	if len(ret) == 0 {
		panic("no return value specified for GetReconciler")
	}

	var r0 *Reconciler
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Reconciler, error)); ok {
		return rf(ctx, reconcilerName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Reconciler); ok {
		r0 = rf(ctx, reconcilerName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Reconciler)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, reconcilerName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetReconciler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReconciler'
type MockDatabase_GetReconciler_Call struct {
	*mock.Call
}

// GetReconciler is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
func (_e *MockDatabase_Expecter) GetReconciler(ctx interface{}, reconcilerName interface{}) *MockDatabase_GetReconciler_Call {
	return &MockDatabase_GetReconciler_Call{Call: _e.mock.On("GetReconciler", ctx, reconcilerName)}
}

func (_c *MockDatabase_GetReconciler_Call) Run(run func(ctx context.Context, reconcilerName string)) *MockDatabase_GetReconciler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDatabase_GetReconciler_Call) Return(_a0 *Reconciler, _a1 error) *MockDatabase_GetReconciler_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetReconciler_Call) RunAndReturn(run func(context.Context, string) (*Reconciler, error)) *MockDatabase_GetReconciler_Call {
	_c.Call.Return(run)
	return _c
}

// GetReconcilerConfig provides a mock function with given fields: ctx, reconcilerName
func (_m *MockDatabase) GetReconcilerConfig(ctx context.Context, reconcilerName string) ([]*ReconcilerConfig, error) {
	ret := _m.Called(ctx, reconcilerName)

	if len(ret) == 0 {
		panic("no return value specified for GetReconcilerConfig")
	}

	var r0 []*ReconcilerConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*ReconcilerConfig, error)); ok {
		return rf(ctx, reconcilerName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*ReconcilerConfig); ok {
		r0 = rf(ctx, reconcilerName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ReconcilerConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, reconcilerName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetReconcilerConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReconcilerConfig'
type MockDatabase_GetReconcilerConfig_Call struct {
	*mock.Call
}

// GetReconcilerConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
func (_e *MockDatabase_Expecter) GetReconcilerConfig(ctx interface{}, reconcilerName interface{}) *MockDatabase_GetReconcilerConfig_Call {
	return &MockDatabase_GetReconcilerConfig_Call{Call: _e.mock.On("GetReconcilerConfig", ctx, reconcilerName)}
}

func (_c *MockDatabase_GetReconcilerConfig_Call) Run(run func(ctx context.Context, reconcilerName string)) *MockDatabase_GetReconcilerConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDatabase_GetReconcilerConfig_Call) Return(_a0 []*ReconcilerConfig, _a1 error) *MockDatabase_GetReconcilerConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetReconcilerConfig_Call) RunAndReturn(run func(context.Context, string) ([]*ReconcilerConfig, error)) *MockDatabase_GetReconcilerConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetReconcilerResources provides a mock function with given fields: ctx, reconcilerName, teamSlug, p
func (_m *MockDatabase) GetReconcilerResources(ctx context.Context, reconcilerName string, teamSlug *slug.Slug, p Page) ([]*ReconcilerResource, error) {
	ret := _m.Called(ctx, reconcilerName, teamSlug, p)

	if len(ret) == 0 {
		panic("no return value specified for GetReconcilerResources")
	}

	var r0 []*ReconcilerResource
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slug.Slug, Page) ([]*ReconcilerResource, error)); ok {
		return rf(ctx, reconcilerName, teamSlug, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slug.Slug, Page) []*ReconcilerResource); ok {
		r0 = rf(ctx, reconcilerName, teamSlug, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ReconcilerResource)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slug.Slug, Page) error); ok {
		r1 = rf(ctx, reconcilerName, teamSlug, p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetReconcilerResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReconcilerResources'
type MockDatabase_GetReconcilerResources_Call struct {
	*mock.Call
}

// GetReconcilerResources is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
//   - teamSlug *slug.Slug
//   - p Page
func (_e *MockDatabase_Expecter) GetReconcilerResources(ctx interface{}, reconcilerName interface{}, teamSlug interface{}, p interface{}) *MockDatabase_GetReconcilerResources_Call {
	return &MockDatabase_GetReconcilerResources_Call{Call: _e.mock.On("GetReconcilerResources", ctx, reconcilerName, teamSlug, p)}
}

func (_c *MockDatabase_GetReconcilerResources_Call) Run(run func(ctx context.Context, reconcilerName string, teamSlug *slug.Slug, p Page)) *MockDatabase_GetReconcilerResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*slug.Slug), args[3].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetReconcilerResources_Call) Return(_a0 []*ReconcilerResource, _a1 error) *MockDatabase_GetReconcilerResources_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetReconcilerResources_Call) RunAndReturn(run func(context.Context, string, *slug.Slug, Page) ([]*ReconcilerResource, error)) *MockDatabase_GetReconcilerResources_Call {
	_c.Call.Return(run)
	return _c
}

// GetReconcilerResourcesByKey provides a mock function with given fields: ctx, reconcilerName, teamSlug, key, p
func (_m *MockDatabase) GetReconcilerResourcesByKey(ctx context.Context, reconcilerName string, teamSlug slug.Slug, key string, p Page) ([]*ReconcilerResource, int, error) {
	ret := _m.Called(ctx, reconcilerName, teamSlug, key, p)

	if len(ret) == 0 {
		panic("no return value specified for GetReconcilerResourcesByKey")
	}

	var r0 []*ReconcilerResource
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, string, Page) ([]*ReconcilerResource, int, error)); ok {
		return rf(ctx, reconcilerName, teamSlug, key, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, string, Page) []*ReconcilerResource); ok {
		r0 = rf(ctx, reconcilerName, teamSlug, key, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ReconcilerResource)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, slug.Slug, string, Page) int); ok {
		r1 = rf(ctx, reconcilerName, teamSlug, key, p)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, slug.Slug, string, Page) error); ok {
		r2 = rf(ctx, reconcilerName, teamSlug, key, p)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDatabase_GetReconcilerResourcesByKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReconcilerResourcesByKey'
type MockDatabase_GetReconcilerResourcesByKey_Call struct {
	*mock.Call
}

// GetReconcilerResourcesByKey is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
//   - teamSlug slug.Slug
//   - key string
//   - p Page
func (_e *MockDatabase_Expecter) GetReconcilerResourcesByKey(ctx interface{}, reconcilerName interface{}, teamSlug interface{}, key interface{}, p interface{}) *MockDatabase_GetReconcilerResourcesByKey_Call {
	return &MockDatabase_GetReconcilerResourcesByKey_Call{Call: _e.mock.On("GetReconcilerResourcesByKey", ctx, reconcilerName, teamSlug, key, p)}
}

func (_c *MockDatabase_GetReconcilerResourcesByKey_Call) Run(run func(ctx context.Context, reconcilerName string, teamSlug slug.Slug, key string, p Page)) *MockDatabase_GetReconcilerResourcesByKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(slug.Slug), args[3].(string), args[4].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetReconcilerResourcesByKey_Call) Return(ret []*ReconcilerResource, total int, err error) *MockDatabase_GetReconcilerResourcesByKey_Call {
	_c.Call.Return(ret, total, err)
	return _c
}

func (_c *MockDatabase_GetReconcilerResourcesByKey_Call) RunAndReturn(run func(context.Context, string, slug.Slug, string, Page) ([]*ReconcilerResource, int, error)) *MockDatabase_GetReconcilerResourcesByKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetReconcilerResourcesByKeyAndValue provides a mock function with given fields: ctx, reconcilerName, teamSlug, key, value
func (_m *MockDatabase) GetReconcilerResourcesByKeyAndValue(ctx context.Context, reconcilerName string, teamSlug slug.Slug, key string, value []byte) (*ReconcilerResource, error) {
	ret := _m.Called(ctx, reconcilerName, teamSlug, key, value)

	if len(ret) == 0 {
		panic("no return value specified for GetReconcilerResourcesByKeyAndValue")
	}

	var r0 *ReconcilerResource
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, string, []byte) (*ReconcilerResource, error)); ok {
		return rf(ctx, reconcilerName, teamSlug, key, value)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, string, []byte) *ReconcilerResource); ok {
		r0 = rf(ctx, reconcilerName, teamSlug, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ReconcilerResource)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, slug.Slug, string, []byte) error); ok {
		r1 = rf(ctx, reconcilerName, teamSlug, key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetReconcilerResourcesByKeyAndValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReconcilerResourcesByKeyAndValue'
type MockDatabase_GetReconcilerResourcesByKeyAndValue_Call struct {
	*mock.Call
}

// GetReconcilerResourcesByKeyAndValue is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
//   - teamSlug slug.Slug
//   - key string
//   - value []byte
func (_e *MockDatabase_Expecter) GetReconcilerResourcesByKeyAndValue(ctx interface{}, reconcilerName interface{}, teamSlug interface{}, key interface{}, value interface{}) *MockDatabase_GetReconcilerResourcesByKeyAndValue_Call {
	return &MockDatabase_GetReconcilerResourcesByKeyAndValue_Call{Call: _e.mock.On("GetReconcilerResourcesByKeyAndValue", ctx, reconcilerName, teamSlug, key, value)}
}

func (_c *MockDatabase_GetReconcilerResourcesByKeyAndValue_Call) Run(run func(ctx context.Context, reconcilerName string, teamSlug slug.Slug, key string, value []byte)) *MockDatabase_GetReconcilerResourcesByKeyAndValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(slug.Slug), args[3].(string), args[4].([]byte))
	})
	return _c
}

func (_c *MockDatabase_GetReconcilerResourcesByKeyAndValue_Call) Return(ret *ReconcilerResource, err error) *MockDatabase_GetReconcilerResourcesByKeyAndValue_Call {
	_c.Call.Return(ret, err)
	return _c
}

func (_c *MockDatabase_GetReconcilerResourcesByKeyAndValue_Call) RunAndReturn(run func(context.Context, string, slug.Slug, string, []byte) (*ReconcilerResource, error)) *MockDatabase_GetReconcilerResourcesByKeyAndValue_Call {
	_c.Call.Return(run)
	return _c
}

// GetReconcilers provides a mock function with given fields: ctx, p
func (_m *MockDatabase) GetReconcilers(ctx context.Context, p Page) ([]*Reconciler, int, error) {
	ret := _m.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for GetReconcilers")
	}

	var r0 []*Reconciler
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, Page) ([]*Reconciler, int, error)); ok {
		return rf(ctx, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, Page) []*Reconciler); ok {
		r0 = rf(ctx, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Reconciler)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, Page) int); ok {
		r1 = rf(ctx, p)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, Page) error); ok {
		r2 = rf(ctx, p)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDatabase_GetReconcilers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReconcilers'
type MockDatabase_GetReconcilers_Call struct {
	*mock.Call
}

// GetReconcilers is a helper method to define mock.On call
//   - ctx context.Context
//   - p Page
func (_e *MockDatabase_Expecter) GetReconcilers(ctx interface{}, p interface{}) *MockDatabase_GetReconcilers_Call {
	return &MockDatabase_GetReconcilers_Call{Call: _e.mock.On("GetReconcilers", ctx, p)}
}

func (_c *MockDatabase_GetReconcilers_Call) Run(run func(ctx context.Context, p Page)) *MockDatabase_GetReconcilers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetReconcilers_Call) Return(_a0 []*Reconciler, _a1 int, _a2 error) *MockDatabase_GetReconcilers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDatabase_GetReconcilers_Call) RunAndReturn(run func(context.Context, Page) ([]*Reconciler, int, error)) *MockDatabase_GetReconcilers_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepositoryAuthorizations provides a mock function with given fields: ctx, teamSlug, repoName
func (_m *MockDatabase) GetRepositoryAuthorizations(ctx context.Context, teamSlug slug.Slug, repoName string) ([]gensql.RepositoryAuthorizationEnum, error) {
	ret := _m.Called(ctx, teamSlug, repoName)

	if len(ret) == 0 {
		panic("no return value specified for GetRepositoryAuthorizations")
	}

	var r0 []gensql.RepositoryAuthorizationEnum
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string) ([]gensql.RepositoryAuthorizationEnum, error)); ok {
		return rf(ctx, teamSlug, repoName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string) []gensql.RepositoryAuthorizationEnum); ok {
		r0 = rf(ctx, teamSlug, repoName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gensql.RepositoryAuthorizationEnum)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, string) error); ok {
		r1 = rf(ctx, teamSlug, repoName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetRepositoryAuthorizations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepositoryAuthorizations'
type MockDatabase_GetRepositoryAuthorizations_Call struct {
	*mock.Call
}

// GetRepositoryAuthorizations is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - repoName string
func (_e *MockDatabase_Expecter) GetRepositoryAuthorizations(ctx interface{}, teamSlug interface{}, repoName interface{}) *MockDatabase_GetRepositoryAuthorizations_Call {
	return &MockDatabase_GetRepositoryAuthorizations_Call{Call: _e.mock.On("GetRepositoryAuthorizations", ctx, teamSlug, repoName)}
}

func (_c *MockDatabase_GetRepositoryAuthorizations_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, repoName string)) *MockDatabase_GetRepositoryAuthorizations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(string))
	})
	return _c
}

func (_c *MockDatabase_GetRepositoryAuthorizations_Call) Return(_a0 []gensql.RepositoryAuthorizationEnum, _a1 error) *MockDatabase_GetRepositoryAuthorizations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetRepositoryAuthorizations_Call) RunAndReturn(run func(context.Context, slug.Slug, string) ([]gensql.RepositoryAuthorizationEnum, error)) *MockDatabase_GetRepositoryAuthorizations_Call {
	_c.Call.Return(run)
	return _c
}

// GetServiceAccountByApiKey provides a mock function with given fields: ctx, apiKey
func (_m *MockDatabase) GetServiceAccountByApiKey(ctx context.Context, apiKey string) (*ServiceAccount, error) {
	ret := _m.Called(ctx, apiKey)

	if len(ret) == 0 {
		panic("no return value specified for GetServiceAccountByApiKey")
	}

	var r0 *ServiceAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*ServiceAccount, error)); ok {
		return rf(ctx, apiKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *ServiceAccount); ok {
		r0 = rf(ctx, apiKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ServiceAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, apiKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetServiceAccountByApiKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServiceAccountByApiKey'
type MockDatabase_GetServiceAccountByApiKey_Call struct {
	*mock.Call
}

// GetServiceAccountByApiKey is a helper method to define mock.On call
//   - ctx context.Context
//   - apiKey string
func (_e *MockDatabase_Expecter) GetServiceAccountByApiKey(ctx interface{}, apiKey interface{}) *MockDatabase_GetServiceAccountByApiKey_Call {
	return &MockDatabase_GetServiceAccountByApiKey_Call{Call: _e.mock.On("GetServiceAccountByApiKey", ctx, apiKey)}
}

func (_c *MockDatabase_GetServiceAccountByApiKey_Call) Run(run func(ctx context.Context, apiKey string)) *MockDatabase_GetServiceAccountByApiKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDatabase_GetServiceAccountByApiKey_Call) Return(_a0 *ServiceAccount, _a1 error) *MockDatabase_GetServiceAccountByApiKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetServiceAccountByApiKey_Call) RunAndReturn(run func(context.Context, string) (*ServiceAccount, error)) *MockDatabase_GetServiceAccountByApiKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetServiceAccountByName provides a mock function with given fields: ctx, name
func (_m *MockDatabase) GetServiceAccountByName(ctx context.Context, name string) (*ServiceAccount, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetServiceAccountByName")
	}

	var r0 *ServiceAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*ServiceAccount, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *ServiceAccount); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ServiceAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetServiceAccountByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServiceAccountByName'
type MockDatabase_GetServiceAccountByName_Call struct {
	*mock.Call
}

// GetServiceAccountByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockDatabase_Expecter) GetServiceAccountByName(ctx interface{}, name interface{}) *MockDatabase_GetServiceAccountByName_Call {
	return &MockDatabase_GetServiceAccountByName_Call{Call: _e.mock.On("GetServiceAccountByName", ctx, name)}
}

func (_c *MockDatabase_GetServiceAccountByName_Call) Run(run func(ctx context.Context, name string)) *MockDatabase_GetServiceAccountByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDatabase_GetServiceAccountByName_Call) Return(_a0 *ServiceAccount, _a1 error) *MockDatabase_GetServiceAccountByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetServiceAccountByName_Call) RunAndReturn(run func(context.Context, string) (*ServiceAccount, error)) *MockDatabase_GetServiceAccountByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetServiceAccountRoles provides a mock function with given fields: ctx, serviceAccountID
func (_m *MockDatabase) GetServiceAccountRoles(ctx context.Context, serviceAccountID uuid.UUID) ([]*authz.Role, error) {
	ret := _m.Called(ctx, serviceAccountID)

	if len(ret) == 0 {
		panic("no return value specified for GetServiceAccountRoles")
	}

	var r0 []*authz.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]*authz.Role, error)); ok {
		return rf(ctx, serviceAccountID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []*authz.Role); ok {
		r0 = rf(ctx, serviceAccountID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*authz.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, serviceAccountID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetServiceAccountRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServiceAccountRoles'
type MockDatabase_GetServiceAccountRoles_Call struct {
	*mock.Call
}

// GetServiceAccountRoles is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceAccountID uuid.UUID
func (_e *MockDatabase_Expecter) GetServiceAccountRoles(ctx interface{}, serviceAccountID interface{}) *MockDatabase_GetServiceAccountRoles_Call {
	return &MockDatabase_GetServiceAccountRoles_Call{Call: _e.mock.On("GetServiceAccountRoles", ctx, serviceAccountID)}
}

func (_c *MockDatabase_GetServiceAccountRoles_Call) Run(run func(ctx context.Context, serviceAccountID uuid.UUID)) *MockDatabase_GetServiceAccountRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_GetServiceAccountRoles_Call) Return(_a0 []*authz.Role, _a1 error) *MockDatabase_GetServiceAccountRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetServiceAccountRoles_Call) RunAndReturn(run func(context.Context, uuid.UUID) ([]*authz.Role, error)) *MockDatabase_GetServiceAccountRoles_Call {
	_c.Call.Return(run)
	return _c
}

// GetServiceAccounts provides a mock function with given fields: ctx
func (_m *MockDatabase) GetServiceAccounts(ctx context.Context) ([]*ServiceAccount, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetServiceAccounts")
	}

	var r0 []*ServiceAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*ServiceAccount, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*ServiceAccount); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ServiceAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetServiceAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServiceAccounts'
type MockDatabase_GetServiceAccounts_Call struct {
	*mock.Call
}

// GetServiceAccounts is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDatabase_Expecter) GetServiceAccounts(ctx interface{}) *MockDatabase_GetServiceAccounts_Call {
	return &MockDatabase_GetServiceAccounts_Call{Call: _e.mock.On("GetServiceAccounts", ctx)}
}

func (_c *MockDatabase_GetServiceAccounts_Call) Run(run func(ctx context.Context)) *MockDatabase_GetServiceAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDatabase_GetServiceAccounts_Call) Return(_a0 []*ServiceAccount, _a1 error) *MockDatabase_GetServiceAccounts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetServiceAccounts_Call) RunAndReturn(run func(context.Context) ([]*ServiceAccount, error)) *MockDatabase_GetServiceAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// GetSessionByID provides a mock function with given fields: ctx, sessionID
func (_m *MockDatabase) GetSessionByID(ctx context.Context, sessionID uuid.UUID) (*Session, error) {
	ret := _m.Called(ctx, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for GetSessionByID")
	}

	var r0 *Session
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*Session, error)); ok {
		return rf(ctx, sessionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *Session); ok {
		r0 = rf(ctx, sessionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Session)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, sessionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetSessionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionByID'
type MockDatabase_GetSessionByID_Call struct {
	*mock.Call
}

// GetSessionByID is a helper method to define mock.On call
//   - ctx context.Context
//   - sessionID uuid.UUID
func (_e *MockDatabase_Expecter) GetSessionByID(ctx interface{}, sessionID interface{}) *MockDatabase_GetSessionByID_Call {
	return &MockDatabase_GetSessionByID_Call{Call: _e.mock.On("GetSessionByID", ctx, sessionID)}
}

func (_c *MockDatabase_GetSessionByID_Call) Run(run func(ctx context.Context, sessionID uuid.UUID)) *MockDatabase_GetSessionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_GetSessionByID_Call) Return(_a0 *Session, _a1 error) *MockDatabase_GetSessionByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetSessionByID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*Session, error)) *MockDatabase_GetSessionByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamBySlug provides a mock function with given fields: ctx, teamSlug
func (_m *MockDatabase) GetTeamBySlug(ctx context.Context, teamSlug slug.Slug) (*Team, error) {
	ret := _m.Called(ctx, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamBySlug")
	}

	var r0 *Team
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) (*Team, error)); ok {
		return rf(ctx, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) *Team); ok {
		r0 = rf(ctx, teamSlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug) error); ok {
		r1 = rf(ctx, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetTeamBySlug_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamBySlug'
type MockDatabase_GetTeamBySlug_Call struct {
	*mock.Call
}

// GetTeamBySlug is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) GetTeamBySlug(ctx interface{}, teamSlug interface{}) *MockDatabase_GetTeamBySlug_Call {
	return &MockDatabase_GetTeamBySlug_Call{Call: _e.mock.On("GetTeamBySlug", ctx, teamSlug)}
}

func (_c *MockDatabase_GetTeamBySlug_Call) Run(run func(ctx context.Context, teamSlug slug.Slug)) *MockDatabase_GetTeamBySlug_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_GetTeamBySlug_Call) Return(_a0 *Team, _a1 error) *MockDatabase_GetTeamBySlug_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetTeamBySlug_Call) RunAndReturn(run func(context.Context, slug.Slug) (*Team, error)) *MockDatabase_GetTeamBySlug_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamDeleteKey provides a mock function with given fields: ctx, key
func (_m *MockDatabase) GetTeamDeleteKey(ctx context.Context, key uuid.UUID) (*TeamDeleteKey, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamDeleteKey")
	}

	var r0 *TeamDeleteKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*TeamDeleteKey, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *TeamDeleteKey); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TeamDeleteKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetTeamDeleteKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamDeleteKey'
type MockDatabase_GetTeamDeleteKey_Call struct {
	*mock.Call
}

// GetTeamDeleteKey is a helper method to define mock.On call
//   - ctx context.Context
//   - key uuid.UUID
func (_e *MockDatabase_Expecter) GetTeamDeleteKey(ctx interface{}, key interface{}) *MockDatabase_GetTeamDeleteKey_Call {
	return &MockDatabase_GetTeamDeleteKey_Call{Call: _e.mock.On("GetTeamDeleteKey", ctx, key)}
}

func (_c *MockDatabase_GetTeamDeleteKey_Call) Run(run func(ctx context.Context, key uuid.UUID)) *MockDatabase_GetTeamDeleteKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_GetTeamDeleteKey_Call) Return(_a0 *TeamDeleteKey, _a1 error) *MockDatabase_GetTeamDeleteKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetTeamDeleteKey_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*TeamDeleteKey, error)) *MockDatabase_GetTeamDeleteKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamEnvironments provides a mock function with given fields: ctx, teamSlug, p
func (_m *MockDatabase) GetTeamEnvironments(ctx context.Context, teamSlug slug.Slug, p Page) ([]*TeamEnvironment, int, error) {
	ret := _m.Called(ctx, teamSlug, p)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamEnvironments")
	}

	var r0 []*TeamEnvironment
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, Page) ([]*TeamEnvironment, int, error)); ok {
		return rf(ctx, teamSlug, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, Page) []*TeamEnvironment); ok {
		r0 = rf(ctx, teamSlug, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*TeamEnvironment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, Page) int); ok {
		r1 = rf(ctx, teamSlug, p)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, slug.Slug, Page) error); ok {
		r2 = rf(ctx, teamSlug, p)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDatabase_GetTeamEnvironments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamEnvironments'
type MockDatabase_GetTeamEnvironments_Call struct {
	*mock.Call
}

// GetTeamEnvironments is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - p Page
func (_e *MockDatabase_Expecter) GetTeamEnvironments(ctx interface{}, teamSlug interface{}, p interface{}) *MockDatabase_GetTeamEnvironments_Call {
	return &MockDatabase_GetTeamEnvironments_Call{Call: _e.mock.On("GetTeamEnvironments", ctx, teamSlug, p)}
}

func (_c *MockDatabase_GetTeamEnvironments_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, p Page)) *MockDatabase_GetTeamEnvironments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetTeamEnvironments_Call) Return(_a0 []*TeamEnvironment, _a1 int, _a2 error) *MockDatabase_GetTeamEnvironments_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDatabase_GetTeamEnvironments_Call) RunAndReturn(run func(context.Context, slug.Slug, Page) ([]*TeamEnvironment, int, error)) *MockDatabase_GetTeamEnvironments_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamEnvironmentsBySlugsAndEnvNames provides a mock function with given fields: ctx, keys
func (_m *MockDatabase) GetTeamEnvironmentsBySlugsAndEnvNames(ctx context.Context, keys []EnvSlugName) ([]*TeamEnvironment, error) {
	ret := _m.Called(ctx, keys)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamEnvironmentsBySlugsAndEnvNames")
	}

	var r0 []*TeamEnvironment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []EnvSlugName) ([]*TeamEnvironment, error)); ok {
		return rf(ctx, keys)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []EnvSlugName) []*TeamEnvironment); ok {
		r0 = rf(ctx, keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*TeamEnvironment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []EnvSlugName) error); ok {
		r1 = rf(ctx, keys)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetTeamEnvironmentsBySlugsAndEnvNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamEnvironmentsBySlugsAndEnvNames'
type MockDatabase_GetTeamEnvironmentsBySlugsAndEnvNames_Call struct {
	*mock.Call
}

// GetTeamEnvironmentsBySlugsAndEnvNames is a helper method to define mock.On call
//   - ctx context.Context
//   - keys []EnvSlugName
func (_e *MockDatabase_Expecter) GetTeamEnvironmentsBySlugsAndEnvNames(ctx interface{}, keys interface{}) *MockDatabase_GetTeamEnvironmentsBySlugsAndEnvNames_Call {
	return &MockDatabase_GetTeamEnvironmentsBySlugsAndEnvNames_Call{Call: _e.mock.On("GetTeamEnvironmentsBySlugsAndEnvNames", ctx, keys)}
}

func (_c *MockDatabase_GetTeamEnvironmentsBySlugsAndEnvNames_Call) Run(run func(ctx context.Context, keys []EnvSlugName)) *MockDatabase_GetTeamEnvironmentsBySlugsAndEnvNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]EnvSlugName))
	})
	return _c
}

func (_c *MockDatabase_GetTeamEnvironmentsBySlugsAndEnvNames_Call) Return(_a0 []*TeamEnvironment, _a1 error) *MockDatabase_GetTeamEnvironmentsBySlugsAndEnvNames_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetTeamEnvironmentsBySlugsAndEnvNames_Call) RunAndReturn(run func(context.Context, []EnvSlugName) ([]*TeamEnvironment, error)) *MockDatabase_GetTeamEnvironmentsBySlugsAndEnvNames_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamMember provides a mock function with given fields: ctx, teamSlug, userID
func (_m *MockDatabase) GetTeamMember(ctx context.Context, teamSlug slug.Slug, userID uuid.UUID) (*User, error) {
	ret := _m.Called(ctx, teamSlug, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamMember")
	}

	var r0 *User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, uuid.UUID) (*User, error)); ok {
		return rf(ctx, teamSlug, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, uuid.UUID) *User); ok {
		r0 = rf(ctx, teamSlug, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, uuid.UUID) error); ok {
		r1 = rf(ctx, teamSlug, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetTeamMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamMember'
type MockDatabase_GetTeamMember_Call struct {
	*mock.Call
}

// GetTeamMember is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - userID uuid.UUID
func (_e *MockDatabase_Expecter) GetTeamMember(ctx interface{}, teamSlug interface{}, userID interface{}) *MockDatabase_GetTeamMember_Call {
	return &MockDatabase_GetTeamMember_Call{Call: _e.mock.On("GetTeamMember", ctx, teamSlug, userID)}
}

func (_c *MockDatabase_GetTeamMember_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, userID uuid.UUID)) *MockDatabase_GetTeamMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_GetTeamMember_Call) Return(_a0 *User, _a1 error) *MockDatabase_GetTeamMember_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetTeamMember_Call) RunAndReturn(run func(context.Context, slug.Slug, uuid.UUID) (*User, error)) *MockDatabase_GetTeamMember_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamMemberOptOuts provides a mock function with given fields: ctx, userID, teamSlug
func (_m *MockDatabase) GetTeamMemberOptOuts(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug) ([]*gensql.GetTeamMemberOptOutsRow, error) {
	ret := _m.Called(ctx, userID, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamMemberOptOuts")
	}

	var r0 []*gensql.GetTeamMemberOptOutsRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, slug.Slug) ([]*gensql.GetTeamMemberOptOutsRow, error)); ok {
		return rf(ctx, userID, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, slug.Slug) []*gensql.GetTeamMemberOptOutsRow); ok {
		r0 = rf(ctx, userID, teamSlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gensql.GetTeamMemberOptOutsRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, slug.Slug) error); ok {
		r1 = rf(ctx, userID, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetTeamMemberOptOuts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamMemberOptOuts'
type MockDatabase_GetTeamMemberOptOuts_Call struct {
	*mock.Call
}

// GetTeamMemberOptOuts is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) GetTeamMemberOptOuts(ctx interface{}, userID interface{}, teamSlug interface{}) *MockDatabase_GetTeamMemberOptOuts_Call {
	return &MockDatabase_GetTeamMemberOptOuts_Call{Call: _e.mock.On("GetTeamMemberOptOuts", ctx, userID, teamSlug)}
}

func (_c *MockDatabase_GetTeamMemberOptOuts_Call) Run(run func(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug)) *MockDatabase_GetTeamMemberOptOuts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_GetTeamMemberOptOuts_Call) Return(_a0 []*gensql.GetTeamMemberOptOutsRow, _a1 error) *MockDatabase_GetTeamMemberOptOuts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetTeamMemberOptOuts_Call) RunAndReturn(run func(context.Context, uuid.UUID, slug.Slug) ([]*gensql.GetTeamMemberOptOutsRow, error)) *MockDatabase_GetTeamMemberOptOuts_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamMembers provides a mock function with given fields: ctx, teamSlug, p
func (_m *MockDatabase) GetTeamMembers(ctx context.Context, teamSlug slug.Slug, p Page) ([]*User, int, error) {
	ret := _m.Called(ctx, teamSlug, p)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamMembers")
	}

	var r0 []*User
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, Page) ([]*User, int, error)); ok {
		return rf(ctx, teamSlug, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, Page) []*User); ok {
		r0 = rf(ctx, teamSlug, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, Page) int); ok {
		r1 = rf(ctx, teamSlug, p)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, slug.Slug, Page) error); ok {
		r2 = rf(ctx, teamSlug, p)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDatabase_GetTeamMembers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamMembers'
type MockDatabase_GetTeamMembers_Call struct {
	*mock.Call
}

// GetTeamMembers is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - p Page
func (_e *MockDatabase_Expecter) GetTeamMembers(ctx interface{}, teamSlug interface{}, p interface{}) *MockDatabase_GetTeamMembers_Call {
	return &MockDatabase_GetTeamMembers_Call{Call: _e.mock.On("GetTeamMembers", ctx, teamSlug, p)}
}

func (_c *MockDatabase_GetTeamMembers_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, p Page)) *MockDatabase_GetTeamMembers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetTeamMembers_Call) Return(_a0 []*User, _a1 int, _a2 error) *MockDatabase_GetTeamMembers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDatabase_GetTeamMembers_Call) RunAndReturn(run func(context.Context, slug.Slug, Page) ([]*User, int, error)) *MockDatabase_GetTeamMembers_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamMembersForReconciler provides a mock function with given fields: ctx, teamSlug, reconcilerName
func (_m *MockDatabase) GetTeamMembersForReconciler(ctx context.Context, teamSlug slug.Slug, reconcilerName string) ([]*User, error) {
	ret := _m.Called(ctx, teamSlug, reconcilerName)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamMembersForReconciler")
	}

	var r0 []*User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string) ([]*User, error)); ok {
		return rf(ctx, teamSlug, reconcilerName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string) []*User); ok {
		r0 = rf(ctx, teamSlug, reconcilerName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, string) error); ok {
		r1 = rf(ctx, teamSlug, reconcilerName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetTeamMembersForReconciler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamMembersForReconciler'
type MockDatabase_GetTeamMembersForReconciler_Call struct {
	*mock.Call
}

// GetTeamMembersForReconciler is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - reconcilerName string
func (_e *MockDatabase_Expecter) GetTeamMembersForReconciler(ctx interface{}, teamSlug interface{}, reconcilerName interface{}) *MockDatabase_GetTeamMembersForReconciler_Call {
	return &MockDatabase_GetTeamMembersForReconciler_Call{Call: _e.mock.On("GetTeamMembersForReconciler", ctx, teamSlug, reconcilerName)}
}

func (_c *MockDatabase_GetTeamMembersForReconciler_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, reconcilerName string)) *MockDatabase_GetTeamMembersForReconciler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(string))
	})
	return _c
}

func (_c *MockDatabase_GetTeamMembersForReconciler_Call) Return(_a0 []*User, _a1 error) *MockDatabase_GetTeamMembersForReconciler_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetTeamMembersForReconciler_Call) RunAndReturn(run func(context.Context, slug.Slug, string) ([]*User, error)) *MockDatabase_GetTeamMembersForReconciler_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamReconcilerErrors provides a mock function with given fields: ctx, teamSlug
func (_m *MockDatabase) GetTeamReconcilerErrors(ctx context.Context, teamSlug slug.Slug) ([]*ReconcilerError, error) {
	ret := _m.Called(ctx, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamReconcilerErrors")
	}

	var r0 []*ReconcilerError
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) ([]*ReconcilerError, error)); ok {
		return rf(ctx, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) []*ReconcilerError); ok {
		r0 = rf(ctx, teamSlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ReconcilerError)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug) error); ok {
		r1 = rf(ctx, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetTeamReconcilerErrors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamReconcilerErrors'
type MockDatabase_GetTeamReconcilerErrors_Call struct {
	*mock.Call
}

// GetTeamReconcilerErrors is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) GetTeamReconcilerErrors(ctx interface{}, teamSlug interface{}) *MockDatabase_GetTeamReconcilerErrors_Call {
	return &MockDatabase_GetTeamReconcilerErrors_Call{Call: _e.mock.On("GetTeamReconcilerErrors", ctx, teamSlug)}
}

func (_c *MockDatabase_GetTeamReconcilerErrors_Call) Run(run func(ctx context.Context, teamSlug slug.Slug)) *MockDatabase_GetTeamReconcilerErrors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_GetTeamReconcilerErrors_Call) Return(_a0 []*ReconcilerError, _a1 error) *MockDatabase_GetTeamReconcilerErrors_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetTeamReconcilerErrors_Call) RunAndReturn(run func(context.Context, slug.Slug) ([]*ReconcilerError, error)) *MockDatabase_GetTeamReconcilerErrors_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeams provides a mock function with given fields: ctx, p
func (_m *MockDatabase) GetTeams(ctx context.Context, p Page) ([]*Team, int, error) {
	ret := _m.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for GetTeams")
	}

	var r0 []*Team
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, Page) ([]*Team, int, error)); ok {
		return rf(ctx, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, Page) []*Team); ok {
		r0 = rf(ctx, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, Page) int); ok {
		r1 = rf(ctx, p)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, Page) error); ok {
		r2 = rf(ctx, p)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDatabase_GetTeams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeams'
type MockDatabase_GetTeams_Call struct {
	*mock.Call
}

// GetTeams is a helper method to define mock.On call
//   - ctx context.Context
//   - p Page
func (_e *MockDatabase_Expecter) GetTeams(ctx interface{}, p interface{}) *MockDatabase_GetTeams_Call {
	return &MockDatabase_GetTeams_Call{Call: _e.mock.On("GetTeams", ctx, p)}
}

func (_c *MockDatabase_GetTeams_Call) Run(run func(ctx context.Context, p Page)) *MockDatabase_GetTeams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetTeams_Call) Return(_a0 []*Team, _a1 int, _a2 error) *MockDatabase_GetTeams_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDatabase_GetTeams_Call) RunAndReturn(run func(context.Context, Page) ([]*Team, int, error)) *MockDatabase_GetTeams_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamsBySlugs provides a mock function with given fields: ctx, teamSlugs
func (_m *MockDatabase) GetTeamsBySlugs(ctx context.Context, teamSlugs []slug.Slug) ([]*Team, error) {
	ret := _m.Called(ctx, teamSlugs)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamsBySlugs")
	}

	var r0 []*Team
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []slug.Slug) ([]*Team, error)); ok {
		return rf(ctx, teamSlugs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []slug.Slug) []*Team); ok {
		r0 = rf(ctx, teamSlugs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []slug.Slug) error); ok {
		r1 = rf(ctx, teamSlugs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetTeamsBySlugs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamsBySlugs'
type MockDatabase_GetTeamsBySlugs_Call struct {
	*mock.Call
}

// GetTeamsBySlugs is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlugs []slug.Slug
func (_e *MockDatabase_Expecter) GetTeamsBySlugs(ctx interface{}, teamSlugs interface{}) *MockDatabase_GetTeamsBySlugs_Call {
	return &MockDatabase_GetTeamsBySlugs_Call{Call: _e.mock.On("GetTeamsBySlugs", ctx, teamSlugs)}
}

func (_c *MockDatabase_GetTeamsBySlugs_Call) Run(run func(ctx context.Context, teamSlugs []slug.Slug)) *MockDatabase_GetTeamsBySlugs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_GetTeamsBySlugs_Call) Return(_a0 []*Team, _a1 error) *MockDatabase_GetTeamsBySlugs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetTeamsBySlugs_Call) RunAndReturn(run func(context.Context, []slug.Slug) ([]*Team, error)) *MockDatabase_GetTeamsBySlugs_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamsWithPermissionInGitHubRepo provides a mock function with given fields: ctx, repoName, permission, p
func (_m *MockDatabase) GetTeamsWithPermissionInGitHubRepo(ctx context.Context, repoName string, permission string, p Page) ([]*Team, int, error) {
	ret := _m.Called(ctx, repoName, permission, p)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamsWithPermissionInGitHubRepo")
	}

	var r0 []*Team
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, Page) ([]*Team, int, error)); ok {
		return rf(ctx, repoName, permission, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, Page) []*Team); ok {
		r0 = rf(ctx, repoName, permission, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, Page) int); ok {
		r1 = rf(ctx, repoName, permission, p)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, Page) error); ok {
		r2 = rf(ctx, repoName, permission, p)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDatabase_GetTeamsWithPermissionInGitHubRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamsWithPermissionInGitHubRepo'
type MockDatabase_GetTeamsWithPermissionInGitHubRepo_Call struct {
	*mock.Call
}

// GetTeamsWithPermissionInGitHubRepo is a helper method to define mock.On call
//   - ctx context.Context
//   - repoName string
//   - permission string
//   - p Page
func (_e *MockDatabase_Expecter) GetTeamsWithPermissionInGitHubRepo(ctx interface{}, repoName interface{}, permission interface{}, p interface{}) *MockDatabase_GetTeamsWithPermissionInGitHubRepo_Call {
	return &MockDatabase_GetTeamsWithPermissionInGitHubRepo_Call{Call: _e.mock.On("GetTeamsWithPermissionInGitHubRepo", ctx, repoName, permission, p)}
}

func (_c *MockDatabase_GetTeamsWithPermissionInGitHubRepo_Call) Run(run func(ctx context.Context, repoName string, permission string, p Page)) *MockDatabase_GetTeamsWithPermissionInGitHubRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetTeamsWithPermissionInGitHubRepo_Call) Return(_a0 []*Team, _a1 int, _a2 error) *MockDatabase_GetTeamsWithPermissionInGitHubRepo_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDatabase_GetTeamsWithPermissionInGitHubRepo_Call) RunAndReturn(run func(context.Context, string, string, Page) ([]*Team, int, error)) *MockDatabase_GetTeamsWithPermissionInGitHubRepo_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByEmail provides a mock function with given fields: ctx, email
func (_m *MockDatabase) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByEmail")
	}

	var r0 *User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*User, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *User); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type MockDatabase_GetUserByEmail_Call struct {
	*mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockDatabase_Expecter) GetUserByEmail(ctx interface{}, email interface{}) *MockDatabase_GetUserByEmail_Call {
	return &MockDatabase_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", ctx, email)}
}

func (_c *MockDatabase_GetUserByEmail_Call) Run(run func(ctx context.Context, email string)) *MockDatabase_GetUserByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDatabase_GetUserByEmail_Call) Return(_a0 *User, _a1 error) *MockDatabase_GetUserByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetUserByEmail_Call) RunAndReturn(run func(context.Context, string) (*User, error)) *MockDatabase_GetUserByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByExternalID provides a mock function with given fields: ctx, externalID
func (_m *MockDatabase) GetUserByExternalID(ctx context.Context, externalID string) (*User, error) {
	ret := _m.Called(ctx, externalID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByExternalID")
	}

	var r0 *User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*User, error)); ok {
		return rf(ctx, externalID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *User); ok {
		r0 = rf(ctx, externalID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, externalID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetUserByExternalID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByExternalID'
type MockDatabase_GetUserByExternalID_Call struct {
	*mock.Call
}

// GetUserByExternalID is a helper method to define mock.On call
//   - ctx context.Context
//   - externalID string
func (_e *MockDatabase_Expecter) GetUserByExternalID(ctx interface{}, externalID interface{}) *MockDatabase_GetUserByExternalID_Call {
	return &MockDatabase_GetUserByExternalID_Call{Call: _e.mock.On("GetUserByExternalID", ctx, externalID)}
}

func (_c *MockDatabase_GetUserByExternalID_Call) Run(run func(ctx context.Context, externalID string)) *MockDatabase_GetUserByExternalID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDatabase_GetUserByExternalID_Call) Return(_a0 *User, _a1 error) *MockDatabase_GetUserByExternalID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetUserByExternalID_Call) RunAndReturn(run func(context.Context, string) (*User, error)) *MockDatabase_GetUserByExternalID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByID provides a mock function with given fields: ctx, id
func (_m *MockDatabase) GetUserByID(ctx context.Context, id uuid.UUID) (*User, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByID")
	}

	var r0 *User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*User, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *User); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetUserByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByID'
type MockDatabase_GetUserByID_Call struct {
	*mock.Call
}

// GetUserByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockDatabase_Expecter) GetUserByID(ctx interface{}, id interface{}) *MockDatabase_GetUserByID_Call {
	return &MockDatabase_GetUserByID_Call{Call: _e.mock.On("GetUserByID", ctx, id)}
}

func (_c *MockDatabase_GetUserByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockDatabase_GetUserByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_GetUserByID_Call) Return(_a0 *User, _a1 error) *MockDatabase_GetUserByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetUserByID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*User, error)) *MockDatabase_GetUserByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserRoles provides a mock function with given fields: ctx, userID
func (_m *MockDatabase) GetUserRoles(ctx context.Context, userID uuid.UUID) ([]*authz.Role, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserRoles")
	}

	var r0 []*authz.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]*authz.Role, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []*authz.Role); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*authz.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetUserRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserRoles'
type MockDatabase_GetUserRoles_Call struct {
	*mock.Call
}

// GetUserRoles is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockDatabase_Expecter) GetUserRoles(ctx interface{}, userID interface{}) *MockDatabase_GetUserRoles_Call {
	return &MockDatabase_GetUserRoles_Call{Call: _e.mock.On("GetUserRoles", ctx, userID)}
}

func (_c *MockDatabase_GetUserRoles_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockDatabase_GetUserRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_GetUserRoles_Call) Return(_a0 []*authz.Role, _a1 error) *MockDatabase_GetUserRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetUserRoles_Call) RunAndReturn(run func(context.Context, uuid.UUID) ([]*authz.Role, error)) *MockDatabase_GetUserRoles_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserRolesForUsers provides a mock function with given fields: ctx, userIDs
func (_m *MockDatabase) GetUserRolesForUsers(ctx context.Context, userIDs []uuid.UUID) (map[uuid.UUID][]*authz.Role, error) {
	ret := _m.Called(ctx, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetUserRolesForUsers")
	}

	var r0 map[uuid.UUID][]*authz.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) (map[uuid.UUID][]*authz.Role, error)); ok {
		return rf(ctx, userIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) map[uuid.UUID][]*authz.Role); ok {
		r0 = rf(ctx, userIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[uuid.UUID][]*authz.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []uuid.UUID) error); ok {
		r1 = rf(ctx, userIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetUserRolesForUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserRolesForUsers'
type MockDatabase_GetUserRolesForUsers_Call struct {
	*mock.Call
}

// GetUserRolesForUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - userIDs []uuid.UUID
func (_e *MockDatabase_Expecter) GetUserRolesForUsers(ctx interface{}, userIDs interface{}) *MockDatabase_GetUserRolesForUsers_Call {
	return &MockDatabase_GetUserRolesForUsers_Call{Call: _e.mock.On("GetUserRolesForUsers", ctx, userIDs)}
}

func (_c *MockDatabase_GetUserRolesForUsers_Call) Run(run func(ctx context.Context, userIDs []uuid.UUID)) *MockDatabase_GetUserRolesForUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_GetUserRolesForUsers_Call) Return(_a0 map[uuid.UUID][]*authz.Role, _a1 error) *MockDatabase_GetUserRolesForUsers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetUserRolesForUsers_Call) RunAndReturn(run func(context.Context, []uuid.UUID) (map[uuid.UUID][]*authz.Role, error)) *MockDatabase_GetUserRolesForUsers_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserTeams provides a mock function with given fields: ctx, userID, p
func (_m *MockDatabase) GetUserTeams(ctx context.Context, userID uuid.UUID, p Page) ([]*UserTeam, int, error) {
	ret := _m.Called(ctx, userID, p)

	if len(ret) == 0 {
		panic("no return value specified for GetUserTeams")
	}

	var r0 []*UserTeam
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, Page) ([]*UserTeam, int, error)); ok {
		return rf(ctx, userID, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, Page) []*UserTeam); ok {
		r0 = rf(ctx, userID, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*UserTeam)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, Page) int); ok {
		r1 = rf(ctx, userID, p)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, uuid.UUID, Page) error); ok {
		r2 = rf(ctx, userID, p)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDatabase_GetUserTeams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserTeams'
type MockDatabase_GetUserTeams_Call struct {
	*mock.Call
}

// GetUserTeams is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - p Page
func (_e *MockDatabase_Expecter) GetUserTeams(ctx interface{}, userID interface{}, p interface{}) *MockDatabase_GetUserTeams_Call {
	return &MockDatabase_GetUserTeams_Call{Call: _e.mock.On("GetUserTeams", ctx, userID, p)}
}

func (_c *MockDatabase_GetUserTeams_Call) Run(run func(ctx context.Context, userID uuid.UUID, p Page)) *MockDatabase_GetUserTeams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetUserTeams_Call) Return(_a0 []*UserTeam, _a1 int, _a2 error) *MockDatabase_GetUserTeams_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDatabase_GetUserTeams_Call) RunAndReturn(run func(context.Context, uuid.UUID, Page) ([]*UserTeam, int, error)) *MockDatabase_GetUserTeams_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsers provides a mock function with given fields: ctx, p
func (_m *MockDatabase) GetUsers(ctx context.Context, p Page) ([]*User, int, error) {
	ret := _m.Called(ctx, p)

	if len(ret) == 0 {
		panic("no return value specified for GetUsers")
	}

	var r0 []*User
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, Page) ([]*User, int, error)); ok {
		return rf(ctx, p)
	}
	if rf, ok := ret.Get(0).(func(context.Context, Page) []*User); ok {
		r0 = rf(ctx, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, Page) int); ok {
		r1 = rf(ctx, p)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, Page) error); ok {
		r2 = rf(ctx, p)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDatabase_GetUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsers'
type MockDatabase_GetUsers_Call struct {
	*mock.Call
}

// GetUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - p Page
func (_e *MockDatabase_Expecter) GetUsers(ctx interface{}, p interface{}) *MockDatabase_GetUsers_Call {
	return &MockDatabase_GetUsers_Call{Call: _e.mock.On("GetUsers", ctx, p)}
}

func (_c *MockDatabase_GetUsers_Call) Run(run func(ctx context.Context, p Page)) *MockDatabase_GetUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(Page))
	})
	return _c
}

func (_c *MockDatabase_GetUsers_Call) Return(_a0 []*User, _a1 int, _a2 error) *MockDatabase_GetUsers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDatabase_GetUsers_Call) RunAndReturn(run func(context.Context, Page) ([]*User, int, error)) *MockDatabase_GetUsers_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsersByIDs provides a mock function with given fields: ctx, ids
func (_m *MockDatabase) GetUsersByIDs(ctx context.Context, ids []uuid.UUID) ([]*User, error) {
	ret := _m.Called(ctx, ids)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersByIDs")
	}

	var r0 []*User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) ([]*User, error)); ok {
		return rf(ctx, ids)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) []*User); ok {
		r0 = rf(ctx, ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []uuid.UUID) error); ok {
		r1 = rf(ctx, ids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetUsersByIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsersByIDs'
type MockDatabase_GetUsersByIDs_Call struct {
	*mock.Call
}

// GetUsersByIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - ids []uuid.UUID
func (_e *MockDatabase_Expecter) GetUsersByIDs(ctx interface{}, ids interface{}) *MockDatabase_GetUsersByIDs_Call {
	return &MockDatabase_GetUsersByIDs_Call{Call: _e.mock.On("GetUsersByIDs", ctx, ids)}
}

func (_c *MockDatabase_GetUsersByIDs_Call) Run(run func(ctx context.Context, ids []uuid.UUID)) *MockDatabase_GetUsersByIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_GetUsersByIDs_Call) Return(_a0 []*User, _a1 error) *MockDatabase_GetUsersByIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetUsersByIDs_Call) RunAndReturn(run func(context.Context, []uuid.UUID) ([]*User, error)) *MockDatabase_GetUsersByIDs_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsersWithGloballyAssignedRole provides a mock function with given fields: ctx, roleName
func (_m *MockDatabase) GetUsersWithGloballyAssignedRole(ctx context.Context, roleName gensql.RoleName) ([]*User, error) {
	ret := _m.Called(ctx, roleName)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersWithGloballyAssignedRole")
	}

	var r0 []*User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gensql.RoleName) ([]*User, error)); ok {
		return rf(ctx, roleName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gensql.RoleName) []*User); ok {
		r0 = rf(ctx, roleName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gensql.RoleName) error); ok {
		r1 = rf(ctx, roleName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_GetUsersWithGloballyAssignedRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsersWithGloballyAssignedRole'
type MockDatabase_GetUsersWithGloballyAssignedRole_Call struct {
	*mock.Call
}

// GetUsersWithGloballyAssignedRole is a helper method to define mock.On call
//   - ctx context.Context
//   - roleName gensql.RoleName
func (_e *MockDatabase_Expecter) GetUsersWithGloballyAssignedRole(ctx interface{}, roleName interface{}) *MockDatabase_GetUsersWithGloballyAssignedRole_Call {
	return &MockDatabase_GetUsersWithGloballyAssignedRole_Call{Call: _e.mock.On("GetUsersWithGloballyAssignedRole", ctx, roleName)}
}

func (_c *MockDatabase_GetUsersWithGloballyAssignedRole_Call) Run(run func(ctx context.Context, roleName gensql.RoleName)) *MockDatabase_GetUsersWithGloballyAssignedRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gensql.RoleName))
	})
	return _c
}

func (_c *MockDatabase_GetUsersWithGloballyAssignedRole_Call) Return(_a0 []*User, _a1 error) *MockDatabase_GetUsersWithGloballyAssignedRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_GetUsersWithGloballyAssignedRole_Call) RunAndReturn(run func(context.Context, gensql.RoleName) ([]*User, error)) *MockDatabase_GetUsersWithGloballyAssignedRole_Call {
	_c.Call.Return(run)
	return _c
}

// InsertEnvironment provides a mock function with given fields: ctx, name, gcp
func (_m *MockDatabase) InsertEnvironment(ctx context.Context, name string, gcp bool) error {
	ret := _m.Called(ctx, name, gcp)

	if len(ret) == 0 {
		panic("no return value specified for InsertEnvironment")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = rf(ctx, name, gcp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_InsertEnvironment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertEnvironment'
type MockDatabase_InsertEnvironment_Call struct {
	*mock.Call
}

// InsertEnvironment is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - gcp bool
func (_e *MockDatabase_Expecter) InsertEnvironment(ctx interface{}, name interface{}, gcp interface{}) *MockDatabase_InsertEnvironment_Call {
	return &MockDatabase_InsertEnvironment_Call{Call: _e.mock.On("InsertEnvironment", ctx, name, gcp)}
}

func (_c *MockDatabase_InsertEnvironment_Call) Run(run func(ctx context.Context, name string, gcp bool)) *MockDatabase_InsertEnvironment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *MockDatabase_InsertEnvironment_Call) Return(_a0 error) *MockDatabase_InsertEnvironment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_InsertEnvironment_Call) RunAndReturn(run func(context.Context, string, bool) error) *MockDatabase_InsertEnvironment_Call {
	_c.Call.Return(run)
	return _c
}

// LastCostDate provides a mock function with given fields: ctx
func (_m *MockDatabase) LastCostDate(ctx context.Context) (pgtype.Date, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for LastCostDate")
	}

	var r0 pgtype.Date
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (pgtype.Date, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) pgtype.Date); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(pgtype.Date)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_LastCostDate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LastCostDate'
type MockDatabase_LastCostDate_Call struct {
	*mock.Call
}

// LastCostDate is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDatabase_Expecter) LastCostDate(ctx interface{}) *MockDatabase_LastCostDate_Call {
	return &MockDatabase_LastCostDate_Call{Call: _e.mock.On("LastCostDate", ctx)}
}

func (_c *MockDatabase_LastCostDate_Call) Run(run func(ctx context.Context)) *MockDatabase_LastCostDate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDatabase_LastCostDate_Call) Return(_a0 pgtype.Date, _a1 error) *MockDatabase_LastCostDate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_LastCostDate_Call) RunAndReturn(run func(context.Context) (pgtype.Date, error)) *MockDatabase_LastCostDate_Call {
	_c.Call.Return(run)
	return _c
}

// MaxResourceUtilizationDate provides a mock function with given fields: ctx
func (_m *MockDatabase) MaxResourceUtilizationDate(ctx context.Context) (pgtype.Timestamptz, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for MaxResourceUtilizationDate")
	}

	var r0 pgtype.Timestamptz
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (pgtype.Timestamptz, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) pgtype.Timestamptz); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(pgtype.Timestamptz)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_MaxResourceUtilizationDate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxResourceUtilizationDate'
type MockDatabase_MaxResourceUtilizationDate_Call struct {
	*mock.Call
}

// MaxResourceUtilizationDate is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDatabase_Expecter) MaxResourceUtilizationDate(ctx interface{}) *MockDatabase_MaxResourceUtilizationDate_Call {
	return &MockDatabase_MaxResourceUtilizationDate_Call{Call: _e.mock.On("MaxResourceUtilizationDate", ctx)}
}

func (_c *MockDatabase_MaxResourceUtilizationDate_Call) Run(run func(ctx context.Context)) *MockDatabase_MaxResourceUtilizationDate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDatabase_MaxResourceUtilizationDate_Call) Return(_a0 pgtype.Timestamptz, _a1 error) *MockDatabase_MaxResourceUtilizationDate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_MaxResourceUtilizationDate_Call) RunAndReturn(run func(context.Context) (pgtype.Timestamptz, error)) *MockDatabase_MaxResourceUtilizationDate_Call {
	_c.Call.Return(run)
	return _c
}

// MonthlyCostForApp provides a mock function with given fields: ctx, teamSlug, app, environment
func (_m *MockDatabase) MonthlyCostForApp(ctx context.Context, teamSlug slug.Slug, app string, environment string) ([]*gensql.MonthlyCostForAppRow, error) {
	ret := _m.Called(ctx, teamSlug, app, environment)

	if len(ret) == 0 {
		panic("no return value specified for MonthlyCostForApp")
	}

	var r0 []*gensql.MonthlyCostForAppRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string, string) ([]*gensql.MonthlyCostForAppRow, error)); ok {
		return rf(ctx, teamSlug, app, environment)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string, string) []*gensql.MonthlyCostForAppRow); ok {
		r0 = rf(ctx, teamSlug, app, environment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gensql.MonthlyCostForAppRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, string, string) error); ok {
		r1 = rf(ctx, teamSlug, app, environment)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_MonthlyCostForApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MonthlyCostForApp'
type MockDatabase_MonthlyCostForApp_Call struct {
	*mock.Call
}

// MonthlyCostForApp is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - app string
//   - environment string
func (_e *MockDatabase_Expecter) MonthlyCostForApp(ctx interface{}, teamSlug interface{}, app interface{}, environment interface{}) *MockDatabase_MonthlyCostForApp_Call {
	return &MockDatabase_MonthlyCostForApp_Call{Call: _e.mock.On("MonthlyCostForApp", ctx, teamSlug, app, environment)}
}

func (_c *MockDatabase_MonthlyCostForApp_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, app string, environment string)) *MockDatabase_MonthlyCostForApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockDatabase_MonthlyCostForApp_Call) Return(_a0 []*gensql.MonthlyCostForAppRow, _a1 error) *MockDatabase_MonthlyCostForApp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_MonthlyCostForApp_Call) RunAndReturn(run func(context.Context, slug.Slug, string, string) ([]*gensql.MonthlyCostForAppRow, error)) *MockDatabase_MonthlyCostForApp_Call {
	_c.Call.Return(run)
	return _c
}

// MonthlyCostForTeam provides a mock function with given fields: ctx, teamSlug
func (_m *MockDatabase) MonthlyCostForTeam(ctx context.Context, teamSlug slug.Slug) ([]*gensql.MonthlyCostForTeamRow, error) {
	ret := _m.Called(ctx, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for MonthlyCostForTeam")
	}

	var r0 []*gensql.MonthlyCostForTeamRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) ([]*gensql.MonthlyCostForTeamRow, error)); ok {
		return rf(ctx, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) []*gensql.MonthlyCostForTeamRow); ok {
		r0 = rf(ctx, teamSlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gensql.MonthlyCostForTeamRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug) error); ok {
		r1 = rf(ctx, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_MonthlyCostForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MonthlyCostForTeam'
type MockDatabase_MonthlyCostForTeam_Call struct {
	*mock.Call
}

// MonthlyCostForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) MonthlyCostForTeam(ctx interface{}, teamSlug interface{}) *MockDatabase_MonthlyCostForTeam_Call {
	return &MockDatabase_MonthlyCostForTeam_Call{Call: _e.mock.On("MonthlyCostForTeam", ctx, teamSlug)}
}

func (_c *MockDatabase_MonthlyCostForTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug)) *MockDatabase_MonthlyCostForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_MonthlyCostForTeam_Call) Return(_a0 []*gensql.MonthlyCostForTeamRow, _a1 error) *MockDatabase_MonthlyCostForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_MonthlyCostForTeam_Call) RunAndReturn(run func(context.Context, slug.Slug) ([]*gensql.MonthlyCostForTeamRow, error)) *MockDatabase_MonthlyCostForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveAllServiceAccountRoles provides a mock function with given fields: ctx, serviceAccountID
func (_m *MockDatabase) RemoveAllServiceAccountRoles(ctx context.Context, serviceAccountID uuid.UUID) error {
	ret := _m.Called(ctx, serviceAccountID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAllServiceAccountRoles")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, serviceAccountID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_RemoveAllServiceAccountRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveAllServiceAccountRoles'
type MockDatabase_RemoveAllServiceAccountRoles_Call struct {
	*mock.Call
}

// RemoveAllServiceAccountRoles is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceAccountID uuid.UUID
func (_e *MockDatabase_Expecter) RemoveAllServiceAccountRoles(ctx interface{}, serviceAccountID interface{}) *MockDatabase_RemoveAllServiceAccountRoles_Call {
	return &MockDatabase_RemoveAllServiceAccountRoles_Call{Call: _e.mock.On("RemoveAllServiceAccountRoles", ctx, serviceAccountID)}
}

func (_c *MockDatabase_RemoveAllServiceAccountRoles_Call) Run(run func(ctx context.Context, serviceAccountID uuid.UUID)) *MockDatabase_RemoveAllServiceAccountRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_RemoveAllServiceAccountRoles_Call) Return(_a0 error) *MockDatabase_RemoveAllServiceAccountRoles_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_RemoveAllServiceAccountRoles_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockDatabase_RemoveAllServiceAccountRoles_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveApiKeysFromServiceAccount provides a mock function with given fields: ctx, serviceAccountID
func (_m *MockDatabase) RemoveApiKeysFromServiceAccount(ctx context.Context, serviceAccountID uuid.UUID) error {
	ret := _m.Called(ctx, serviceAccountID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveApiKeysFromServiceAccount")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, serviceAccountID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_RemoveApiKeysFromServiceAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveApiKeysFromServiceAccount'
type MockDatabase_RemoveApiKeysFromServiceAccount_Call struct {
	*mock.Call
}

// RemoveApiKeysFromServiceAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceAccountID uuid.UUID
func (_e *MockDatabase_Expecter) RemoveApiKeysFromServiceAccount(ctx interface{}, serviceAccountID interface{}) *MockDatabase_RemoveApiKeysFromServiceAccount_Call {
	return &MockDatabase_RemoveApiKeysFromServiceAccount_Call{Call: _e.mock.On("RemoveApiKeysFromServiceAccount", ctx, serviceAccountID)}
}

func (_c *MockDatabase_RemoveApiKeysFromServiceAccount_Call) Run(run func(ctx context.Context, serviceAccountID uuid.UUID)) *MockDatabase_RemoveApiKeysFromServiceAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockDatabase_RemoveApiKeysFromServiceAccount_Call) Return(_a0 error) *MockDatabase_RemoveApiKeysFromServiceAccount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_RemoveApiKeysFromServiceAccount_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockDatabase_RemoveApiKeysFromServiceAccount_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveReconcilerOptOut provides a mock function with given fields: ctx, userID, teamSlug, reconcilerName
func (_m *MockDatabase) RemoveReconcilerOptOut(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug, reconcilerName string) error {
	ret := _m.Called(ctx, userID, teamSlug, reconcilerName)

	if len(ret) == 0 {
		panic("no return value specified for RemoveReconcilerOptOut")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, slug.Slug, string) error); ok {
		r0 = rf(ctx, userID, teamSlug, reconcilerName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_RemoveReconcilerOptOut_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveReconcilerOptOut'
type MockDatabase_RemoveReconcilerOptOut_Call struct {
	*mock.Call
}

// RemoveReconcilerOptOut is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - teamSlug slug.Slug
//   - reconcilerName string
func (_e *MockDatabase_Expecter) RemoveReconcilerOptOut(ctx interface{}, userID interface{}, teamSlug interface{}, reconcilerName interface{}) *MockDatabase_RemoveReconcilerOptOut_Call {
	return &MockDatabase_RemoveReconcilerOptOut_Call{Call: _e.mock.On("RemoveReconcilerOptOut", ctx, userID, teamSlug, reconcilerName)}
}

func (_c *MockDatabase_RemoveReconcilerOptOut_Call) Run(run func(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug, reconcilerName string)) *MockDatabase_RemoveReconcilerOptOut_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(slug.Slug), args[3].(string))
	})
	return _c
}

func (_c *MockDatabase_RemoveReconcilerOptOut_Call) Return(_a0 error) *MockDatabase_RemoveReconcilerOptOut_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_RemoveReconcilerOptOut_Call) RunAndReturn(run func(context.Context, uuid.UUID, slug.Slug, string) error) *MockDatabase_RemoveReconcilerOptOut_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRepositoryAuthorization provides a mock function with given fields: ctx, teamSlug, repoName, authorization
func (_m *MockDatabase) RemoveRepositoryAuthorization(ctx context.Context, teamSlug slug.Slug, repoName string, authorization gensql.RepositoryAuthorizationEnum) error {
	ret := _m.Called(ctx, teamSlug, repoName, authorization)

	if len(ret) == 0 {
		panic("no return value specified for RemoveRepositoryAuthorization")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string, gensql.RepositoryAuthorizationEnum) error); ok {
		r0 = rf(ctx, teamSlug, repoName, authorization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_RemoveRepositoryAuthorization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRepositoryAuthorization'
type MockDatabase_RemoveRepositoryAuthorization_Call struct {
	*mock.Call
}

// RemoveRepositoryAuthorization is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - repoName string
//   - authorization gensql.RepositoryAuthorizationEnum
func (_e *MockDatabase_Expecter) RemoveRepositoryAuthorization(ctx interface{}, teamSlug interface{}, repoName interface{}, authorization interface{}) *MockDatabase_RemoveRepositoryAuthorization_Call {
	return &MockDatabase_RemoveRepositoryAuthorization_Call{Call: _e.mock.On("RemoveRepositoryAuthorization", ctx, teamSlug, repoName, authorization)}
}

func (_c *MockDatabase_RemoveRepositoryAuthorization_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, repoName string, authorization gensql.RepositoryAuthorizationEnum)) *MockDatabase_RemoveRepositoryAuthorization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(string), args[3].(gensql.RepositoryAuthorizationEnum))
	})
	return _c
}

func (_c *MockDatabase_RemoveRepositoryAuthorization_Call) Return(_a0 error) *MockDatabase_RemoveRepositoryAuthorization_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_RemoveRepositoryAuthorization_Call) RunAndReturn(run func(context.Context, slug.Slug, string, gensql.RepositoryAuthorizationEnum) error) *MockDatabase_RemoveRepositoryAuthorization_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveUserFromTeam provides a mock function with given fields: ctx, userID, teamSlug
func (_m *MockDatabase) RemoveUserFromTeam(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug) error {
	ret := _m.Called(ctx, userID, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for RemoveUserFromTeam")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, slug.Slug) error); ok {
		r0 = rf(ctx, userID, teamSlug)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_RemoveUserFromTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveUserFromTeam'
type MockDatabase_RemoveUserFromTeam_Call struct {
	*mock.Call
}

// RemoveUserFromTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) RemoveUserFromTeam(ctx interface{}, userID interface{}, teamSlug interface{}) *MockDatabase_RemoveUserFromTeam_Call {
	return &MockDatabase_RemoveUserFromTeam_Call{Call: _e.mock.On("RemoveUserFromTeam", ctx, userID, teamSlug)}
}

func (_c *MockDatabase_RemoveUserFromTeam_Call) Run(run func(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug)) *MockDatabase_RemoveUserFromTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_RemoveUserFromTeam_Call) Return(_a0 error) *MockDatabase_RemoveUserFromTeam_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_RemoveUserFromTeam_Call) RunAndReturn(run func(context.Context, uuid.UUID, slug.Slug) error) *MockDatabase_RemoveUserFromTeam_Call {
	_c.Call.Return(run)
	return _c
}

// ResetReconcilerConfig provides a mock function with given fields: ctx, reconcilerName
func (_m *MockDatabase) ResetReconcilerConfig(ctx context.Context, reconcilerName string) (*Reconciler, error) {
	ret := _m.Called(ctx, reconcilerName)

	if len(ret) == 0 {
		panic("no return value specified for ResetReconcilerConfig")
	}

	var r0 *Reconciler
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Reconciler, error)); ok {
		return rf(ctx, reconcilerName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Reconciler); ok {
		r0 = rf(ctx, reconcilerName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Reconciler)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, reconcilerName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_ResetReconcilerConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetReconcilerConfig'
type MockDatabase_ResetReconcilerConfig_Call struct {
	*mock.Call
}

// ResetReconcilerConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
func (_e *MockDatabase_Expecter) ResetReconcilerConfig(ctx interface{}, reconcilerName interface{}) *MockDatabase_ResetReconcilerConfig_Call {
	return &MockDatabase_ResetReconcilerConfig_Call{Call: _e.mock.On("ResetReconcilerConfig", ctx, reconcilerName)}
}

func (_c *MockDatabase_ResetReconcilerConfig_Call) Run(run func(ctx context.Context, reconcilerName string)) *MockDatabase_ResetReconcilerConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDatabase_ResetReconcilerConfig_Call) Return(_a0 *Reconciler, _a1 error) *MockDatabase_ResetReconcilerConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_ResetReconcilerConfig_Call) RunAndReturn(run func(context.Context, string) (*Reconciler, error)) *MockDatabase_ResetReconcilerConfig_Call {
	_c.Call.Return(run)
	return _c
}

// ResourceUtilizationForApp provides a mock function with given fields: ctx, arg
func (_m *MockDatabase) ResourceUtilizationForApp(ctx context.Context, arg gensql.ResourceUtilizationForAppParams) ([]*gensql.ResourceUtilizationMetric, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for ResourceUtilizationForApp")
	}

	var r0 []*gensql.ResourceUtilizationMetric
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gensql.ResourceUtilizationForAppParams) ([]*gensql.ResourceUtilizationMetric, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gensql.ResourceUtilizationForAppParams) []*gensql.ResourceUtilizationMetric); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gensql.ResourceUtilizationMetric)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gensql.ResourceUtilizationForAppParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_ResourceUtilizationForApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResourceUtilizationForApp'
type MockDatabase_ResourceUtilizationForApp_Call struct {
	*mock.Call
}

// ResourceUtilizationForApp is a helper method to define mock.On call
//   - ctx context.Context
//   - arg gensql.ResourceUtilizationForAppParams
func (_e *MockDatabase_Expecter) ResourceUtilizationForApp(ctx interface{}, arg interface{}) *MockDatabase_ResourceUtilizationForApp_Call {
	return &MockDatabase_ResourceUtilizationForApp_Call{Call: _e.mock.On("ResourceUtilizationForApp", ctx, arg)}
}

func (_c *MockDatabase_ResourceUtilizationForApp_Call) Run(run func(ctx context.Context, arg gensql.ResourceUtilizationForAppParams)) *MockDatabase_ResourceUtilizationForApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gensql.ResourceUtilizationForAppParams))
	})
	return _c
}

func (_c *MockDatabase_ResourceUtilizationForApp_Call) Return(_a0 []*gensql.ResourceUtilizationMetric, _a1 error) *MockDatabase_ResourceUtilizationForApp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_ResourceUtilizationForApp_Call) RunAndReturn(run func(context.Context, gensql.ResourceUtilizationForAppParams) ([]*gensql.ResourceUtilizationMetric, error)) *MockDatabase_ResourceUtilizationForApp_Call {
	_c.Call.Return(run)
	return _c
}

// ResourceUtilizationForTeam provides a mock function with given fields: ctx, environment, teamSlug, resourceType, start, end
func (_m *MockDatabase) ResourceUtilizationForTeam(ctx context.Context, environment string, teamSlug slug.Slug, resourceType gensql.ResourceType, start pgtype.Timestamptz, end pgtype.Timestamptz) ([]*gensql.ResourceUtilizationForTeamRow, error) {
	ret := _m.Called(ctx, environment, teamSlug, resourceType, start, end)

	if len(ret) == 0 {
		panic("no return value specified for ResourceUtilizationForTeam")
	}

	var r0 []*gensql.ResourceUtilizationForTeamRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, gensql.ResourceType, pgtype.Timestamptz, pgtype.Timestamptz) ([]*gensql.ResourceUtilizationForTeamRow, error)); ok {
		return rf(ctx, environment, teamSlug, resourceType, start, end)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, gensql.ResourceType, pgtype.Timestamptz, pgtype.Timestamptz) []*gensql.ResourceUtilizationForTeamRow); ok {
		r0 = rf(ctx, environment, teamSlug, resourceType, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gensql.ResourceUtilizationForTeamRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, slug.Slug, gensql.ResourceType, pgtype.Timestamptz, pgtype.Timestamptz) error); ok {
		r1 = rf(ctx, environment, teamSlug, resourceType, start, end)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_ResourceUtilizationForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResourceUtilizationForTeam'
type MockDatabase_ResourceUtilizationForTeam_Call struct {
	*mock.Call
}

// ResourceUtilizationForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - environment string
//   - teamSlug slug.Slug
//   - resourceType gensql.ResourceType
//   - start pgtype.Timestamptz
//   - end pgtype.Timestamptz
func (_e *MockDatabase_Expecter) ResourceUtilizationForTeam(ctx interface{}, environment interface{}, teamSlug interface{}, resourceType interface{}, start interface{}, end interface{}) *MockDatabase_ResourceUtilizationForTeam_Call {
	return &MockDatabase_ResourceUtilizationForTeam_Call{Call: _e.mock.On("ResourceUtilizationForTeam", ctx, environment, teamSlug, resourceType, start, end)}
}

func (_c *MockDatabase_ResourceUtilizationForTeam_Call) Run(run func(ctx context.Context, environment string, teamSlug slug.Slug, resourceType gensql.ResourceType, start pgtype.Timestamptz, end pgtype.Timestamptz)) *MockDatabase_ResourceUtilizationForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(slug.Slug), args[3].(gensql.ResourceType), args[4].(pgtype.Timestamptz), args[5].(pgtype.Timestamptz))
	})
	return _c
}

func (_c *MockDatabase_ResourceUtilizationForTeam_Call) Return(_a0 []*gensql.ResourceUtilizationForTeamRow, _a1 error) *MockDatabase_ResourceUtilizationForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_ResourceUtilizationForTeam_Call) RunAndReturn(run func(context.Context, string, slug.Slug, gensql.ResourceType, pgtype.Timestamptz, pgtype.Timestamptz) ([]*gensql.ResourceUtilizationForTeamRow, error)) *MockDatabase_ResourceUtilizationForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// ResourceUtilizationOverageForTeam provides a mock function with given fields: ctx, teamSlug, timestamp, resourceType
func (_m *MockDatabase) ResourceUtilizationOverageForTeam(ctx context.Context, teamSlug slug.Slug, timestamp pgtype.Timestamptz, resourceType gensql.ResourceType) ([]*gensql.ResourceUtilizationOverageForTeamRow, error) {
	ret := _m.Called(ctx, teamSlug, timestamp, resourceType)

	if len(ret) == 0 {
		panic("no return value specified for ResourceUtilizationOverageForTeam")
	}

	var r0 []*gensql.ResourceUtilizationOverageForTeamRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, pgtype.Timestamptz, gensql.ResourceType) ([]*gensql.ResourceUtilizationOverageForTeamRow, error)); ok {
		return rf(ctx, teamSlug, timestamp, resourceType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, pgtype.Timestamptz, gensql.ResourceType) []*gensql.ResourceUtilizationOverageForTeamRow); ok {
		r0 = rf(ctx, teamSlug, timestamp, resourceType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gensql.ResourceUtilizationOverageForTeamRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, pgtype.Timestamptz, gensql.ResourceType) error); ok {
		r1 = rf(ctx, teamSlug, timestamp, resourceType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_ResourceUtilizationOverageForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResourceUtilizationOverageForTeam'
type MockDatabase_ResourceUtilizationOverageForTeam_Call struct {
	*mock.Call
}

// ResourceUtilizationOverageForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - timestamp pgtype.Timestamptz
//   - resourceType gensql.ResourceType
func (_e *MockDatabase_Expecter) ResourceUtilizationOverageForTeam(ctx interface{}, teamSlug interface{}, timestamp interface{}, resourceType interface{}) *MockDatabase_ResourceUtilizationOverageForTeam_Call {
	return &MockDatabase_ResourceUtilizationOverageForTeam_Call{Call: _e.mock.On("ResourceUtilizationOverageForTeam", ctx, teamSlug, timestamp, resourceType)}
}

func (_c *MockDatabase_ResourceUtilizationOverageForTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, timestamp pgtype.Timestamptz, resourceType gensql.ResourceType)) *MockDatabase_ResourceUtilizationOverageForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(pgtype.Timestamptz), args[3].(gensql.ResourceType))
	})
	return _c
}

func (_c *MockDatabase_ResourceUtilizationOverageForTeam_Call) Return(_a0 []*gensql.ResourceUtilizationOverageForTeamRow, _a1 error) *MockDatabase_ResourceUtilizationOverageForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_ResourceUtilizationOverageForTeam_Call) RunAndReturn(run func(context.Context, slug.Slug, pgtype.Timestamptz, gensql.ResourceType) ([]*gensql.ResourceUtilizationOverageForTeamRow, error)) *MockDatabase_ResourceUtilizationOverageForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// ResourceUtilizationRangeForApp provides a mock function with given fields: ctx, environment, teamSlug, app
func (_m *MockDatabase) ResourceUtilizationRangeForApp(ctx context.Context, environment string, teamSlug slug.Slug, app string) (*gensql.ResourceUtilizationRangeForAppRow, error) {
	ret := _m.Called(ctx, environment, teamSlug, app)

	if len(ret) == 0 {
		panic("no return value specified for ResourceUtilizationRangeForApp")
	}

	var r0 *gensql.ResourceUtilizationRangeForAppRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, string) (*gensql.ResourceUtilizationRangeForAppRow, error)); ok {
		return rf(ctx, environment, teamSlug, app)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, string) *gensql.ResourceUtilizationRangeForAppRow); ok {
		r0 = rf(ctx, environment, teamSlug, app)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gensql.ResourceUtilizationRangeForAppRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, slug.Slug, string) error); ok {
		r1 = rf(ctx, environment, teamSlug, app)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_ResourceUtilizationRangeForApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResourceUtilizationRangeForApp'
type MockDatabase_ResourceUtilizationRangeForApp_Call struct {
	*mock.Call
}

// ResourceUtilizationRangeForApp is a helper method to define mock.On call
//   - ctx context.Context
//   - environment string
//   - teamSlug slug.Slug
//   - app string
func (_e *MockDatabase_Expecter) ResourceUtilizationRangeForApp(ctx interface{}, environment interface{}, teamSlug interface{}, app interface{}) *MockDatabase_ResourceUtilizationRangeForApp_Call {
	return &MockDatabase_ResourceUtilizationRangeForApp_Call{Call: _e.mock.On("ResourceUtilizationRangeForApp", ctx, environment, teamSlug, app)}
}

func (_c *MockDatabase_ResourceUtilizationRangeForApp_Call) Run(run func(ctx context.Context, environment string, teamSlug slug.Slug, app string)) *MockDatabase_ResourceUtilizationRangeForApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(slug.Slug), args[3].(string))
	})
	return _c
}

func (_c *MockDatabase_ResourceUtilizationRangeForApp_Call) Return(_a0 *gensql.ResourceUtilizationRangeForAppRow, _a1 error) *MockDatabase_ResourceUtilizationRangeForApp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_ResourceUtilizationRangeForApp_Call) RunAndReturn(run func(context.Context, string, slug.Slug, string) (*gensql.ResourceUtilizationRangeForAppRow, error)) *MockDatabase_ResourceUtilizationRangeForApp_Call {
	_c.Call.Return(run)
	return _c
}

// ResourceUtilizationRangeForTeam provides a mock function with given fields: ctx, teamSlug
func (_m *MockDatabase) ResourceUtilizationRangeForTeam(ctx context.Context, teamSlug slug.Slug) (*gensql.ResourceUtilizationRangeForTeamRow, error) {
	ret := _m.Called(ctx, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for ResourceUtilizationRangeForTeam")
	}

	var r0 *gensql.ResourceUtilizationRangeForTeamRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) (*gensql.ResourceUtilizationRangeForTeamRow, error)); ok {
		return rf(ctx, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) *gensql.ResourceUtilizationRangeForTeamRow); ok {
		r0 = rf(ctx, teamSlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gensql.ResourceUtilizationRangeForTeamRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug) error); ok {
		r1 = rf(ctx, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_ResourceUtilizationRangeForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResourceUtilizationRangeForTeam'
type MockDatabase_ResourceUtilizationRangeForTeam_Call struct {
	*mock.Call
}

// ResourceUtilizationRangeForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) ResourceUtilizationRangeForTeam(ctx interface{}, teamSlug interface{}) *MockDatabase_ResourceUtilizationRangeForTeam_Call {
	return &MockDatabase_ResourceUtilizationRangeForTeam_Call{Call: _e.mock.On("ResourceUtilizationRangeForTeam", ctx, teamSlug)}
}

func (_c *MockDatabase_ResourceUtilizationRangeForTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug)) *MockDatabase_ResourceUtilizationRangeForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_ResourceUtilizationRangeForTeam_Call) Return(_a0 *gensql.ResourceUtilizationRangeForTeamRow, _a1 error) *MockDatabase_ResourceUtilizationRangeForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_ResourceUtilizationRangeForTeam_Call) RunAndReturn(run func(context.Context, slug.Slug) (*gensql.ResourceUtilizationRangeForTeamRow, error)) *MockDatabase_ResourceUtilizationRangeForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// ResourceUtilizationUpsert provides a mock function with given fields: ctx, arg
func (_m *MockDatabase) ResourceUtilizationUpsert(ctx context.Context, arg []gensql.ResourceUtilizationUpsertParams) *gensql.ResourceUtilizationUpsertBatchResults {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for ResourceUtilizationUpsert")
	}

	var r0 *gensql.ResourceUtilizationUpsertBatchResults
	if rf, ok := ret.Get(0).(func(context.Context, []gensql.ResourceUtilizationUpsertParams) *gensql.ResourceUtilizationUpsertBatchResults); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gensql.ResourceUtilizationUpsertBatchResults)
		}
	}

	return r0
}

// MockDatabase_ResourceUtilizationUpsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResourceUtilizationUpsert'
type MockDatabase_ResourceUtilizationUpsert_Call struct {
	*mock.Call
}

// ResourceUtilizationUpsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg []gensql.ResourceUtilizationUpsertParams
func (_e *MockDatabase_Expecter) ResourceUtilizationUpsert(ctx interface{}, arg interface{}) *MockDatabase_ResourceUtilizationUpsert_Call {
	return &MockDatabase_ResourceUtilizationUpsert_Call{Call: _e.mock.On("ResourceUtilizationUpsert", ctx, arg)}
}

func (_c *MockDatabase_ResourceUtilizationUpsert_Call) Run(run func(ctx context.Context, arg []gensql.ResourceUtilizationUpsertParams)) *MockDatabase_ResourceUtilizationUpsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]gensql.ResourceUtilizationUpsertParams))
	})
	return _c
}

func (_c *MockDatabase_ResourceUtilizationUpsert_Call) Return(_a0 *gensql.ResourceUtilizationUpsertBatchResults) *MockDatabase_ResourceUtilizationUpsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_ResourceUtilizationUpsert_Call) RunAndReturn(run func(context.Context, []gensql.ResourceUtilizationUpsertParams) *gensql.ResourceUtilizationUpsertBatchResults) *MockDatabase_ResourceUtilizationUpsert_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeGlobalUserRole provides a mock function with given fields: ctx, userID, roleName
func (_m *MockDatabase) RevokeGlobalUserRole(ctx context.Context, userID uuid.UUID, roleName gensql.RoleName) error {
	ret := _m.Called(ctx, userID, roleName)

	if len(ret) == 0 {
		panic("no return value specified for RevokeGlobalUserRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, gensql.RoleName) error); ok {
		r0 = rf(ctx, userID, roleName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_RevokeGlobalUserRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeGlobalUserRole'
type MockDatabase_RevokeGlobalUserRole_Call struct {
	*mock.Call
}

// RevokeGlobalUserRole is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - roleName gensql.RoleName
func (_e *MockDatabase_Expecter) RevokeGlobalUserRole(ctx interface{}, userID interface{}, roleName interface{}) *MockDatabase_RevokeGlobalUserRole_Call {
	return &MockDatabase_RevokeGlobalUserRole_Call{Call: _e.mock.On("RevokeGlobalUserRole", ctx, userID, roleName)}
}

func (_c *MockDatabase_RevokeGlobalUserRole_Call) Run(run func(ctx context.Context, userID uuid.UUID, roleName gensql.RoleName)) *MockDatabase_RevokeGlobalUserRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(gensql.RoleName))
	})
	return _c
}

func (_c *MockDatabase_RevokeGlobalUserRole_Call) Return(_a0 error) *MockDatabase_RevokeGlobalUserRole_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_RevokeGlobalUserRole_Call) RunAndReturn(run func(context.Context, uuid.UUID, gensql.RoleName) error) *MockDatabase_RevokeGlobalUserRole_Call {
	_c.Call.Return(run)
	return _c
}

// SearchTeams provides a mock function with given fields: ctx, slugMatch, limit
func (_m *MockDatabase) SearchTeams(ctx context.Context, slugMatch string, limit int32) ([]*gensql.Team, error) {
	ret := _m.Called(ctx, slugMatch, limit)

	if len(ret) == 0 {
		panic("no return value specified for SearchTeams")
	}

	var r0 []*gensql.Team
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int32) ([]*gensql.Team, error)); ok {
		return rf(ctx, slugMatch, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int32) []*gensql.Team); ok {
		r0 = rf(ctx, slugMatch, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gensql.Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int32) error); ok {
		r1 = rf(ctx, slugMatch, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_SearchTeams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchTeams'
type MockDatabase_SearchTeams_Call struct {
	*mock.Call
}

// SearchTeams is a helper method to define mock.On call
//   - ctx context.Context
//   - slugMatch string
//   - limit int32
func (_e *MockDatabase_Expecter) SearchTeams(ctx interface{}, slugMatch interface{}, limit interface{}) *MockDatabase_SearchTeams_Call {
	return &MockDatabase_SearchTeams_Call{Call: _e.mock.On("SearchTeams", ctx, slugMatch, limit)}
}

func (_c *MockDatabase_SearchTeams_Call) Run(run func(ctx context.Context, slugMatch string, limit int32)) *MockDatabase_SearchTeams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int32))
	})
	return _c
}

func (_c *MockDatabase_SearchTeams_Call) Return(_a0 []*gensql.Team, _a1 error) *MockDatabase_SearchTeams_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_SearchTeams_Call) RunAndReturn(run func(context.Context, string, int32) ([]*gensql.Team, error)) *MockDatabase_SearchTeams_Call {
	_c.Call.Return(run)
	return _c
}

// SetLastSuccessfulSyncForTeam provides a mock function with given fields: ctx, teamSlug
func (_m *MockDatabase) SetLastSuccessfulSyncForTeam(ctx context.Context, teamSlug slug.Slug) error {
	ret := _m.Called(ctx, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for SetLastSuccessfulSyncForTeam")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) error); ok {
		r0 = rf(ctx, teamSlug)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_SetLastSuccessfulSyncForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLastSuccessfulSyncForTeam'
type MockDatabase_SetLastSuccessfulSyncForTeam_Call struct {
	*mock.Call
}

// SetLastSuccessfulSyncForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) SetLastSuccessfulSyncForTeam(ctx interface{}, teamSlug interface{}) *MockDatabase_SetLastSuccessfulSyncForTeam_Call {
	return &MockDatabase_SetLastSuccessfulSyncForTeam_Call{Call: _e.mock.On("SetLastSuccessfulSyncForTeam", ctx, teamSlug)}
}

func (_c *MockDatabase_SetLastSuccessfulSyncForTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug)) *MockDatabase_SetLastSuccessfulSyncForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_SetLastSuccessfulSyncForTeam_Call) Return(_a0 error) *MockDatabase_SetLastSuccessfulSyncForTeam_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_SetLastSuccessfulSyncForTeam_Call) RunAndReturn(run func(context.Context, slug.Slug) error) *MockDatabase_SetLastSuccessfulSyncForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// SetReconcilerErrorForTeam provides a mock function with given fields: ctx, correlationID, teamSlug, reconcilerName, err
func (_m *MockDatabase) SetReconcilerErrorForTeam(ctx context.Context, correlationID uuid.UUID, teamSlug slug.Slug, reconcilerName string, err error) error {
	ret := _m.Called(ctx, correlationID, teamSlug, reconcilerName, err)

	if len(ret) == 0 {
		panic("no return value specified for SetReconcilerErrorForTeam")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, slug.Slug, string, error) error); ok {
		r0 = rf(ctx, correlationID, teamSlug, reconcilerName, err)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_SetReconcilerErrorForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetReconcilerErrorForTeam'
type MockDatabase_SetReconcilerErrorForTeam_Call struct {
	*mock.Call
}

// SetReconcilerErrorForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - correlationID uuid.UUID
//   - teamSlug slug.Slug
//   - reconcilerName string
//   - err error
func (_e *MockDatabase_Expecter) SetReconcilerErrorForTeam(ctx interface{}, correlationID interface{}, teamSlug interface{}, reconcilerName interface{}, err interface{}) *MockDatabase_SetReconcilerErrorForTeam_Call {
	return &MockDatabase_SetReconcilerErrorForTeam_Call{Call: _e.mock.On("SetReconcilerErrorForTeam", ctx, correlationID, teamSlug, reconcilerName, err)}
}

func (_c *MockDatabase_SetReconcilerErrorForTeam_Call) Run(run func(ctx context.Context, correlationID uuid.UUID, teamSlug slug.Slug, reconcilerName string, err error)) *MockDatabase_SetReconcilerErrorForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(slug.Slug), args[3].(string), args[4].(error))
	})
	return _c
}

func (_c *MockDatabase_SetReconcilerErrorForTeam_Call) Return(_a0 error) *MockDatabase_SetReconcilerErrorForTeam_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_SetReconcilerErrorForTeam_Call) RunAndReturn(run func(context.Context, uuid.UUID, slug.Slug, string, error) error) *MockDatabase_SetReconcilerErrorForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// SetTeamMemberRole provides a mock function with given fields: ctx, userID, teamSlug, roleName
func (_m *MockDatabase) SetTeamMemberRole(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug, roleName gensql.RoleName) error {
	ret := _m.Called(ctx, userID, teamSlug, roleName)

	if len(ret) == 0 {
		panic("no return value specified for SetTeamMemberRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, slug.Slug, gensql.RoleName) error); ok {
		r0 = rf(ctx, userID, teamSlug, roleName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_SetTeamMemberRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTeamMemberRole'
type MockDatabase_SetTeamMemberRole_Call struct {
	*mock.Call
}

// SetTeamMemberRole is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - teamSlug slug.Slug
//   - roleName gensql.RoleName
func (_e *MockDatabase_Expecter) SetTeamMemberRole(ctx interface{}, userID interface{}, teamSlug interface{}, roleName interface{}) *MockDatabase_SetTeamMemberRole_Call {
	return &MockDatabase_SetTeamMemberRole_Call{Call: _e.mock.On("SetTeamMemberRole", ctx, userID, teamSlug, roleName)}
}

func (_c *MockDatabase_SetTeamMemberRole_Call) Run(run func(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug, roleName gensql.RoleName)) *MockDatabase_SetTeamMemberRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(slug.Slug), args[3].(gensql.RoleName))
	})
	return _c
}

func (_c *MockDatabase_SetTeamMemberRole_Call) Return(_a0 error) *MockDatabase_SetTeamMemberRole_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_SetTeamMemberRole_Call) RunAndReturn(run func(context.Context, uuid.UUID, slug.Slug, gensql.RoleName) error) *MockDatabase_SetTeamMemberRole_Call {
	_c.Call.Return(run)
	return _c
}

// SpecificResourceUtilizationForApp provides a mock function with given fields: ctx, environment, teamSlug, app, resourceType, timestamp
func (_m *MockDatabase) SpecificResourceUtilizationForApp(ctx context.Context, environment string, teamSlug slug.Slug, app string, resourceType gensql.ResourceType, timestamp pgtype.Timestamptz) (*gensql.SpecificResourceUtilizationForAppRow, error) {
	ret := _m.Called(ctx, environment, teamSlug, app, resourceType, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for SpecificResourceUtilizationForApp")
	}

	var r0 *gensql.SpecificResourceUtilizationForAppRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, string, gensql.ResourceType, pgtype.Timestamptz) (*gensql.SpecificResourceUtilizationForAppRow, error)); ok {
		return rf(ctx, environment, teamSlug, app, resourceType, timestamp)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, string, gensql.ResourceType, pgtype.Timestamptz) *gensql.SpecificResourceUtilizationForAppRow); ok {
		r0 = rf(ctx, environment, teamSlug, app, resourceType, timestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gensql.SpecificResourceUtilizationForAppRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, slug.Slug, string, gensql.ResourceType, pgtype.Timestamptz) error); ok {
		r1 = rf(ctx, environment, teamSlug, app, resourceType, timestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_SpecificResourceUtilizationForApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SpecificResourceUtilizationForApp'
type MockDatabase_SpecificResourceUtilizationForApp_Call struct {
	*mock.Call
}

// SpecificResourceUtilizationForApp is a helper method to define mock.On call
//   - ctx context.Context
//   - environment string
//   - teamSlug slug.Slug
//   - app string
//   - resourceType gensql.ResourceType
//   - timestamp pgtype.Timestamptz
func (_e *MockDatabase_Expecter) SpecificResourceUtilizationForApp(ctx interface{}, environment interface{}, teamSlug interface{}, app interface{}, resourceType interface{}, timestamp interface{}) *MockDatabase_SpecificResourceUtilizationForApp_Call {
	return &MockDatabase_SpecificResourceUtilizationForApp_Call{Call: _e.mock.On("SpecificResourceUtilizationForApp", ctx, environment, teamSlug, app, resourceType, timestamp)}
}

func (_c *MockDatabase_SpecificResourceUtilizationForApp_Call) Run(run func(ctx context.Context, environment string, teamSlug slug.Slug, app string, resourceType gensql.ResourceType, timestamp pgtype.Timestamptz)) *MockDatabase_SpecificResourceUtilizationForApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(slug.Slug), args[3].(string), args[4].(gensql.ResourceType), args[5].(pgtype.Timestamptz))
	})
	return _c
}

func (_c *MockDatabase_SpecificResourceUtilizationForApp_Call) Return(_a0 *gensql.SpecificResourceUtilizationForAppRow, _a1 error) *MockDatabase_SpecificResourceUtilizationForApp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_SpecificResourceUtilizationForApp_Call) RunAndReturn(run func(context.Context, string, slug.Slug, string, gensql.ResourceType, pgtype.Timestamptz) (*gensql.SpecificResourceUtilizationForAppRow, error)) *MockDatabase_SpecificResourceUtilizationForApp_Call {
	_c.Call.Return(run)
	return _c
}

// SpecificResourceUtilizationForTeam provides a mock function with given fields: ctx, teamSlug, resourceType, timestamp
func (_m *MockDatabase) SpecificResourceUtilizationForTeam(ctx context.Context, teamSlug slug.Slug, resourceType gensql.ResourceType, timestamp pgtype.Timestamptz) (*gensql.SpecificResourceUtilizationForTeamRow, error) {
	ret := _m.Called(ctx, teamSlug, resourceType, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for SpecificResourceUtilizationForTeam")
	}

	var r0 *gensql.SpecificResourceUtilizationForTeamRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, gensql.ResourceType, pgtype.Timestamptz) (*gensql.SpecificResourceUtilizationForTeamRow, error)); ok {
		return rf(ctx, teamSlug, resourceType, timestamp)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, gensql.ResourceType, pgtype.Timestamptz) *gensql.SpecificResourceUtilizationForTeamRow); ok {
		r0 = rf(ctx, teamSlug, resourceType, timestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gensql.SpecificResourceUtilizationForTeamRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, gensql.ResourceType, pgtype.Timestamptz) error); ok {
		r1 = rf(ctx, teamSlug, resourceType, timestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_SpecificResourceUtilizationForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SpecificResourceUtilizationForTeam'
type MockDatabase_SpecificResourceUtilizationForTeam_Call struct {
	*mock.Call
}

// SpecificResourceUtilizationForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - resourceType gensql.ResourceType
//   - timestamp pgtype.Timestamptz
func (_e *MockDatabase_Expecter) SpecificResourceUtilizationForTeam(ctx interface{}, teamSlug interface{}, resourceType interface{}, timestamp interface{}) *MockDatabase_SpecificResourceUtilizationForTeam_Call {
	return &MockDatabase_SpecificResourceUtilizationForTeam_Call{Call: _e.mock.On("SpecificResourceUtilizationForTeam", ctx, teamSlug, resourceType, timestamp)}
}

func (_c *MockDatabase_SpecificResourceUtilizationForTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, resourceType gensql.ResourceType, timestamp pgtype.Timestamptz)) *MockDatabase_SpecificResourceUtilizationForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(gensql.ResourceType), args[3].(pgtype.Timestamptz))
	})
	return _c
}

func (_c *MockDatabase_SpecificResourceUtilizationForTeam_Call) Return(_a0 *gensql.SpecificResourceUtilizationForTeamRow, _a1 error) *MockDatabase_SpecificResourceUtilizationForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_SpecificResourceUtilizationForTeam_Call) RunAndReturn(run func(context.Context, slug.Slug, gensql.ResourceType, pgtype.Timestamptz) (*gensql.SpecificResourceUtilizationForTeamRow, error)) *MockDatabase_SpecificResourceUtilizationForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// SyncEnvironments provides a mock function with given fields: ctx, envs
func (_m *MockDatabase) SyncEnvironments(ctx context.Context, envs []*Environment) error {
	ret := _m.Called(ctx, envs)

	if len(ret) == 0 {
		panic("no return value specified for SyncEnvironments")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*Environment) error); ok {
		r0 = rf(ctx, envs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_SyncEnvironments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncEnvironments'
type MockDatabase_SyncEnvironments_Call struct {
	*mock.Call
}

// SyncEnvironments is a helper method to define mock.On call
//   - ctx context.Context
//   - envs []*Environment
func (_e *MockDatabase_Expecter) SyncEnvironments(ctx interface{}, envs interface{}) *MockDatabase_SyncEnvironments_Call {
	return &MockDatabase_SyncEnvironments_Call{Call: _e.mock.On("SyncEnvironments", ctx, envs)}
}

func (_c *MockDatabase_SyncEnvironments_Call) Run(run func(ctx context.Context, envs []*Environment)) *MockDatabase_SyncEnvironments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*Environment))
	})
	return _c
}

func (_c *MockDatabase_SyncEnvironments_Call) Return(_a0 error) *MockDatabase_SyncEnvironments_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_SyncEnvironments_Call) RunAndReturn(run func(context.Context, []*Environment) error) *MockDatabase_SyncEnvironments_Call {
	_c.Call.Return(run)
	return _c
}

// SyncReconcilerConfig provides a mock function with given fields: ctx, reconcilerName, configs
func (_m *MockDatabase) SyncReconcilerConfig(ctx context.Context, reconcilerName string, configs []*protoapi.ReconcilerConfigSpec) error {
	ret := _m.Called(ctx, reconcilerName, configs)

	if len(ret) == 0 {
		panic("no return value specified for SyncReconcilerConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []*protoapi.ReconcilerConfigSpec) error); ok {
		r0 = rf(ctx, reconcilerName, configs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_SyncReconcilerConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncReconcilerConfig'
type MockDatabase_SyncReconcilerConfig_Call struct {
	*mock.Call
}

// SyncReconcilerConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
//   - configs []*protoapi.ReconcilerConfigSpec
func (_e *MockDatabase_Expecter) SyncReconcilerConfig(ctx interface{}, reconcilerName interface{}, configs interface{}) *MockDatabase_SyncReconcilerConfig_Call {
	return &MockDatabase_SyncReconcilerConfig_Call{Call: _e.mock.On("SyncReconcilerConfig", ctx, reconcilerName, configs)}
}

func (_c *MockDatabase_SyncReconcilerConfig_Call) Run(run func(ctx context.Context, reconcilerName string, configs []*protoapi.ReconcilerConfigSpec)) *MockDatabase_SyncReconcilerConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]*protoapi.ReconcilerConfigSpec))
	})
	return _c
}

func (_c *MockDatabase_SyncReconcilerConfig_Call) Return(_a0 error) *MockDatabase_SyncReconcilerConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_SyncReconcilerConfig_Call) RunAndReturn(run func(context.Context, string, []*protoapi.ReconcilerConfigSpec) error) *MockDatabase_SyncReconcilerConfig_Call {
	_c.Call.Return(run)
	return _c
}

// TeamExists provides a mock function with given fields: ctx, team
func (_m *MockDatabase) TeamExists(ctx context.Context, team slug.Slug) (bool, error) {
	ret := _m.Called(ctx, team)

	if len(ret) == 0 {
		panic("no return value specified for TeamExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) (bool, error)); ok {
		return rf(ctx, team)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) bool); ok {
		r0 = rf(ctx, team)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug) error); ok {
		r1 = rf(ctx, team)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_TeamExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TeamExists'
type MockDatabase_TeamExists_Call struct {
	*mock.Call
}

// TeamExists is a helper method to define mock.On call
//   - ctx context.Context
//   - team slug.Slug
func (_e *MockDatabase_Expecter) TeamExists(ctx interface{}, team interface{}) *MockDatabase_TeamExists_Call {
	return &MockDatabase_TeamExists_Call{Call: _e.mock.On("TeamExists", ctx, team)}
}

func (_c *MockDatabase_TeamExists_Call) Run(run func(ctx context.Context, team slug.Slug)) *MockDatabase_TeamExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_TeamExists_Call) Return(_a0 bool, _a1 error) *MockDatabase_TeamExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_TeamExists_Call) RunAndReturn(run func(context.Context, slug.Slug) (bool, error)) *MockDatabase_TeamExists_Call {
	_c.Call.Return(run)
	return _c
}

// Transaction provides a mock function with given fields: ctx, fn
func (_m *MockDatabase) Transaction(ctx context.Context, fn DatabaseTransactionFunc) error {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for Transaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DatabaseTransactionFunc) error); ok {
		r0 = rf(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_Transaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transaction'
type MockDatabase_Transaction_Call struct {
	*mock.Call
}

// Transaction is a helper method to define mock.On call
//   - ctx context.Context
//   - fn DatabaseTransactionFunc
func (_e *MockDatabase_Expecter) Transaction(ctx interface{}, fn interface{}) *MockDatabase_Transaction_Call {
	return &MockDatabase_Transaction_Call{Call: _e.mock.On("Transaction", ctx, fn)}
}

func (_c *MockDatabase_Transaction_Call) Run(run func(ctx context.Context, fn DatabaseTransactionFunc)) *MockDatabase_Transaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DatabaseTransactionFunc))
	})
	return _c
}

func (_c *MockDatabase_Transaction_Call) Return(_a0 error) *MockDatabase_Transaction_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_Transaction_Call) RunAndReturn(run func(context.Context, DatabaseTransactionFunc) error) *MockDatabase_Transaction_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTeam provides a mock function with given fields: ctx, teamSlug, purpose, slackChannel
func (_m *MockDatabase) UpdateTeam(ctx context.Context, teamSlug slug.Slug, purpose *string, slackChannel *string) (*Team, error) {
	ret := _m.Called(ctx, teamSlug, purpose, slackChannel)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTeam")
	}

	var r0 *Team
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, *string, *string) (*Team, error)); ok {
		return rf(ctx, teamSlug, purpose, slackChannel)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, *string, *string) *Team); ok {
		r0 = rf(ctx, teamSlug, purpose, slackChannel)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug, *string, *string) error); ok {
		r1 = rf(ctx, teamSlug, purpose, slackChannel)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_UpdateTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTeam'
type MockDatabase_UpdateTeam_Call struct {
	*mock.Call
}

// UpdateTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - purpose *string
//   - slackChannel *string
func (_e *MockDatabase_Expecter) UpdateTeam(ctx interface{}, teamSlug interface{}, purpose interface{}, slackChannel interface{}) *MockDatabase_UpdateTeam_Call {
	return &MockDatabase_UpdateTeam_Call{Call: _e.mock.On("UpdateTeam", ctx, teamSlug, purpose, slackChannel)}
}

func (_c *MockDatabase_UpdateTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, purpose *string, slackChannel *string)) *MockDatabase_UpdateTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(*string), args[3].(*string))
	})
	return _c
}

func (_c *MockDatabase_UpdateTeam_Call) Return(_a0 *Team, _a1 error) *MockDatabase_UpdateTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_UpdateTeam_Call) RunAndReturn(run func(context.Context, slug.Slug, *string, *string) (*Team, error)) *MockDatabase_UpdateTeam_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTeamExternalReferences provides a mock function with given fields: ctx, params
func (_m *MockDatabase) UpdateTeamExternalReferences(ctx context.Context, params gensql.UpdateTeamExternalReferencesParams) (*Team, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTeamExternalReferences")
	}

	var r0 *Team
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gensql.UpdateTeamExternalReferencesParams) (*Team, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gensql.UpdateTeamExternalReferencesParams) *Team); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gensql.UpdateTeamExternalReferencesParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_UpdateTeamExternalReferences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTeamExternalReferences'
type MockDatabase_UpdateTeamExternalReferences_Call struct {
	*mock.Call
}

// UpdateTeamExternalReferences is a helper method to define mock.On call
//   - ctx context.Context
//   - params gensql.UpdateTeamExternalReferencesParams
func (_e *MockDatabase_Expecter) UpdateTeamExternalReferences(ctx interface{}, params interface{}) *MockDatabase_UpdateTeamExternalReferences_Call {
	return &MockDatabase_UpdateTeamExternalReferences_Call{Call: _e.mock.On("UpdateTeamExternalReferences", ctx, params)}
}

func (_c *MockDatabase_UpdateTeamExternalReferences_Call) Run(run func(ctx context.Context, params gensql.UpdateTeamExternalReferencesParams)) *MockDatabase_UpdateTeamExternalReferences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gensql.UpdateTeamExternalReferencesParams))
	})
	return _c
}

func (_c *MockDatabase_UpdateTeamExternalReferences_Call) Return(_a0 *Team, _a1 error) *MockDatabase_UpdateTeamExternalReferences_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_UpdateTeamExternalReferences_Call) RunAndReturn(run func(context.Context, gensql.UpdateTeamExternalReferencesParams) (*Team, error)) *MockDatabase_UpdateTeamExternalReferences_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function with given fields: ctx, userID, name, email, externalID
func (_m *MockDatabase) UpdateUser(ctx context.Context, userID uuid.UUID, name string, email string, externalID string) (*User, error) {
	ret := _m.Called(ctx, userID, name, email, externalID)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 *User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, string, string) (*User, error)); ok {
		return rf(ctx, userID, name, email, externalID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, string, string) *User); ok {
		r0 = rf(ctx, userID, name, email, externalID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, string, string) error); ok {
		r1 = rf(ctx, userID, name, email, externalID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type MockDatabase_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - name string
//   - email string
//   - externalID string
func (_e *MockDatabase_Expecter) UpdateUser(ctx interface{}, userID interface{}, name interface{}, email interface{}, externalID interface{}) *MockDatabase_UpdateUser_Call {
	return &MockDatabase_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, userID, name, email, externalID)}
}

func (_c *MockDatabase_UpdateUser_Call) Run(run func(ctx context.Context, userID uuid.UUID, name string, email string, externalID string)) *MockDatabase_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *MockDatabase_UpdateUser_Call) Return(_a0 *User, _a1 error) *MockDatabase_UpdateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_UpdateUser_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, string, string) (*User, error)) *MockDatabase_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertReconciler provides a mock function with given fields: ctx, name, displayName, description, memberAware, enableIfNew
func (_m *MockDatabase) UpsertReconciler(ctx context.Context, name string, displayName string, description string, memberAware bool, enableIfNew bool) (*Reconciler, error) {
	ret := _m.Called(ctx, name, displayName, description, memberAware, enableIfNew)

	if len(ret) == 0 {
		panic("no return value specified for UpsertReconciler")
	}

	var r0 *Reconciler
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool, bool) (*Reconciler, error)); ok {
		return rf(ctx, name, displayName, description, memberAware, enableIfNew)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool, bool) *Reconciler); ok {
		r0 = rf(ctx, name, displayName, description, memberAware, enableIfNew)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Reconciler)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, bool, bool) error); ok {
		r1 = rf(ctx, name, displayName, description, memberAware, enableIfNew)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_UpsertReconciler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertReconciler'
type MockDatabase_UpsertReconciler_Call struct {
	*mock.Call
}

// UpsertReconciler is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - displayName string
//   - description string
//   - memberAware bool
//   - enableIfNew bool
func (_e *MockDatabase_Expecter) UpsertReconciler(ctx interface{}, name interface{}, displayName interface{}, description interface{}, memberAware interface{}, enableIfNew interface{}) *MockDatabase_UpsertReconciler_Call {
	return &MockDatabase_UpsertReconciler_Call{Call: _e.mock.On("UpsertReconciler", ctx, name, displayName, description, memberAware, enableIfNew)}
}

func (_c *MockDatabase_UpsertReconciler_Call) Run(run func(ctx context.Context, name string, displayName string, description string, memberAware bool, enableIfNew bool)) *MockDatabase_UpsertReconciler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(bool), args[5].(bool))
	})
	return _c
}

func (_c *MockDatabase_UpsertReconciler_Call) Return(_a0 *Reconciler, _a1 error) *MockDatabase_UpsertReconciler_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_UpsertReconciler_Call) RunAndReturn(run func(context.Context, string, string, string, bool, bool) (*Reconciler, error)) *MockDatabase_UpsertReconciler_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertReconcilerConfig provides a mock function with given fields: ctx, reconciler, key, displayName, description, secret
func (_m *MockDatabase) UpsertReconcilerConfig(ctx context.Context, reconciler string, key string, displayName string, description string, secret bool) error {
	ret := _m.Called(ctx, reconciler, key, displayName, description, secret)

	if len(ret) == 0 {
		panic("no return value specified for UpsertReconcilerConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, bool) error); ok {
		r0 = rf(ctx, reconciler, key, displayName, description, secret)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_UpsertReconcilerConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertReconcilerConfig'
type MockDatabase_UpsertReconcilerConfig_Call struct {
	*mock.Call
}

// UpsertReconcilerConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - reconciler string
//   - key string
//   - displayName string
//   - description string
//   - secret bool
func (_e *MockDatabase_Expecter) UpsertReconcilerConfig(ctx interface{}, reconciler interface{}, key interface{}, displayName interface{}, description interface{}, secret interface{}) *MockDatabase_UpsertReconcilerConfig_Call {
	return &MockDatabase_UpsertReconcilerConfig_Call{Call: _e.mock.On("UpsertReconcilerConfig", ctx, reconciler, key, displayName, description, secret)}
}

func (_c *MockDatabase_UpsertReconcilerConfig_Call) Run(run func(ctx context.Context, reconciler string, key string, displayName string, description string, secret bool)) *MockDatabase_UpsertReconcilerConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(bool))
	})
	return _c
}

func (_c *MockDatabase_UpsertReconcilerConfig_Call) Return(_a0 error) *MockDatabase_UpsertReconcilerConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_UpsertReconcilerConfig_Call) RunAndReturn(run func(context.Context, string, string, string, string, bool) error) *MockDatabase_UpsertReconcilerConfig_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertReconcilerResource provides a mock function with given fields: ctx, reconcilerName, teamSlug, key, value, metadata
func (_m *MockDatabase) UpsertReconcilerResource(ctx context.Context, reconcilerName string, teamSlug slug.Slug, key string, value []byte, metadata []byte) (*ReconcilerResource, error) {
	ret := _m.Called(ctx, reconcilerName, teamSlug, key, value, metadata)

	if len(ret) == 0 {
		panic("no return value specified for UpsertReconcilerResource")
	}

	var r0 *ReconcilerResource
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, string, []byte, []byte) (*ReconcilerResource, error)); ok {
		return rf(ctx, reconcilerName, teamSlug, key, value, metadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, slug.Slug, string, []byte, []byte) *ReconcilerResource); ok {
		r0 = rf(ctx, reconcilerName, teamSlug, key, value, metadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ReconcilerResource)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, slug.Slug, string, []byte, []byte) error); ok {
		r1 = rf(ctx, reconcilerName, teamSlug, key, value, metadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_UpsertReconcilerResource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertReconcilerResource'
type MockDatabase_UpsertReconcilerResource_Call struct {
	*mock.Call
}

// UpsertReconcilerResource is a helper method to define mock.On call
//   - ctx context.Context
//   - reconcilerName string
//   - teamSlug slug.Slug
//   - key string
//   - value []byte
//   - metadata []byte
func (_e *MockDatabase_Expecter) UpsertReconcilerResource(ctx interface{}, reconcilerName interface{}, teamSlug interface{}, key interface{}, value interface{}, metadata interface{}) *MockDatabase_UpsertReconcilerResource_Call {
	return &MockDatabase_UpsertReconcilerResource_Call{Call: _e.mock.On("UpsertReconcilerResource", ctx, reconcilerName, teamSlug, key, value, metadata)}
}

func (_c *MockDatabase_UpsertReconcilerResource_Call) Run(run func(ctx context.Context, reconcilerName string, teamSlug slug.Slug, key string, value []byte, metadata []byte)) *MockDatabase_UpsertReconcilerResource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(slug.Slug), args[3].(string), args[4].([]byte), args[5].([]byte))
	})
	return _c
}

func (_c *MockDatabase_UpsertReconcilerResource_Call) Return(_a0 *ReconcilerResource, _a1 error) *MockDatabase_UpsertReconcilerResource_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_UpsertReconcilerResource_Call) RunAndReturn(run func(context.Context, string, slug.Slug, string, []byte, []byte) (*ReconcilerResource, error)) *MockDatabase_UpsertReconcilerResource_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertTeamEnvironment provides a mock function with given fields: ctx, teamSlug, environment, slackChannel, gcpProjectID
func (_m *MockDatabase) UpsertTeamEnvironment(ctx context.Context, teamSlug slug.Slug, environment string, slackChannel *string, gcpProjectID *string) error {
	ret := _m.Called(ctx, teamSlug, environment, slackChannel, gcpProjectID)

	if len(ret) == 0 {
		panic("no return value specified for UpsertTeamEnvironment")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug, string, *string, *string) error); ok {
		r0 = rf(ctx, teamSlug, environment, slackChannel, gcpProjectID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDatabase_UpsertTeamEnvironment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertTeamEnvironment'
type MockDatabase_UpsertTeamEnvironment_Call struct {
	*mock.Call
}

// UpsertTeamEnvironment is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
//   - environment string
//   - slackChannel *string
//   - gcpProjectID *string
func (_e *MockDatabase_Expecter) UpsertTeamEnvironment(ctx interface{}, teamSlug interface{}, environment interface{}, slackChannel interface{}, gcpProjectID interface{}) *MockDatabase_UpsertTeamEnvironment_Call {
	return &MockDatabase_UpsertTeamEnvironment_Call{Call: _e.mock.On("UpsertTeamEnvironment", ctx, teamSlug, environment, slackChannel, gcpProjectID)}
}

func (_c *MockDatabase_UpsertTeamEnvironment_Call) Run(run func(ctx context.Context, teamSlug slug.Slug, environment string, slackChannel *string, gcpProjectID *string)) *MockDatabase_UpsertTeamEnvironment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug), args[2].(string), args[3].(*string), args[4].(*string))
	})
	return _c
}

func (_c *MockDatabase_UpsertTeamEnvironment_Call) Return(_a0 error) *MockDatabase_UpsertTeamEnvironment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_UpsertTeamEnvironment_Call) RunAndReturn(run func(context.Context, slug.Slug, string, *string, *string) error) *MockDatabase_UpsertTeamEnvironment_Call {
	_c.Call.Return(run)
	return _c
}

// UserIsTeamOwner provides a mock function with given fields: ctx, userID, teamSlug
func (_m *MockDatabase) UserIsTeamOwner(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug) (bool, error) {
	ret := _m.Called(ctx, userID, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for UserIsTeamOwner")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, slug.Slug) (bool, error)); ok {
		return rf(ctx, userID, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, slug.Slug) bool); ok {
		r0 = rf(ctx, userID, teamSlug)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, slug.Slug) error); ok {
		r1 = rf(ctx, userID, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_UserIsTeamOwner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserIsTeamOwner'
type MockDatabase_UserIsTeamOwner_Call struct {
	*mock.Call
}

// UserIsTeamOwner is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) UserIsTeamOwner(ctx interface{}, userID interface{}, teamSlug interface{}) *MockDatabase_UserIsTeamOwner_Call {
	return &MockDatabase_UserIsTeamOwner_Call{Call: _e.mock.On("UserIsTeamOwner", ctx, userID, teamSlug)}
}

func (_c *MockDatabase_UserIsTeamOwner_Call) Run(run func(ctx context.Context, userID uuid.UUID, teamSlug slug.Slug)) *MockDatabase_UserIsTeamOwner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_UserIsTeamOwner_Call) Return(_a0 bool, _a1 error) *MockDatabase_UserIsTeamOwner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_UserIsTeamOwner_Call) RunAndReturn(run func(context.Context, uuid.UUID, slug.Slug) (bool, error)) *MockDatabase_UserIsTeamOwner_Call {
	_c.Call.Return(run)
	return _c
}

// VulnerabilityMetricsDateRangeForTeam provides a mock function with given fields: ctx, teamSlug
func (_m *MockDatabase) VulnerabilityMetricsDateRangeForTeam(ctx context.Context, teamSlug slug.Slug) (*gensql.VulnerabilityMetricsDateRangeForTeamRow, error) {
	ret := _m.Called(ctx, teamSlug)

	if len(ret) == 0 {
		panic("no return value specified for VulnerabilityMetricsDateRangeForTeam")
	}

	var r0 *gensql.VulnerabilityMetricsDateRangeForTeamRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) (*gensql.VulnerabilityMetricsDateRangeForTeamRow, error)); ok {
		return rf(ctx, teamSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, slug.Slug) *gensql.VulnerabilityMetricsDateRangeForTeamRow); ok {
		r0 = rf(ctx, teamSlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gensql.VulnerabilityMetricsDateRangeForTeamRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, slug.Slug) error); ok {
		r1 = rf(ctx, teamSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDatabase_VulnerabilityMetricsDateRangeForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VulnerabilityMetricsDateRangeForTeam'
type MockDatabase_VulnerabilityMetricsDateRangeForTeam_Call struct {
	*mock.Call
}

// VulnerabilityMetricsDateRangeForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - teamSlug slug.Slug
func (_e *MockDatabase_Expecter) VulnerabilityMetricsDateRangeForTeam(ctx interface{}, teamSlug interface{}) *MockDatabase_VulnerabilityMetricsDateRangeForTeam_Call {
	return &MockDatabase_VulnerabilityMetricsDateRangeForTeam_Call{Call: _e.mock.On("VulnerabilityMetricsDateRangeForTeam", ctx, teamSlug)}
}

func (_c *MockDatabase_VulnerabilityMetricsDateRangeForTeam_Call) Run(run func(ctx context.Context, teamSlug slug.Slug)) *MockDatabase_VulnerabilityMetricsDateRangeForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(slug.Slug))
	})
	return _c
}

func (_c *MockDatabase_VulnerabilityMetricsDateRangeForTeam_Call) Return(_a0 *gensql.VulnerabilityMetricsDateRangeForTeamRow, _a1 error) *MockDatabase_VulnerabilityMetricsDateRangeForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDatabase_VulnerabilityMetricsDateRangeForTeam_Call) RunAndReturn(run func(context.Context, slug.Slug) (*gensql.VulnerabilityMetricsDateRangeForTeamRow, error)) *MockDatabase_VulnerabilityMetricsDateRangeForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// VulnerabilityMetricsUpsert provides a mock function with given fields: ctx, arg
func (_m *MockDatabase) VulnerabilityMetricsUpsert(ctx context.Context, arg []gensql.VulnerabilityMetricsUpsertParams) *gensql.VulnerabilityMetricsUpsertBatchResults {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for VulnerabilityMetricsUpsert")
	}

	var r0 *gensql.VulnerabilityMetricsUpsertBatchResults
	if rf, ok := ret.Get(0).(func(context.Context, []gensql.VulnerabilityMetricsUpsertParams) *gensql.VulnerabilityMetricsUpsertBatchResults); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gensql.VulnerabilityMetricsUpsertBatchResults)
		}
	}

	return r0
}

// MockDatabase_VulnerabilityMetricsUpsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VulnerabilityMetricsUpsert'
type MockDatabase_VulnerabilityMetricsUpsert_Call struct {
	*mock.Call
}

// VulnerabilityMetricsUpsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg []gensql.VulnerabilityMetricsUpsertParams
func (_e *MockDatabase_Expecter) VulnerabilityMetricsUpsert(ctx interface{}, arg interface{}) *MockDatabase_VulnerabilityMetricsUpsert_Call {
	return &MockDatabase_VulnerabilityMetricsUpsert_Call{Call: _e.mock.On("VulnerabilityMetricsUpsert", ctx, arg)}
}

func (_c *MockDatabase_VulnerabilityMetricsUpsert_Call) Run(run func(ctx context.Context, arg []gensql.VulnerabilityMetricsUpsertParams)) *MockDatabase_VulnerabilityMetricsUpsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]gensql.VulnerabilityMetricsUpsertParams))
	})
	return _c
}

func (_c *MockDatabase_VulnerabilityMetricsUpsert_Call) Return(_a0 *gensql.VulnerabilityMetricsUpsertBatchResults) *MockDatabase_VulnerabilityMetricsUpsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDatabase_VulnerabilityMetricsUpsert_Call) RunAndReturn(run func(context.Context, []gensql.VulnerabilityMetricsUpsertParams) *gensql.VulnerabilityMetricsUpsertBatchResults) *MockDatabase_VulnerabilityMetricsUpsert_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDatabase creates a new instance of MockDatabase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDatabase(t interface {
	mock.TestingT
	Cleanup(func())
},
) *MockDatabase {
	mock := &MockDatabase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

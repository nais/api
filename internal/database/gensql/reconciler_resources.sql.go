// Code generated by sqlc. DO NOT EDIT.
// source: reconciler_resources.sql

package gensql

import (
	"context"

	"github.com/nais/api/internal/slug"
)

const deleteAllReconcilerResources = `-- name: DeleteAllReconcilerResources :exec
DELETE FROM reconciler_resources
WHERE reconciler_name = $1 AND team_slug = $2
`

type DeleteAllReconcilerResourcesParams struct {
	ReconcilerName string
	TeamSlug       slug.Slug
}

func (q *Queries) DeleteAllReconcilerResources(ctx context.Context, arg DeleteAllReconcilerResourcesParams) error {
	_, err := q.db.Exec(ctx, deleteAllReconcilerResources, arg.ReconcilerName, arg.TeamSlug)
	return err
}

const getReconcilerResourceByKey = `-- name: GetReconcilerResourceByKey :many
SELECT id, reconciler_name, team_slug, name, value, metadata, created_at, updated_at
FROM reconciler_resources
WHERE reconciler_name = $1 AND team_slug = $2 AND name = $3
ORDER BY value ASC LIMIT $5 OFFSET $4
`

type GetReconcilerResourceByKeyParams struct {
	ReconcilerName string
	TeamSlug       slug.Slug
	Name           string
	Offset         int32
	Limit          int32
}

func (q *Queries) GetReconcilerResourceByKey(ctx context.Context, arg GetReconcilerResourceByKeyParams) ([]*ReconcilerResource, error) {
	rows, err := q.db.Query(ctx, getReconcilerResourceByKey,
		arg.ReconcilerName,
		arg.TeamSlug,
		arg.Name,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ReconcilerResource{}
	for rows.Next() {
		var i ReconcilerResource
		if err := rows.Scan(
			&i.ID,
			&i.ReconcilerName,
			&i.TeamSlug,
			&i.Name,
			&i.Value,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReconcilerResourceByKeyAndValue = `-- name: GetReconcilerResourceByKeyAndValue :one
SELECT id, reconciler_name, team_slug, name, value, metadata, created_at, updated_at
FROM reconciler_resources
WHERE reconciler_name = $1 AND team_slug = $2 AND name = $3 AND value = $4
`

type GetReconcilerResourceByKeyAndValueParams struct {
	ReconcilerName string
	TeamSlug       slug.Slug
	Name           string
	Value          []byte
}

func (q *Queries) GetReconcilerResourceByKeyAndValue(ctx context.Context, arg GetReconcilerResourceByKeyAndValueParams) (*ReconcilerResource, error) {
	row := q.db.QueryRow(ctx, getReconcilerResourceByKeyAndValue,
		arg.ReconcilerName,
		arg.TeamSlug,
		arg.Name,
		arg.Value,
	)
	var i ReconcilerResource
	err := row.Scan(
		&i.ID,
		&i.ReconcilerName,
		&i.TeamSlug,
		&i.Name,
		&i.Value,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getReconcilerResourceByKeyTotal = `-- name: GetReconcilerResourceByKeyTotal :one
SELECT COUNT(*)
FROM reconciler_resources
WHERE reconciler_name = $1 AND team_slug = $2 AND name = $3
`

type GetReconcilerResourceByKeyTotalParams struct {
	ReconcilerName string
	TeamSlug       slug.Slug
	Name           string
}

func (q *Queries) GetReconcilerResourceByKeyTotal(ctx context.Context, arg GetReconcilerResourceByKeyTotalParams) (int64, error) {
	row := q.db.QueryRow(ctx, getReconcilerResourceByKeyTotal, arg.ReconcilerName, arg.TeamSlug, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getReconcilerResourcesForReconciler = `-- name: GetReconcilerResourcesForReconciler :many
SELECT id, reconciler_name, team_slug, name, value, metadata, created_at, updated_at
FROM reconciler_resources
WHERE reconciler_name = $1
ORDER BY team_slug, name ASC
LIMIT $3 OFFSET $2
`

type GetReconcilerResourcesForReconcilerParams struct {
	ReconcilerName string
	Offset         int32
	Limit          int32
}

func (q *Queries) GetReconcilerResourcesForReconciler(ctx context.Context, arg GetReconcilerResourcesForReconcilerParams) ([]*ReconcilerResource, error) {
	rows, err := q.db.Query(ctx, getReconcilerResourcesForReconciler, arg.ReconcilerName, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ReconcilerResource{}
	for rows.Next() {
		var i ReconcilerResource
		if err := rows.Scan(
			&i.ID,
			&i.ReconcilerName,
			&i.TeamSlug,
			&i.Name,
			&i.Value,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReconcilerResourcesForReconcilerAndTeam = `-- name: GetReconcilerResourcesForReconcilerAndTeam :many
SELECT id, reconciler_name, team_slug, name, value, metadata, created_at, updated_at
FROM reconciler_resources
WHERE reconciler_name = $1 AND team_slug = $2
ORDER BY team_slug, name ASC
LIMIT $4 OFFSET $3
`

type GetReconcilerResourcesForReconcilerAndTeamParams struct {
	ReconcilerName string
	TeamSlug       slug.Slug
	Offset         int32
	Limit          int32
}

func (q *Queries) GetReconcilerResourcesForReconcilerAndTeam(ctx context.Context, arg GetReconcilerResourcesForReconcilerAndTeamParams) ([]*ReconcilerResource, error) {
	rows, err := q.db.Query(ctx, getReconcilerResourcesForReconcilerAndTeam,
		arg.ReconcilerName,
		arg.TeamSlug,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ReconcilerResource{}
	for rows.Next() {
		var i ReconcilerResource
		if err := rows.Scan(
			&i.ID,
			&i.ReconcilerName,
			&i.TeamSlug,
			&i.Name,
			&i.Value,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertReconcilerResource = `-- name: UpsertReconcilerResource :one
INSERT INTO reconciler_resources (
  reconciler_name,
  team_slug,
  name,
  value,
  metadata
) VALUES (
  $1,
  $2,
  $3,
  $4,
  COALESCE($5, '{}'::jsonb)
)
ON CONFLICT (reconciler_name, team_slug, name, value) DO
UPDATE SET metadata = EXCLUDED.metadata
RETURNING id, reconciler_name, team_slug, name, value, metadata, created_at, updated_at
`

type UpsertReconcilerResourceParams struct {
	ReconcilerName string
	TeamSlug       slug.Slug
	Name           string
	Value          []byte
	Metadata       interface{}
}

func (q *Queries) UpsertReconcilerResource(ctx context.Context, arg UpsertReconcilerResourceParams) (*ReconcilerResource, error) {
	row := q.db.QueryRow(ctx, upsertReconcilerResource,
		arg.ReconcilerName,
		arg.TeamSlug,
		arg.Name,
		arg.Value,
		arg.Metadata,
	)
	var i ReconcilerResource
	err := row.Scan(
		&i.ID,
		&i.ReconcilerName,
		&i.TeamSlug,
		&i.Name,
		&i.Value,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

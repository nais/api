// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: reconcilers.sql

package gensql

import (
	"context"

	"github.com/google/uuid"
	"github.com/nais/api/internal/slug"
)

const addReconcilerOptOut = `-- name: AddReconcilerOptOut :exec
INSERT INTO reconciler_opt_outs (team_slug, user_id, reconciler_name)
VALUES ($1, $2, $3) ON CONFLICT DO NOTHING
`

func (q *Queries) AddReconcilerOptOut(ctx context.Context, teamSlug slug.Slug, userID uuid.UUID, reconcilerName string) error {
	_, err := q.db.Exec(ctx, addReconcilerOptOut, teamSlug, userID, reconcilerName)
	return err
}

const configureReconciler = `-- name: ConfigureReconciler :exec
UPDATE reconciler_config
SET value = $1::TEXT
WHERE reconciler = $2 AND key = $3
`

func (q *Queries) ConfigureReconciler(ctx context.Context, value string, reconcilerName string, key string) error {
	_, err := q.db.Exec(ctx, configureReconciler, value, reconcilerName, key)
	return err
}

const dangerousGetReconcilerConfigValues = `-- name: DangerousGetReconcilerConfigValues :many
SELECT key, value::TEXT
FROM reconciler_config
WHERE reconciler = $1
ORDER BY key ASC
`

type DangerousGetReconcilerConfigValuesRow struct {
	Key   string
	Value string
}

func (q *Queries) DangerousGetReconcilerConfigValues(ctx context.Context, reconcilerName string) ([]*DangerousGetReconcilerConfigValuesRow, error) {
	rows, err := q.db.Query(ctx, dangerousGetReconcilerConfigValues, reconcilerName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DangerousGetReconcilerConfigValuesRow{}
	for rows.Next() {
		var i DangerousGetReconcilerConfigValuesRow
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteReconcilerConfig = `-- name: DeleteReconcilerConfig :exec
DELETE FROM reconciler_config
WHERE reconciler = $1 AND key = ANY($2::TEXT[])
`

func (q *Queries) DeleteReconcilerConfig(ctx context.Context, reconciler string, keys []string) error {
	_, err := q.db.Exec(ctx, deleteReconcilerConfig, reconciler, keys)
	return err
}

const disableReconciler = `-- name: DisableReconciler :one
UPDATE reconcilers
SET enabled = false
WHERE name = $1
RETURNING name, display_name, description, enabled, member_aware
`

func (q *Queries) DisableReconciler(ctx context.Context, name string) (*Reconciler, error) {
	row := q.db.QueryRow(ctx, disableReconciler, name)
	var i Reconciler
	err := row.Scan(
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Enabled,
		&i.MemberAware,
	)
	return &i, err
}

const enableReconciler = `-- name: EnableReconciler :one
UPDATE reconcilers
SET enabled = true
WHERE name = $1
RETURNING name, display_name, description, enabled, member_aware
`

func (q *Queries) EnableReconciler(ctx context.Context, name string) (*Reconciler, error) {
	row := q.db.QueryRow(ctx, enableReconciler, name)
	var i Reconciler
	err := row.Scan(
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Enabled,
		&i.MemberAware,
	)
	return &i, err
}

const getEnabledReconcilers = `-- name: GetEnabledReconcilers :many
SELECT name, display_name, description, enabled, member_aware FROM reconcilers
WHERE enabled = true
ORDER BY display_name ASC
`

func (q *Queries) GetEnabledReconcilers(ctx context.Context) ([]*Reconciler, error) {
	rows, err := q.db.Query(ctx, getEnabledReconcilers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Reconciler{}
	for rows.Next() {
		var i Reconciler
		if err := rows.Scan(
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.Enabled,
			&i.MemberAware,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReconciler = `-- name: GetReconciler :one
SELECT name, display_name, description, enabled, member_aware FROM reconcilers
WHERE name = $1
`

func (q *Queries) GetReconciler(ctx context.Context, name string) (*Reconciler, error) {
	row := q.db.QueryRow(ctx, getReconciler, name)
	var i Reconciler
	err := row.Scan(
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Enabled,
		&i.MemberAware,
	)
	return &i, err
}

const getReconcilerConfig = `-- name: GetReconcilerConfig :many
SELECT
    rc.reconciler,
    rc.key,
    rc.display_name,
    rc.description,
    (rc.value IS NOT NULL)::BOOL AS configured,
    rc2.value,
    rc.secret
FROM reconciler_config rc
LEFT JOIN reconciler_config rc2 ON rc2.reconciler = rc.reconciler AND rc2.key = rc.key AND rc2.secret = false
WHERE rc.reconciler = $1
ORDER BY rc.display_name ASC
`

type GetReconcilerConfigRow struct {
	Reconciler  string
	Key         string
	DisplayName string
	Description string
	Configured  bool
	Value       *string
	Secret      bool
}

func (q *Queries) GetReconcilerConfig(ctx context.Context, reconcilerName string) ([]*GetReconcilerConfigRow, error) {
	rows, err := q.db.Query(ctx, getReconcilerConfig, reconcilerName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetReconcilerConfigRow{}
	for rows.Next() {
		var i GetReconcilerConfigRow
		if err := rows.Scan(
			&i.Reconciler,
			&i.Key,
			&i.DisplayName,
			&i.Description,
			&i.Configured,
			&i.Value,
			&i.Secret,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReconcilers = `-- name: GetReconcilers :many
SELECT name, display_name, description, enabled, member_aware FROM reconcilers
ORDER BY display_name ASC LIMIT $2 OFFSET $1
`

func (q *Queries) GetReconcilers(ctx context.Context, offset int32, limit int32) ([]*Reconciler, error) {
	rows, err := q.db.Query(ctx, getReconcilers, offset, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Reconciler{}
	for rows.Next() {
		var i Reconciler
		if err := rows.Scan(
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.Enabled,
			&i.MemberAware,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReconcilersCount = `-- name: GetReconcilersCount :one
SELECT COUNT(*) as total FROM reconcilers
`

func (q *Queries) GetReconcilersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getReconcilersCount)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const removeReconcilerOptOut = `-- name: RemoveReconcilerOptOut :exec
DELETE FROM reconciler_opt_outs
WHERE team_slug = $1 AND user_id = $2 AND reconciler_name = $3
`

func (q *Queries) RemoveReconcilerOptOut(ctx context.Context, teamSlug slug.Slug, userID uuid.UUID, reconcilerName string) error {
	_, err := q.db.Exec(ctx, removeReconcilerOptOut, teamSlug, userID, reconcilerName)
	return err
}

const resetReconcilerConfig = `-- name: ResetReconcilerConfig :exec
UPDATE reconciler_config
SET value = NULL
WHERE reconciler = $1
`

func (q *Queries) ResetReconcilerConfig(ctx context.Context, reconcilerName string) error {
	_, err := q.db.Exec(ctx, resetReconcilerConfig, reconcilerName)
	return err
}

const upsertReconciler = `-- name: UpsertReconciler :one
INSERT INTO reconcilers (name, display_name, description, member_aware)
VALUES ($1, $2, $3, $4)
ON CONFLICT (name) DO UPDATE
SET display_name = $2, description = $3, member_aware = $4
RETURNING name, display_name, description, enabled, member_aware
`

func (q *Queries) UpsertReconciler(ctx context.Context, name string, displayName string, description string, memberAware bool) (*Reconciler, error) {
	row := q.db.QueryRow(ctx, upsertReconciler,
		name,
		displayName,
		description,
		memberAware,
	)
	var i Reconciler
	err := row.Scan(
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Enabled,
		&i.MemberAware,
	)
	return &i, err
}

const upsertReconcilerConfig = `-- name: UpsertReconcilerConfig :exec
INSERT INTO reconciler_config (reconciler, key, display_name, description, secret)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (reconciler, key) DO UPDATE
SET display_name = $3, description = $4, secret = $5
`

func (q *Queries) UpsertReconcilerConfig(ctx context.Context, reconciler string, key string, displayName string, description string, secret bool) error {
	_, err := q.db.Exec(ctx, upsertReconcilerConfig,
		reconciler,
		key,
		displayName,
		description,
		secret,
	)
	return err
}

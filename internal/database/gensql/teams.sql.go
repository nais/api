// Code generated by sqlc. DO NOT EDIT.
// source: teams.sql

package gensql

import (
	"context"

	"github.com/google/uuid"
	"github.com/nais/api/internal/slug"
)

const confirmTeamDeleteKey = `-- name: ConfirmTeamDeleteKey :exec
UPDATE team_delete_keys
SET team_delete_keys.confirmed_at = NOW()
WHERE team_delete_keys.key = $1
`

// ConfirmTeamDeleteKey confirms a delete key for a team.
func (q *Queries) ConfirmTeamDeleteKey(ctx context.Context, key uuid.UUID) error {
	_, err := q.db.Exec(ctx, confirmTeamDeleteKey, key)
	return err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (slug, purpose, slack_channel)
VALUES ($1, $2, $3)
RETURNING slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, cdn_bucket, deleted_at
`

type CreateTeamParams struct {
	Slug         slug.Slug
	Purpose      string
	SlackChannel string
}

// CreateTeam creates a new team.
func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (*Team, error) {
	row := q.db.QueryRow(ctx, createTeam, arg.Slug, arg.Purpose, arg.SlackChannel)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.CdnBucket,
		&i.DeletedAt,
	)
	return &i, err
}

const createTeamDeleteKey = `-- name: CreateTeamDeleteKey :one
INSERT INTO team_delete_keys (team_slug, created_by)
VALUES($1, $2)
RETURNING key, team_slug, created_at, created_by, confirmed_at
`

type CreateTeamDeleteKeyParams struct {
	TeamSlug  slug.Slug
	CreatedBy uuid.UUID
}

// CreateTeamDeleteKey creates a new delete key for a team.
func (q *Queries) CreateTeamDeleteKey(ctx context.Context, arg CreateTeamDeleteKeyParams) (*TeamDeleteKey, error) {
	row := q.db.QueryRow(ctx, createTeamDeleteKey, arg.TeamSlug, arg.CreatedBy)
	var i TeamDeleteKey
	err := row.Scan(
		&i.Key,
		&i.TeamSlug,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ConfirmedAt,
	)
	return &i, err
}

const deleteTeam = `-- name: DeleteTeam :exec
UPDATE teams
SET teams.deleted_at = NOW()
WHERE
    teams.slug = $1
    AND teams.deleted_at IS NULL
    AND EXISTS(
        SELECT team_delete_keys.team_slug
        FROM team_delete_keys
        WHERE
            team_delete_keys.team_slug = $1
            AND team_delete_keys.confirmed_at IS NOT NULL
    )
`

// DeleteTeam marks a team as deleted. The team must have an already confirmed delete key for this to succeed.
func (q *Queries) DeleteTeam(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, deleteTeam, argSlug)
	return err
}

const getActiveOrDeletedTeamBySlug = `-- name: GetActiveOrDeletedTeamBySlug :one
SELECT
    teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug, teams.gar_repository, teams.cdn_bucket, teams.deleted_at,
    (
        COUNT(team_delete_keys.*) > 0
        AND teams.deleted_at IS NULL
    )::BOOL AS canBeDeleted
FROM teams
LEFT JOIN team_delete_keys ON
    team_delete_keys.team_slug = teams.slug
    AND team_delete_keys.confirmed_at IS NOT NULL
WHERE teams.slug = $1
GROUP BY teams.slug
`

type GetActiveOrDeletedTeamBySlugRow struct {
	Team         Team
	Canbedeleted bool
}

// GetActiveOrDeletedTeamBySlug returns a team by its slug, including deleted teams.
func (q *Queries) GetActiveOrDeletedTeamBySlug(ctx context.Context, argSlug slug.Slug) (*GetActiveOrDeletedTeamBySlugRow, error) {
	row := q.db.QueryRow(ctx, getActiveOrDeletedTeamBySlug, argSlug)
	var i GetActiveOrDeletedTeamBySlugRow
	err := row.Scan(
		&i.Team.Slug,
		&i.Team.Purpose,
		&i.Team.LastSuccessfulSync,
		&i.Team.SlackChannel,
		&i.Team.GoogleGroupEmail,
		&i.Team.AzureGroupID,
		&i.Team.GithubTeamSlug,
		&i.Team.GarRepository,
		&i.Team.CdnBucket,
		&i.Team.DeletedAt,
		&i.Canbedeleted,
	)
	return &i, err
}

const getActiveOrDeletedTeams = `-- name: GetActiveOrDeletedTeams :many
SELECT
    teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug, teams.gar_repository, teams.cdn_bucket, teams.deleted_at,
    (
        COUNT(team_delete_keys.*) > 0
        AND teams.deleted_at IS NULL
    )::BOOL AS canBeDeleted
FROM teams
LEFT JOIN team_delete_keys ON
    team_delete_keys.team_slug = teams.slug
    AND team_delete_keys.confirmed_at IS NOT NULL
GROUP BY teams.slug
ORDER BY teams.slug ASC
LIMIT $2
OFFSET $1
`

type GetActiveOrDeletedTeamsParams struct {
	Offset int32
	Limit  int32
}

type GetActiveOrDeletedTeamsRow struct {
	Team         Team
	Canbedeleted bool
}

// GetActiveOrDeletedTeams returns a slice of teams, including deleted teams.
func (q *Queries) GetActiveOrDeletedTeams(ctx context.Context, arg GetActiveOrDeletedTeamsParams) ([]*GetActiveOrDeletedTeamsRow, error) {
	rows, err := q.db.Query(ctx, getActiveOrDeletedTeams, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetActiveOrDeletedTeamsRow{}
	for rows.Next() {
		var i GetActiveOrDeletedTeamsRow
		if err := rows.Scan(
			&i.Team.Slug,
			&i.Team.Purpose,
			&i.Team.LastSuccessfulSync,
			&i.Team.SlackChannel,
			&i.Team.GoogleGroupEmail,
			&i.Team.AzureGroupID,
			&i.Team.GithubTeamSlug,
			&i.Team.GarRepository,
			&i.Team.CdnBucket,
			&i.Team.DeletedAt,
			&i.Canbedeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveOrDeletedTeamsCount = `-- name: GetActiveOrDeletedTeamsCount :one
SELECT COUNT(teams.*) AS total
FROM teams
`

// GetActiveOrDeletedTeamsCount returns the total number or teams, including deleted teams.
func (q *Queries) GetActiveOrDeletedTeamsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getActiveOrDeletedTeamsCount)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getAllTeamMembers = `-- name: GetAllTeamMembers :many
SELECT users.id, users.email, users.name, users.external_id
FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
JOIN users ON users.id = user_roles.user_id
WHERE
    user_roles.target_team_slug = $1
    AND teams.deleted_at IS NULL
ORDER BY users.name ASC
`

// GetAllTeamMembers returns all team members of a non-deleted team.
func (q *Queries) GetAllTeamMembers(ctx context.Context, teamSlug *slug.Slug) ([]*User, error) {
	rows, err := q.db.Query(ctx, getAllTeamMembers, teamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTeamSlugs = `-- name: GetAllTeamSlugs :many
SELECT teams.slug
FROM teams
WHERE teams.deleted_at IS NULL
ORDER BY teams.slug ASC
`

// GetAllTeamSlugs returns all team slugs in ascending order, excluding deleted teams.
func (q *Queries) GetAllTeamSlugs(ctx context.Context) ([]slug.Slug, error) {
	rows, err := q.db.Query(ctx, getAllTeamSlugs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []slug.Slug{}
	for rows.Next() {
		var slug slug.Slug
		if err := rows.Scan(&slug); err != nil {
			return nil, err
		}
		items = append(items, slug)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamBySlug = `-- name: GetTeamBySlug :one
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug, teams.gar_repository, teams.cdn_bucket, teams.deleted_at
FROM teams
WHERE
    teams.slug = $1
    AND teams.deleted_at IS NULL
`

// GetTeamBySlug returns a team by its slug, excluding deleted teams.
func (q *Queries) GetTeamBySlug(ctx context.Context, argSlug slug.Slug) (*Team, error) {
	row := q.db.QueryRow(ctx, getTeamBySlug, argSlug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.CdnBucket,
		&i.DeletedAt,
	)
	return &i, err
}

const getTeamDeleteKey = `-- name: GetTeamDeleteKey :one
SELECT team_delete_keys.key, team_delete_keys.team_slug, team_delete_keys.created_at, team_delete_keys.created_by, team_delete_keys.confirmed_at
FROM team_delete_keys
WHERE team_delete_keys.key = $1
`

// GetTeamDeleteKey returns a delete key for a team.
func (q *Queries) GetTeamDeleteKey(ctx context.Context, key uuid.UUID) (*TeamDeleteKey, error) {
	row := q.db.QueryRow(ctx, getTeamDeleteKey, key)
	var i TeamDeleteKey
	err := row.Scan(
		&i.Key,
		&i.TeamSlug,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ConfirmedAt,
	)
	return &i, err
}

const getTeamEnvironments = `-- name: GetTeamEnvironments :many
SELECT team_all_environments.team_slug, team_all_environments.environment, team_all_environments.gcp, team_all_environments.gcp_project_id, team_all_environments.id, team_all_environments.slack_alerts_channel
FROM team_all_environments
JOIN teams ON teams.slug = team_all_environments.team_slug
WHERE
    team_all_environments.team_slug = $1
    AND teams.deleted_at IS NULL
ORDER BY team_all_environments.environment ASC
LIMIT $3
OFFSET $2
`

type GetTeamEnvironmentsParams struct {
	TeamSlug slug.Slug
	Offset   int32
	Limit    int32
}

// GetTeamEnvironments returns a slice of team environments, excluding deleted teams.
func (q *Queries) GetTeamEnvironments(ctx context.Context, arg GetTeamEnvironmentsParams) ([]*TeamAllEnvironment, error) {
	rows, err := q.db.Query(ctx, getTeamEnvironments, arg.TeamSlug, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TeamAllEnvironment{}
	for rows.Next() {
		var i TeamAllEnvironment
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Environment,
			&i.Gcp,
			&i.GcpProjectID,
			&i.ID,
			&i.SlackAlertsChannel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamEnvironmentsBySlugsAndEnvNames = `-- name: GetTeamEnvironmentsBySlugsAndEnvNames :many
WITH input AS (
    SELECT
        unnest($1::slug[]) AS team_slug,
        unnest($2::text[]) AS environment
)
SELECT team_all_environments.team_slug, team_all_environments.environment, team_all_environments.gcp, team_all_environments.gcp_project_id, team_all_environments.id, team_all_environments.slack_alerts_channel
FROM team_all_environments
JOIN input ON input.team_slug = team_all_environments.team_slug
JOIN teams ON teams.slug = team_all_environments.team_slug
WHERE
    team_all_environments.environment = input.environment
    AND teams.deleted_at IS NULL
ORDER BY team_all_environments.environment ASC
`

type GetTeamEnvironmentsBySlugsAndEnvNamesParams struct {
	TeamSlugs    []slug.Slug
	Environments []string
}

// GetTeamEnvironmentsBySlugsAndEnvNames returns a slice of team environments for a list of teams/envs, excluding
// deleted teams.
// Input is two arrays of equal length, one for slugs and one for names
func (q *Queries) GetTeamEnvironmentsBySlugsAndEnvNames(ctx context.Context, arg GetTeamEnvironmentsBySlugsAndEnvNamesParams) ([]*TeamAllEnvironment, error) {
	rows, err := q.db.Query(ctx, getTeamEnvironmentsBySlugsAndEnvNames, arg.TeamSlugs, arg.Environments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TeamAllEnvironment{}
	for rows.Next() {
		var i TeamAllEnvironment
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Environment,
			&i.Gcp,
			&i.GcpProjectID,
			&i.ID,
			&i.SlackAlertsChannel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamEnvironmentsCount = `-- name: GetTeamEnvironmentsCount :one
SELECT COUNT(team_all_environments.*) AS total
FROM team_all_environments
JOIN teams ON teams.slug = team_all_environments.team_slug
WHERE
    team_all_environments.team_slug = $1
    AND teams.deleted_at IS NULL
`

// GetTeamEnvironmentsCount returns the total number of team environments, excluding deleted teams.
func (q *Queries) GetTeamEnvironmentsCount(ctx context.Context, teamSlug slug.Slug) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamEnvironmentsCount, teamSlug)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTeamMember = `-- name: GetTeamMember :one
SELECT users.id, users.email, users.name, users.external_id
FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
JOIN users ON users.id = user_roles.user_id
WHERE
    user_roles.target_team_slug = $1::slug
    AND users.id = $2
    AND teams.deleted_at IS NULL
ORDER BY users.name ASC
`

type GetTeamMemberParams struct {
	TeamSlug slug.Slug
	UserID   uuid.UUID
}

// GetTeamMember returns a specific team member of a non-deleted team.
func (q *Queries) GetTeamMember(ctx context.Context, arg GetTeamMemberParams) (*User, error) {
	row := q.db.QueryRow(ctx, getTeamMember, arg.TeamSlug, arg.UserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.ExternalID,
	)
	return &i, err
}

const getTeamMemberOptOuts = `-- name: GetTeamMemberOptOuts :many
SELECT
    reconcilers.name,
    NOT EXISTS(
        SELECT reconciler_name
        FROM reconciler_opt_outs
        WHERE
            reconciler_opt_outs.user_id = $1
            AND reconciler_opt_outs.team_slug = $2
            AND reconciler_opt_outs.reconciler_name = reconcilers.name
    ) AS enabled
FROM reconcilers
WHERE reconcilers.enabled = true
ORDER BY reconcilers.name ASC
`

type GetTeamMemberOptOutsParams struct {
	UserID   uuid.UUID
	TeamSlug slug.Slug
}

type GetTeamMemberOptOutsRow struct {
	Name    string
	Enabled bool
}

// GetTeamMemberOptOuts returns a slice of team member opt-outs.
func (q *Queries) GetTeamMemberOptOuts(ctx context.Context, arg GetTeamMemberOptOutsParams) ([]*GetTeamMemberOptOutsRow, error) {
	rows, err := q.db.Query(ctx, getTeamMemberOptOuts, arg.UserID, arg.TeamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTeamMemberOptOutsRow{}
	for rows.Next() {
		var i GetTeamMemberOptOutsRow
		if err := rows.Scan(&i.Name, &i.Enabled); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT users.id, users.email, users.name, users.external_id
FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
JOIN users ON users.id = user_roles.user_id
WHERE
    user_roles.target_team_slug = $1::slug
    AND teams.deleted_at IS NULL
ORDER BY users.name ASC
LIMIT $3
OFFSET $2
`

type GetTeamMembersParams struct {
	TeamSlug slug.Slug
	Offset   int32
	Limit    int32
}

// GetTeamMembers returns a slice of team members of a non-deleted team.
func (q *Queries) GetTeamMembers(ctx context.Context, arg GetTeamMembersParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, getTeamMembers, arg.TeamSlug, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembersCount = `-- name: GetTeamMembersCount :one
SELECT COUNT(user_roles.*) AS total
FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
WHERE
    user_roles.target_team_slug = $1
    AND teams.deleted_at IS NULL
`

// GetTeamMembersCount returns the total number of team members of a non-deleted team.
func (q *Queries) GetTeamMembersCount(ctx context.Context, teamSlug *slug.Slug) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamMembersCount, teamSlug)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTeams = `-- name: GetTeams :many
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug, teams.gar_repository, teams.cdn_bucket, teams.deleted_at
FROM teams
WHERE teams.deleted_at IS NULL
ORDER BY teams.slug ASC
LIMIT $2
OFFSET $1
`

type GetTeamsParams struct {
	Offset int32
	Limit  int32
}

// GetTeams returns a slice of teams, excluding deleted teams.
func (q *Queries) GetTeams(ctx context.Context, arg GetTeamsParams) ([]*Team, error) {
	rows, err := q.db.Query(ctx, getTeams, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
			&i.GarRepository,
			&i.CdnBucket,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsBySlugs = `-- name: GetTeamsBySlugs :many
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug, teams.gar_repository, teams.cdn_bucket, teams.deleted_at
FROM teams
WHERE
    teams.slug = ANY($1::slug[])
    AND teams.deleted_at IS NULL
ORDER BY teams.slug ASC
`

// GetTeamsBySlugs returns a slice of teams by their slugs, excluding deleted teams.
func (q *Queries) GetTeamsBySlugs(ctx context.Context, slugs []slug.Slug) ([]*Team, error) {
	rows, err := q.db.Query(ctx, getTeamsBySlugs, slugs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
			&i.GarRepository,
			&i.CdnBucket,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsCount = `-- name: GetTeamsCount :one
SELECT COUNT(teams.*) AS total
FROM teams
WHERE teams.deleted_at IS NULL
`

// GetTeamsCount returns the total number or teams, excluding deleted teams.
func (q *Queries) GetTeamsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamsCount)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const removeUserFromTeam = `-- name: RemoveUserFromTeam :exec
DELETE FROM user_roles
WHERE
    user_roles.user_id = $1
    AND user_roles.target_team_slug = $2::slug
`

type RemoveUserFromTeamParams struct {
	UserID   uuid.UUID
	TeamSlug slug.Slug
}

// RemoveUserFromTeam removes a user from a team.
func (q *Queries) RemoveUserFromTeam(ctx context.Context, arg RemoveUserFromTeamParams) error {
	_, err := q.db.Exec(ctx, removeUserFromTeam, arg.UserID, arg.TeamSlug)
	return err
}

const setLastSuccessfulSyncForTeam = `-- name: SetLastSuccessfulSyncForTeam :exec
UPDATE teams
SET teams.last_successful_sync = NOW()
WHERE
    teams.slug = $1
    AND teams.deleted_at IS NULL
`

// SetLastSuccessfulSyncForTeam sets the last successful sync time for a non-deleted team.
func (q *Queries) SetLastSuccessfulSyncForTeam(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, setLastSuccessfulSyncForTeam, argSlug)
	return err
}

const teamExists = `-- name: TeamExists :one
SELECT EXISTS(
    SELECT 1 FROM teams
    WHERE
        teams.slug = $1
        AND teams.deleted_at IS NULL
) AS exists
`

// TeamExists checks if a team exists. Deleted teams are not considered.
func (q *Queries) TeamExists(ctx context.Context, argSlug slug.Slug) (bool, error) {
	row := q.db.QueryRow(ctx, teamExists, argSlug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const teamHasConfirmedDeleteKey = `-- name: TeamHasConfirmedDeleteKey :one
SELECT EXISTS(
    SELECT team_delete_keys.team_slug
    FROM team_delete_keys
    JOIN teams ON teams.slug = team_delete_keys.team_slug
    WHERE
        team_delete_keys.team_slug = $1
        AND team_delete_keys.confirmed_at IS NOT NULL
        AND teams.deleted_at IS NULL
) AS exists
`

// TeamHasConfirmedDeleteKey checks if a team has a confirmed delete key. This means that the team is currently being
// deleted. Already deleted teams are not considered.
func (q *Queries) TeamHasConfirmedDeleteKey(ctx context.Context, argSlug slug.Slug) (bool, error) {
	row := q.db.QueryRow(ctx, teamHasConfirmedDeleteKey, argSlug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE teams
SET
    purpose = COALESCE($1, purpose),
    slack_channel = COALESCE($2, slack_channel)
WHERE
    teams.slug = $3
    AND teams.deleted_at IS NULL
RETURNING slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, cdn_bucket, deleted_at
`

type UpdateTeamParams struct {
	Purpose      *string
	SlackChannel *string
	Slug         slug.Slug
}

// UpdateTeam updates the purpose and slack channel of a non-deleted team.
func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (*Team, error) {
	row := q.db.QueryRow(ctx, updateTeam, arg.Purpose, arg.SlackChannel, arg.Slug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.CdnBucket,
		&i.DeletedAt,
	)
	return &i, err
}

const updateTeamExternalReferences = `-- name: UpdateTeamExternalReferences :one
UPDATE teams
SET
    google_group_email = COALESCE($1, google_group_email),
    azure_group_id =  COALESCE($2, azure_group_id),
    github_team_slug = COALESCE($3, github_team_slug),
    gar_repository = COALESCE($4, gar_repository),
    cdn_bucket = COALESCE($5, cdn_bucket)
WHERE
    teams.slug = $6
    AND teams.deleted_at IS NULL
RETURNING slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, cdn_bucket, deleted_at
`

type UpdateTeamExternalReferencesParams struct {
	GoogleGroupEmail *string
	AzureGroupID     *uuid.UUID
	GithubTeamSlug   *string
	GarRepository    *string
	CdnBucket        *string
	Slug             slug.Slug
}

// UpdateTeamExternalReferences updates the external references of a non-deleted team.
func (q *Queries) UpdateTeamExternalReferences(ctx context.Context, arg UpdateTeamExternalReferencesParams) (*Team, error) {
	row := q.db.QueryRow(ctx, updateTeamExternalReferences,
		arg.GoogleGroupEmail,
		arg.AzureGroupID,
		arg.GithubTeamSlug,
		arg.GarRepository,
		arg.CdnBucket,
		arg.Slug,
	)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.CdnBucket,
		&i.DeletedAt,
	)
	return &i, err
}

const upsertTeamEnvironment = `-- name: UpsertTeamEnvironment :one
INSERT INTO team_environments (team_slug, environment, slack_alerts_channel, gcp_project_id)
VALUES (
    $1,
    $2,
    $3,
    $4
)
ON CONFLICT (team_slug, environment) DO UPDATE
SET
    slack_alerts_channel = COALESCE(EXCLUDED.slack_alerts_channel, team_environments.slack_alerts_channel),
    gcp_project_id = COALESCE(EXCLUDED.gcp_project_id, team_environments.gcp_project_id)
RETURNING id, team_slug, environment, slack_alerts_channel, gcp_project_id
`

type UpsertTeamEnvironmentParams struct {
	TeamSlug           slug.Slug
	Environment        string
	SlackAlertsChannel *string
	GcpProjectID       *string
}

// UpsertTeamEnvironment creates or updates a team environment.
func (q *Queries) UpsertTeamEnvironment(ctx context.Context, arg UpsertTeamEnvironmentParams) (*TeamEnvironment, error) {
	row := q.db.QueryRow(ctx, upsertTeamEnvironment,
		arg.TeamSlug,
		arg.Environment,
		arg.SlackAlertsChannel,
		arg.GcpProjectID,
	)
	var i TeamEnvironment
	err := row.Scan(
		&i.ID,
		&i.TeamSlug,
		&i.Environment,
		&i.SlackAlertsChannel,
		&i.GcpProjectID,
	)
	return &i, err
}

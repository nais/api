// Code generated by sqlc. DO NOT EDIT.
// source: teams.sql

package gensql

import (
	"context"

	"github.com/google/uuid"
	"github.com/nais/api/internal/slug"
)

const confirmTeamDeleteKey = `-- name: ConfirmTeamDeleteKey :exec
UPDATE team_delete_keys
SET confirmed_at = NOW()
WHERE key = $1
`

func (q *Queries) ConfirmTeamDeleteKey(ctx context.Context, key uuid.UUID) error {
	_, err := q.db.Exec(ctx, confirmTeamDeleteKey, key)
	return err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (slug, purpose, slack_channel)
VALUES ($1, $2, $3)
RETURNING slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, deleted_at
`

type CreateTeamParams struct {
	Slug         slug.Slug
	Purpose      string
	SlackChannel string
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (*Team, error) {
	row := q.db.QueryRow(ctx, createTeam, arg.Slug, arg.Purpose, arg.SlackChannel)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.DeletedAt,
	)
	return &i, err
}

const createTeamDeleteKey = `-- name: CreateTeamDeleteKey :one
INSERT INTO team_delete_keys (team_slug, created_by)
VALUES($1, $2)
RETURNING key, team_slug, created_at, created_by, confirmed_at
`

type CreateTeamDeleteKeyParams struct {
	TeamSlug  slug.Slug
	CreatedBy uuid.UUID
}

func (q *Queries) CreateTeamDeleteKey(ctx context.Context, arg CreateTeamDeleteKeyParams) (*TeamDeleteKey, error) {
	row := q.db.QueryRow(ctx, createTeamDeleteKey, arg.TeamSlug, arg.CreatedBy)
	var i TeamDeleteKey
	err := row.Scan(
		&i.Key,
		&i.TeamSlug,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ConfirmedAt,
	)
	return &i, err
}

const deleteTeam = `-- name: DeleteTeam :exec
UPDATE active_and_deleted_teams t
SET deleted_at = NOW()
WHERE
    t.slug = $1
    AND t.deleted_at IS NULL
    AND EXISTS(
        SELECT team_delete_keys.team_slug
        FROM team_delete_keys
        WHERE
            team_delete_keys.team_slug = $1
            AND team_delete_keys.confirmed_at IS NOT NULL
    )
`

func (q *Queries) DeleteTeam(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, deleteTeam, argSlug)
	return err
}

const getActiveAndDeletedTeams = `-- name: GetActiveAndDeletedTeams :many
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug, teams.gar_repository, teams.deleted_at FROM active_and_deleted_teams teams
ORDER BY teams.slug ASC
`

func (q *Queries) GetActiveAndDeletedTeams(ctx context.Context) ([]*ActiveAndDeletedTeam, error) {
	rows, err := q.db.Query(ctx, getActiveAndDeletedTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ActiveAndDeletedTeam{}
	for rows.Next() {
		var i ActiveAndDeletedTeam
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
			&i.GarRepository,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveTeamBySlug = `-- name: GetActiveTeamBySlug :one
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug, teams.gar_repository, teams.deleted_at FROM teams
WHERE teams.slug = $1
`

func (q *Queries) GetActiveTeamBySlug(ctx context.Context, argSlug slug.Slug) (*Team, error) {
	row := q.db.QueryRow(ctx, getActiveTeamBySlug, argSlug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.DeletedAt,
	)
	return &i, err
}

const getAllTeamMembers = `-- name: GetAllTeamMembers :many
SELECT users.id, users.email, users.name, users.external_id FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
JOIN users ON users.id = user_roles.user_id
WHERE user_roles.target_team_slug = $1
ORDER BY users.name ASC
`

func (q *Queries) GetAllTeamMembers(ctx context.Context, teamSlug *slug.Slug) ([]*User, error) {
	rows, err := q.db.Query(ctx, getAllTeamMembers, teamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTeamSlugs = `-- name: GetAllTeamSlugs :many
SELECT teams.slug FROM teams
ORDER BY teams.slug ASC
`

func (q *Queries) GetAllTeamSlugs(ctx context.Context) ([]slug.Slug, error) {
	rows, err := q.db.Query(ctx, getAllTeamSlugs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []slug.Slug{}
	for rows.Next() {
		var slug slug.Slug
		if err := rows.Scan(&slug); err != nil {
			return nil, err
		}
		items = append(items, slug)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedTeams = `-- name: GetPaginatedTeams :many
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug, teams.gar_repository, teams.deleted_at FROM teams
ORDER BY teams.slug ASC
LIMIT $2 OFFSET $1
`

type GetPaginatedTeamsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetPaginatedTeams(ctx context.Context, arg GetPaginatedTeamsParams) ([]*Team, error) {
	rows, err := q.db.Query(ctx, getPaginatedTeams, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
			&i.GarRepository,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamBySlug = `-- name: GetTeamBySlug :one
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug, teams.gar_repository, teams.deleted_at FROM teams
WHERE teams.slug = $1
`

// FIXME: consider removing one of either this one or the one above
func (q *Queries) GetTeamBySlug(ctx context.Context, argSlug slug.Slug) (*Team, error) {
	row := q.db.QueryRow(ctx, getTeamBySlug, argSlug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.DeletedAt,
	)
	return &i, err
}

const getTeamBySlugs = `-- name: GetTeamBySlugs :many
SELECT slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, deleted_at FROM teams
WHERE slug = ANY($1::slug[])
ORDER BY slug ASC
`

func (q *Queries) GetTeamBySlugs(ctx context.Context, slugs []slug.Slug) ([]*Team, error) {
	rows, err := q.db.Query(ctx, getTeamBySlugs, slugs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
			&i.GarRepository,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamDeleteKey = `-- name: GetTeamDeleteKey :one
SELECT key, team_slug, created_at, created_by, confirmed_at FROM team_delete_keys
WHERE key = $1
`

func (q *Queries) GetTeamDeleteKey(ctx context.Context, key uuid.UUID) (*TeamDeleteKey, error) {
	row := q.db.QueryRow(ctx, getTeamDeleteKey, key)
	var i TeamDeleteKey
	err := row.Scan(
		&i.Key,
		&i.TeamSlug,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ConfirmedAt,
	)
	return &i, err
}

const getTeamEnvironments = `-- name: GetTeamEnvironments :many
SELECT team_slug, environment, gcp, gcp_project_id, id, slack_alerts_channel
FROM team_all_environments
WHERE team_slug = $1
ORDER BY environment ASC
LIMIT $3 OFFSET $2
`

type GetTeamEnvironmentsParams struct {
	TeamSlug slug.Slug
	Offset   int32
	Limit    int32
}

func (q *Queries) GetTeamEnvironments(ctx context.Context, arg GetTeamEnvironmentsParams) ([]*TeamAllEnvironment, error) {
	rows, err := q.db.Query(ctx, getTeamEnvironments, arg.TeamSlug, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TeamAllEnvironment{}
	for rows.Next() {
		var i TeamAllEnvironment
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Environment,
			&i.Gcp,
			&i.GcpProjectID,
			&i.ID,
			&i.SlackAlertsChannel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamEnvironmentsBySlugsAndEnvNames = `-- name: GetTeamEnvironmentsBySlugsAndEnvNames :many
WITH input AS (
    SELECT
        unnest($1::slug[]) AS team_slug,
        unnest($2::text[]) AS environment
)
SELECT team_all_environments.team_slug, team_all_environments.environment, team_all_environments.gcp, team_all_environments.gcp_project_id, team_all_environments.id, team_all_environments.slack_alerts_channel
FROM team_all_environments
JOIN input ON input.team_slug = team_all_environments.team_slug
JOIN teams ON teams.slug = team_all_environments.team_slug
WHERE team_all_environments.environment = input.environment
ORDER BY team_all_environments.environment ASC
`

type GetTeamEnvironmentsBySlugsAndEnvNamesParams struct {
	TeamSlugs    []slug.Slug
	Environments []string
}

// Input is two arrays of equal length, one for slugs and one for names
func (q *Queries) GetTeamEnvironmentsBySlugsAndEnvNames(ctx context.Context, arg GetTeamEnvironmentsBySlugsAndEnvNamesParams) ([]*TeamAllEnvironment, error) {
	rows, err := q.db.Query(ctx, getTeamEnvironmentsBySlugsAndEnvNames, arg.TeamSlugs, arg.Environments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TeamAllEnvironment{}
	for rows.Next() {
		var i TeamAllEnvironment
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Environment,
			&i.Gcp,
			&i.GcpProjectID,
			&i.ID,
			&i.SlackAlertsChannel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamEnvironmentsCount = `-- name: GetTeamEnvironmentsCount :one
SELECT COUNT(*) as total
FROM team_all_environments
WHERE team_slug = $1
`

func (q *Queries) GetTeamEnvironmentsCount(ctx context.Context, teamSlug slug.Slug) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamEnvironmentsCount, teamSlug)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTeamMember = `-- name: GetTeamMember :one
SELECT users.id, users.email, users.name, users.external_id FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
JOIN users ON users.id = user_roles.user_id
WHERE user_roles.target_team_slug = $1::slug AND users.id = $2
ORDER BY users.name ASC
`

type GetTeamMemberParams struct {
	TeamSlug slug.Slug
	UserID   uuid.UUID
}

func (q *Queries) GetTeamMember(ctx context.Context, arg GetTeamMemberParams) (*User, error) {
	row := q.db.QueryRow(ctx, getTeamMember, arg.TeamSlug, arg.UserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.ExternalID,
	)
	return &i, err
}

const getTeamMemberOptOuts = `-- name: GetTeamMemberOptOuts :many
SELECT
    reconcilers.name,
    NOT EXISTS(
        SELECT reconciler_name FROM reconciler_opt_outs
        WHERE user_id = $1 AND team_slug = $2 AND reconciler_name = reconcilers.name
    ) AS enabled
FROM reconcilers
WHERE reconcilers.enabled = true
ORDER BY reconcilers.name ASC
`

type GetTeamMemberOptOutsParams struct {
	UserID   uuid.UUID
	TeamSlug slug.Slug
}

type GetTeamMemberOptOutsRow struct {
	Name    string
	Enabled bool
}

func (q *Queries) GetTeamMemberOptOuts(ctx context.Context, arg GetTeamMemberOptOutsParams) ([]*GetTeamMemberOptOutsRow, error) {
	rows, err := q.db.Query(ctx, getTeamMemberOptOuts, arg.UserID, arg.TeamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTeamMemberOptOutsRow{}
	for rows.Next() {
		var i GetTeamMemberOptOutsRow
		if err := rows.Scan(&i.Name, &i.Enabled); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT users.id, users.email, users.name, users.external_id FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
JOIN users ON users.id = user_roles.user_id
WHERE user_roles.target_team_slug = $1::slug
ORDER BY users.name ASC LIMIT $3 OFFSET $2
`

type GetTeamMembersParams struct {
	TeamSlug slug.Slug
	Offset   int32
	Limit    int32
}

func (q *Queries) GetTeamMembers(ctx context.Context, arg GetTeamMembersParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, getTeamMembers, arg.TeamSlug, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembersCount = `-- name: GetTeamMembersCount :one
SELECT COUNT(*) FROM user_roles
WHERE user_roles.target_team_slug = $1
`

func (q *Queries) GetTeamMembersCount(ctx context.Context, teamSlug *slug.Slug) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamMembersCount, teamSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTeamMembersForReconciler = `-- name: GetTeamMembersForReconciler :many
SELECT users.id, users.email, users.name, users.external_id FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
JOIN users ON users.id = user_roles.user_id
WHERE
    user_roles.target_team_slug = $1::slug
    AND NOT EXISTS (
        SELECT roo.user_id
        FROM reconciler_opt_outs AS roo
        WHERE
            roo.team_slug = $1
            AND roo.reconciler_name = $2
            AND roo.user_id = users.id
    )
ORDER BY users.name ASC
`

type GetTeamMembersForReconcilerParams struct {
	TeamSlug       slug.Slug
	ReconcilerName string
}

func (q *Queries) GetTeamMembersForReconciler(ctx context.Context, arg GetTeamMembersForReconcilerParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, getTeamMembersForReconciler, arg.TeamSlug, arg.ReconcilerName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeams = `-- name: GetTeams :many
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug, teams.gar_repository, teams.deleted_at FROM teams
ORDER BY teams.slug ASC
`

func (q *Queries) GetTeams(ctx context.Context) ([]*Team, error) {
	rows, err := q.db.Query(ctx, getTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
			&i.GarRepository,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsCount = `-- name: GetTeamsCount :one
SELECT COUNT(*) as total
FROM teams
`

func (q *Queries) GetTeamsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamsCount)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const removeUserFromTeam = `-- name: RemoveUserFromTeam :exec
DELETE FROM user_roles
WHERE user_id = $1 AND target_team_slug = $2::slug
`

type RemoveUserFromTeamParams struct {
	UserID   uuid.UUID
	TeamSlug slug.Slug
}

func (q *Queries) RemoveUserFromTeam(ctx context.Context, arg RemoveUserFromTeamParams) error {
	_, err := q.db.Exec(ctx, removeUserFromTeam, arg.UserID, arg.TeamSlug)
	return err
}

const setLastSuccessfulSyncForTeam = `-- name: SetLastSuccessfulSyncForTeam :exec
UPDATE teams SET last_successful_sync = NOW()
WHERE slug = $1
`

func (q *Queries) SetLastSuccessfulSyncForTeam(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, setLastSuccessfulSyncForTeam, argSlug)
	return err
}

const teamExists = `-- name: TeamExists :one
SELECT EXISTS(
    SELECT 1 FROM teams
    WHERE slug = $1
) AS exists
`

func (q *Queries) TeamExists(ctx context.Context, argSlug slug.Slug) (bool, error) {
	row := q.db.QueryRow(ctx, teamExists, argSlug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE teams
SET purpose = COALESCE($1, purpose),
    slack_channel = COALESCE($2, slack_channel)
WHERE slug = $3
RETURNING slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, deleted_at
`

type UpdateTeamParams struct {
	Purpose      *string
	SlackChannel *string
	Slug         slug.Slug
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (*Team, error) {
	row := q.db.QueryRow(ctx, updateTeam, arg.Purpose, arg.SlackChannel, arg.Slug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.DeletedAt,
	)
	return &i, err
}

const updateTeamExternalReferences = `-- name: UpdateTeamExternalReferences :one
UPDATE teams
SET google_group_email = COALESCE($1, google_group_email),
    azure_group_id =  COALESCE($2, azure_group_id),
    github_team_slug = COALESCE($3, github_team_slug),
    gar_repository = COALESCE($4, gar_repository)
WHERE slug = $5
RETURNING slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug, gar_repository, deleted_at
`

type UpdateTeamExternalReferencesParams struct {
	GoogleGroupEmail *string
	AzureGroupID     *uuid.UUID
	GithubTeamSlug   *string
	GarRepository    *string
	Slug             slug.Slug
}

func (q *Queries) UpdateTeamExternalReferences(ctx context.Context, arg UpdateTeamExternalReferencesParams) (*Team, error) {
	row := q.db.QueryRow(ctx, updateTeamExternalReferences,
		arg.GoogleGroupEmail,
		arg.AzureGroupID,
		arg.GithubTeamSlug,
		arg.GarRepository,
		arg.Slug,
	)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
		&i.GarRepository,
		&i.DeletedAt,
	)
	return &i, err
}

const upsertTeamEnvironment = `-- name: UpsertTeamEnvironment :one
INSERT INTO team_environments (team_slug, environment, slack_alerts_channel, gcp_project_id)
VALUES (
    $1,
    $2,
    $3,
    $4
)
ON CONFLICT (team_slug, environment) DO UPDATE
SET
    slack_alerts_channel = COALESCE(EXCLUDED.slack_alerts_channel, team_environments.slack_alerts_channel),
    gcp_project_id = COALESCE(EXCLUDED.gcp_project_id, team_environments.gcp_project_id)
RETURNING id, team_slug, environment, slack_alerts_channel, gcp_project_id
`

type UpsertTeamEnvironmentParams struct {
	TeamSlug           slug.Slug
	Environment        string
	SlackAlertsChannel *string
	GcpProjectID       *string
}

func (q *Queries) UpsertTeamEnvironment(ctx context.Context, arg UpsertTeamEnvironmentParams) (*TeamEnvironment, error) {
	row := q.db.QueryRow(ctx, upsertTeamEnvironment,
		arg.TeamSlug,
		arg.Environment,
		arg.SlackAlertsChannel,
		arg.GcpProjectID,
	)
	var i TeamEnvironment
	err := row.Scan(
		&i.ID,
		&i.TeamSlug,
		&i.Environment,
		&i.SlackAlertsChannel,
		&i.GcpProjectID,
	)
	return &i, err
}

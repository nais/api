// Code generated by sqlc. DO NOT EDIT.
// source: teams.sql

package gensql

import (
	"context"

	"github.com/google/uuid"
	"github.com/nais/api/internal/slug"
)

const confirmTeamDeleteKey = `-- name: ConfirmTeamDeleteKey :exec
UPDATE team_delete_keys
SET confirmed_at = NOW()
WHERE key = $1
`

func (q *Queries) ConfirmTeamDeleteKey(ctx context.Context, key uuid.UUID) error {
	_, err := q.db.Exec(ctx, confirmTeamDeleteKey, key)
	return err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (slug, purpose, slack_channel)
VALUES ($1, $2, $3)
RETURNING slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug
`

type CreateTeamParams struct {
	Slug         slug.Slug
	Purpose      string
	SlackChannel string
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (*Team, error) {
	row := q.db.QueryRow(ctx, createTeam, arg.Slug, arg.Purpose, arg.SlackChannel)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
	)
	return &i, err
}

const createTeamDeleteKey = `-- name: CreateTeamDeleteKey :one
INSERT INTO team_delete_keys (team_slug, created_by)
VALUES($1, $2)
RETURNING key, team_slug, created_at, created_by, confirmed_at
`

type CreateTeamDeleteKeyParams struct {
	TeamSlug  slug.Slug
	CreatedBy uuid.UUID
}

func (q *Queries) CreateTeamDeleteKey(ctx context.Context, arg CreateTeamDeleteKeyParams) (*TeamDeleteKey, error) {
	row := q.db.QueryRow(ctx, createTeamDeleteKey, arg.TeamSlug, arg.CreatedBy)
	var i TeamDeleteKey
	err := row.Scan(
		&i.Key,
		&i.TeamSlug,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ConfirmedAt,
	)
	return &i, err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM teams
WHERE slug = $1
`

func (q *Queries) DeleteTeam(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, deleteTeam, argSlug)
	return err
}

const getActiveTeamBySlug = `-- name: GetActiveTeamBySlug :one
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug FROM teams
WHERE
    teams.slug = $1
    AND NOT EXISTS (
        SELECT team_delete_keys.team_slug
        FROM team_delete_keys
        WHERE
            team_delete_keys.team_slug = $1
            AND team_delete_keys.confirmed_at IS NOT NULL
    )
`

func (q *Queries) GetActiveTeamBySlug(ctx context.Context, argSlug slug.Slug) (*Team, error) {
	row := q.db.QueryRow(ctx, getActiveTeamBySlug, argSlug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
	)
	return &i, err
}

const getActiveTeams = `-- name: GetActiveTeams :many
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug FROM teams
WHERE NOT EXISTS (
    SELECT team_delete_keys.team_slug
    FROM team_delete_keys
    WHERE
        team_delete_keys.team_slug = teams.slug
        AND team_delete_keys.confirmed_at IS NOT NULL
)
ORDER BY teams.slug ASC
`

func (q *Queries) GetActiveTeams(ctx context.Context) ([]*Team, error) {
	rows, err := q.db.Query(ctx, getActiveTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTeamMembers = `-- name: GetAllTeamMembers :many
SELECT users.id, users.email, users.name, users.external_id FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
JOIN users ON users.id = user_roles.user_id
WHERE user_roles.target_team_slug = $1
ORDER BY users.name ASC
`

func (q *Queries) GetAllTeamMembers(ctx context.Context, teamSlug *slug.Slug) ([]*User, error) {
	rows, err := q.db.Query(ctx, getAllTeamMembers, teamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlackAlertsChannels = `-- name: GetSlackAlertsChannels :many
SELECT team_slug, environment, channel_name FROM slack_alerts_channels
WHERE team_slug = $1
ORDER BY environment ASC
`

func (q *Queries) GetSlackAlertsChannels(ctx context.Context, teamSlug slug.Slug) ([]*SlackAlertsChannel, error) {
	rows, err := q.db.Query(ctx, getSlackAlertsChannels, teamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SlackAlertsChannel{}
	for rows.Next() {
		var i SlackAlertsChannel
		if err := rows.Scan(&i.TeamSlug, &i.Environment, &i.ChannelName); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamBySlug = `-- name: GetTeamBySlug :one
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug FROM teams
WHERE teams.slug = $1
`

func (q *Queries) GetTeamBySlug(ctx context.Context, argSlug slug.Slug) (*Team, error) {
	row := q.db.QueryRow(ctx, getTeamBySlug, argSlug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
	)
	return &i, err
}

const getTeamDeleteKey = `-- name: GetTeamDeleteKey :one
SELECT key, team_slug, created_at, created_by, confirmed_at FROM team_delete_keys
WHERE key = $1
`

func (q *Queries) GetTeamDeleteKey(ctx context.Context, key uuid.UUID) (*TeamDeleteKey, error) {
	row := q.db.QueryRow(ctx, getTeamDeleteKey, key)
	var i TeamDeleteKey
	err := row.Scan(
		&i.Key,
		&i.TeamSlug,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ConfirmedAt,
	)
	return &i, err
}

const getTeamEnvironments = `-- name: GetTeamEnvironments :many
SELECT team_environments.id, team_environments.team_slug, team_environments.environment, team_environments.namespace, team_environments.gcp_project_id
FROM team_environments
WHERE team_environments.team_slug = $1
ORDER BY team_environments.environment ASC
LIMIT $3 OFFSET $2
`

type GetTeamEnvironmentsParams struct {
	TeamSlug slug.Slug
	Offset   int32
	Limit    int32
}

func (q *Queries) GetTeamEnvironments(ctx context.Context, arg GetTeamEnvironmentsParams) ([]*TeamEnvironment, error) {
	rows, err := q.db.Query(ctx, getTeamEnvironments, arg.TeamSlug, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TeamEnvironment{}
	for rows.Next() {
		var i TeamEnvironment
		if err := rows.Scan(
			&i.ID,
			&i.TeamSlug,
			&i.Environment,
			&i.Namespace,
			&i.GcpProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamEnvironmentsCount = `-- name: GetTeamEnvironmentsCount :one
SELECT COUNT(*) as total
FROM team_environments
WHERE team_slug = $1
`

func (q *Queries) GetTeamEnvironmentsCount(ctx context.Context, teamSlug slug.Slug) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamEnvironmentsCount, teamSlug)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTeamMember = `-- name: GetTeamMember :one
SELECT users.id, users.email, users.name, users.external_id FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
JOIN users ON users.id = user_roles.user_id
WHERE user_roles.target_team_slug = $1::slug AND users.id = $2
ORDER BY users.name ASC
`

type GetTeamMemberParams struct {
	TeamSlug slug.Slug
	UserID   uuid.UUID
}

func (q *Queries) GetTeamMember(ctx context.Context, arg GetTeamMemberParams) (*User, error) {
	row := q.db.QueryRow(ctx, getTeamMember, arg.TeamSlug, arg.UserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.ExternalID,
	)
	return &i, err
}

const getTeamMemberOptOuts = `-- name: GetTeamMemberOptOuts :many
SELECT
    reconcilers.name,
    NOT EXISTS(
        SELECT reconciler_name FROM reconciler_opt_outs
        WHERE user_id = $1 AND team_slug = $2 AND reconciler_name = reconcilers.name
    ) AS enabled
FROM reconcilers
WHERE reconcilers.enabled = true
ORDER BY reconcilers.name ASC
`

type GetTeamMemberOptOutsParams struct {
	UserID   uuid.UUID
	TeamSlug slug.Slug
}

type GetTeamMemberOptOutsRow struct {
	Name    string
	Enabled bool
}

func (q *Queries) GetTeamMemberOptOuts(ctx context.Context, arg GetTeamMemberOptOutsParams) ([]*GetTeamMemberOptOutsRow, error) {
	rows, err := q.db.Query(ctx, getTeamMemberOptOuts, arg.UserID, arg.TeamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTeamMemberOptOutsRow{}
	for rows.Next() {
		var i GetTeamMemberOptOutsRow
		if err := rows.Scan(&i.Name, &i.Enabled); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT users.id, users.email, users.name, users.external_id FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
JOIN users ON users.id = user_roles.user_id
WHERE user_roles.target_team_slug = $1::slug
ORDER BY users.name ASC LIMIT $3 OFFSET $2
`

type GetTeamMembersParams struct {
	TeamSlug slug.Slug
	Offset   int32
	Limit    int32
}

func (q *Queries) GetTeamMembers(ctx context.Context, arg GetTeamMembersParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, getTeamMembers, arg.TeamSlug, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembersCount = `-- name: GetTeamMembersCount :one
SELECT COUNT(*) FROM user_roles
WHERE user_roles.target_team_slug = $1
`

func (q *Queries) GetTeamMembersCount(ctx context.Context, teamSlug *slug.Slug) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamMembersCount, teamSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTeamMembersForReconciler = `-- name: GetTeamMembersForReconciler :many
SELECT users.id, users.email, users.name, users.external_id FROM user_roles
JOIN teams ON teams.slug = user_roles.target_team_slug
JOIN users ON users.id = user_roles.user_id
WHERE
    user_roles.target_team_slug = $1::slug
    AND NOT EXISTS (
        SELECT roo.user_id
        FROM reconciler_opt_outs AS roo
        WHERE
            roo.team_slug = $1
            AND roo.reconciler_name = $2
            AND roo.user_id = users.id
    )
ORDER BY users.name ASC
`

type GetTeamMembersForReconcilerParams struct {
	TeamSlug       slug.Slug
	ReconcilerName string
}

func (q *Queries) GetTeamMembersForReconciler(ctx context.Context, arg GetTeamMembersForReconcilerParams) ([]*User, error) {
	rows, err := q.db.Query(ctx, getTeamMembersForReconciler, arg.TeamSlug, arg.ReconcilerName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeams = `-- name: GetTeams :many
SELECT teams.slug, teams.purpose, teams.last_successful_sync, teams.slack_channel, teams.google_group_email, teams.azure_group_id, teams.github_team_slug FROM teams
ORDER BY teams.slug ASC
LIMIT $2 OFFSET $1
`

type GetTeamsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetTeams(ctx context.Context, arg GetTeamsParams) ([]*Team, error) {
	rows, err := q.db.Query(ctx, getTeams, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsCount = `-- name: GetTeamsCount :one
SELECT COUNT(*) as total FROM teams
`

func (q *Queries) GetTeamsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamsCount)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const removeSlackAlertsChannel = `-- name: RemoveSlackAlertsChannel :exec
DELETE FROM slack_alerts_channels
WHERE team_slug = $1 AND environment = $2
`

type RemoveSlackAlertsChannelParams struct {
	TeamSlug    slug.Slug
	Environment string
}

func (q *Queries) RemoveSlackAlertsChannel(ctx context.Context, arg RemoveSlackAlertsChannelParams) error {
	_, err := q.db.Exec(ctx, removeSlackAlertsChannel, arg.TeamSlug, arg.Environment)
	return err
}

const removeUserFromTeam = `-- name: RemoveUserFromTeam :exec
DELETE FROM user_roles
WHERE user_id = $1 AND target_team_slug = $2::slug
`

type RemoveUserFromTeamParams struct {
	UserID   uuid.UUID
	TeamSlug slug.Slug
}

func (q *Queries) RemoveUserFromTeam(ctx context.Context, arg RemoveUserFromTeamParams) error {
	_, err := q.db.Exec(ctx, removeUserFromTeam, arg.UserID, arg.TeamSlug)
	return err
}

const searchTeams = `-- name: SearchTeams :many
SELECT slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug
FROM teams
WHERE levenshtein($1::text, slug) >= 0
ORDER BY levenshtein($1::text, slug) ASC
LIMIT $2
`

type SearchTeamsParams struct {
	SlugMatch string
	Limit     int32
}

func (q *Queries) SearchTeams(ctx context.Context, arg SearchTeamsParams) ([]*Team, error) {
	rows, err := q.db.Query(ctx, searchTeams, arg.SlugMatch, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Slug,
			&i.Purpose,
			&i.LastSuccessfulSync,
			&i.SlackChannel,
			&i.GoogleGroupEmail,
			&i.AzureGroupID,
			&i.GithubTeamSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setLastSuccessfulSyncForTeam = `-- name: SetLastSuccessfulSyncForTeam :exec
UPDATE teams SET last_successful_sync = NOW()
WHERE slug = $1
`

func (q *Queries) SetLastSuccessfulSyncForTeam(ctx context.Context, argSlug slug.Slug) error {
	_, err := q.db.Exec(ctx, setLastSuccessfulSyncForTeam, argSlug)
	return err
}

const setSlackAlertsChannel = `-- name: SetSlackAlertsChannel :exec
INSERT INTO slack_alerts_channels (team_slug, environment, channel_name)
VALUES ($1, $2, $3)
ON CONFLICT (team_slug, environment) DO
    UPDATE SET channel_name = $3
`

type SetSlackAlertsChannelParams struct {
	TeamSlug    slug.Slug
	Environment string
	ChannelName string
}

func (q *Queries) SetSlackAlertsChannel(ctx context.Context, arg SetSlackAlertsChannelParams) error {
	_, err := q.db.Exec(ctx, setSlackAlertsChannel, arg.TeamSlug, arg.Environment, arg.ChannelName)
	return err
}

const teamExists = `-- name: TeamExists :one
SELECT EXISTS(
    SELECT 1 FROM teams
    WHERE slug = $1
) AS exists
`

func (q *Queries) TeamExists(ctx context.Context, argSlug slug.Slug) (bool, error) {
	row := q.db.QueryRow(ctx, teamExists, argSlug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE teams
SET purpose = COALESCE($1, purpose),
    slack_channel = COALESCE($2, slack_channel)
WHERE slug = $3
RETURNING slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug
`

type UpdateTeamParams struct {
	Purpose      *string
	SlackChannel *string
	Slug         slug.Slug
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (*Team, error) {
	row := q.db.QueryRow(ctx, updateTeam, arg.Purpose, arg.SlackChannel, arg.Slug)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
	)
	return &i, err
}

const updateTeamExternalReferences = `-- name: UpdateTeamExternalReferences :one
UPDATE teams
SET google_group_email = COALESCE($1, google_group_email),
    azure_group_id =  COALESCE($2, azure_group_id),
    github_team_slug = COALESCE($3, github_team_slug)
WHERE slug = $4
RETURNING slug, purpose, last_successful_sync, slack_channel, google_group_email, azure_group_id, github_team_slug
`

type UpdateTeamExternalReferencesParams struct {
	GoogleGroupEmail *string
	AzureGroupID     *uuid.UUID
	GithubTeamSlug   *string
	Slug             slug.Slug
}

func (q *Queries) UpdateTeamExternalReferences(ctx context.Context, arg UpdateTeamExternalReferencesParams) (*Team, error) {
	row := q.db.QueryRow(ctx, updateTeamExternalReferences,
		arg.GoogleGroupEmail,
		arg.AzureGroupID,
		arg.GithubTeamSlug,
		arg.Slug,
	)
	var i Team
	err := row.Scan(
		&i.Slug,
		&i.Purpose,
		&i.LastSuccessfulSync,
		&i.SlackChannel,
		&i.GoogleGroupEmail,
		&i.AzureGroupID,
		&i.GithubTeamSlug,
	)
	return &i, err
}

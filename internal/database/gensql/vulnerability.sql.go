// Code generated by sqlc. DO NOT EDIT.
// source: vulnerability.sql

package gensql

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/api/internal/slug"
)

const createDependencytrackProject = `-- name: CreateDependencytrackProject :exec
INSERT INTO dependencytrack_projects (environment, team_slug, app, projectId)
VALUES ($1, $2, $3, $4)
    ON CONFLICT ON CONSTRAINT dependencytrack_projects_key DO NOTHING
`

type CreateDependencytrackProjectParams struct {
	Environment string
	TeamSlug    slug.Slug
	App         string
	Projectid   uuid.UUID
}

func (q *Queries) CreateDependencytrackProject(ctx context.Context, arg CreateDependencytrackProjectParams) error {
	_, err := q.db.Exec(ctx, createDependencytrackProject,
		arg.Environment,
		arg.TeamSlug,
		arg.App,
		arg.Projectid,
	)
	return err
}

const dailyVulnerabilityForTeam = `-- name: DailyVulnerabilityForTeam :many
SELECT
    sum(critical) AS critical,
    sum(high) AS high,
    sum(medium) AS medium,
    sum(low) AS low,
    sum(unassigned) AS unassigned,
    sum(risk_score) AS risk_score,
    date
FROM
    vulnerability_metrics
WHERE
    date >= $1::date
  AND date <= $2::date
  AND dependencytrack_project_id in (SELECT projectId
FROM "dependencytrack_projects"
WHERE CAST("team_slug" AS text) = $3::slug)
GROUP BY
    date
ORDER BY
    date ASC
`

type DailyVulnerabilityForTeamParams struct {
	FromDate pgtype.Date
	ToDate   pgtype.Date
	TeamSlug slug.Slug
}

type DailyVulnerabilityForTeamRow struct {
	Critical   int64
	High       int64
	Medium     int64
	Low        int64
	Unassigned int64
	RiskScore  int64
	Date       pgtype.Date
}

func (q *Queries) DailyVulnerabilityForTeam(ctx context.Context, arg DailyVulnerabilityForTeamParams) ([]*DailyVulnerabilityForTeamRow, error) {
	rows, err := q.db.Query(ctx, dailyVulnerabilityForTeam, arg.FromDate, arg.ToDate, arg.TeamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyVulnerabilityForTeamRow{}
	for rows.Next() {
		var i DailyVulnerabilityForTeamRow
		if err := rows.Scan(
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vulnerabilityMetricsDateRangeForTeam = `-- name: VulnerabilityMetricsDateRangeForTeam :one
SELECT
    MIN(date)::date AS from_date,
    MAX(date)::date AS to_date
FROM
    vulnerability_metrics
WHERE dependencytrack_project_id in (SELECT projectId
FROM "dependencytrack_projects"
WHERE CAST("team_slug" AS text) = $1::slug)
`

type VulnerabilityMetricsDateRangeForTeamRow struct {
	FromDate pgtype.Date
	ToDate   pgtype.Date
}

// VulnerabilityMetricsDateRangeForTeam will return the first and last date that has a metrics.
func (q *Queries) VulnerabilityMetricsDateRangeForTeam(ctx context.Context, teamSlug slug.Slug) (*VulnerabilityMetricsDateRangeForTeamRow, error) {
	row := q.db.QueryRow(ctx, vulnerabilityMetricsDateRangeForTeam, teamSlug)
	var i VulnerabilityMetricsDateRangeForTeamRow
	err := row.Scan(&i.FromDate, &i.ToDate)
	return &i, err
}

// Code generated by sqlc. DO NOT EDIT.
// source: vulnerability.sql

package gensql

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/api/internal/slug"
)

const createDependencytrackProject = `-- name: CreateDependencytrackProject :exec
INSERT INTO dependencytrack_projects (id, environment, team_slug, workload, workload_type)
VALUES ($1, $2, $3, $4, $5)
    ON CONFLICT DO NOTHING
`

type CreateDependencytrackProjectParams struct {
	ID           uuid.UUID
	Environment  string
	TeamSlug     slug.Slug
	Workload     string
	WorkloadType WorkloadType
}

func (q *Queries) CreateDependencytrackProject(ctx context.Context, arg CreateDependencytrackProjectParams) error {
	_, err := q.db.Exec(ctx, createDependencytrackProject,
		arg.ID,
		arg.Environment,
		arg.TeamSlug,
		arg.Workload,
		arg.WorkloadType,
	)
	return err
}

const dailyVulnerabilityForTeam = `-- name: DailyVulnerabilityForTeam :many
SELECT
    sum(critical) AS critical,
    sum(high) AS high,
    sum(medium) AS medium,
    sum(low) AS low,
    sum(unassigned) AS unassigned,
    sum(risk_score) AS risk_score,
    COUNT(DISTINCT dependencytrack_project_id) AS count,
    date
FROM
    vulnerability_metrics
WHERE
    date >= $1::date
    AND date <= $2::date
    AND dependencytrack_project_id IN (
        SELECT id
        FROM dependencytrack_projects
        WHERE team_slug = $3
    )
GROUP BY
    date
ORDER BY
    date ASC
`

type DailyVulnerabilityForTeamParams struct {
	FromDate pgtype.Date
	ToDate   pgtype.Date
	TeamSlug slug.Slug
}

type DailyVulnerabilityForTeamRow struct {
	Critical   int64
	High       int64
	Medium     int64
	Low        int64
	Unassigned int64
	RiskScore  int64
	Count      int64
	Date       pgtype.Date
}

// DailyVulnerabilityForTeam will return the metrics for the given team from first to last date.
func (q *Queries) DailyVulnerabilityForTeam(ctx context.Context, arg DailyVulnerabilityForTeamParams) ([]*DailyVulnerabilityForTeamRow, error) {
	rows, err := q.db.Query(ctx, dailyVulnerabilityForTeam, arg.FromDate, arg.ToDate, arg.TeamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyVulnerabilityForTeamRow{}
	for rows.Next() {
		var i DailyVulnerabilityForTeamRow
		if err := rows.Scan(
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.Count,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dailyVulnerabilityForTeamAndEnvironment = `-- name: DailyVulnerabilityForTeamAndEnvironment :many
SELECT
    sum(critical) AS critical,
    sum(high) AS high,
    sum(medium) AS medium,
    sum(low) AS low,
    sum(unassigned) AS unassigned,
    sum(risk_score) AS risk_score,
    COUNT(DISTINCT dependencytrack_project_id) AS count,
    date
FROM
    vulnerability_metrics
WHERE
    date >= $1::date
    AND date <= $2::date
    AND dependencytrack_project_id IN (
        SELECT id
        FROM dependencytrack_projects
        WHERE
            team_slug = $3
            AND environment = $4
    )
GROUP BY
    date
ORDER BY
    date ASC
`

type DailyVulnerabilityForTeamAndEnvironmentParams struct {
	FromDate    pgtype.Date
	ToDate      pgtype.Date
	TeamSlug    slug.Slug
	Environment string
}

type DailyVulnerabilityForTeamAndEnvironmentRow struct {
	Critical   int64
	High       int64
	Medium     int64
	Low        int64
	Unassigned int64
	RiskScore  int64
	Count      int64
	Date       pgtype.Date
}

// DailyVulnerabilityForTeamAndEnvironment will return the metrics for the given team and environment from first to last date.
func (q *Queries) DailyVulnerabilityForTeamAndEnvironment(ctx context.Context, arg DailyVulnerabilityForTeamAndEnvironmentParams) ([]*DailyVulnerabilityForTeamAndEnvironmentRow, error) {
	rows, err := q.db.Query(ctx, dailyVulnerabilityForTeamAndEnvironment,
		arg.FromDate,
		arg.ToDate,
		arg.TeamSlug,
		arg.Environment,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyVulnerabilityForTeamAndEnvironmentRow{}
	for rows.Next() {
		var i DailyVulnerabilityForTeamAndEnvironmentRow
		if err := rows.Scan(
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.Count,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vulnerabilityMetricsMaxDate = `-- name: VulnerabilityMetricsMaxDate :one
SELECT
    MAX(date)::date AS to_date
FROM
    vulnerability_metrics
WHERE
    dependencytrack_project_id = ANY(
        SELECT id
        FROM dependencytrack_projects
        WHERE
            environment = $1
            AND workload = $2
            AND workload_type = $3
            AND team_slug = $4
    )
`

type VulnerabilityMetricsMaxDateParams struct {
	Environment  string
	Workload     string
	WorkloadType WorkloadType
	TeamSlug     slug.Slug
}

// VulnerabilityMetricsMaxDate will return the last date that has a metrics for the given project id.
func (q *Queries) VulnerabilityMetricsMaxDate(ctx context.Context, arg VulnerabilityMetricsMaxDateParams) (pgtype.Date, error) {
	row := q.db.QueryRow(ctx, vulnerabilityMetricsMaxDate,
		arg.Environment,
		arg.Workload,
		arg.WorkloadType,
		arg.TeamSlug,
	)
	var to_date pgtype.Date
	err := row.Scan(&to_date)
	return to_date, err
}

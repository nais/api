// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: vulnerability.sql

package gensql

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/api/internal/slug"
)

const createDependencytrackProject = `-- name: CreateDependencytrackProject :exec
INSERT INTO dependencytrack_projects (environment, team_slug, app, projectId)
VALUES ($1, $2, $3, $4)
    ON CONFLICT ON CONSTRAINT dependencytrack_projects DO NOTHING
`

func (q *Queries) CreateDependencytrackProject(ctx context.Context, environment string, teamSlug slug.Slug, app string, projectid uuid.UUID) error {
	_, err := q.db.Exec(ctx, createDependencytrackProject,
		environment,
		teamSlug,
		app,
		projectid,
	)
	return err
}

const dailyVulnerabilityForTeam = `-- name: DailyVulnerabilityForTeam :many
SELECT
    sum(critical) AS critical,
    sum(high) AS high,
    sum(medium) AS medium,
    sum(low) AS low,
    sum(unassigned) AS unassigned,
    sum(risk_score) AS risk_score,
    date
FROM
    vulnerability_metrics
WHERE
    date >= $1::date
  AND date <= $2::date
  AND team_slug = $3::slug
GROUP BY
    date
ORDER BY
    date ASC
`

type DailyVulnerabilityForTeamRow struct {
	Critical   int64
	High       int64
	Medium     int64
	Low        int64
	Unassigned int64
	RiskScore  int64
	Date       pgtype.Date
}

func (q *Queries) DailyVulnerabilityForTeam(ctx context.Context, fromDate pgtype.Date, toDate pgtype.Date, teamSlug slug.Slug) ([]*DailyVulnerabilityForTeamRow, error) {
	rows, err := q.db.Query(ctx, dailyVulnerabilityForTeam, fromDate, toDate, teamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyVulnerabilityForTeamRow{}
	for rows.Next() {
		var i DailyVulnerabilityForTeamRow
		if err := rows.Scan(
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

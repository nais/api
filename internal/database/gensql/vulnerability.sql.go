// Code generated by sqlc. DO NOT EDIT.
// source: vulnerability.sql

package gensql

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/api/internal/slug"
)

const createDependencytrackProject = `-- name: CreateDependencytrackProject :exec
INSERT INTO dependencytrack_projects (id, environment, team_slug, app)
VALUES ($1, $2, $3, $4)
    ON CONFLICT DO NOTHING
`

type CreateDependencytrackProjectParams struct {
	ID          uuid.UUID
	Environment string
	TeamSlug    slug.Slug
	App         string
}

func (q *Queries) CreateDependencytrackProject(ctx context.Context, arg CreateDependencytrackProjectParams) error {
	_, err := q.db.Exec(ctx, createDependencytrackProject,
		arg.ID,
		arg.Environment,
		arg.TeamSlug,
		arg.App,
	)
	return err
}

const dailyVulnerabilityForTeam = `-- name: DailyVulnerabilityForTeam :many
SELECT
    sum(critical) AS critical,
    sum(high) AS high,
    sum(medium) AS medium,
    sum(low) AS low,
    sum(unassigned) AS unassigned,
    sum(risk_score) AS risk_score,
    date
FROM
    vulnerability_metrics
WHERE
    date >= $1::date
    AND date <= $2::date
    AND dependencytrack_project_id IN (
        SELECT id
        FROM dependencytrack_projects
        WHERE team_slug = $3
    )
GROUP BY
    date
ORDER BY
    date ASC
`

type DailyVulnerabilityForTeamParams struct {
	FromDate pgtype.Date
	ToDate   pgtype.Date
	TeamSlug slug.Slug
}

type DailyVulnerabilityForTeamRow struct {
	Critical   int64
	High       int64
	Medium     int64
	Low        int64
	Unassigned int64
	RiskScore  int64
	Date       pgtype.Date
}

// DailyVulnerabilityForTeam will return the metrics for the given team from first to last date.
func (q *Queries) DailyVulnerabilityForTeam(ctx context.Context, arg DailyVulnerabilityForTeamParams) ([]*DailyVulnerabilityForTeamRow, error) {
	rows, err := q.db.Query(ctx, dailyVulnerabilityForTeam, arg.FromDate, arg.ToDate, arg.TeamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyVulnerabilityForTeamRow{}
	for rows.Next() {
		var i DailyVulnerabilityForTeamRow
		if err := rows.Scan(
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dailyVulnerabilityForTeamAndEnvironment = `-- name: DailyVulnerabilityForTeamAndEnvironment :many
SELECT
    sum(critical) AS critical,
    sum(high) AS high,
    sum(medium) AS medium,
    sum(low) AS low,
    sum(unassigned) AS unassigned,
    sum(risk_score) AS risk_score,
    date
FROM
    vulnerability_metrics
WHERE
    date >= $1::date
    AND date <= $2::date
    AND dependencytrack_project_id IN (
        SELECT id
        FROM dependencytrack_projects
        WHERE
            team_slug = $3
            AND environment = $4
    )
GROUP BY
    date
ORDER BY
    date ASC
`

type DailyVulnerabilityForTeamAndEnvironmentParams struct {
	FromDate    pgtype.Date
	ToDate      pgtype.Date
	TeamSlug    slug.Slug
	Environment string
}

type DailyVulnerabilityForTeamAndEnvironmentRow struct {
	Critical   int64
	High       int64
	Medium     int64
	Low        int64
	Unassigned int64
	RiskScore  int64
	Date       pgtype.Date
}

// DailyVulnerabilityForTeamAndEnvironment will return the metrics for the given team and environment from first to last date.
func (q *Queries) DailyVulnerabilityForTeamAndEnvironment(ctx context.Context, arg DailyVulnerabilityForTeamAndEnvironmentParams) ([]*DailyVulnerabilityForTeamAndEnvironmentRow, error) {
	rows, err := q.db.Query(ctx, dailyVulnerabilityForTeamAndEnvironment,
		arg.FromDate,
		arg.ToDate,
		arg.TeamSlug,
		arg.Environment,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyVulnerabilityForTeamAndEnvironmentRow{}
	for rows.Next() {
		var i DailyVulnerabilityForTeamAndEnvironmentRow
		if err := rows.Scan(
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vulnerabilityMetricsDateRangeForTeam = `-- name: VulnerabilityMetricsDateRangeForTeam :one
SELECT
    MIN(date)::date AS from_date,
    MAX(date)::date AS to_date
FROM
    vulnerability_metrics
WHERE
    dependencytrack_project_id IN (
        SELECT id
        FROM dependencytrack_projects
        WHERE team_slug = $1
    )
`

type VulnerabilityMetricsDateRangeForTeamRow struct {
	FromDate pgtype.Date
	ToDate   pgtype.Date
}

// VulnerabilityMetricsDateRangeForTeam will return the first and last date that has a metrics.
func (q *Queries) VulnerabilityMetricsDateRangeForTeam(ctx context.Context, teamSlug slug.Slug) (*VulnerabilityMetricsDateRangeForTeamRow, error) {
	row := q.db.QueryRow(ctx, vulnerabilityMetricsDateRangeForTeam, teamSlug)
	var i VulnerabilityMetricsDateRangeForTeamRow
	err := row.Scan(&i.FromDate, &i.ToDate)
	return &i, err
}

const vulnerabilityMetricsMaxDate = `-- name: VulnerabilityMetricsMaxDate :one
SELECT
    MAX(date)::date AS to_date
FROM
    vulnerability_metrics
WHERE
    dependencytrack_project_id = ANY(
        SELECT id
        FROM dependencytrack_projects
        WHERE
            environment = $1
            AND app = $2
            AND team_slug = $3
    )
`

type VulnerabilityMetricsMaxDateParams struct {
	Environment string
	App         string
	TeamSlug    slug.Slug
}

// VulnerabilityMetricsMaxDate will return the last date that has a metrics for the given project id.
func (q *Queries) VulnerabilityMetricsMaxDate(ctx context.Context, arg VulnerabilityMetricsMaxDateParams) (pgtype.Date, error) {
	row := q.db.QueryRow(ctx, vulnerabilityMetricsMaxDate, arg.Environment, arg.App, arg.TeamSlug)
	var to_date pgtype.Date
	err := row.Scan(&to_date)
	return to_date, err
}

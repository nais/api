// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gengql

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/nais/api/internal/activitylog"
	"github.com/nais/api/internal/cost"
	"github.com/nais/api/internal/deployment"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/issue"
	"github.com/nais/api/internal/persistence/bigquery"
	"github.com/nais/api/internal/persistence/bucket"
	"github.com/nais/api/internal/persistence/kafkatopic"
	"github.com/nais/api/internal/persistence/opensearch"
	"github.com/nais/api/internal/persistence/postgres"
	"github.com/nais/api/internal/persistence/sqlinstance"
	"github.com/nais/api/internal/persistence/valkey"
	"github.com/nais/api/internal/team"
	"github.com/nais/api/internal/utilization"
	"github.com/nais/api/internal/vulnerability"
	"github.com/nais/api/internal/workload"
	"github.com/nais/api/internal/workload/application"
	"github.com/nais/api/internal/workload/logging"
	"github.com/nais/api/internal/workload/netpol"
	"github.com/nais/api/internal/workload/secret"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

type ApplicationResolver interface {
	Team(ctx context.Context, obj *application.Application) (*team.Team, error)
	Environment(ctx context.Context, obj *application.Application) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *application.Application) (*team.TeamEnvironment, error)

	AuthIntegrations(ctx context.Context, obj *application.Application) ([]workload.ApplicationAuthIntegrations, error)
	Manifest(ctx context.Context, obj *application.Application) (*application.ApplicationManifest, error)
	Instances(ctx context.Context, obj *application.Application, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*application.ApplicationInstance], error)

	ActivityLog(ctx context.Context, obj *application.Application, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter *activitylog.ActivityLogFilter) (*pagination.Connection[activitylog.ActivityLogEntry], error)
	State(ctx context.Context, obj *application.Application) (application.ApplicationState, error)
	Issues(ctx context.Context, obj *application.Application, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *issue.IssueOrder, filter *issue.ResourceIssueFilter) (*pagination.Connection[issue.Issue], error)
	BigQueryDatasets(ctx context.Context, obj *application.Application, orderBy *bigquery.BigQueryDatasetOrder) (*pagination.Connection[*bigquery.BigQueryDataset], error)
	Buckets(ctx context.Context, obj *application.Application, orderBy *bucket.BucketOrder) (*pagination.Connection[*bucket.Bucket], error)
	Cost(ctx context.Context, obj *application.Application) (*cost.WorkloadCost, error)
	Deployments(ctx context.Context, obj *application.Application, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*deployment.Deployment], error)
	KafkaTopicAcls(ctx context.Context, obj *application.Application, orderBy *kafkatopic.KafkaTopicACLOrder) (*pagination.Connection[*kafkatopic.KafkaTopicACL], error)
	LogDestinations(ctx context.Context, obj *application.Application) ([]logging.LogDestination, error)
	NetworkPolicy(ctx context.Context, obj *application.Application) (*netpol.NetworkPolicy, error)
	OpenSearch(ctx context.Context, obj *application.Application) (*opensearch.OpenSearch, error)
	PostgresInstances(ctx context.Context, obj *application.Application, orderBy *postgres.PostgresInstanceOrder) (*pagination.Connection[*postgres.PostgresInstance], error)
	Secrets(ctx context.Context, obj *application.Application, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*secret.Secret], error)
	SQLInstances(ctx context.Context, obj *application.Application, orderBy *sqlinstance.SQLInstanceOrder) (*pagination.Connection[*sqlinstance.SQLInstance], error)
	Utilization(ctx context.Context, obj *application.Application) (*utilization.WorkloadUtilization, error)
	Valkeys(ctx context.Context, obj *application.Application, orderBy *valkey.ValkeyOrder) (*pagination.Connection[*valkey.Valkey], error)
	ImageVulnerabilityHistory(ctx context.Context, obj *application.Application, from scalar.Date) (*vulnerability.ImageVulnerabilityHistory, error)
	VulnerabilityFixHistory(ctx context.Context, obj *application.Application, from scalar.Date) (*vulnerability.VulnerabilityFixHistory, error)
}
type ApplicationInstanceResolver interface {
	InstanceUtilization(ctx context.Context, obj *application.ApplicationInstance, resourceType utilization.UtilizationResourceType) (*utilization.ApplicationInstanceUtilization, error)
}
type DeleteApplicationPayloadResolver interface {
	Team(ctx context.Context, obj *application.DeleteApplicationPayload) (*team.Team, error)
}
type IngressResolver interface {
	Type(ctx context.Context, obj *application.Ingress) (application.IngressType, error)
	Metrics(ctx context.Context, obj *application.Ingress) (*application.IngressMetrics, error)
}
type IngressMetricsResolver interface {
	RequestsPerSecond(ctx context.Context, obj *application.IngressMetrics) (float64, error)
	ErrorsPerSecond(ctx context.Context, obj *application.IngressMetrics) (float64, error)
	Series(ctx context.Context, obj *application.IngressMetrics, input application.IngressMetricsInput) ([]*application.IngressMetricSample, error)
}
type RestartApplicationPayloadResolver interface {
	Application(ctx context.Context, obj *application.RestartApplicationPayload) (*application.Application, error)
}

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_ApplicationInstance_instanceUtilization_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "resourceType", ec.unmarshalNUtilizationResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋutilizationᚐUtilizationResourceType)
	if err != nil {
		return nil, err
	}
	args["resourceType"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_activityLog_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOActivityLogFilter2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋactivitylogᚐActivityLogFilter)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg4
	return args, nil
}

func (ec *executionContext) field_Application_bigQueryDatasets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "orderBy", ec.unmarshalOBigQueryDatasetOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋbigqueryᚐBigQueryDatasetOrder)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_buckets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "orderBy", ec.unmarshalOBucketOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋbucketᚐBucketOrder)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_deployments_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}

func (ec *executionContext) field_Application_imageVulnerabilityHistory_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "from", ec.unmarshalNDate2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋscalarᚐDate)
	if err != nil {
		return nil, err
	}
	args["from"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_instances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}

func (ec *executionContext) field_Application_issues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "orderBy", ec.unmarshalOIssueOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueOrder)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	arg5, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOResourceIssueFilter2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐResourceIssueFilter)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg5
	return args, nil
}

func (ec *executionContext) field_Application_kafkaTopicAcls_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "orderBy", ec.unmarshalOKafkaTopicAclOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋkafkatopicᚐKafkaTopicACLOrder)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_postgresInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "orderBy", ec.unmarshalOPostgresInstanceOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋpostgresᚐPostgresInstanceOrder)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_secrets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}

func (ec *executionContext) field_Application_sqlInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "orderBy", ec.unmarshalOSqlInstanceOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋsqlinstanceᚐSQLInstanceOrder)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_valkeys_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "orderBy", ec.unmarshalOValkeyOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋvalkeyᚐValkeyOrder)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_vulnerabilityFixHistory_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "from", ec.unmarshalNDate2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋscalarᚐDate)
	if err != nil {
		return nil, err
	}
	args["from"] = arg0
	return args, nil
}

func (ec *executionContext) field_IngressMetrics_series_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNIngressMetricsInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetricsInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Application_id(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_id,
		func(ctx context.Context) (any, error) {
			return obj.ID(), nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_name(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_team(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_team,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Application().Team(ctx, obj)
		},
		nil,
		ec.marshalNTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeam,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "alerts":
				return ec.fieldContext_Team_alerts(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "issues":
				return ec.fieldContext_Team_issues(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearches":
				return ec.fieldContext_Team_openSearches(ctx, field)
			case "postgresInstances":
				return ec.fieldContext_Team_postgresInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeys":
				return ec.fieldContext_Team_valkeys(ctx, field)
			case "imageVulnerabilityHistory":
				return ec.fieldContext_Team_imageVulnerabilityHistory(ctx, field)
			case "vulnerabilityFixHistory":
				return ec.fieldContext_Team_vulnerabilityFixHistory(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "vulnerabilitySummaries":
				return ec.fieldContext_Team_vulnerabilitySummaries(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_environment(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_environment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Application().Environment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "postgresInstances":
				return ec.fieldContext_TeamEnvironment_postgresInstances(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Application().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "postgresInstances":
				return ec.fieldContext_TeamEnvironment_postgresInstances(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_image(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_image,
		func(ctx context.Context) (any, error) {
			return obj.Image(), nil
		},
		nil,
		ec.marshalNContainerImage2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐContainerImage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerImage_id(ctx, field)
			case "name":
				return ec.fieldContext_ContainerImage_name(ctx, field)
			case "tag":
				return ec.fieldContext_ContainerImage_tag(ctx, field)
			case "activityLog":
				return ec.fieldContext_ContainerImage_activityLog(ctx, field)
			case "hasSBOM":
				return ec.fieldContext_ContainerImage_hasSBOM(ctx, field)
			case "vulnerabilities":
				return ec.fieldContext_ContainerImage_vulnerabilities(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_ContainerImage_vulnerabilitySummary(ctx, field)
			case "workloadReferences":
				return ec.fieldContext_ContainerImage_workloadReferences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_resources(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_resources,
		func(ctx context.Context) (any, error) {
			return obj.Resources(), nil
		},
		nil,
		ec.marshalNApplicationResources2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationResources,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_resources(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "limits":
				return ec.fieldContext_ApplicationResources_limits(ctx, field)
			case "requests":
				return ec.fieldContext_ApplicationResources_requests(ctx, field)
			case "scaling":
				return ec.fieldContext_ApplicationResources_scaling(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_ingresses(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_ingresses,
		func(ctx context.Context) (any, error) {
			return obj.Ingresses(), nil
		},
		nil,
		ec.marshalNIngress2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_ingresses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_Ingress_url(ctx, field)
			case "type":
				return ec.fieldContext_Ingress_type(ctx, field)
			case "metrics":
				return ec.fieldContext_Ingress_metrics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Ingress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_authIntegrations(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_authIntegrations,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Application().AuthIntegrations(ctx, obj)
		},
		nil,
		ec.marshalNApplicationAuthIntegrations2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐApplicationAuthIntegrationsᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_authIntegrations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ApplicationAuthIntegrations does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_manifest(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_manifest,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Application().Manifest(ctx, obj)
		},
		nil,
		ec.marshalNApplicationManifest2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationManifest,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_manifest(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "content":
				return ec.fieldContext_ApplicationManifest_content(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationManifest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_instances(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_instances,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().Instances(ctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
		},
		nil,
		ec.marshalNApplicationInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_instances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ApplicationInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ApplicationInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ApplicationInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_instances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_deletionStartedAt(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_deletionStartedAt,
		func(ctx context.Context) (any, error) {
			return obj.DeletionStartedAt, nil
		},
		nil,
		ec.marshalOTime2ᚖtimeᚐTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Application_deletionStartedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_activityLog(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_activityLog,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().ActivityLog(ctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["filter"].(*activitylog.ActivityLogFilter))
		},
		nil,
		ec.marshalNActivityLogEntryConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_activityLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ActivityLogEntryConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ActivityLogEntryConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ActivityLogEntryConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ActivityLogEntryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_activityLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_state(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_state,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Application().State(ctx, obj)
		},
		nil,
		ec.marshalNApplicationState2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationState,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ApplicationState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_issues(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_issues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().Issues(ctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*issue.IssueOrder), fc.Args["filter"].(*issue.ResourceIssueFilter))
		},
		nil,
		ec.marshalNIssueConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_issues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_IssueConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_IssueConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_IssueConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_issues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_bigQueryDatasets(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_bigQueryDatasets,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().BigQueryDatasets(ctx, obj, fc.Args["orderBy"].(*bigquery.BigQueryDatasetOrder))
		},
		nil,
		ec.marshalNBigQueryDatasetConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_bigQueryDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BigQueryDatasetConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BigQueryDatasetConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BigQueryDatasetConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_bigQueryDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_buckets(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_buckets,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().Buckets(ctx, obj, fc.Args["orderBy"].(*bucket.BucketOrder))
		},
		nil,
		ec.marshalNBucketConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_buckets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BucketConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BucketConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BucketConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_buckets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_cost(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_cost,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Application().Cost(ctx, obj)
		},
		nil,
		ec.marshalNWorkloadCost2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋcostᚐWorkloadCost,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "daily":
				return ec.fieldContext_WorkloadCost_daily(ctx, field)
			case "monthly":
				return ec.fieldContext_WorkloadCost_monthly(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_deployments(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_deployments,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().Deployments(ctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
		},
		nil,
		ec.marshalNDeploymentConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_deployments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_DeploymentConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_DeploymentConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_DeploymentConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_deployments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_kafkaTopicAcls(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_kafkaTopicAcls,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().KafkaTopicAcls(ctx, obj, fc.Args["orderBy"].(*kafkatopic.KafkaTopicACLOrder))
		},
		nil,
		ec.marshalNKafkaTopicAclConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_kafkaTopicAcls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_KafkaTopicAclConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_KafkaTopicAclConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_KafkaTopicAclConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAclConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_kafkaTopicAcls_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_logDestinations(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_logDestinations,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Application().LogDestinations(ctx, obj)
		},
		nil,
		ec.marshalNLogDestination2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋloggingᚐLogDestinationᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_logDestinations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_networkPolicy(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_networkPolicy,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Application().NetworkPolicy(ctx, obj)
		},
		nil,
		ec.marshalNNetworkPolicy2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋnetpolᚐNetworkPolicy,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_networkPolicy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "inbound":
				return ec.fieldContext_NetworkPolicy_inbound(ctx, field)
			case "outbound":
				return ec.fieldContext_NetworkPolicy_outbound(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_openSearch(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_openSearch,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Application().OpenSearch(ctx, obj)
		},
		nil,
		ec.marshalOOpenSearch2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋopensearchᚐOpenSearch,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Application_openSearch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_OpenSearch_teamEnvironment(ctx, field)
			case "terminationProtection":
				return ec.fieldContext_OpenSearch_terminationProtection(ctx, field)
			case "state":
				return ec.fieldContext_OpenSearch_state(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "version":
				return ec.fieldContext_OpenSearch_version(ctx, field)
			case "tier":
				return ec.fieldContext_OpenSearch_tier(ctx, field)
			case "memory":
				return ec.fieldContext_OpenSearch_memory(ctx, field)
			case "storageGB":
				return ec.fieldContext_OpenSearch_storageGB(ctx, field)
			case "issues":
				return ec.fieldContext_OpenSearch_issues(ctx, field)
			case "activityLog":
				return ec.fieldContext_OpenSearch_activityLog(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			case "maintenance":
				return ec.fieldContext_OpenSearch_maintenance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_postgresInstances(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_postgresInstances,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().PostgresInstances(ctx, obj, fc.Args["orderBy"].(*postgres.PostgresInstanceOrder))
		},
		nil,
		ec.marshalNPostgresInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_postgresInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_PostgresInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_PostgresInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_PostgresInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PostgresInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_postgresInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_secrets(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_secrets,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().Secrets(ctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
		},
		nil,
		ec.marshalNSecretConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_secrets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SecretConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SecretConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SecretConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_secrets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_sqlInstances(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_sqlInstances,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().SQLInstances(ctx, obj, fc.Args["orderBy"].(*sqlinstance.SQLInstanceOrder))
		},
		nil,
		ec.marshalNSqlInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_sqlInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SqlInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SqlInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SqlInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_sqlInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_utilization(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_utilization,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Application().Utilization(ctx, obj)
		},
		nil,
		ec.marshalNWorkloadUtilization2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋutilizationᚐWorkloadUtilization,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_utilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_WorkloadUtilization_current(ctx, field)
			case "requested":
				return ec.fieldContext_WorkloadUtilization_requested(ctx, field)
			case "requestedSeries":
				return ec.fieldContext_WorkloadUtilization_requestedSeries(ctx, field)
			case "limit":
				return ec.fieldContext_WorkloadUtilization_limit(ctx, field)
			case "limitSeries":
				return ec.fieldContext_WorkloadUtilization_limitSeries(ctx, field)
			case "series":
				return ec.fieldContext_WorkloadUtilization_series(ctx, field)
			case "recommendations":
				return ec.fieldContext_WorkloadUtilization_recommendations(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadUtilization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_valkeys(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_valkeys,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().Valkeys(ctx, obj, fc.Args["orderBy"].(*valkey.ValkeyOrder))
		},
		nil,
		ec.marshalNValkeyConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_valkeys(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ValkeyConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ValkeyConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ValkeyConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_valkeys_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_imageVulnerabilityHistory(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_imageVulnerabilityHistory,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().ImageVulnerabilityHistory(ctx, obj, fc.Args["from"].(scalar.Date))
		},
		nil,
		ec.marshalNImageVulnerabilityHistory2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋvulnerabilityᚐImageVulnerabilityHistory,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_imageVulnerabilityHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "samples":
				return ec.fieldContext_ImageVulnerabilityHistory_samples(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilityHistory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_imageVulnerabilityHistory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_vulnerabilityFixHistory(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Application_vulnerabilityFixHistory,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Application().VulnerabilityFixHistory(ctx, obj, fc.Args["from"].(scalar.Date))
		},
		nil,
		ec.marshalNVulnerabilityFixHistory2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋvulnerabilityᚐVulnerabilityFixHistory,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Application_vulnerabilityFixHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "samples":
				return ec.fieldContext_VulnerabilityFixHistory_samples(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VulnerabilityFixHistory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_vulnerabilityFixHistory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.Application]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.Application]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationConnection_nodes,
		func(ctx context.Context) (any, error) {
			return obj.Nodes(), nil
		},
		nil,
		ec.marshalNApplication2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Application_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "instances":
				return ec.fieldContext_Application_instances(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Application_deletionStartedAt(ctx, field)
			case "activityLog":
				return ec.fieldContext_Application_activityLog(ctx, field)
			case "state":
				return ec.fieldContext_Application_state(ctx, field)
			case "issues":
				return ec.fieldContext_Application_issues(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Application_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Application_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "postgresInstances":
				return ec.fieldContext_Application_postgresInstances(ctx, field)
			case "secrets":
				return ec.fieldContext_Application_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			case "valkeys":
				return ec.fieldContext_Application_valkeys(ctx, field)
			case "imageVulnerabilityHistory":
				return ec.fieldContext_Application_imageVulnerabilityHistory(ctx, field)
			case "vulnerabilityFixHistory":
				return ec.fieldContext_Application_vulnerabilityFixHistory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.Application]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationConnection_edges,
		func(ctx context.Context) (any, error) {
			return obj.Edges, nil
		},
		nil,
		ec.marshalNApplicationEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdgeᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ApplicationEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ApplicationEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationDeletedActivityLogEntry_id,
		func(ctx context.Context) (any, error) {
			return obj.ID(), nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationDeletedActivityLogEntry_actor,
		func(ctx context.Context) (any, error) {
			return obj.Actor, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationDeletedActivityLogEntry_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationDeletedActivityLogEntry_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationDeletedActivityLogEntry_resourceType,
		func(ctx context.Context) (any, error) {
			return obj.ResourceType, nil
		},
		nil,
		ec.marshalNActivityLogEntryResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋactivitylogᚐActivityLogEntryResourceType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationDeletedActivityLogEntry_resourceName,
		func(ctx context.Context) (any, error) {
			return obj.ResourceName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationDeletedActivityLogEntry_teamSlug,
		func(ctx context.Context) (any, error) {
			return obj.TeamSlug, nil
		},
		nil,
		ec.marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationDeletedActivityLogEntry_environmentName,
		func(ctx context.Context) (any, error) {
			return obj.EnvironmentName, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*application.Application]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationEdge_cursor,
		func(ctx context.Context) (any, error) {
			return obj.Cursor, nil
		},
		nil,
		ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*application.Application]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationEdge_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalNApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplication,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Application_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "instances":
				return ec.fieldContext_Application_instances(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Application_deletionStartedAt(ctx, field)
			case "activityLog":
				return ec.fieldContext_Application_activityLog(ctx, field)
			case "state":
				return ec.fieldContext_Application_state(ctx, field)
			case "issues":
				return ec.fieldContext_Application_issues(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Application_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Application_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "postgresInstances":
				return ec.fieldContext_Application_postgresInstances(ctx, field)
			case "secrets":
				return ec.fieldContext_Application_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			case "valkeys":
				return ec.fieldContext_Application_valkeys(ctx, field)
			case "imageVulnerabilityHistory":
				return ec.fieldContext_Application_imageVulnerabilityHistory(ctx, field)
			case "vulnerabilityFixHistory":
				return ec.fieldContext_Application_vulnerabilityFixHistory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_id(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstance_id,
		func(ctx context.Context) (any, error) {
			return obj.ID(), nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstance_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_name(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstance_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstance_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_image(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstance_image,
		func(ctx context.Context) (any, error) {
			return obj.Image(), nil
		},
		nil,
		ec.marshalNContainerImage2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐContainerImage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstance_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerImage_id(ctx, field)
			case "name":
				return ec.fieldContext_ContainerImage_name(ctx, field)
			case "tag":
				return ec.fieldContext_ContainerImage_tag(ctx, field)
			case "activityLog":
				return ec.fieldContext_ContainerImage_activityLog(ctx, field)
			case "hasSBOM":
				return ec.fieldContext_ContainerImage_hasSBOM(ctx, field)
			case "vulnerabilities":
				return ec.fieldContext_ContainerImage_vulnerabilities(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_ContainerImage_vulnerabilitySummary(ctx, field)
			case "workloadReferences":
				return ec.fieldContext_ContainerImage_workloadReferences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_restarts(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstance_restarts,
		func(ctx context.Context) (any, error) {
			return obj.Restarts, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstance_restarts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_created(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstance_created,
		func(ctx context.Context) (any, error) {
			return obj.Created, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstance_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_status(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstance_status,
		func(ctx context.Context) (any, error) {
			return obj.Status(), nil
		},
		nil,
		ec.marshalNApplicationInstanceStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationInstanceStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstance_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_ApplicationInstanceStatus_state(ctx, field)
			case "message":
				return ec.fieldContext_ApplicationInstanceStatus_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationInstanceStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_instanceUtilization(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstance_instanceUtilization,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.ApplicationInstance().InstanceUtilization(ctx, obj, fc.Args["resourceType"].(utilization.UtilizationResourceType))
		},
		nil,
		ec.marshalNApplicationInstanceUtilization2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋutilizationᚐApplicationInstanceUtilization,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstance_instanceUtilization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_ApplicationInstanceUtilization_current(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationInstanceUtilization", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationInstance_instanceUtilization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.ApplicationInstance]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstanceConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstanceConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.ApplicationInstance]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstanceConnection_nodes,
		func(ctx context.Context) (any, error) {
			return obj.Nodes(), nil
		},
		nil,
		ec.marshalNApplicationInstance2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationInstanceᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstanceConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationInstance_name(ctx, field)
			case "image":
				return ec.fieldContext_ApplicationInstance_image(ctx, field)
			case "restarts":
				return ec.fieldContext_ApplicationInstance_restarts(ctx, field)
			case "created":
				return ec.fieldContext_ApplicationInstance_created(ctx, field)
			case "status":
				return ec.fieldContext_ApplicationInstance_status(ctx, field)
			case "instanceUtilization":
				return ec.fieldContext_ApplicationInstance_instanceUtilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.ApplicationInstance]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstanceConnection_edges,
		func(ctx context.Context) (any, error) {
			return obj.Edges, nil
		},
		nil,
		ec.marshalNApplicationInstanceEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdgeᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstanceConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ApplicationInstanceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ApplicationInstanceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationInstanceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*application.ApplicationInstance]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstanceEdge_cursor,
		func(ctx context.Context) (any, error) {
			return obj.Cursor, nil
		},
		nil,
		ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstanceEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*application.ApplicationInstance]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstanceEdge_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalNApplicationInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationInstance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstanceEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationInstance_name(ctx, field)
			case "image":
				return ec.fieldContext_ApplicationInstance_image(ctx, field)
			case "restarts":
				return ec.fieldContext_ApplicationInstance_restarts(ctx, field)
			case "created":
				return ec.fieldContext_ApplicationInstance_created(ctx, field)
			case "status":
				return ec.fieldContext_ApplicationInstance_status(ctx, field)
			case "instanceUtilization":
				return ec.fieldContext_ApplicationInstance_instanceUtilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceStatus_state(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstanceStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstanceStatus_state,
		func(ctx context.Context) (any, error) {
			return obj.State, nil
		},
		nil,
		ec.marshalNApplicationInstanceState2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationInstanceState,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstanceStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ApplicationInstanceState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceStatus_message(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstanceStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationInstanceStatus_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationInstanceStatus_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationManifest_content(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationManifest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationManifest_content,
		func(ctx context.Context) (any, error) {
			return obj.Content, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationManifest_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationManifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationResources_limits(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationResources) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationResources_limits,
		func(ctx context.Context) (any, error) {
			return obj.Limits, nil
		},
		nil,
		ec.marshalNWorkloadResourceQuantity2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐWorkloadResourceQuantity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationResources_limits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadResourceQuantity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationResources_requests(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationResources) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationResources_requests,
		func(ctx context.Context) (any, error) {
			return obj.Requests, nil
		},
		nil,
		ec.marshalNWorkloadResourceQuantity2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐWorkloadResourceQuantity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationResources_requests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadResourceQuantity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationResources_scaling(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationResources) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationResources_scaling,
		func(ctx context.Context) (any, error) {
			return obj.Scaling, nil
		},
		nil,
		ec.marshalNApplicationScaling2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationScaling,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationResources_scaling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "minInstances":
				return ec.fieldContext_ApplicationScaling_minInstances(ctx, field)
			case "maxInstances":
				return ec.fieldContext_ApplicationScaling_maxInstances(ctx, field)
			case "strategies":
				return ec.fieldContext_ApplicationScaling_strategies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationScaling", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationRestartedActivityLogEntry_id,
		func(ctx context.Context) (any, error) {
			return obj.ID(), nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationRestartedActivityLogEntry_actor,
		func(ctx context.Context) (any, error) {
			return obj.Actor, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationRestartedActivityLogEntry_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationRestartedActivityLogEntry_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationRestartedActivityLogEntry_resourceType,
		func(ctx context.Context) (any, error) {
			return obj.ResourceType, nil
		},
		nil,
		ec.marshalNActivityLogEntryResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋactivitylogᚐActivityLogEntryResourceType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationRestartedActivityLogEntry_resourceName,
		func(ctx context.Context) (any, error) {
			return obj.ResourceName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationRestartedActivityLogEntry_teamSlug,
		func(ctx context.Context) (any, error) {
			return obj.TeamSlug, nil
		},
		nil,
		ec.marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationRestartedActivityLogEntry_environmentName,
		func(ctx context.Context) (any, error) {
			return obj.EnvironmentName, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaledActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaledActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaledActivityLogEntry_id,
		func(ctx context.Context) (any, error) {
			return obj.ID(), nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaledActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaledActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaledActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaledActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaledActivityLogEntry_actor,
		func(ctx context.Context) (any, error) {
			return obj.Actor, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaledActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaledActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaledActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaledActivityLogEntry_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaledActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaledActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaledActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaledActivityLogEntry_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaledActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaledActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaledActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaledActivityLogEntry_resourceType,
		func(ctx context.Context) (any, error) {
			return obj.ResourceType, nil
		},
		nil,
		ec.marshalNActivityLogEntryResourceType2githubᚗcomᚋnaisᚋapiᚋinternalᚋactivitylogᚐActivityLogEntryResourceType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaledActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaledActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaledActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaledActivityLogEntry_resourceName,
		func(ctx context.Context) (any, error) {
			return obj.ResourceName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaledActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaledActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaledActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaledActivityLogEntry_teamSlug,
		func(ctx context.Context) (any, error) {
			return obj.TeamSlug, nil
		},
		nil,
		ec.marshalNSlug2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaledActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaledActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaledActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaledActivityLogEntry_environmentName,
		func(ctx context.Context) (any, error) {
			return obj.EnvironmentName, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaledActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaledActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaledActivityLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaledActivityLogEntry_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNApplicationScaledActivityLogEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationScaledActivityLogEntryData,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaledActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "newSize":
				return ec.fieldContext_ApplicationScaledActivityLogEntryData_newSize(ctx, field)
			case "direction":
				return ec.fieldContext_ApplicationScaledActivityLogEntryData_direction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationScaledActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaledActivityLogEntryData_newSize(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaledActivityLogEntryData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaledActivityLogEntryData_newSize,
		func(ctx context.Context) (any, error) {
			return obj.NewSize, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaledActivityLogEntryData_newSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaledActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaledActivityLogEntryData_direction(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaledActivityLogEntryData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaledActivityLogEntryData_direction,
		func(ctx context.Context) (any, error) {
			return obj.Direction, nil
		},
		nil,
		ec.marshalNScalingDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐScalingDirection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaledActivityLogEntryData_direction(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaledActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScalingDirection does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaling_minInstances(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaling) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaling_minInstances,
		func(ctx context.Context) (any, error) {
			return obj.MinInstances, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaling_minInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaling",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaling_maxInstances(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaling) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaling_maxInstances,
		func(ctx context.Context) (any, error) {
			return obj.MaxInstances, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaling_maxInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaling",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaling_strategies(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaling) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ApplicationScaling_strategies,
		func(ctx context.Context) (any, error) {
			return obj.Strategies, nil
		},
		nil,
		ec.marshalNScalingStrategy2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐScalingStrategyᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ApplicationScaling_strategies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaling",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScalingStrategy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CPUScalingStrategy_threshold(ctx context.Context, field graphql.CollectedField, obj *application.CPUScalingStrategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CPUScalingStrategy_threshold,
		func(ctx context.Context) (any, error) {
			return obj.Threshold, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CPUScalingStrategy_threshold(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CPUScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteApplicationPayload_team(ctx context.Context, field graphql.CollectedField, obj *application.DeleteApplicationPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeleteApplicationPayload_team,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.DeleteApplicationPayload().Team(ctx, obj)
		},
		nil,
		ec.marshalOTeam2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeam,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DeleteApplicationPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteApplicationPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "alerts":
				return ec.fieldContext_Team_alerts(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "issues":
				return ec.fieldContext_Team_issues(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearches":
				return ec.fieldContext_Team_openSearches(ctx, field)
			case "postgresInstances":
				return ec.fieldContext_Team_postgresInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeys":
				return ec.fieldContext_Team_valkeys(ctx, field)
			case "imageVulnerabilityHistory":
				return ec.fieldContext_Team_imageVulnerabilityHistory(ctx, field)
			case "vulnerabilityFixHistory":
				return ec.fieldContext_Team_vulnerabilityFixHistory(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "vulnerabilitySummaries":
				return ec.fieldContext_Team_vulnerabilitySummaries(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteApplicationPayload_success(ctx context.Context, field graphql.CollectedField, obj *application.DeleteApplicationPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeleteApplicationPayload_success,
		func(ctx context.Context) (any, error) {
			return obj.Success, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DeleteApplicationPayload_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteApplicationPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ingress_url(ctx context.Context, field graphql.CollectedField, obj *application.Ingress) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Ingress_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Ingress_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ingress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ingress_type(ctx context.Context, field graphql.CollectedField, obj *application.Ingress) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Ingress_type,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Ingress().Type(ctx, obj)
		},
		nil,
		ec.marshalNIngressType2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Ingress_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ingress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IngressType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ingress_metrics(ctx context.Context, field graphql.CollectedField, obj *application.Ingress) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Ingress_metrics,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Ingress().Metrics(ctx, obj)
		},
		nil,
		ec.marshalNIngressMetrics2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetrics,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Ingress_metrics(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ingress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "requestsPerSecond":
				return ec.fieldContext_IngressMetrics_requestsPerSecond(ctx, field)
			case "errorsPerSecond":
				return ec.fieldContext_IngressMetrics_errorsPerSecond(ctx, field)
			case "series":
				return ec.fieldContext_IngressMetrics_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IngressMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IngressMetricSample_timestamp(ctx context.Context, field graphql.CollectedField, obj *application.IngressMetricSample) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IngressMetricSample_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IngressMetricSample_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IngressMetricSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IngressMetricSample_value(ctx context.Context, field graphql.CollectedField, obj *application.IngressMetricSample) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IngressMetricSample_value,
		func(ctx context.Context) (any, error) {
			return obj.Value, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IngressMetricSample_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IngressMetricSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IngressMetrics_requestsPerSecond(ctx context.Context, field graphql.CollectedField, obj *application.IngressMetrics) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IngressMetrics_requestsPerSecond,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.IngressMetrics().RequestsPerSecond(ctx, obj)
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IngressMetrics_requestsPerSecond(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IngressMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IngressMetrics_errorsPerSecond(ctx context.Context, field graphql.CollectedField, obj *application.IngressMetrics) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IngressMetrics_errorsPerSecond,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.IngressMetrics().ErrorsPerSecond(ctx, obj)
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IngressMetrics_errorsPerSecond(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IngressMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IngressMetrics_series(ctx context.Context, field graphql.CollectedField, obj *application.IngressMetrics) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IngressMetrics_series,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.IngressMetrics().Series(ctx, obj, fc.Args["input"].(application.IngressMetricsInput))
		},
		nil,
		ec.marshalNIngressMetricSample2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetricSampleᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IngressMetrics_series(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IngressMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "timestamp":
				return ec.fieldContext_IngressMetricSample_timestamp(ctx, field)
			case "value":
				return ec.fieldContext_IngressMetricSample_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IngressMetricSample", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_IngressMetrics_series_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KafkaLagScalingStrategy_threshold(ctx context.Context, field graphql.CollectedField, obj *application.KafkaLagScalingStrategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_KafkaLagScalingStrategy_threshold,
		func(ctx context.Context) (any, error) {
			return obj.Threshold, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_KafkaLagScalingStrategy_threshold(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaLagScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaLagScalingStrategy_consumerGroup(ctx context.Context, field graphql.CollectedField, obj *application.KafkaLagScalingStrategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_KafkaLagScalingStrategy_consumerGroup,
		func(ctx context.Context) (any, error) {
			return obj.ConsumerGroup, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_KafkaLagScalingStrategy_consumerGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaLagScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaLagScalingStrategy_topicName(ctx context.Context, field graphql.CollectedField, obj *application.KafkaLagScalingStrategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_KafkaLagScalingStrategy_topicName,
		func(ctx context.Context) (any, error) {
			return obj.TopicName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_KafkaLagScalingStrategy_topicName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaLagScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RestartApplicationPayload_application(ctx context.Context, field graphql.CollectedField, obj *application.RestartApplicationPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RestartApplicationPayload_application,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.RestartApplicationPayload().Application(ctx, obj)
		},
		nil,
		ec.marshalOApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplication,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RestartApplicationPayload_application(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RestartApplicationPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Application_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "instances":
				return ec.fieldContext_Application_instances(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Application_deletionStartedAt(ctx, field)
			case "activityLog":
				return ec.fieldContext_Application_activityLog(ctx, field)
			case "state":
				return ec.fieldContext_Application_state(ctx, field)
			case "issues":
				return ec.fieldContext_Application_issues(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Application_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Application_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "postgresInstances":
				return ec.fieldContext_Application_postgresInstances(ctx, field)
			case "secrets":
				return ec.fieldContext_Application_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			case "valkeys":
				return ec.fieldContext_Application_valkeys(ctx, field)
			case "imageVulnerabilityHistory":
				return ec.fieldContext_Application_imageVulnerabilityHistory(ctx, field)
			case "vulnerabilityFixHistory":
				return ec.fieldContext_Application_vulnerabilityFixHistory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountApplications_total(ctx context.Context, field graphql.CollectedField, obj *application.TeamInventoryCountApplications) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TeamInventoryCountApplications_total,
		func(ctx context.Context) (any, error) {
			return obj.Total, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TeamInventoryCountApplications_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountApplications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputApplicationOrder(ctx context.Context, obj any) (application.ApplicationOrder, error) {
	var it application.ApplicationOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNApplicationOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋmodelᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteApplicationInput(ctx context.Context, obj any) (application.DeleteApplicationInput, error) {
	var it application.DeleteApplicationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "teamSlug", "environmentName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "environmentName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environmentName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnvironmentName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIngressMetricsInput(ctx context.Context, obj any) (application.IngressMetricsInput, error) {
	var it application.IngressMetricsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"start", "end", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "start":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Start = data
		case "end":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.End = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNIngressMetricsType2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetricsType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRestartApplicationInput(ctx context.Context, obj any) (application.RestartApplicationInput, error) {
	var it application.RestartApplicationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "teamSlug", "environmentName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubᚗcomᚋnaisᚋapiᚋinternalᚋslugᚐSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "environmentName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environmentName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnvironmentName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamApplicationsFilter(ctx context.Context, obj any) (application.TeamApplicationsFilter, error) {
	var it application.TeamApplicationsFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "environments"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "environments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environments"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environments = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _ApplicationAuthIntegrations(ctx context.Context, sel ast.SelectionSet, obj workload.ApplicationAuthIntegrations) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case workload.TokenXAuthIntegration:
		return ec._TokenXAuthIntegration(ctx, sel, &obj)
	case *workload.TokenXAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._TokenXAuthIntegration(ctx, sel, obj)
	case workload.MaskinportenAuthIntegration:
		return ec._MaskinportenAuthIntegration(ctx, sel, &obj)
	case *workload.MaskinportenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._MaskinportenAuthIntegration(ctx, sel, obj)
	case workload.IDPortenAuthIntegration:
		return ec._IDPortenAuthIntegration(ctx, sel, &obj)
	case *workload.IDPortenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._IDPortenAuthIntegration(ctx, sel, obj)
	case workload.EntraIDAuthIntegration:
		return ec._EntraIDAuthIntegration(ctx, sel, &obj)
	case *workload.EntraIDAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._EntraIDAuthIntegration(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ScalingStrategy(ctx context.Context, sel ast.SelectionSet, obj application.ScalingStrategy) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case application.KafkaLagScalingStrategy:
		return ec._KafkaLagScalingStrategy(ctx, sel, &obj)
	case *application.KafkaLagScalingStrategy:
		if obj == nil {
			return graphql.Null
		}
		return ec._KafkaLagScalingStrategy(ctx, sel, obj)
	case application.CPUScalingStrategy:
		return ec._CPUScalingStrategy(ctx, sel, &obj)
	case *application.CPUScalingStrategy:
		if obj == nil {
			return graphql.Null
		}
		return ec._CPUScalingStrategy(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var applicationImplementors = []string{"Application", "Node", "Workload", "ActivityLogger", "SearchNode"}

func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *application.Application) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "id":
			out.Values[i] = ec._Application_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Application_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "image":
			out.Values[i] = ec._Application_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resources":
			out.Values[i] = ec._Application_resources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ingresses":
			out.Values[i] = ec._Application_ingresses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authIntegrations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_authIntegrations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "manifest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_manifest(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "instances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_instances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deletionStartedAt":
			out.Values[i] = ec._Application_deletionStartedAt(ctx, field, obj)
		case "activityLog":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_activityLog(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "state":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "issues":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_issues(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bigQueryDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_bigQueryDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buckets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_buckets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deployments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_deployments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "kafkaTopicAcls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_kafkaTopicAcls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logDestinations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_logDestinations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "networkPolicy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_networkPolicy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "openSearch":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_openSearch(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "postgresInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_postgresInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "secrets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_secrets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sqlInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_sqlInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "utilization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_utilization(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "valkeys":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_valkeys(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "imageVulnerabilityHistory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_imageVulnerabilityHistory(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vulnerabilityFixHistory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_vulnerabilityFixHistory(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationConnectionImplementors = []string{"ApplicationConnection"}

func (ec *executionContext) _ApplicationConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*application.Application]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationConnection")
		case "pageInfo":
			out.Values[i] = ec._ApplicationConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ApplicationConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ApplicationConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationDeletedActivityLogEntryImplementors = []string{"ApplicationDeletedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationDeletedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationDeletedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationDeletedActivityLogEntry")
		case "id":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationEdgeImplementors = []string{"ApplicationEdge"}

func (ec *executionContext) _ApplicationEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*application.Application]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationEdge")
		case "cursor":
			out.Values[i] = ec._ApplicationEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ApplicationEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationInstanceImplementors = []string{"ApplicationInstance", "Node"}

func (ec *executionContext) _ApplicationInstance(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationInstance")
		case "id":
			out.Values[i] = ec._ApplicationInstance_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._ApplicationInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "image":
			out.Values[i] = ec._ApplicationInstance_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "restarts":
			out.Values[i] = ec._ApplicationInstance_restarts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "created":
			out.Values[i] = ec._ApplicationInstance_created(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._ApplicationInstance_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "instanceUtilization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationInstance_instanceUtilization(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationInstanceConnectionImplementors = []string{"ApplicationInstanceConnection"}

func (ec *executionContext) _ApplicationInstanceConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*application.ApplicationInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationInstanceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationInstanceConnection")
		case "pageInfo":
			out.Values[i] = ec._ApplicationInstanceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ApplicationInstanceConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ApplicationInstanceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationInstanceEdgeImplementors = []string{"ApplicationInstanceEdge"}

func (ec *executionContext) _ApplicationInstanceEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*application.ApplicationInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationInstanceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationInstanceEdge")
		case "cursor":
			out.Values[i] = ec._ApplicationInstanceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ApplicationInstanceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationInstanceStatusImplementors = []string{"ApplicationInstanceStatus"}

func (ec *executionContext) _ApplicationInstanceStatus(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationInstanceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationInstanceStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationInstanceStatus")
		case "state":
			out.Values[i] = ec._ApplicationInstanceStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ApplicationInstanceStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationManifestImplementors = []string{"ApplicationManifest", "WorkloadManifest"}

func (ec *executionContext) _ApplicationManifest(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationManifest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationManifestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationManifest")
		case "content":
			out.Values[i] = ec._ApplicationManifest_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationResourcesImplementors = []string{"ApplicationResources", "WorkloadResources"}

func (ec *executionContext) _ApplicationResources(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationResourcesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationResources")
		case "limits":
			out.Values[i] = ec._ApplicationResources_limits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requests":
			out.Values[i] = ec._ApplicationResources_requests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scaling":
			out.Values[i] = ec._ApplicationResources_scaling(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationRestartedActivityLogEntryImplementors = []string{"ApplicationRestartedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationRestartedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationRestartedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationRestartedActivityLogEntry")
		case "id":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationScaledActivityLogEntryImplementors = []string{"ApplicationScaledActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ApplicationScaledActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationScaledActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationScaledActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationScaledActivityLogEntry")
		case "id":
			out.Values[i] = ec._ApplicationScaledActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ApplicationScaledActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ApplicationScaledActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ApplicationScaledActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ApplicationScaledActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ApplicationScaledActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ApplicationScaledActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._ApplicationScaledActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._ApplicationScaledActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationScaledActivityLogEntryDataImplementors = []string{"ApplicationScaledActivityLogEntryData"}

func (ec *executionContext) _ApplicationScaledActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationScaledActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationScaledActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationScaledActivityLogEntryData")
		case "newSize":
			out.Values[i] = ec._ApplicationScaledActivityLogEntryData_newSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "direction":
			out.Values[i] = ec._ApplicationScaledActivityLogEntryData_direction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationScalingImplementors = []string{"ApplicationScaling"}

func (ec *executionContext) _ApplicationScaling(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationScaling) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationScalingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationScaling")
		case "minInstances":
			out.Values[i] = ec._ApplicationScaling_minInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxInstances":
			out.Values[i] = ec._ApplicationScaling_maxInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "strategies":
			out.Values[i] = ec._ApplicationScaling_strategies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cPUScalingStrategyImplementors = []string{"CPUScalingStrategy", "ScalingStrategy"}

func (ec *executionContext) _CPUScalingStrategy(ctx context.Context, sel ast.SelectionSet, obj *application.CPUScalingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cPUScalingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CPUScalingStrategy")
		case "threshold":
			out.Values[i] = ec._CPUScalingStrategy_threshold(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteApplicationPayloadImplementors = []string{"DeleteApplicationPayload"}

func (ec *executionContext) _DeleteApplicationPayload(ctx context.Context, sel ast.SelectionSet, obj *application.DeleteApplicationPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteApplicationPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteApplicationPayload")
		case "team":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteApplicationPayload_team(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "success":
			out.Values[i] = ec._DeleteApplicationPayload_success(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ingressImplementors = []string{"Ingress"}

func (ec *executionContext) _Ingress(ctx context.Context, sel ast.SelectionSet, obj *application.Ingress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ingressImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Ingress")
		case "url":
			out.Values[i] = ec._Ingress_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ingress_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metrics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ingress_metrics(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ingressMetricSampleImplementors = []string{"IngressMetricSample"}

func (ec *executionContext) _IngressMetricSample(ctx context.Context, sel ast.SelectionSet, obj *application.IngressMetricSample) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ingressMetricSampleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IngressMetricSample")
		case "timestamp":
			out.Values[i] = ec._IngressMetricSample_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._IngressMetricSample_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ingressMetricsImplementors = []string{"IngressMetrics"}

func (ec *executionContext) _IngressMetrics(ctx context.Context, sel ast.SelectionSet, obj *application.IngressMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ingressMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IngressMetrics")
		case "requestsPerSecond":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IngressMetrics_requestsPerSecond(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "errorsPerSecond":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IngressMetrics_errorsPerSecond(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "series":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IngressMetrics_series(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaLagScalingStrategyImplementors = []string{"KafkaLagScalingStrategy", "ScalingStrategy"}

func (ec *executionContext) _KafkaLagScalingStrategy(ctx context.Context, sel ast.SelectionSet, obj *application.KafkaLagScalingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaLagScalingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaLagScalingStrategy")
		case "threshold":
			out.Values[i] = ec._KafkaLagScalingStrategy_threshold(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consumerGroup":
			out.Values[i] = ec._KafkaLagScalingStrategy_consumerGroup(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "topicName":
			out.Values[i] = ec._KafkaLagScalingStrategy_topicName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var restartApplicationPayloadImplementors = []string{"RestartApplicationPayload"}

func (ec *executionContext) _RestartApplicationPayload(ctx context.Context, sel ast.SelectionSet, obj *application.RestartApplicationPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, restartApplicationPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestartApplicationPayload")
		case "application":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RestartApplicationPayload_application(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamInventoryCountApplicationsImplementors = []string{"TeamInventoryCountApplications"}

func (ec *executionContext) _TeamInventoryCountApplications(ctx context.Context, sel ast.SelectionSet, obj *application.TeamInventoryCountApplications) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamInventoryCountApplicationsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamInventoryCountApplications")
		case "total":
			out.Values[i] = ec._TeamInventoryCountApplications_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNApplication2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplication(ctx context.Context, sel ast.SelectionSet, v application.Application) graphql.Marshaler {
	return ec._Application(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplication2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationᚄ(ctx context.Context, sel ast.SelectionSet, v []*application.Application) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplication(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplication(ctx context.Context, sel ast.SelectionSet, v *application.Application) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationAuthIntegrations2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐApplicationAuthIntegrations(ctx context.Context, sel ast.SelectionSet, v workload.ApplicationAuthIntegrations) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationAuthIntegrations(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationAuthIntegrations2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐApplicationAuthIntegrationsᚄ(ctx context.Context, sel ast.SelectionSet, v []workload.ApplicationAuthIntegrations) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationAuthIntegrations2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐApplicationAuthIntegrations(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*application.Application]) graphql.Marshaler {
	return ec._ApplicationConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*application.Application]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*application.Application]) graphql.Marshaler {
	return ec._ApplicationEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*application.Application]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationInstance2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationInstanceᚄ(ctx context.Context, sel ast.SelectionSet, v []*application.ApplicationInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationInstance(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationInstanceConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*application.ApplicationInstance]) graphql.Marshaler {
	return ec._ApplicationInstanceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationInstanceConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*application.ApplicationInstance]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationInstanceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationInstanceEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*application.ApplicationInstance]) graphql.Marshaler {
	return ec._ApplicationInstanceEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationInstanceEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*application.ApplicationInstance]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationInstanceEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNApplicationInstanceState2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationInstanceState(ctx context.Context, v any) (application.ApplicationInstanceState, error) {
	var res application.ApplicationInstanceState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationInstanceState2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationInstanceState(ctx context.Context, sel ast.SelectionSet, v application.ApplicationInstanceState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNApplicationInstanceStatus2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationInstanceStatus(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationInstanceStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationInstanceStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationManifest2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationManifest(ctx context.Context, sel ast.SelectionSet, v application.ApplicationManifest) graphql.Marshaler {
	return ec._ApplicationManifest(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationManifest2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationManifest(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationManifest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationManifest(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationOrderField(ctx context.Context, v any) (application.ApplicationOrderField, error) {
	var res application.ApplicationOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationOrderField(ctx context.Context, sel ast.SelectionSet, v application.ApplicationOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNApplicationResources2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationResources(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationResources) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationResources(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationScaledActivityLogEntryData2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationScaledActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationScaledActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationScaledActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationScaling2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationScaling(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationScaling) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationScaling(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationState2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationState(ctx context.Context, v any) (application.ApplicationState, error) {
	var res application.ApplicationState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationState2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationState(ctx context.Context, sel ast.SelectionSet, v application.ApplicationState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDeleteApplicationInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐDeleteApplicationInput(ctx context.Context, v any) (application.DeleteApplicationInput, error) {
	res, err := ec.unmarshalInputDeleteApplicationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteApplicationPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐDeleteApplicationPayload(ctx context.Context, sel ast.SelectionSet, v application.DeleteApplicationPayload) graphql.Marshaler {
	return ec._DeleteApplicationPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteApplicationPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐDeleteApplicationPayload(ctx context.Context, sel ast.SelectionSet, v *application.DeleteApplicationPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteApplicationPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNIngress2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressᚄ(ctx context.Context, sel ast.SelectionSet, v []*application.Ingress) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIngress2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngress(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIngress2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngress(ctx context.Context, sel ast.SelectionSet, v *application.Ingress) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Ingress(ctx, sel, v)
}

func (ec *executionContext) marshalNIngressMetricSample2ᚕᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetricSampleᚄ(ctx context.Context, sel ast.SelectionSet, v []*application.IngressMetricSample) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIngressMetricSample2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetricSample(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIngressMetricSample2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetricSample(ctx context.Context, sel ast.SelectionSet, v *application.IngressMetricSample) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IngressMetricSample(ctx, sel, v)
}

func (ec *executionContext) marshalNIngressMetrics2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetrics(ctx context.Context, sel ast.SelectionSet, v application.IngressMetrics) graphql.Marshaler {
	return ec._IngressMetrics(ctx, sel, &v)
}

func (ec *executionContext) marshalNIngressMetrics2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetrics(ctx context.Context, sel ast.SelectionSet, v *application.IngressMetrics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IngressMetrics(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIngressMetricsInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetricsInput(ctx context.Context, v any) (application.IngressMetricsInput, error) {
	res, err := ec.unmarshalInputIngressMetricsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNIngressMetricsType2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetricsType(ctx context.Context, v any) (application.IngressMetricsType, error) {
	var res application.IngressMetricsType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIngressMetricsType2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressMetricsType(ctx context.Context, sel ast.SelectionSet, v application.IngressMetricsType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNIngressType2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressType(ctx context.Context, v any) (application.IngressType, error) {
	var res application.IngressType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIngressType2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐIngressType(ctx context.Context, sel ast.SelectionSet, v application.IngressType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRestartApplicationInput2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐRestartApplicationInput(ctx context.Context, v any) (application.RestartApplicationInput, error) {
	res, err := ec.unmarshalInputRestartApplicationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRestartApplicationPayload2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐRestartApplicationPayload(ctx context.Context, sel ast.SelectionSet, v application.RestartApplicationPayload) graphql.Marshaler {
	return ec._RestartApplicationPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRestartApplicationPayload2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐRestartApplicationPayload(ctx context.Context, sel ast.SelectionSet, v *application.RestartApplicationPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RestartApplicationPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNScalingDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐScalingDirection(ctx context.Context, v any) (application.ScalingDirection, error) {
	var res application.ScalingDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNScalingDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐScalingDirection(ctx context.Context, sel ast.SelectionSet, v application.ScalingDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNScalingStrategy2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐScalingStrategy(ctx context.Context, sel ast.SelectionSet, v application.ScalingStrategy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScalingStrategy(ctx, sel, v)
}

func (ec *executionContext) marshalNScalingStrategy2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐScalingStrategyᚄ(ctx context.Context, sel ast.SelectionSet, v []application.ScalingStrategy) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNScalingStrategy2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐScalingStrategy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamInventoryCountApplications2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐTeamInventoryCountApplications(ctx context.Context, sel ast.SelectionSet, v application.TeamInventoryCountApplications) graphql.Marshaler {
	return ec._TeamInventoryCountApplications(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamInventoryCountApplications2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐTeamInventoryCountApplications(ctx context.Context, sel ast.SelectionSet, v *application.TeamInventoryCountApplications) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamInventoryCountApplications(ctx, sel, v)
}

func (ec *executionContext) marshalOApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplication(ctx context.Context, sel ast.SelectionSet, v *application.Application) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) unmarshalOApplicationOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplicationOrder(ctx context.Context, v any) (*application.ApplicationOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputApplicationOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTeamApplicationsFilter2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐTeamApplicationsFilter(ctx context.Context, v any) (*application.TeamApplicationsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamApplicationsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

// endregion ***************************** type.gotpl *****************************

// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gengql

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/issue"
	"github.com/nais/api/internal/persistence/opensearch"
	"github.com/nais/api/internal/persistence/sqlinstance"
	"github.com/nais/api/internal/persistence/valkey"
	"github.com/nais/api/internal/team"
	"github.com/nais/api/internal/workload"
	"github.com/nais/api/internal/workload/application"
	"github.com/nais/api/internal/workload/job"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

type DeprecatedIngressIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.DeprecatedIngressIssue) (*team.TeamEnvironment, error)

	Application(ctx context.Context, obj *issue.DeprecatedIngressIssue) (*application.Application, error)
}
type DeprecatedRegistryIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.DeprecatedRegistryIssue) (*team.TeamEnvironment, error)

	Workload(ctx context.Context, obj *issue.DeprecatedRegistryIssue) (workload.Workload, error)
}
type FailedJobRunsIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.FailedJobRunsIssue) (*team.TeamEnvironment, error)

	Job(ctx context.Context, obj *issue.FailedJobRunsIssue) (*job.Job, error)
}
type FailedSynchronizationIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.FailedSynchronizationIssue) (*team.TeamEnvironment, error)

	Workload(ctx context.Context, obj *issue.FailedSynchronizationIssue) (workload.Workload, error)
}
type InvalidSpecIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.InvalidSpecIssue) (*team.TeamEnvironment, error)

	Workload(ctx context.Context, obj *issue.InvalidSpecIssue) (workload.Workload, error)
}
type MissingSbomIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.MissingSbomIssue) (*team.TeamEnvironment, error)

	Workload(ctx context.Context, obj *issue.MissingSbomIssue) (workload.Workload, error)
}
type NoRunningInstancesIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.NoRunningInstancesIssue) (*team.TeamEnvironment, error)

	Workload(ctx context.Context, obj *issue.NoRunningInstancesIssue) (workload.Workload, error)
}
type OpenSearchIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.OpenSearchIssue) (*team.TeamEnvironment, error)

	OpenSearch(ctx context.Context, obj *issue.OpenSearchIssue) (*opensearch.OpenSearch, error)
}
type SqlInstanceStateIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.SqlInstanceStateIssue) (*team.TeamEnvironment, error)

	SQLInstance(ctx context.Context, obj *issue.SqlInstanceStateIssue) (*sqlinstance.SQLInstance, error)
}
type SqlInstanceVersionIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.SqlInstanceVersionIssue) (*team.TeamEnvironment, error)

	SQLInstance(ctx context.Context, obj *issue.SqlInstanceVersionIssue) (*sqlinstance.SQLInstance, error)
}
type ValkeyIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.ValkeyIssue) (*team.TeamEnvironment, error)

	Valkey(ctx context.Context, obj *issue.ValkeyIssue) (*valkey.Valkey, error)
}
type VulnerableImageIssueResolver interface {
	TeamEnvironment(ctx context.Context, obj *issue.VulnerableImageIssue) (*team.TeamEnvironment, error)

	Workload(ctx context.Context, obj *issue.VulnerableImageIssue) (workload.Workload, error)
}

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _DeprecatedIngressIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.DeprecatedIngressIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeprecatedIngressIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeprecatedIngressIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecatedIngressIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecatedIngressIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.DeprecatedIngressIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeprecatedIngressIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.DeprecatedIngressIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeprecatedIngressIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecatedIngressIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecatedIngressIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.DeprecatedIngressIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeprecatedIngressIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeprecatedIngressIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecatedIngressIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecatedIngressIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.DeprecatedIngressIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeprecatedIngressIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeprecatedIngressIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecatedIngressIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecatedIngressIssue_ingresses(ctx context.Context, field graphql.CollectedField, obj *issue.DeprecatedIngressIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeprecatedIngressIssue_ingresses,
		func(ctx context.Context) (any, error) {
			return obj.Ingresses, nil
		},
		nil,
		ec.marshalNString2ᚕstringᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeprecatedIngressIssue_ingresses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecatedIngressIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecatedIngressIssue_application(ctx context.Context, field graphql.CollectedField, obj *issue.DeprecatedIngressIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeprecatedIngressIssue_application,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.DeprecatedIngressIssue().Application(ctx, obj)
		},
		nil,
		ec.marshalNApplication2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋapplicationᚐApplication,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeprecatedIngressIssue_application(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecatedIngressIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Application_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "instances":
				return ec.fieldContext_Application_instances(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Application_deletionStartedAt(ctx, field)
			case "activityLog":
				return ec.fieldContext_Application_activityLog(ctx, field)
			case "state":
				return ec.fieldContext_Application_state(ctx, field)
			case "issues":
				return ec.fieldContext_Application_issues(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Application_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Application_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "secrets":
				return ec.fieldContext_Application_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			case "valkeys":
				return ec.fieldContext_Application_valkeys(ctx, field)
			case "imageVulnerabilityHistory":
				return ec.fieldContext_Application_imageVulnerabilityHistory(ctx, field)
			case "vulnerabilityFixHistory":
				return ec.fieldContext_Application_vulnerabilityFixHistory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecatedRegistryIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.DeprecatedRegistryIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeprecatedRegistryIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeprecatedRegistryIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecatedRegistryIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecatedRegistryIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.DeprecatedRegistryIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeprecatedRegistryIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.DeprecatedRegistryIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeprecatedRegistryIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecatedRegistryIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecatedRegistryIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.DeprecatedRegistryIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeprecatedRegistryIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeprecatedRegistryIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecatedRegistryIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecatedRegistryIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.DeprecatedRegistryIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeprecatedRegistryIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeprecatedRegistryIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecatedRegistryIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecatedRegistryIssue_workload(ctx context.Context, field graphql.CollectedField, obj *issue.DeprecatedRegistryIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeprecatedRegistryIssue_workload,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.DeprecatedRegistryIssue().Workload(ctx, obj)
		},
		nil,
		ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐWorkload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeprecatedRegistryIssue_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecatedRegistryIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedJobRunsIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.FailedJobRunsIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedJobRunsIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedJobRunsIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedJobRunsIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedJobRunsIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.FailedJobRunsIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedJobRunsIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FailedJobRunsIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedJobRunsIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedJobRunsIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedJobRunsIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.FailedJobRunsIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedJobRunsIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedJobRunsIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedJobRunsIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedJobRunsIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.FailedJobRunsIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedJobRunsIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedJobRunsIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedJobRunsIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedJobRunsIssue_job(ctx context.Context, field graphql.CollectedField, obj *issue.FailedJobRunsIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedJobRunsIssue_job,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FailedJobRunsIssue().Job(ctx, obj)
		},
		nil,
		ec.marshalNJob2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚋjobᚐJob,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedJobRunsIssue_job(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedJobRunsIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "name":
				return ec.fieldContext_Job_name(ctx, field)
			case "team":
				return ec.fieldContext_Job_team(ctx, field)
			case "environment":
				return ec.fieldContext_Job_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Job_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Job_image(ctx, field)
			case "resources":
				return ec.fieldContext_Job_resources(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Job_authIntegrations(ctx, field)
			case "schedule":
				return ec.fieldContext_Job_schedule(ctx, field)
			case "runs":
				return ec.fieldContext_Job_runs(ctx, field)
			case "manifest":
				return ec.fieldContext_Job_manifest(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Job_deletionStartedAt(ctx, field)
			case "activityLog":
				return ec.fieldContext_Job_activityLog(ctx, field)
			case "state":
				return ec.fieldContext_Job_state(ctx, field)
			case "issues":
				return ec.fieldContext_Job_issues(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Job_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Job_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Job_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Job_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Job_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Job_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Job_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Job_openSearch(ctx, field)
			case "secrets":
				return ec.fieldContext_Job_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Job_sqlInstances(ctx, field)
			case "valkeys":
				return ec.fieldContext_Job_valkeys(ctx, field)
			case "imageVulnerabilityHistory":
				return ec.fieldContext_Job_imageVulnerabilityHistory(ctx, field)
			case "vulnerabilityFixHistory":
				return ec.fieldContext_Job_vulnerabilityFixHistory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedSynchronizationIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.FailedSynchronizationIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedSynchronizationIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedSynchronizationIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedSynchronizationIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedSynchronizationIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.FailedSynchronizationIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedSynchronizationIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FailedSynchronizationIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedSynchronizationIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedSynchronizationIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedSynchronizationIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.FailedSynchronizationIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedSynchronizationIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedSynchronizationIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedSynchronizationIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedSynchronizationIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.FailedSynchronizationIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedSynchronizationIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedSynchronizationIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedSynchronizationIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedSynchronizationIssue_workload(ctx context.Context, field graphql.CollectedField, obj *issue.FailedSynchronizationIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedSynchronizationIssue_workload,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FailedSynchronizationIssue().Workload(ctx, obj)
		},
		nil,
		ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐWorkload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedSynchronizationIssue_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedSynchronizationIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidSpecIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.InvalidSpecIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvalidSpecIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvalidSpecIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidSpecIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidSpecIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.InvalidSpecIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvalidSpecIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.InvalidSpecIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvalidSpecIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidSpecIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidSpecIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.InvalidSpecIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvalidSpecIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvalidSpecIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidSpecIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidSpecIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.InvalidSpecIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvalidSpecIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvalidSpecIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidSpecIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidSpecIssue_workload(ctx context.Context, field graphql.CollectedField, obj *issue.InvalidSpecIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvalidSpecIssue_workload,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.InvalidSpecIssue().Workload(ctx, obj)
		},
		nil,
		ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐWorkload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvalidSpecIssue_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidSpecIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[issue.Issue]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IssueConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNPageInfo2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IssueConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[issue.Issue]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IssueConnection_nodes,
		func(ctx context.Context) (any, error) {
			return obj.Nodes(), nil
		},
		nil,
		ec.marshalNIssue2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IssueConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[issue.Issue]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IssueConnection_edges,
		func(ctx context.Context) (any, error) {
			return obj.Edges, nil
		},
		nil,
		ec.marshalNIssueEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdgeᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IssueConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_IssueEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_IssueEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[issue.Issue]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IssueEdge_cursor,
		func(ctx context.Context) (any, error) {
			return obj.Cursor, nil
		},
		nil,
		ec.marshalNCursor2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐCursor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IssueEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[issue.Issue]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IssueEdge_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalNIssue2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IssueEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MissingSbomIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.MissingSbomIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MissingSbomIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_MissingSbomIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MissingSbomIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MissingSbomIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.MissingSbomIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MissingSbomIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.MissingSbomIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_MissingSbomIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MissingSbomIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MissingSbomIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.MissingSbomIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MissingSbomIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_MissingSbomIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MissingSbomIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MissingSbomIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.MissingSbomIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MissingSbomIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_MissingSbomIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MissingSbomIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MissingSbomIssue_workload(ctx context.Context, field graphql.CollectedField, obj *issue.MissingSbomIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MissingSbomIssue_workload,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.MissingSbomIssue().Workload(ctx, obj)
		},
		nil,
		ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐWorkload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_MissingSbomIssue_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MissingSbomIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NoRunningInstancesIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.NoRunningInstancesIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NoRunningInstancesIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NoRunningInstancesIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NoRunningInstancesIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NoRunningInstancesIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.NoRunningInstancesIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NoRunningInstancesIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.NoRunningInstancesIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NoRunningInstancesIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NoRunningInstancesIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NoRunningInstancesIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.NoRunningInstancesIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NoRunningInstancesIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NoRunningInstancesIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NoRunningInstancesIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NoRunningInstancesIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.NoRunningInstancesIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NoRunningInstancesIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NoRunningInstancesIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NoRunningInstancesIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NoRunningInstancesIssue_workload(ctx context.Context, field graphql.CollectedField, obj *issue.NoRunningInstancesIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NoRunningInstancesIssue_workload,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.NoRunningInstancesIssue().Workload(ctx, obj)
		},
		nil,
		ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐWorkload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NoRunningInstancesIssue_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NoRunningInstancesIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.OpenSearchIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpenSearchIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OpenSearchIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.OpenSearchIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpenSearchIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.OpenSearchIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OpenSearchIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.OpenSearchIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpenSearchIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OpenSearchIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.OpenSearchIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpenSearchIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OpenSearchIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchIssue_openSearch(ctx context.Context, field graphql.CollectedField, obj *issue.OpenSearchIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpenSearchIssue_openSearch,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.OpenSearchIssue().OpenSearch(ctx, obj)
		},
		nil,
		ec.marshalNOpenSearch2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋopensearchᚐOpenSearch,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OpenSearchIssue_openSearch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_OpenSearch_teamEnvironment(ctx, field)
			case "terminationProtection":
				return ec.fieldContext_OpenSearch_terminationProtection(ctx, field)
			case "state":
				return ec.fieldContext_OpenSearch_state(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "version":
				return ec.fieldContext_OpenSearch_version(ctx, field)
			case "tier":
				return ec.fieldContext_OpenSearch_tier(ctx, field)
			case "memory":
				return ec.fieldContext_OpenSearch_memory(ctx, field)
			case "storageGB":
				return ec.fieldContext_OpenSearch_storageGB(ctx, field)
			case "issues":
				return ec.fieldContext_OpenSearch_issues(ctx, field)
			case "activityLog":
				return ec.fieldContext_OpenSearch_activityLog(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			case "maintenance":
				return ec.fieldContext_OpenSearch_maintenance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchIssue_event(ctx context.Context, field graphql.CollectedField, obj *issue.OpenSearchIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpenSearchIssue_event,
		func(ctx context.Context) (any, error) {
			return obj.Event, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OpenSearchIssue_event(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceStateIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.SqlInstanceStateIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SqlInstanceStateIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SqlInstanceStateIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceStateIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceStateIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.SqlInstanceStateIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SqlInstanceStateIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SqlInstanceStateIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SqlInstanceStateIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceStateIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceStateIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.SqlInstanceStateIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SqlInstanceStateIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SqlInstanceStateIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceStateIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceStateIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.SqlInstanceStateIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SqlInstanceStateIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SqlInstanceStateIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceStateIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceStateIssue_state(ctx context.Context, field graphql.CollectedField, obj *issue.SqlInstanceStateIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SqlInstanceStateIssue_state,
		func(ctx context.Context) (any, error) {
			return obj.State, nil
		},
		nil,
		ec.marshalNSqlInstanceState2githubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋsqlinstanceᚐSQLInstanceState,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SqlInstanceStateIssue_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceStateIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SqlInstanceState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceStateIssue_sqlInstance(ctx context.Context, field graphql.CollectedField, obj *issue.SqlInstanceStateIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SqlInstanceStateIssue_sqlInstance,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SqlInstanceStateIssue().SQLInstance(ctx, obj)
		},
		nil,
		ec.marshalNSqlInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋsqlinstanceᚐSQLInstance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SqlInstanceStateIssue_sqlInstance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceStateIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SqlInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_SqlInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_SqlInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_SqlInstance_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_SqlInstance_teamEnvironment(ctx, field)
			case "workload":
				return ec.fieldContext_SqlInstance_workload(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_SqlInstance_cascadingDelete(ctx, field)
			case "connectionName":
				return ec.fieldContext_SqlInstance_connectionName(ctx, field)
			case "diskAutoresize":
				return ec.fieldContext_SqlInstance_diskAutoresize(ctx, field)
			case "diskAutoresizeLimit":
				return ec.fieldContext_SqlInstance_diskAutoresizeLimit(ctx, field)
			case "highAvailability":
				return ec.fieldContext_SqlInstance_highAvailability(ctx, field)
			case "healthy":
				return ec.fieldContext_SqlInstance_healthy(ctx, field)
			case "maintenanceVersion":
				return ec.fieldContext_SqlInstance_maintenanceVersion(ctx, field)
			case "maintenanceWindow":
				return ec.fieldContext_SqlInstance_maintenanceWindow(ctx, field)
			case "backupConfiguration":
				return ec.fieldContext_SqlInstance_backupConfiguration(ctx, field)
			case "projectID":
				return ec.fieldContext_SqlInstance_projectID(ctx, field)
			case "tier":
				return ec.fieldContext_SqlInstance_tier(ctx, field)
			case "version":
				return ec.fieldContext_SqlInstance_version(ctx, field)
			case "status":
				return ec.fieldContext_SqlInstance_status(ctx, field)
			case "database":
				return ec.fieldContext_SqlInstance_database(ctx, field)
			case "flags":
				return ec.fieldContext_SqlInstance_flags(ctx, field)
			case "users":
				return ec.fieldContext_SqlInstance_users(ctx, field)
			case "metrics":
				return ec.fieldContext_SqlInstance_metrics(ctx, field)
			case "state":
				return ec.fieldContext_SqlInstance_state(ctx, field)
			case "issues":
				return ec.fieldContext_SqlInstance_issues(ctx, field)
			case "cost":
				return ec.fieldContext_SqlInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceVersionIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.SqlInstanceVersionIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SqlInstanceVersionIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SqlInstanceVersionIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceVersionIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceVersionIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.SqlInstanceVersionIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SqlInstanceVersionIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SqlInstanceVersionIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SqlInstanceVersionIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceVersionIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceVersionIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.SqlInstanceVersionIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SqlInstanceVersionIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SqlInstanceVersionIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceVersionIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceVersionIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.SqlInstanceVersionIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SqlInstanceVersionIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SqlInstanceVersionIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceVersionIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceVersionIssue_sqlInstance(ctx context.Context, field graphql.CollectedField, obj *issue.SqlInstanceVersionIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SqlInstanceVersionIssue_sqlInstance,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SqlInstanceVersionIssue().SQLInstance(ctx, obj)
		},
		nil,
		ec.marshalNSqlInstance2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋsqlinstanceᚐSQLInstance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SqlInstanceVersionIssue_sqlInstance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceVersionIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SqlInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_SqlInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_SqlInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_SqlInstance_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_SqlInstance_teamEnvironment(ctx, field)
			case "workload":
				return ec.fieldContext_SqlInstance_workload(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_SqlInstance_cascadingDelete(ctx, field)
			case "connectionName":
				return ec.fieldContext_SqlInstance_connectionName(ctx, field)
			case "diskAutoresize":
				return ec.fieldContext_SqlInstance_diskAutoresize(ctx, field)
			case "diskAutoresizeLimit":
				return ec.fieldContext_SqlInstance_diskAutoresizeLimit(ctx, field)
			case "highAvailability":
				return ec.fieldContext_SqlInstance_highAvailability(ctx, field)
			case "healthy":
				return ec.fieldContext_SqlInstance_healthy(ctx, field)
			case "maintenanceVersion":
				return ec.fieldContext_SqlInstance_maintenanceVersion(ctx, field)
			case "maintenanceWindow":
				return ec.fieldContext_SqlInstance_maintenanceWindow(ctx, field)
			case "backupConfiguration":
				return ec.fieldContext_SqlInstance_backupConfiguration(ctx, field)
			case "projectID":
				return ec.fieldContext_SqlInstance_projectID(ctx, field)
			case "tier":
				return ec.fieldContext_SqlInstance_tier(ctx, field)
			case "version":
				return ec.fieldContext_SqlInstance_version(ctx, field)
			case "status":
				return ec.fieldContext_SqlInstance_status(ctx, field)
			case "database":
				return ec.fieldContext_SqlInstance_database(ctx, field)
			case "flags":
				return ec.fieldContext_SqlInstance_flags(ctx, field)
			case "users":
				return ec.fieldContext_SqlInstance_users(ctx, field)
			case "metrics":
				return ec.fieldContext_SqlInstance_metrics(ctx, field)
			case "state":
				return ec.fieldContext_SqlInstance_state(ctx, field)
			case "issues":
				return ec.fieldContext_SqlInstance_issues(ctx, field)
			case "cost":
				return ec.fieldContext_SqlInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.ValkeyIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ValkeyIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ValkeyIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.ValkeyIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ValkeyIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ValkeyIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ValkeyIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.ValkeyIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ValkeyIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ValkeyIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.ValkeyIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ValkeyIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ValkeyIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyIssue_valkey(ctx context.Context, field graphql.CollectedField, obj *issue.ValkeyIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ValkeyIssue_valkey,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ValkeyIssue().Valkey(ctx, obj)
		},
		nil,
		ec.marshalNValkey2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋpersistenceᚋvalkeyᚐValkey,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ValkeyIssue_valkey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Valkey_id(ctx, field)
			case "name":
				return ec.fieldContext_Valkey_name(ctx, field)
			case "terminationProtection":
				return ec.fieldContext_Valkey_terminationProtection(ctx, field)
			case "team":
				return ec.fieldContext_Valkey_team(ctx, field)
			case "environment":
				return ec.fieldContext_Valkey_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Valkey_teamEnvironment(ctx, field)
			case "access":
				return ec.fieldContext_Valkey_access(ctx, field)
			case "workload":
				return ec.fieldContext_Valkey_workload(ctx, field)
			case "state":
				return ec.fieldContext_Valkey_state(ctx, field)
			case "tier":
				return ec.fieldContext_Valkey_tier(ctx, field)
			case "memory":
				return ec.fieldContext_Valkey_memory(ctx, field)
			case "maxMemoryPolicy":
				return ec.fieldContext_Valkey_maxMemoryPolicy(ctx, field)
			case "issues":
				return ec.fieldContext_Valkey_issues(ctx, field)
			case "activityLog":
				return ec.fieldContext_Valkey_activityLog(ctx, field)
			case "cost":
				return ec.fieldContext_Valkey_cost(ctx, field)
			case "maintenance":
				return ec.fieldContext_Valkey_maintenance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Valkey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyIssue_event(ctx context.Context, field graphql.CollectedField, obj *issue.ValkeyIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ValkeyIssue_event,
		func(ctx context.Context) (any, error) {
			return obj.Event, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ValkeyIssue_event(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerableImageIssue_id(ctx context.Context, field graphql.CollectedField, obj *issue.VulnerableImageIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VulnerableImageIssue_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋidentᚐIdent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_VulnerableImageIssue_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerableImageIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerableImageIssue_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *issue.VulnerableImageIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VulnerableImageIssue_teamEnvironment,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.VulnerableImageIssue().TeamEnvironment(ctx, obj)
		},
		nil,
		ec.marshalNTeamEnvironment2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋteamᚐTeamEnvironment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_VulnerableImageIssue_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerableImageIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "alerts":
				return ec.fieldContext_TeamEnvironment_alerts(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearch":
				return ec.fieldContext_TeamEnvironment_openSearch(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkey":
				return ec.fieldContext_TeamEnvironment_valkey(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerableImageIssue_severity(ctx context.Context, field graphql.CollectedField, obj *issue.VulnerableImageIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VulnerableImageIssue_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_VulnerableImageIssue_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerableImageIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Severity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerableImageIssue_message(ctx context.Context, field graphql.CollectedField, obj *issue.VulnerableImageIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VulnerableImageIssue_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_VulnerableImageIssue_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerableImageIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerableImageIssue_workload(ctx context.Context, field graphql.CollectedField, obj *issue.VulnerableImageIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VulnerableImageIssue_workload,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.VulnerableImageIssue().Workload(ctx, obj)
		},
		nil,
		ec.marshalNWorkload2githubᚗcomᚋnaisᚋapiᚋinternalᚋworkloadᚐWorkload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_VulnerableImageIssue_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerableImageIssue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerableImageIssue_riskScore(ctx context.Context, field graphql.CollectedField, obj *issue.VulnerableImageIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VulnerableImageIssue_riskScore,
		func(ctx context.Context) (any, error) {
			return obj.RiskScore, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_VulnerableImageIssue_riskScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerableImageIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerableImageIssue_critical(ctx context.Context, field graphql.CollectedField, obj *issue.VulnerableImageIssue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VulnerableImageIssue_critical,
		func(ctx context.Context) (any, error) {
			return obj.Critical, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_VulnerableImageIssue_critical(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerableImageIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputIssueFilter(ctx context.Context, obj any) (issue.IssueFilter, error) {
	var it issue.IssueFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"resourceName", "resourceType", "environments", "severity", "issueType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "resourceName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceName = data
		case "resourceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
			data, err := ec.unmarshalOResourceType2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐResourceType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		case "environments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environments"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environments = data
		case "severity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("severity"))
			data, err := ec.unmarshalOSeverity2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Severity = data
		case "issueType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issueType"))
			data, err := ec.unmarshalOIssueType2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueType(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssueType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIssueOrder(ctx context.Context, obj any) (issue.IssueOrder, error) {
	var it issue.IssueOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNIssueOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋmodelᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResourceIssueFilter(ctx context.Context, obj any) (issue.ResourceIssueFilter, error) {
	var it issue.ResourceIssueFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"severity", "issueType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "severity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("severity"))
			data, err := ec.unmarshalOSeverity2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Severity = data
		case "issueType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issueType"))
			data, err := ec.unmarshalOIssueType2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueType(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssueType = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Issue(ctx context.Context, sel ast.SelectionSet, obj issue.Issue) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case issue.VulnerableImageIssue:
		return ec._VulnerableImageIssue(ctx, sel, &obj)
	case *issue.VulnerableImageIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._VulnerableImageIssue(ctx, sel, obj)
	case issue.ValkeyIssue:
		return ec._ValkeyIssue(ctx, sel, &obj)
	case *issue.ValkeyIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._ValkeyIssue(ctx, sel, obj)
	case issue.SqlInstanceVersionIssue:
		return ec._SqlInstanceVersionIssue(ctx, sel, &obj)
	case *issue.SqlInstanceVersionIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlInstanceVersionIssue(ctx, sel, obj)
	case issue.SqlInstanceStateIssue:
		return ec._SqlInstanceStateIssue(ctx, sel, &obj)
	case *issue.SqlInstanceStateIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlInstanceStateIssue(ctx, sel, obj)
	case issue.OpenSearchIssue:
		return ec._OpenSearchIssue(ctx, sel, &obj)
	case *issue.OpenSearchIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._OpenSearchIssue(ctx, sel, obj)
	case issue.NoRunningInstancesIssue:
		return ec._NoRunningInstancesIssue(ctx, sel, &obj)
	case *issue.NoRunningInstancesIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._NoRunningInstancesIssue(ctx, sel, obj)
	case issue.MissingSbomIssue:
		return ec._MissingSbomIssue(ctx, sel, &obj)
	case *issue.MissingSbomIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._MissingSbomIssue(ctx, sel, obj)
	case issue.InvalidSpecIssue:
		return ec._InvalidSpecIssue(ctx, sel, &obj)
	case *issue.InvalidSpecIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvalidSpecIssue(ctx, sel, obj)
	case issue.FailedSynchronizationIssue:
		return ec._FailedSynchronizationIssue(ctx, sel, &obj)
	case *issue.FailedSynchronizationIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._FailedSynchronizationIssue(ctx, sel, obj)
	case issue.FailedJobRunsIssue:
		return ec._FailedJobRunsIssue(ctx, sel, &obj)
	case *issue.FailedJobRunsIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._FailedJobRunsIssue(ctx, sel, obj)
	case issue.DeprecatedRegistryIssue:
		return ec._DeprecatedRegistryIssue(ctx, sel, &obj)
	case *issue.DeprecatedRegistryIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeprecatedRegistryIssue(ctx, sel, obj)
	case issue.DeprecatedIngressIssue:
		return ec._DeprecatedIngressIssue(ctx, sel, &obj)
	case *issue.DeprecatedIngressIssue:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeprecatedIngressIssue(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var deprecatedIngressIssueImplementors = []string{"DeprecatedIngressIssue", "Issue", "Node"}

func (ec *executionContext) _DeprecatedIngressIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.DeprecatedIngressIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deprecatedIngressIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeprecatedIngressIssue")
		case "id":
			out.Values[i] = ec._DeprecatedIngressIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeprecatedIngressIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._DeprecatedIngressIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._DeprecatedIngressIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ingresses":
			out.Values[i] = ec._DeprecatedIngressIssue_ingresses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "application":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeprecatedIngressIssue_application(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deprecatedRegistryIssueImplementors = []string{"DeprecatedRegistryIssue", "Issue", "Node"}

func (ec *executionContext) _DeprecatedRegistryIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.DeprecatedRegistryIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deprecatedRegistryIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeprecatedRegistryIssue")
		case "id":
			out.Values[i] = ec._DeprecatedRegistryIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeprecatedRegistryIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._DeprecatedRegistryIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._DeprecatedRegistryIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeprecatedRegistryIssue_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var failedJobRunsIssueImplementors = []string{"FailedJobRunsIssue", "Issue", "Node"}

func (ec *executionContext) _FailedJobRunsIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.FailedJobRunsIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, failedJobRunsIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FailedJobRunsIssue")
		case "id":
			out.Values[i] = ec._FailedJobRunsIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FailedJobRunsIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._FailedJobRunsIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._FailedJobRunsIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "job":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FailedJobRunsIssue_job(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var failedSynchronizationIssueImplementors = []string{"FailedSynchronizationIssue", "Issue", "Node"}

func (ec *executionContext) _FailedSynchronizationIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.FailedSynchronizationIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, failedSynchronizationIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FailedSynchronizationIssue")
		case "id":
			out.Values[i] = ec._FailedSynchronizationIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FailedSynchronizationIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._FailedSynchronizationIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._FailedSynchronizationIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FailedSynchronizationIssue_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var invalidSpecIssueImplementors = []string{"InvalidSpecIssue", "Issue", "Node"}

func (ec *executionContext) _InvalidSpecIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.InvalidSpecIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invalidSpecIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvalidSpecIssue")
		case "id":
			out.Values[i] = ec._InvalidSpecIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InvalidSpecIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._InvalidSpecIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._InvalidSpecIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InvalidSpecIssue_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var issueConnectionImplementors = []string{"IssueConnection"}

func (ec *executionContext) _IssueConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[issue.Issue]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, issueConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IssueConnection")
		case "pageInfo":
			out.Values[i] = ec._IssueConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._IssueConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._IssueConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var issueEdgeImplementors = []string{"IssueEdge"}

func (ec *executionContext) _IssueEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[issue.Issue]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, issueEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IssueEdge")
		case "cursor":
			out.Values[i] = ec._IssueEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._IssueEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var missingSbomIssueImplementors = []string{"MissingSbomIssue", "Issue", "Node"}

func (ec *executionContext) _MissingSbomIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.MissingSbomIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, missingSbomIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MissingSbomIssue")
		case "id":
			out.Values[i] = ec._MissingSbomIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MissingSbomIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._MissingSbomIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._MissingSbomIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MissingSbomIssue_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var noRunningInstancesIssueImplementors = []string{"NoRunningInstancesIssue", "Issue", "Node"}

func (ec *executionContext) _NoRunningInstancesIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.NoRunningInstancesIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, noRunningInstancesIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NoRunningInstancesIssue")
		case "id":
			out.Values[i] = ec._NoRunningInstancesIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._NoRunningInstancesIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._NoRunningInstancesIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._NoRunningInstancesIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._NoRunningInstancesIssue_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchIssueImplementors = []string{"OpenSearchIssue", "Issue", "Node"}

func (ec *executionContext) _OpenSearchIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.OpenSearchIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchIssue")
		case "id":
			out.Values[i] = ec._OpenSearchIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearchIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._OpenSearchIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._OpenSearchIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "openSearch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearchIssue_openSearch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "event":
			out.Values[i] = ec._OpenSearchIssue_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceStateIssueImplementors = []string{"SqlInstanceStateIssue", "Issue", "Node"}

func (ec *executionContext) _SqlInstanceStateIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.SqlInstanceStateIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceStateIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceStateIssue")
		case "id":
			out.Values[i] = ec._SqlInstanceStateIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstanceStateIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._SqlInstanceStateIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._SqlInstanceStateIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "state":
			out.Values[i] = ec._SqlInstanceStateIssue_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sqlInstance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstanceStateIssue_sqlInstance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceVersionIssueImplementors = []string{"SqlInstanceVersionIssue", "Issue", "Node"}

func (ec *executionContext) _SqlInstanceVersionIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.SqlInstanceVersionIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceVersionIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceVersionIssue")
		case "id":
			out.Values[i] = ec._SqlInstanceVersionIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstanceVersionIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._SqlInstanceVersionIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._SqlInstanceVersionIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sqlInstance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstanceVersionIssue_sqlInstance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var valkeyIssueImplementors = []string{"ValkeyIssue", "Issue", "Node"}

func (ec *executionContext) _ValkeyIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.ValkeyIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, valkeyIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValkeyIssue")
		case "id":
			out.Values[i] = ec._ValkeyIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValkeyIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._ValkeyIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._ValkeyIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "valkey":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValkeyIssue_valkey(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "event":
			out.Values[i] = ec._ValkeyIssue_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vulnerableImageIssueImplementors = []string{"VulnerableImageIssue", "Issue", "Node"}

func (ec *executionContext) _VulnerableImageIssue(ctx context.Context, sel ast.SelectionSet, obj *issue.VulnerableImageIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vulnerableImageIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VulnerableImageIssue")
		case "id":
			out.Values[i] = ec._VulnerableImageIssue_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VulnerableImageIssue_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "severity":
			out.Values[i] = ec._VulnerableImageIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._VulnerableImageIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VulnerableImageIssue_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "riskScore":
			out.Values[i] = ec._VulnerableImageIssue_riskScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "critical":
			out.Values[i] = ec._VulnerableImageIssue_critical(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNIssue2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssue(ctx context.Context, sel ast.SelectionSet, v issue.Issue) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Issue(ctx, sel, v)
}

func (ec *executionContext) marshalNIssue2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueᚄ(ctx context.Context, sel ast.SelectionSet, v []issue.Issue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIssue2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIssueConnection2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[issue.Issue]) graphql.Marshaler {
	return ec._IssueConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNIssueConnection2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[issue.Issue]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IssueConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNIssueEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[issue.Issue]) graphql.Marshaler {
	return ec._IssueEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNIssueEdge2ᚕgithubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[issue.Issue]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIssueEdge2githubᚗcomᚋnaisᚋapiᚋinternalᚋgraphᚋpaginationᚐEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNIssueOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueOrderField(ctx context.Context, v any) (issue.IssueOrderField, error) {
	var res issue.IssueOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIssueOrderField2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueOrderField(ctx context.Context, sel ast.SelectionSet, v issue.IssueOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity(ctx context.Context, v any) (issue.Severity, error) {
	var res issue.Severity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSeverity2githubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity(ctx context.Context, sel ast.SelectionSet, v issue.Severity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOIssueFilter2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueFilter(ctx context.Context, v any) (*issue.IssueFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputIssueFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOIssueOrder2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueOrder(ctx context.Context, v any) (*issue.IssueOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputIssueOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOIssueType2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueType(ctx context.Context, v any) (*issue.IssueType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(issue.IssueType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOIssueType2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐIssueType(ctx context.Context, sel ast.SelectionSet, v *issue.IssueType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOResourceIssueFilter2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐResourceIssueFilter(ctx context.Context, v any) (*issue.ResourceIssueFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputResourceIssueFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOResourceType2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐResourceType(ctx context.Context, v any) (*issue.ResourceType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(issue.ResourceType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOResourceType2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐResourceType(ctx context.Context, sel ast.SelectionSet, v *issue.ResourceType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSeverity2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity(ctx context.Context, v any) (*issue.Severity, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(issue.Severity)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSeverity2ᚖgithubᚗcomᚋnaisᚋapiᚋinternalᚋissueᚐSeverity(ctx context.Context, sel ast.SelectionSet, v *issue.Severity) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

// endregion ***************************** type.gotpl *****************************

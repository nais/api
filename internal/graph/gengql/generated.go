// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gengql

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/nais/api/internal/activitylog"
	"github.com/nais/api/internal/auth/authz"
	"github.com/nais/api/internal/cost"
	"github.com/nais/api/internal/deployment"
	"github.com/nais/api/internal/environment"
	"github.com/nais/api/internal/feature"
	"github.com/nais/api/internal/github/repository"
	"github.com/nais/api/internal/graph/ident"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/persistence"
	"github.com/nais/api/internal/persistence/bigquery"
	"github.com/nais/api/internal/persistence/bucket"
	"github.com/nais/api/internal/persistence/kafkatopic"
	"github.com/nais/api/internal/persistence/opensearch"
	"github.com/nais/api/internal/persistence/redis"
	"github.com/nais/api/internal/persistence/sqlinstance"
	"github.com/nais/api/internal/persistence/valkey"
	"github.com/nais/api/internal/reconciler"
	"github.com/nais/api/internal/search"
	"github.com/nais/api/internal/serviceaccount"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/status"
	"github.com/nais/api/internal/team"
	"github.com/nais/api/internal/unleash"
	"github.com/nais/api/internal/user"
	"github.com/nais/api/internal/usersync"
	"github.com/nais/api/internal/utilization"
	"github.com/nais/api/internal/vulnerability"
	"github.com/nais/api/internal/workload"
	"github.com/nais/api/internal/workload/application"
	"github.com/nais/api/internal/workload/job"
	"github.com/nais/api/internal/workload/logging"
	"github.com/nais/api/internal/workload/netpol"
	"github.com/nais/api/internal/workload/podlog"
	"github.com/nais/api/internal/workload/secret"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Application() ApplicationResolver
	BigQueryDataset() BigQueryDatasetResolver
	Bucket() BucketResolver
	ContainerImage() ContainerImageResolver
	ContainerImageWorkloadReference() ContainerImageWorkloadReferenceResolver
	DeleteApplicationPayload() DeleteApplicationPayloadResolver
	DeleteJobPayload() DeleteJobPayloadResolver
	Deployment() DeploymentResolver
	Environment() EnvironmentResolver
	ImageVulnerability() ImageVulnerabilityResolver
	ImageVulnerabilityAnalysisTrail() ImageVulnerabilityAnalysisTrailResolver
	Ingress() IngressResolver
	Job() JobResolver
	JobRun() JobRunResolver
	KafkaTopic() KafkaTopicResolver
	KafkaTopicAcl() KafkaTopicAclResolver
	Mutation() MutationResolver
	NetworkPolicyRule() NetworkPolicyRuleResolver
	OpenSearch() OpenSearchResolver
	OpenSearchAccess() OpenSearchAccessResolver
	Query() QueryResolver
	Reconciler() ReconcilerResolver
	ReconcilerError() ReconcilerErrorResolver
	RedisInstance() RedisInstanceResolver
	RedisInstanceAccess() RedisInstanceAccessResolver
	RemoveTeamMemberPayload() RemoveTeamMemberPayloadResolver
	Repository() RepositoryResolver
	RestartApplicationPayload() RestartApplicationPayloadResolver
	Secret() SecretResolver
	ServiceAccount() ServiceAccountResolver
	SqlDatabase() SqlDatabaseResolver
	SqlInstance() SqlInstanceResolver
	SqlInstanceMetrics() SqlInstanceMetricsResolver
	Subscription() SubscriptionResolver
	Team() TeamResolver
	TeamCost() TeamCostResolver
	TeamDeleteKey() TeamDeleteKeyResolver
	TeamEnvironment() TeamEnvironmentResolver
	TeamEnvironmentCost() TeamEnvironmentCostResolver
	TeamInventoryCountApplications() TeamInventoryCountApplicationsResolver
	TeamInventoryCountJobs() TeamInventoryCountJobsResolver
	TeamInventoryCounts() TeamInventoryCountsResolver
	TeamMember() TeamMemberResolver
	TeamServiceUtilization() TeamServiceUtilizationResolver
	TeamServiceUtilizationSqlInstances() TeamServiceUtilizationSqlInstancesResolver
	TeamUtilizationData() TeamUtilizationDataResolver
	TeamVulnerabilitySummary() TeamVulnerabilitySummaryResolver
	TriggerJobPayload() TriggerJobPayloadResolver
	UnleashInstance() UnleashInstanceResolver
	UnleashInstanceMetrics() UnleashInstanceMetricsResolver
	UpdateTeamEnvironmentPayload() UpdateTeamEnvironmentPayloadResolver
	User() UserResolver
	ValkeyInstance() ValkeyInstanceResolver
	ValkeyInstanceAccess() ValkeyInstanceAccessResolver
	WorkloadCost() WorkloadCostResolver
	WorkloadCostSample() WorkloadCostSampleResolver
	WorkloadUtilization() WorkloadUtilizationResolver
	WorkloadUtilizationData() WorkloadUtilizationDataResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	ActivityLogEntryConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ActivityLogEntryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	AddRepositoryToTeamPayload struct {
		Repository func(childComplexity int) int
	}

	AddSecretValuePayload struct {
		Secret func(childComplexity int) int
	}

	AddTeamMemberPayload struct {
		Member func(childComplexity int) int
	}

	AllowTeamAccessToUnleashPayload struct {
		Unleash func(childComplexity int) int
	}

	Application struct {
		AuthIntegrations  func(childComplexity int) int
		BigQueryDatasets  func(childComplexity int, orderBy *bigquery.BigQueryDatasetOrder) int
		Buckets           func(childComplexity int, orderBy *bucket.BucketOrder) int
		Cost              func(childComplexity int) int
		DeletionStartedAt func(childComplexity int) int
		Deployments       func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Environment       func(childComplexity int) int
		ID                func(childComplexity int) int
		Image             func(childComplexity int) int
		Ingresses         func(childComplexity int) int
		Instances         func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		KafkaTopicAcls    func(childComplexity int, orderBy *kafkatopic.KafkaTopicACLOrder) int
		LogDestinations   func(childComplexity int) int
		Manifest          func(childComplexity int) int
		Name              func(childComplexity int) int
		NetworkPolicy     func(childComplexity int) int
		OpenSearch        func(childComplexity int) int
		RedisInstances    func(childComplexity int, orderBy *redis.RedisInstanceOrder) int
		Resources         func(childComplexity int) int
		SQLInstances      func(childComplexity int, orderBy *sqlinstance.SQLInstanceOrder) int
		Secrets           func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Status            func(childComplexity int) int
		Team              func(childComplexity int) int
		TeamEnvironment   func(childComplexity int) int
		Utilization       func(childComplexity int) int
		ValkeyInstances   func(childComplexity int, orderBy *valkey.ValkeyInstanceOrder) int
	}

	ApplicationConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ApplicationDeletedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	ApplicationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ApplicationInstance struct {
		Created  func(childComplexity int) int
		ID       func(childComplexity int) int
		Image    func(childComplexity int) int
		Name     func(childComplexity int) int
		Restarts func(childComplexity int) int
		Status   func(childComplexity int) int
	}

	ApplicationInstanceConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ApplicationInstanceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ApplicationInstanceStatus struct {
		Message func(childComplexity int) int
		State   func(childComplexity int) int
	}

	ApplicationManifest struct {
		Content func(childComplexity int) int
	}

	ApplicationResources struct {
		Limits   func(childComplexity int) int
		Requests func(childComplexity int) int
		Scaling  func(childComplexity int) int
	}

	ApplicationRestartedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	ApplicationScaling struct {
		MaxInstances func(childComplexity int) int
		MinInstances func(childComplexity int) int
		Strategies   func(childComplexity int) int
	}

	AssignRoleToServiceAccountPayload struct {
		ServiceAccount func(childComplexity int) int
	}

	BigQueryDataset struct {
		Access          func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bigquery.BigQueryDatasetAccessOrder) int
		CascadingDelete func(childComplexity int) int
		Cost            func(childComplexity int) int
		Description     func(childComplexity int) int
		Environment     func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Status          func(childComplexity int) int
		Team            func(childComplexity int) int
		TeamEnvironment func(childComplexity int) int
		Workload        func(childComplexity int) int
	}

	BigQueryDatasetAccess struct {
		Email func(childComplexity int) int
		Role  func(childComplexity int) int
	}

	BigQueryDatasetAccessConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	BigQueryDatasetAccessEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BigQueryDatasetConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	BigQueryDatasetCost struct {
		Sum func(childComplexity int) int
	}

	BigQueryDatasetEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BigQueryDatasetStatus struct {
		CreationTime     func(childComplexity int) int
		LastModifiedTime func(childComplexity int) int
	}

	Bucket struct {
		CascadingDelete          func(childComplexity int) int
		Environment              func(childComplexity int) int
		ID                       func(childComplexity int) int
		Name                     func(childComplexity int) int
		PublicAccessPrevention   func(childComplexity int) int
		Status                   func(childComplexity int) int
		Team                     func(childComplexity int) int
		TeamEnvironment          func(childComplexity int) int
		UniformBucketLevelAccess func(childComplexity int) int
		Workload                 func(childComplexity int) int
	}

	BucketConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	BucketEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BucketError struct {
		Details func(childComplexity int) int
		Message func(childComplexity int) int
	}

	BucketStatus struct {
		Errors func(childComplexity int) int
		State  func(childComplexity int) int
	}

	CPUScalingStrategy struct {
		Threshold func(childComplexity int) int
	}

	ChangeDeploymentKeyPayload struct {
		DeploymentKey func(childComplexity int) int
	}

	ConfirmTeamDeletionPayload struct {
		DeletionStarted func(childComplexity int) int
	}

	ContainerImage struct {
		HasSbom              func(childComplexity int) int
		ID                   func(childComplexity int) int
		Name                 func(childComplexity int) int
		Tag                  func(childComplexity int) int
		Vulnerabilities      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *vulnerability.ImageVulnerabilityOrder) int
		VulnerabilitySummary func(childComplexity int) int
		WorkloadReferences   func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
	}

	ContainerImageWorkloadReference struct {
		Workload func(childComplexity int) int
	}

	ContainerImageWorkloadReferenceConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ContainerImageWorkloadReferenceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	CreateSecretPayload struct {
		Secret func(childComplexity int) int
	}

	CreateServiceAccountPayload struct {
		ServiceAccount func(childComplexity int) int
	}

	CreateServiceAccountTokenPayload struct {
		Secret              func(childComplexity int) int
		ServiceAccount      func(childComplexity int) int
		ServiceAccountToken func(childComplexity int) int
	}

	CreateTeamPayload struct {
		Team func(childComplexity int) int
	}

	CreateUnleashForTeamPayload struct {
		Unleash func(childComplexity int) int
	}

	DeleteApplicationPayload struct {
		Success func(childComplexity int) int
		Team    func(childComplexity int) int
	}

	DeleteJobPayload struct {
		Success func(childComplexity int) int
		Team    func(childComplexity int) int
	}

	DeleteSecretPayload struct {
		SecretDeleted func(childComplexity int) int
	}

	DeleteServiceAccountPayload struct {
		ServiceAccountDeleted func(childComplexity int) int
	}

	DeleteServiceAccountTokenPayload struct {
		ServiceAccount             func(childComplexity int) int
		ServiceAccountTokenDeleted func(childComplexity int) int
	}

	Deployment struct {
		CommitSha        func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		DeployerUsername func(childComplexity int) int
		EnvironmentName  func(childComplexity int) int
		ID               func(childComplexity int) int
		Repository       func(childComplexity int) int
		Resources        func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Statuses         func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		TeamSlug         func(childComplexity int) int
		TriggerUrl       func(childComplexity int) int
	}

	DeploymentConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	DeploymentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	DeploymentKey struct {
		Created func(childComplexity int) int
		Expires func(childComplexity int) int
		ID      func(childComplexity int) int
		Key     func(childComplexity int) int
	}

	DeploymentResource struct {
		ID   func(childComplexity int) int
		Kind func(childComplexity int) int
		Name func(childComplexity int) int
	}

	DeploymentResourceConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	DeploymentResourceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	DeploymentStatus struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		State     func(childComplexity int) int
	}

	DeploymentStatusConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	DeploymentStatusEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	EntraIDAuthIntegration struct {
		Name func(childComplexity int) int
	}

	Environment struct {
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Workloads func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *workload.EnvironmentWorkloadOrder) int
	}

	EnvironmentConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	EnvironmentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ExternalNetworkPolicyHost struct {
		Ports  func(childComplexity int) int
		Target func(childComplexity int) int
	}

	ExternalNetworkPolicyIpv4 struct {
		Ports  func(childComplexity int) int
		Target func(childComplexity int) int
	}

	FeatureKafka struct {
		Enabled func(childComplexity int) int
		ID      func(childComplexity int) int
	}

	FeatureOpenSearch struct {
		Enabled func(childComplexity int) int
		ID      func(childComplexity int) int
	}

	FeatureRedis struct {
		Enabled func(childComplexity int) int
		ID      func(childComplexity int) int
	}

	FeatureUnleash struct {
		Enabled func(childComplexity int) int
		ID      func(childComplexity int) int
	}

	FeatureValkey struct {
		Enabled func(childComplexity int) int
		ID      func(childComplexity int) int
	}

	Features struct {
		ID         func(childComplexity int) int
		Kafka      func(childComplexity int) int
		OpenSearch func(childComplexity int) int
		Redis      func(childComplexity int) int
		Unleash    func(childComplexity int) int
		Valkey     func(childComplexity int) int
	}

	IDPortenAuthIntegration struct {
		Name func(childComplexity int) int
	}

	ImageVulnerability struct {
		AnalysisTrail func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		Identifier    func(childComplexity int) int
		Package       func(childComplexity int) int
		Severity      func(childComplexity int) int
		State         func(childComplexity int) int
	}

	ImageVulnerabilityAnalysisComment struct {
		Comment    func(childComplexity int) int
		OnBehalfOf func(childComplexity int) int
		State      func(childComplexity int) int
		Suppressed func(childComplexity int) int
		Timestamp  func(childComplexity int) int
	}

	ImageVulnerabilityAnalysisCommentConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ImageVulnerabilityAnalysisCommentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ImageVulnerabilityAnalysisTrail struct {
		Comments   func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		State      func(childComplexity int) int
		Suppressed func(childComplexity int) int
	}

	ImageVulnerabilityConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ImageVulnerabilityEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ImageVulnerabilitySummary struct {
		Critical   func(childComplexity int) int
		High       func(childComplexity int) int
		Low        func(childComplexity int) int
		Medium     func(childComplexity int) int
		RiskScore  func(childComplexity int) int
		Total      func(childComplexity int) int
		Unassigned func(childComplexity int) int
	}

	InboundNetworkPolicy struct {
		Rules func(childComplexity int) int
	}

	Ingress struct {
		Type func(childComplexity int) int
		URL  func(childComplexity int) int
	}

	Job struct {
		AuthIntegrations  func(childComplexity int) int
		BigQueryDatasets  func(childComplexity int, orderBy *bigquery.BigQueryDatasetOrder) int
		Buckets           func(childComplexity int, orderBy *bucket.BucketOrder) int
		Cost              func(childComplexity int) int
		DeletionStartedAt func(childComplexity int) int
		Deployments       func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Environment       func(childComplexity int) int
		ID                func(childComplexity int) int
		Image             func(childComplexity int) int
		KafkaTopicAcls    func(childComplexity int, orderBy *kafkatopic.KafkaTopicACLOrder) int
		LogDestinations   func(childComplexity int) int
		Manifest          func(childComplexity int) int
		Name              func(childComplexity int) int
		NetworkPolicy     func(childComplexity int) int
		OpenSearch        func(childComplexity int) int
		RedisInstances    func(childComplexity int, orderBy *redis.RedisInstanceOrder) int
		Resources         func(childComplexity int) int
		Runs              func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		SQLInstances      func(childComplexity int, orderBy *sqlinstance.SQLInstanceOrder) int
		Schedule          func(childComplexity int) int
		Secrets           func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Status            func(childComplexity int) int
		Team              func(childComplexity int) int
		TeamEnvironment   func(childComplexity int) int
		ValkeyInstances   func(childComplexity int, orderBy *valkey.ValkeyInstanceOrder) int
	}

	JobConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	JobDeletedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	JobEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	JobManifest struct {
		Content func(childComplexity int) int
	}

	JobResources struct {
		Limits   func(childComplexity int) int
		Requests func(childComplexity int) int
	}

	JobRun struct {
		CompletionTime func(childComplexity int) int
		Duration       func(childComplexity int) int
		ID             func(childComplexity int) int
		Image          func(childComplexity int) int
		Instances      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Name           func(childComplexity int) int
		StartTime      func(childComplexity int) int
		Status         func(childComplexity int) int
		Trigger        func(childComplexity int) int
	}

	JobRunConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	JobRunEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	JobRunInstance struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	JobRunInstanceConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	JobRunInstanceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	JobRunStatus struct {
		Message func(childComplexity int) int
		State   func(childComplexity int) int
	}

	JobRunTrigger struct {
		Actor func(childComplexity int) int
		Type  func(childComplexity int) int
	}

	JobSchedule struct {
		Expression func(childComplexity int) int
		TimeZone   func(childComplexity int) int
	}

	JobTriggeredActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	KafkaLagScalingStrategy struct {
		ConsumerGroup func(childComplexity int) int
		Threshold     func(childComplexity int) int
		TopicName     func(childComplexity int) int
	}

	KafkaTopic struct {
		ACL             func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter *kafkatopic.KafkaTopicACLFilter, orderBy *kafkatopic.KafkaTopicACLOrder) int
		Configuration   func(childComplexity int) int
		Environment     func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Pool            func(childComplexity int) int
		Team            func(childComplexity int) int
		TeamEnvironment func(childComplexity int) int
	}

	KafkaTopicAcl struct {
		Access       func(childComplexity int) int
		Team         func(childComplexity int) int
		TeamName     func(childComplexity int) int
		Topic        func(childComplexity int) int
		Workload     func(childComplexity int) int
		WorkloadName func(childComplexity int) int
	}

	KafkaTopicAclConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	KafkaTopicAclEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	KafkaTopicConfiguration struct {
		CleanupPolicy         func(childComplexity int) int
		MaxMessageBytes       func(childComplexity int) int
		MinimumInSyncReplicas func(childComplexity int) int
		Partitions            func(childComplexity int) int
		Replication           func(childComplexity int) int
		RetentionBytes        func(childComplexity int) int
		RetentionHours        func(childComplexity int) int
		SegmentHours          func(childComplexity int) int
	}

	KafkaTopicConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	KafkaTopicEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	LogDestinationLoki struct {
		GrafanaURL func(childComplexity int) int
		ID         func(childComplexity int) int
	}

	LogDestinationSecureLogs struct {
		ID func(childComplexity int) int
	}

	MaskinportenAuthIntegration struct {
		Name func(childComplexity int) int
	}

	Mutation struct {
		AddRepositoryToTeam          func(childComplexity int, input repository.AddRepositoryToTeamInput) int
		AddSecretValue               func(childComplexity int, input secret.AddSecretValueInput) int
		AddTeamMember                func(childComplexity int, input team.AddTeamMemberInput) int
		AllowTeamAccessToUnleash     func(childComplexity int, input unleash.AllowTeamAccessToUnleashInput) int
		AssignRoleToServiceAccount   func(childComplexity int, input serviceaccount.AssignRoleToServiceAccountInput) int
		ChangeDeploymentKey          func(childComplexity int, input deployment.ChangeDeploymentKeyInput) int
		ConfigureReconciler          func(childComplexity int, input reconciler.ConfigureReconcilerInput) int
		ConfirmTeamDeletion          func(childComplexity int, input team.ConfirmTeamDeletionInput) int
		CreateSecret                 func(childComplexity int, input secret.CreateSecretInput) int
		CreateServiceAccount         func(childComplexity int, input serviceaccount.CreateServiceAccountInput) int
		CreateServiceAccountToken    func(childComplexity int, input serviceaccount.CreateServiceAccountTokenInput) int
		CreateTeam                   func(childComplexity int, input team.CreateTeamInput) int
		CreateUnleashForTeam         func(childComplexity int, input unleash.CreateUnleashForTeamInput) int
		DeleteApplication            func(childComplexity int, input application.DeleteApplicationInput) int
		DeleteJob                    func(childComplexity int, input job.DeleteJobInput) int
		DeleteSecret                 func(childComplexity int, input secret.DeleteSecretInput) int
		DeleteServiceAccount         func(childComplexity int, input serviceaccount.DeleteServiceAccountInput) int
		DeleteServiceAccountToken    func(childComplexity int, input serviceaccount.DeleteServiceAccountTokenInput) int
		DisableReconciler            func(childComplexity int, input reconciler.DisableReconcilerInput) int
		EnableReconciler             func(childComplexity int, input reconciler.EnableReconcilerInput) int
		RemoveRepositoryFromTeam     func(childComplexity int, input repository.RemoveRepositoryFromTeamInput) int
		RemoveSecretValue            func(childComplexity int, input secret.RemoveSecretValueInput) int
		RemoveTeamMember             func(childComplexity int, input team.RemoveTeamMemberInput) int
		RequestTeamDeletion          func(childComplexity int, input team.RequestTeamDeletionInput) int
		RestartApplication           func(childComplexity int, input application.RestartApplicationInput) int
		RevokeRoleFromServiceAccount func(childComplexity int, input serviceaccount.RevokeRoleFromServiceAccountInput) int
		RevokeTeamAccessToUnleash    func(childComplexity int, input unleash.RevokeTeamAccessToUnleashInput) int
		SetTeamMemberRole            func(childComplexity int, input team.SetTeamMemberRoleInput) int
		TriggerJob                   func(childComplexity int, input job.TriggerJobInput) int
		UpdateImageVulnerability     func(childComplexity int, input vulnerability.UpdateImageVulnerabilityInput) int
		UpdateSecretValue            func(childComplexity int, input secret.UpdateSecretValueInput) int
		UpdateServiceAccount         func(childComplexity int, input serviceaccount.UpdateServiceAccountInput) int
		UpdateServiceAccountToken    func(childComplexity int, input serviceaccount.UpdateServiceAccountTokenInput) int
		UpdateTeam                   func(childComplexity int, input team.UpdateTeamInput) int
		UpdateTeamEnvironment        func(childComplexity int, input team.UpdateTeamEnvironmentInput) int
	}

	NetworkPolicy struct {
		Inbound  func(childComplexity int) int
		Outbound func(childComplexity int) int
	}

	NetworkPolicyRule struct {
		Mutual             func(childComplexity int) int
		TargetTeam         func(childComplexity int) int
		TargetTeamSlug     func(childComplexity int) int
		TargetWorkload     func(childComplexity int) int
		TargetWorkloadName func(childComplexity int) int
	}

	OpenSearch struct {
		Access          func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *opensearch.OpenSearchAccessOrder) int
		Cost            func(childComplexity int) int
		Environment     func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Status          func(childComplexity int) int
		Team            func(childComplexity int) int
		TeamEnvironment func(childComplexity int) int
		Workload        func(childComplexity int) int
	}

	OpenSearchAccess struct {
		Access   func(childComplexity int) int
		Workload func(childComplexity int) int
	}

	OpenSearchAccessConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	OpenSearchAccessEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	OpenSearchConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	OpenSearchCost struct {
		Sum func(childComplexity int) int
	}

	OpenSearchEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	OpenSearchStatus struct {
		State func(childComplexity int) int
	}

	OutboundNetworkPolicy struct {
		External func(childComplexity int) int
		Rules    func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		PageEnd         func(childComplexity int) int
		PageStart       func(childComplexity int) int
		StartCursor     func(childComplexity int) int
		TotalCount      func(childComplexity int) int
	}

	Query struct {
		Environment      func(childComplexity int, name string) int
		Environments     func(childComplexity int, orderBy *environment.EnvironmentOrder) int
		Features         func(childComplexity int) int
		Me               func(childComplexity int) int
		Node             func(childComplexity int, id ident.Ident) int
		Reconcilers      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Roles            func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Search           func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter search.SearchFilter) int
		ServiceAccount   func(childComplexity int, id ident.Ident) int
		ServiceAccounts  func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Team             func(childComplexity int, slug slug.Slug) int
		Teams            func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.TeamOrder) int
		TeamsUtilization func(childComplexity int, resourceType utilization.UtilizationResourceType) int
		User             func(childComplexity int, email *string) int
		UserSyncLog      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Users            func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *user.UserOrder) int
	}

	Reconciler struct {
		ActivityLog func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Config      func(childComplexity int) int
		Configured  func(childComplexity int) int
		Description func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Enabled     func(childComplexity int) int
		Errors      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	ReconcilerConfig struct {
		Configured  func(childComplexity int) int
		Description func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Key         func(childComplexity int) int
		Secret      func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	ReconcilerConfiguredActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	ReconcilerConfiguredActivityLogEntryData struct {
		UpdatedKeys func(childComplexity int) int
	}

	ReconcilerConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ReconcilerDisabledActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	ReconcilerEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ReconcilerEnabledActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	ReconcilerError struct {
		CorrelationID func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		ID            func(childComplexity int) int
		Message       func(childComplexity int) int
		Team          func(childComplexity int) int
	}

	ReconcilerErrorConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ReconcilerErrorEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RedisInstance struct {
		Access          func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *redis.RedisInstanceAccessOrder) int
		Cost            func(childComplexity int) int
		Environment     func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Status          func(childComplexity int) int
		Team            func(childComplexity int) int
		TeamEnvironment func(childComplexity int) int
		Workload        func(childComplexity int) int
	}

	RedisInstanceAccess struct {
		Access   func(childComplexity int) int
		Workload func(childComplexity int) int
	}

	RedisInstanceAccessConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	RedisInstanceAccessEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RedisInstanceConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	RedisInstanceCost struct {
		Sum func(childComplexity int) int
	}

	RedisInstanceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RedisInstanceStatus struct {
		State func(childComplexity int) int
	}

	RemoveRepositoryFromTeamPayload struct {
		Success func(childComplexity int) int
	}

	RemoveSecretValuePayload struct {
		Secret func(childComplexity int) int
	}

	RemoveTeamMemberPayload struct {
		Team func(childComplexity int) int
		User func(childComplexity int) int
	}

	Repository struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
		Team func(childComplexity int) int
	}

	RepositoryAddedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	RepositoryConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	RepositoryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RepositoryRemovedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	RequestTeamDeletionPayload struct {
		Key func(childComplexity int) int
	}

	RestartApplicationPayload struct {
		Application func(childComplexity int) int
	}

	RevokeRoleFromServiceAccountPayload struct {
		ServiceAccount func(childComplexity int) int
	}

	RevokeTeamAccessToUnleashPayload struct {
		Unleash func(childComplexity int) int
	}

	Role struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	RoleAssignedToServiceAccountActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	RoleAssignedToServiceAccountActivityLogEntryData struct {
		RoleName func(childComplexity int) int
	}

	RoleAssignedUserSyncLogEntry struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		RoleName  func(childComplexity int) int
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
		UserName  func(childComplexity int) int
	}

	RoleConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	RoleEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RoleRevokedFromServiceAccountActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	RoleRevokedFromServiceAccountActivityLogEntryData struct {
		RoleName func(childComplexity int) int
	}

	RoleRevokedUserSyncLogEntry struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		RoleName  func(childComplexity int) int
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
		UserName  func(childComplexity int) int
	}

	SearchNodeConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	SearchNodeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Secret struct {
		Applications    func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Environment     func(childComplexity int) int
		ID              func(childComplexity int) int
		Jobs            func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		LastModifiedAt  func(childComplexity int) int
		LastModifiedBy  func(childComplexity int) int
		Name            func(childComplexity int) int
		Team            func(childComplexity int) int
		TeamEnvironment func(childComplexity int) int
		Values          func(childComplexity int) int
		Workloads       func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
	}

	SecretConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	SecretCreatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	SecretDeletedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	SecretEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	SecretValue struct {
		Name  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	SecretValueAddedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	SecretValueAddedActivityLogEntryData struct {
		ValueName func(childComplexity int) int
	}

	SecretValueRemovedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	SecretValueRemovedActivityLogEntryData struct {
		ValueName func(childComplexity int) int
	}

	SecretValueUpdatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	SecretValueUpdatedActivityLogEntryData struct {
		ValueName func(childComplexity int) int
	}

	ServiceAccount struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		LastUsedAt  func(childComplexity int) int
		Name        func(childComplexity int) int
		Roles       func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Team        func(childComplexity int) int
		Tokens      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		UpdatedAt   func(childComplexity int) int
	}

	ServiceAccountConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ServiceAccountCreatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	ServiceAccountDeletedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	ServiceAccountEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ServiceAccountToken struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ExpiresAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		LastUsedAt  func(childComplexity int) int
		Name        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	ServiceAccountTokenConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ServiceAccountTokenCreatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	ServiceAccountTokenCreatedActivityLogEntryData struct {
		TokenName func(childComplexity int) int
	}

	ServiceAccountTokenDeletedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	ServiceAccountTokenDeletedActivityLogEntryData struct {
		TokenName func(childComplexity int) int
	}

	ServiceAccountTokenEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ServiceAccountTokenUpdatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	ServiceAccountTokenUpdatedActivityLogEntryData struct {
		UpdatedFields func(childComplexity int) int
	}

	ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField struct {
		Field    func(childComplexity int) int
		NewValue func(childComplexity int) int
		OldValue func(childComplexity int) int
	}

	ServiceAccountUpdatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	ServiceAccountUpdatedActivityLogEntryData struct {
		UpdatedFields func(childComplexity int) int
	}

	ServiceAccountUpdatedActivityLogEntryDataUpdatedField struct {
		Field    func(childComplexity int) int
		NewValue func(childComplexity int) int
		OldValue func(childComplexity int) int
	}

	ServiceCostSample struct {
		Cost    func(childComplexity int) int
		Service func(childComplexity int) int
	}

	ServiceCostSeries struct {
		Date     func(childComplexity int) int
		Services func(childComplexity int) int
		Sum      func(childComplexity int) int
	}

	SetTeamMemberRolePayload struct {
		Member func(childComplexity int) int
	}

	SqlDatabase struct {
		Charset         func(childComplexity int) int
		Collation       func(childComplexity int) int
		DeletionPolicy  func(childComplexity int) int
		Environment     func(childComplexity int) int
		Healthy         func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Team            func(childComplexity int) int
		TeamEnvironment func(childComplexity int) int
	}

	SqlInstance struct {
		BackupConfiguration func(childComplexity int) int
		CascadingDelete     func(childComplexity int) int
		ConnectionName      func(childComplexity int) int
		Cost                func(childComplexity int) int
		Database            func(childComplexity int) int
		DiskAutoresize      func(childComplexity int) int
		DiskAutoresizeLimit func(childComplexity int) int
		Environment         func(childComplexity int) int
		Flags               func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Healthy             func(childComplexity int) int
		HighAvailability    func(childComplexity int) int
		ID                  func(childComplexity int) int
		MaintenanceVersion  func(childComplexity int) int
		MaintenanceWindow   func(childComplexity int) int
		Metrics             func(childComplexity int) int
		Name                func(childComplexity int) int
		ProjectID           func(childComplexity int) int
		State               func(childComplexity int) int
		Status              func(childComplexity int) int
		Team                func(childComplexity int) int
		TeamEnvironment     func(childComplexity int) int
		Tier                func(childComplexity int) int
		Users               func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *sqlinstance.SQLInstanceUserOrder) int
		Version             func(childComplexity int) int
		Workload            func(childComplexity int) int
	}

	SqlInstanceBackupConfiguration struct {
		Enabled                     func(childComplexity int) int
		PointInTimeRecovery         func(childComplexity int) int
		RetainedBackups             func(childComplexity int) int
		StartTime                   func(childComplexity int) int
		TransactionLogRetentionDays func(childComplexity int) int
	}

	SqlInstanceConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	SqlInstanceCost struct {
		Sum func(childComplexity int) int
	}

	SqlInstanceCpu struct {
		Cores       func(childComplexity int) int
		Utilization func(childComplexity int) int
	}

	SqlInstanceDisk struct {
		QuotaBytes  func(childComplexity int) int
		Utilization func(childComplexity int) int
	}

	SqlInstanceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	SqlInstanceFlag struct {
		Name  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	SqlInstanceFlagConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	SqlInstanceFlagEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	SqlInstanceMaintenanceWindow struct {
		Day  func(childComplexity int) int
		Hour func(childComplexity int) int
	}

	SqlInstanceMemory struct {
		QuotaBytes  func(childComplexity int) int
		Utilization func(childComplexity int) int
	}

	SqlInstanceMetrics struct {
		CPU    func(childComplexity int) int
		Disk   func(childComplexity int) int
		Memory func(childComplexity int) int
	}

	SqlInstanceStatus struct {
		PrivateIPAddress func(childComplexity int) int
		PublicIPAddress  func(childComplexity int) int
	}

	SqlInstanceUser struct {
		Authentication func(childComplexity int) int
		Name           func(childComplexity int) int
	}

	SqlInstanceUserConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	SqlInstanceUserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Subscription struct {
		WorkloadLog func(childComplexity int, filter podlog.WorkloadLogSubscriptionFilter) int
	}

	Team struct {
		ActivityLog          func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Applications         func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *application.ApplicationOrder, filter *application.TeamApplicationsFilter) int
		BigQueryDatasets     func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bigquery.BigQueryDatasetOrder) int
		Buckets              func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bucket.BucketOrder) int
		Cost                 func(childComplexity int) int
		DeleteKey            func(childComplexity int, key string) int
		DeletionInProgress   func(childComplexity int) int
		DeploymentKey        func(childComplexity int) int
		Deployments          func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		Environment          func(childComplexity int, name string) int
		Environments         func(childComplexity int) int
		ExternalResources    func(childComplexity int) int
		ID                   func(childComplexity int) int
		InventoryCounts      func(childComplexity int) int
		Jobs                 func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *job.JobOrder, filter *job.TeamJobsFilter) int
		KafkaTopics          func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *kafkatopic.KafkaTopicOrder) int
		LastSuccessfulSync   func(childComplexity int) int
		Member               func(childComplexity int, email string) int
		Members              func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.TeamMemberOrder) int
		OpenSearchInstances  func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *opensearch.OpenSearchOrder) int
		Purpose              func(childComplexity int) int
		RedisInstances       func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *redis.RedisInstanceOrder) int
		Repositories         func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *repository.RepositoryOrder, filter *repository.TeamRepositoryFilter) int
		SQLInstances         func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *sqlinstance.SQLInstanceOrder) int
		Secrets              func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *secret.SecretOrder, filter *secret.SecretFilter) int
		ServiceUtilization   func(childComplexity int) int
		SlackChannel         func(childComplexity int) int
		Slug                 func(childComplexity int) int
		Unleash              func(childComplexity int) int
		ValkeyInstances      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *valkey.ValkeyInstanceOrder) int
		ViewerIsMember       func(childComplexity int) int
		ViewerIsOwner        func(childComplexity int) int
		VulnerabilitySummary func(childComplexity int, filter *vulnerability.TeamVulnerabilitySummaryFilter) int
		WorkloadUtilization  func(childComplexity int, resourceType utilization.UtilizationResourceType) int
		Workloads            func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *workload.WorkloadOrder, filter *workload.TeamWorkloadsFilter) int
	}

	TeamCDN struct {
		Bucket func(childComplexity int) int
	}

	TeamConfirmDeleteKeyActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	TeamCost struct {
		Daily          func(childComplexity int, from scalar.Date, to scalar.Date, filter *cost.TeamCostDailyFilter) int
		MonthlySummary func(childComplexity int) int
	}

	TeamCostMonthlySample struct {
		Cost func(childComplexity int) int
		Date func(childComplexity int) int
	}

	TeamCostMonthlySummary struct {
		Series func(childComplexity int) int
		Sum    func(childComplexity int) int
	}

	TeamCostPeriod struct {
		Series func(childComplexity int) int
		Sum    func(childComplexity int) int
	}

	TeamCreateDeleteKeyActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamCreatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamDeleteKey struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int) int
		Expires   func(childComplexity int) int
		Key       func(childComplexity int) int
		Team      func(childComplexity int) int
	}

	TeamDeployKeyUpdatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TeamEntraIDGroup struct {
		GroupID func(childComplexity int) int
	}

	TeamEnvironment struct {
		Application        func(childComplexity int, name string) int
		BigQueryDataset    func(childComplexity int, name string) int
		Bucket             func(childComplexity int, name string) int
		Cost               func(childComplexity int) int
		Environment        func(childComplexity int) int
		GCPProjectID       func(childComplexity int) int
		ID                 func(childComplexity int) int
		Job                func(childComplexity int, name string) int
		KafkaTopic         func(childComplexity int, name string) int
		Name               func(childComplexity int) int
		OpenSearchInstance func(childComplexity int, name string) int
		RedisInstance      func(childComplexity int, name string) int
		SQLInstance        func(childComplexity int, name string) int
		Secret             func(childComplexity int, name string) int
		SlackAlertsChannel func(childComplexity int) int
		Team               func(childComplexity int) int
		ValkeyInstance     func(childComplexity int, name string) int
		Workload           func(childComplexity int, name string) int
	}

	TeamEnvironmentCost struct {
		Daily func(childComplexity int, from scalar.Date, to scalar.Date) int
	}

	TeamEnvironmentCostPeriod struct {
		Series func(childComplexity int) int
		Sum    func(childComplexity int) int
	}

	TeamEnvironmentUpdatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamEnvironmentUpdatedActivityLogEntryData struct {
		UpdatedFields func(childComplexity int) int
	}

	TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField struct {
		Field    func(childComplexity int) int
		NewValue func(childComplexity int) int
		OldValue func(childComplexity int) int
	}

	TeamExternalResources struct {
		CDN                    func(childComplexity int) int
		EntraIDGroup           func(childComplexity int) int
		GitHubTeam             func(childComplexity int) int
		GoogleArtifactRegistry func(childComplexity int) int
		GoogleGroup            func(childComplexity int) int
	}

	TeamGitHubTeam struct {
		Slug func(childComplexity int) int
	}

	TeamGoogleArtifactRegistry struct {
		Repository func(childComplexity int) int
	}

	TeamGoogleGroup struct {
		Email func(childComplexity int) int
	}

	TeamInventoryCountApplications struct {
		NotNais func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	TeamInventoryCountBigQueryDatasets struct {
		Total func(childComplexity int) int
	}

	TeamInventoryCountBuckets struct {
		Total func(childComplexity int) int
	}

	TeamInventoryCountJobs struct {
		NotNais func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	TeamInventoryCountKafkaTopics struct {
		Total func(childComplexity int) int
	}

	TeamInventoryCountOpenSearchInstances struct {
		Total func(childComplexity int) int
	}

	TeamInventoryCountRedisInstances struct {
		Total func(childComplexity int) int
	}

	TeamInventoryCountSqlInstances struct {
		Total func(childComplexity int) int
	}

	TeamInventoryCountValkeyInstances struct {
		Total func(childComplexity int) int
	}

	TeamInventoryCounts struct {
		Applications        func(childComplexity int) int
		BigQueryDatasets    func(childComplexity int) int
		Buckets             func(childComplexity int) int
		Jobs                func(childComplexity int) int
		KafkaTopics         func(childComplexity int) int
		OpenSearchInstances func(childComplexity int) int
		RedisInstances      func(childComplexity int) int
		SQLInstances        func(childComplexity int) int
		ValkeyInstances     func(childComplexity int) int
	}

	TeamMember struct {
		Role func(childComplexity int) int
		Team func(childComplexity int) int
		User func(childComplexity int) int
	}

	TeamMemberAddedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamMemberAddedActivityLogEntryData struct {
		Role      func(childComplexity int) int
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	TeamMemberConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	TeamMemberEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TeamMemberRemovedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamMemberRemovedActivityLogEntryData struct {
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	TeamMemberSetRoleActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamMemberSetRoleActivityLogEntryData struct {
		Role      func(childComplexity int) int
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	TeamServiceUtilization struct {
		SQLInstances func(childComplexity int) int
	}

	TeamServiceUtilizationSqlInstances struct {
		CPU    func(childComplexity int) int
		Disk   func(childComplexity int) int
		Memory func(childComplexity int) int
	}

	TeamServiceUtilizationSqlInstancesCPU struct {
		Requested   func(childComplexity int) int
		Used        func(childComplexity int) int
		Utilization func(childComplexity int) int
	}

	TeamServiceUtilizationSqlInstancesDisk struct {
		Requested   func(childComplexity int) int
		Used        func(childComplexity int) int
		Utilization func(childComplexity int) int
	}

	TeamServiceUtilizationSqlInstancesMemory struct {
		Requested   func(childComplexity int) int
		Used        func(childComplexity int) int
		Utilization func(childComplexity int) int
	}

	TeamUpdatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	TeamUpdatedActivityLogEntryData struct {
		UpdatedFields func(childComplexity int) int
	}

	TeamUpdatedActivityLogEntryDataUpdatedField struct {
		Field    func(childComplexity int) int
		NewValue func(childComplexity int) int
		OldValue func(childComplexity int) int
	}

	TeamUtilizationData struct {
		Environment     func(childComplexity int) int
		Requested       func(childComplexity int) int
		Team            func(childComplexity int) int
		TeamEnvironment func(childComplexity int) int
		Used            func(childComplexity int) int
	}

	TeamVulnerabilityStatus struct {
		Description func(childComplexity int) int
		State       func(childComplexity int) int
		Title       func(childComplexity int) int
	}

	TeamVulnerabilitySummary struct {
		BomCount       func(childComplexity int) int
		Coverage       func(childComplexity int) int
		Critical       func(childComplexity int) int
		High           func(childComplexity int) int
		Low            func(childComplexity int) int
		Medium         func(childComplexity int) int
		Ranking        func(childComplexity int) int
		RiskScore      func(childComplexity int) int
		RiskScoreTrend func(childComplexity int) int
		Status         func(childComplexity int) int
		Unassigned     func(childComplexity int) int
	}

	TokenXAuthIntegration struct {
		Name func(childComplexity int) int
	}

	TriggerJobPayload struct {
		Job    func(childComplexity int) int
		JobRun func(childComplexity int) int
	}

	UnleashInstance struct {
		APIIngress   func(childComplexity int) int
		AllowedTeams func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) int
		ID           func(childComplexity int) int
		Metrics      func(childComplexity int) int
		Name         func(childComplexity int) int
		Ready        func(childComplexity int) int
		Version      func(childComplexity int) int
		WebIngress   func(childComplexity int) int
	}

	UnleashInstanceCreatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	UnleashInstanceMetrics struct {
		APITokens         func(childComplexity int) int
		CPURequests       func(childComplexity int) int
		CPUUtilization    func(childComplexity int) int
		MemoryRequests    func(childComplexity int) int
		MemoryUtilization func(childComplexity int) int
		Toggles           func(childComplexity int) int
	}

	UnleashInstanceUpdatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	UnleashInstanceUpdatedActivityLogEntryData struct {
		AllowedTeamSlug func(childComplexity int) int
		RevokedTeamSlug func(childComplexity int) int
	}

	UpdateImageVulnerabilityPayload struct {
		Vulnerability func(childComplexity int) int
	}

	UpdateSecretValuePayload struct {
		Secret func(childComplexity int) int
	}

	UpdateServiceAccountPayload struct {
		ServiceAccount func(childComplexity int) int
	}

	UpdateServiceAccountTokenPayload struct {
		ServiceAccount      func(childComplexity int) int
		ServiceAccountToken func(childComplexity int) int
	}

	UpdateTeamEnvironmentPayload struct {
		Environment     func(childComplexity int) int
		TeamEnvironment func(childComplexity int) int
	}

	UpdateTeamPayload struct {
		Team func(childComplexity int) int
	}

	User struct {
		Email      func(childComplexity int) int
		ExternalID func(childComplexity int) int
		ID         func(childComplexity int) int
		IsAdmin    func(childComplexity int) int
		Name       func(childComplexity int) int
		Teams      func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.UserTeamOrder) int
	}

	UserConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	UserCreatedUserSyncLogEntry struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
		UserName  func(childComplexity int) int
	}

	UserDeletedUserSyncLogEntry struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
		UserName  func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserSyncLogEntryConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	UserSyncLogEntryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserUpdatedUserSyncLogEntry struct {
		CreatedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		Message      func(childComplexity int) int
		OldUserEmail func(childComplexity int) int
		OldUserName  func(childComplexity int) int
		UserEmail    func(childComplexity int) int
		UserID       func(childComplexity int) int
		UserName     func(childComplexity int) int
	}

	UtilizationSample struct {
		Instance  func(childComplexity int) int
		Timestamp func(childComplexity int) int
		Value     func(childComplexity int) int
	}

	ValkeyInstance struct {
		Access          func(childComplexity int, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *valkey.ValkeyInstanceAccessOrder) int
		Cost            func(childComplexity int) int
		Environment     func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Status          func(childComplexity int) int
		Team            func(childComplexity int) int
		TeamEnvironment func(childComplexity int) int
		Workload        func(childComplexity int) int
	}

	ValkeyInstanceAccess struct {
		Access   func(childComplexity int) int
		Workload func(childComplexity int) int
	}

	ValkeyInstanceAccessConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ValkeyInstanceAccessEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ValkeyInstanceConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ValkeyInstanceCost struct {
		Sum func(childComplexity int) int
	}

	ValkeyInstanceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ValkeyInstanceStatus struct {
		State func(childComplexity int) int
	}

	VulnerabilityUpdatedActivityLogEntry struct {
		Actor           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		EnvironmentName func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		ResourceName    func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TeamSlug        func(childComplexity int) int
	}

	WorkloadConnection struct {
		Edges    func(childComplexity int) int
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	WorkloadCost struct {
		Daily   func(childComplexity int, from scalar.Date, to scalar.Date) int
		Monthly func(childComplexity int) int
	}

	WorkloadCostPeriod struct {
		Series func(childComplexity int) int
		Sum    func(childComplexity int) int
	}

	WorkloadCostSample struct {
		Cost         func(childComplexity int) int
		Workload     func(childComplexity int) int
		WorkloadName func(childComplexity int) int
	}

	WorkloadCostSeries struct {
		Date      func(childComplexity int) int
		Sum       func(childComplexity int) int
		Workloads func(childComplexity int) int
	}

	WorkloadEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	WorkloadLogLine struct {
		Instance func(childComplexity int) int
		Message  func(childComplexity int) int
		Time     func(childComplexity int) int
	}

	WorkloadResourceQuantity struct {
		CPU    func(childComplexity int) int
		Memory func(childComplexity int) int
	}

	WorkloadStatus struct {
		Errors func(childComplexity int) int
		State  func(childComplexity int) int
	}

	WorkloadStatusDeprecatedIngress struct {
		Ingress func(childComplexity int) int
		Level   func(childComplexity int) int
	}

	WorkloadStatusDeprecatedRegistry struct {
		Level      func(childComplexity int) int
		Name       func(childComplexity int) int
		Registry   func(childComplexity int) int
		Repository func(childComplexity int) int
		Tag        func(childComplexity int) int
	}

	WorkloadStatusFailedRun struct {
		Detail func(childComplexity int) int
		Level  func(childComplexity int) int
		Name   func(childComplexity int) int
	}

	WorkloadStatusInboundNetwork struct {
		Level  func(childComplexity int) int
		Policy func(childComplexity int) int
	}

	WorkloadStatusInvalidNaisYaml struct {
		Detail func(childComplexity int) int
		Level  func(childComplexity int) int
	}

	WorkloadStatusMissingSBOM struct {
		Level func(childComplexity int) int
	}

	WorkloadStatusNewInstancesFailing struct {
		FailingInstances func(childComplexity int) int
		Level            func(childComplexity int) int
	}

	WorkloadStatusNoRunningInstances struct {
		Level func(childComplexity int) int
	}

	WorkloadStatusOutboundNetwork struct {
		Level  func(childComplexity int) int
		Policy func(childComplexity int) int
	}

	WorkloadStatusSynchronizationFailing struct {
		Detail func(childComplexity int) int
		Level  func(childComplexity int) int
	}

	WorkloadStatusVulnerable struct {
		Level   func(childComplexity int) int
		Summary func(childComplexity int) int
	}

	WorkloadUtilization struct {
		Current   func(childComplexity int, resourceType utilization.UtilizationResourceType) int
		Limit     func(childComplexity int, resourceType utilization.UtilizationResourceType) int
		Requested func(childComplexity int, resourceType utilization.UtilizationResourceType) int
		Series    func(childComplexity int, input utilization.WorkloadUtilizationSeriesInput) int
	}

	WorkloadUtilizationData struct {
		Requested func(childComplexity int) int
		Used      func(childComplexity int) int
		Workload  func(childComplexity int) int
	}
}

type ApplicationResolver interface {
	Team(ctx context.Context, obj *application.Application) (*team.Team, error)
	Environment(ctx context.Context, obj *application.Application) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *application.Application) (*team.TeamEnvironment, error)

	AuthIntegrations(ctx context.Context, obj *application.Application) ([]workload.ApplicationAuthIntegrations, error)
	Manifest(ctx context.Context, obj *application.Application) (*application.ApplicationManifest, error)
	Instances(ctx context.Context, obj *application.Application, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*application.ApplicationInstance], error)

	BigQueryDatasets(ctx context.Context, obj *application.Application, orderBy *bigquery.BigQueryDatasetOrder) (*pagination.Connection[*bigquery.BigQueryDataset], error)
	Buckets(ctx context.Context, obj *application.Application, orderBy *bucket.BucketOrder) (*pagination.Connection[*bucket.Bucket], error)
	Cost(ctx context.Context, obj *application.Application) (*cost.WorkloadCost, error)
	Deployments(ctx context.Context, obj *application.Application, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*deployment.Deployment], error)
	KafkaTopicAcls(ctx context.Context, obj *application.Application, orderBy *kafkatopic.KafkaTopicACLOrder) (*pagination.Connection[*kafkatopic.KafkaTopicACL], error)
	LogDestinations(ctx context.Context, obj *application.Application) ([]logging.LogDestination, error)
	NetworkPolicy(ctx context.Context, obj *application.Application) (*netpol.NetworkPolicy, error)
	OpenSearch(ctx context.Context, obj *application.Application) (*opensearch.OpenSearch, error)
	RedisInstances(ctx context.Context, obj *application.Application, orderBy *redis.RedisInstanceOrder) (*pagination.Connection[*redis.RedisInstance], error)
	Secrets(ctx context.Context, obj *application.Application, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*secret.Secret], error)
	SQLInstances(ctx context.Context, obj *application.Application, orderBy *sqlinstance.SQLInstanceOrder) (*pagination.Connection[*sqlinstance.SQLInstance], error)
	Status(ctx context.Context, obj *application.Application) (*status.WorkloadStatus, error)
	Utilization(ctx context.Context, obj *application.Application) (*utilization.WorkloadUtilization, error)
	ValkeyInstances(ctx context.Context, obj *application.Application, orderBy *valkey.ValkeyInstanceOrder) (*pagination.Connection[*valkey.ValkeyInstance], error)
}
type BigQueryDatasetResolver interface {
	Team(ctx context.Context, obj *bigquery.BigQueryDataset) (*team.Team, error)
	Environment(ctx context.Context, obj *bigquery.BigQueryDataset) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *bigquery.BigQueryDataset) (*team.TeamEnvironment, error)

	Access(ctx context.Context, obj *bigquery.BigQueryDataset, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bigquery.BigQueryDatasetAccessOrder) (*pagination.Connection[*bigquery.BigQueryDatasetAccess], error)

	Workload(ctx context.Context, obj *bigquery.BigQueryDataset) (workload.Workload, error)
	Cost(ctx context.Context, obj *bigquery.BigQueryDataset) (*cost.BigQueryDatasetCost, error)
}
type BucketResolver interface {
	Team(ctx context.Context, obj *bucket.Bucket) (*team.Team, error)
	Environment(ctx context.Context, obj *bucket.Bucket) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *bucket.Bucket) (*team.TeamEnvironment, error)

	Workload(ctx context.Context, obj *bucket.Bucket) (workload.Workload, error)
}
type ContainerImageResolver interface {
	HasSbom(ctx context.Context, obj *workload.ContainerImage) (bool, error)
	Vulnerabilities(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *vulnerability.ImageVulnerabilityOrder) (*pagination.Connection[*vulnerability.ImageVulnerability], error)
	VulnerabilitySummary(ctx context.Context, obj *workload.ContainerImage) (*vulnerability.ImageVulnerabilitySummary, error)
	WorkloadReferences(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ContainerImageWorkloadReference], error)
}
type ContainerImageWorkloadReferenceResolver interface {
	Workload(ctx context.Context, obj *vulnerability.ContainerImageWorkloadReference) (workload.Workload, error)
}
type DeleteApplicationPayloadResolver interface {
	Team(ctx context.Context, obj *application.DeleteApplicationPayload) (*team.Team, error)
}
type DeleteJobPayloadResolver interface {
	Team(ctx context.Context, obj *job.DeleteJobPayload) (*team.Team, error)
}
type DeploymentResolver interface {
	Resources(ctx context.Context, obj *deployment.Deployment, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*deployment.DeploymentResource], error)
	Statuses(ctx context.Context, obj *deployment.Deployment, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*deployment.DeploymentStatus], error)
}
type EnvironmentResolver interface {
	Workloads(ctx context.Context, obj *environment.Environment, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *workload.EnvironmentWorkloadOrder) (*pagination.Connection[workload.Workload], error)
}
type ImageVulnerabilityResolver interface {
	AnalysisTrail(ctx context.Context, obj *vulnerability.ImageVulnerability) (*vulnerability.ImageVulnerabilityAnalysisTrail, error)
}
type ImageVulnerabilityAnalysisTrailResolver interface {
	Comments(ctx context.Context, obj *vulnerability.ImageVulnerabilityAnalysisTrail, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment], error)
}
type IngressResolver interface {
	Type(ctx context.Context, obj *application.Ingress) (application.IngressType, error)
}
type JobResolver interface {
	Team(ctx context.Context, obj *job.Job) (*team.Team, error)
	Environment(ctx context.Context, obj *job.Job) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *job.Job) (*team.TeamEnvironment, error)

	AuthIntegrations(ctx context.Context, obj *job.Job) ([]workload.JobAuthIntegrations, error)

	Runs(ctx context.Context, obj *job.Job, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*job.JobRun], error)
	Manifest(ctx context.Context, obj *job.Job) (*job.JobManifest, error)

	BigQueryDatasets(ctx context.Context, obj *job.Job, orderBy *bigquery.BigQueryDatasetOrder) (*pagination.Connection[*bigquery.BigQueryDataset], error)
	Buckets(ctx context.Context, obj *job.Job, orderBy *bucket.BucketOrder) (*pagination.Connection[*bucket.Bucket], error)
	Cost(ctx context.Context, obj *job.Job) (*cost.WorkloadCost, error)
	Deployments(ctx context.Context, obj *job.Job, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*deployment.Deployment], error)
	KafkaTopicAcls(ctx context.Context, obj *job.Job, orderBy *kafkatopic.KafkaTopicACLOrder) (*pagination.Connection[*kafkatopic.KafkaTopicACL], error)
	LogDestinations(ctx context.Context, obj *job.Job) ([]logging.LogDestination, error)
	NetworkPolicy(ctx context.Context, obj *job.Job) (*netpol.NetworkPolicy, error)
	OpenSearch(ctx context.Context, obj *job.Job) (*opensearch.OpenSearch, error)
	RedisInstances(ctx context.Context, obj *job.Job, orderBy *redis.RedisInstanceOrder) (*pagination.Connection[*redis.RedisInstance], error)
	Secrets(ctx context.Context, obj *job.Job, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*secret.Secret], error)
	SQLInstances(ctx context.Context, obj *job.Job, orderBy *sqlinstance.SQLInstanceOrder) (*pagination.Connection[*sqlinstance.SQLInstance], error)
	Status(ctx context.Context, obj *job.Job) (*status.WorkloadStatus, error)
	ValkeyInstances(ctx context.Context, obj *job.Job, orderBy *valkey.ValkeyInstanceOrder) (*pagination.Connection[*valkey.ValkeyInstance], error)
}
type JobRunResolver interface {
	Duration(ctx context.Context, obj *job.JobRun) (int, error)
	Instances(ctx context.Context, obj *job.JobRun, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*job.JobRunInstance], error)
}
type KafkaTopicResolver interface {
	Team(ctx context.Context, obj *kafkatopic.KafkaTopic) (*team.Team, error)
	Environment(ctx context.Context, obj *kafkatopic.KafkaTopic) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *kafkatopic.KafkaTopic) (*team.TeamEnvironment, error)
	ACL(ctx context.Context, obj *kafkatopic.KafkaTopic, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter *kafkatopic.KafkaTopicACLFilter, orderBy *kafkatopic.KafkaTopicACLOrder) (*pagination.Connection[*kafkatopic.KafkaTopicACL], error)
}
type KafkaTopicAclResolver interface {
	Team(ctx context.Context, obj *kafkatopic.KafkaTopicACL) (*team.Team, error)
	Workload(ctx context.Context, obj *kafkatopic.KafkaTopicACL) (workload.Workload, error)
	Topic(ctx context.Context, obj *kafkatopic.KafkaTopicACL) (*kafkatopic.KafkaTopic, error)
}
type MutationResolver interface {
	DeleteApplication(ctx context.Context, input application.DeleteApplicationInput) (*application.DeleteApplicationPayload, error)
	RestartApplication(ctx context.Context, input application.RestartApplicationInput) (*application.RestartApplicationPayload, error)
	ChangeDeploymentKey(ctx context.Context, input deployment.ChangeDeploymentKeyInput) (*deployment.ChangeDeploymentKeyPayload, error)
	DeleteJob(ctx context.Context, input job.DeleteJobInput) (*job.DeleteJobPayload, error)
	TriggerJob(ctx context.Context, input job.TriggerJobInput) (*job.TriggerJobPayload, error)
	EnableReconciler(ctx context.Context, input reconciler.EnableReconcilerInput) (*reconciler.Reconciler, error)
	DisableReconciler(ctx context.Context, input reconciler.DisableReconcilerInput) (*reconciler.Reconciler, error)
	ConfigureReconciler(ctx context.Context, input reconciler.ConfigureReconcilerInput) (*reconciler.Reconciler, error)
	AddRepositoryToTeam(ctx context.Context, input repository.AddRepositoryToTeamInput) (*repository.AddRepositoryToTeamPayload, error)
	RemoveRepositoryFromTeam(ctx context.Context, input repository.RemoveRepositoryFromTeamInput) (*repository.RemoveRepositoryFromTeamPayload, error)
	CreateSecret(ctx context.Context, input secret.CreateSecretInput) (*secret.CreateSecretPayload, error)
	AddSecretValue(ctx context.Context, input secret.AddSecretValueInput) (*secret.AddSecretValuePayload, error)
	UpdateSecretValue(ctx context.Context, input secret.UpdateSecretValueInput) (*secret.UpdateSecretValuePayload, error)
	RemoveSecretValue(ctx context.Context, input secret.RemoveSecretValueInput) (*secret.RemoveSecretValuePayload, error)
	DeleteSecret(ctx context.Context, input secret.DeleteSecretInput) (*secret.DeleteSecretPayload, error)
	CreateServiceAccount(ctx context.Context, input serviceaccount.CreateServiceAccountInput) (*serviceaccount.CreateServiceAccountPayload, error)
	UpdateServiceAccount(ctx context.Context, input serviceaccount.UpdateServiceAccountInput) (*serviceaccount.UpdateServiceAccountPayload, error)
	DeleteServiceAccount(ctx context.Context, input serviceaccount.DeleteServiceAccountInput) (*serviceaccount.DeleteServiceAccountPayload, error)
	AssignRoleToServiceAccount(ctx context.Context, input serviceaccount.AssignRoleToServiceAccountInput) (*serviceaccount.AssignRoleToServiceAccountPayload, error)
	RevokeRoleFromServiceAccount(ctx context.Context, input serviceaccount.RevokeRoleFromServiceAccountInput) (*serviceaccount.RevokeRoleFromServiceAccountPayload, error)
	CreateServiceAccountToken(ctx context.Context, input serviceaccount.CreateServiceAccountTokenInput) (*serviceaccount.CreateServiceAccountTokenPayload, error)
	UpdateServiceAccountToken(ctx context.Context, input serviceaccount.UpdateServiceAccountTokenInput) (*serviceaccount.UpdateServiceAccountTokenPayload, error)
	DeleteServiceAccountToken(ctx context.Context, input serviceaccount.DeleteServiceAccountTokenInput) (*serviceaccount.DeleteServiceAccountTokenPayload, error)
	CreateTeam(ctx context.Context, input team.CreateTeamInput) (*team.CreateTeamPayload, error)
	UpdateTeam(ctx context.Context, input team.UpdateTeamInput) (*team.UpdateTeamPayload, error)
	UpdateTeamEnvironment(ctx context.Context, input team.UpdateTeamEnvironmentInput) (*team.UpdateTeamEnvironmentPayload, error)
	RequestTeamDeletion(ctx context.Context, input team.RequestTeamDeletionInput) (*team.RequestTeamDeletionPayload, error)
	ConfirmTeamDeletion(ctx context.Context, input team.ConfirmTeamDeletionInput) (*team.ConfirmTeamDeletionPayload, error)
	AddTeamMember(ctx context.Context, input team.AddTeamMemberInput) (*team.AddTeamMemberPayload, error)
	RemoveTeamMember(ctx context.Context, input team.RemoveTeamMemberInput) (*team.RemoveTeamMemberPayload, error)
	SetTeamMemberRole(ctx context.Context, input team.SetTeamMemberRoleInput) (*team.SetTeamMemberRolePayload, error)
	CreateUnleashForTeam(ctx context.Context, input unleash.CreateUnleashForTeamInput) (*unleash.CreateUnleashForTeamPayload, error)
	AllowTeamAccessToUnleash(ctx context.Context, input unleash.AllowTeamAccessToUnleashInput) (*unleash.AllowTeamAccessToUnleashPayload, error)
	RevokeTeamAccessToUnleash(ctx context.Context, input unleash.RevokeTeamAccessToUnleashInput) (*unleash.RevokeTeamAccessToUnleashPayload, error)
	UpdateImageVulnerability(ctx context.Context, input vulnerability.UpdateImageVulnerabilityInput) (*vulnerability.UpdateImageVulnerabilityPayload, error)
}
type NetworkPolicyRuleResolver interface {
	TargetWorkload(ctx context.Context, obj *netpol.NetworkPolicyRule) (workload.Workload, error)

	TargetTeam(ctx context.Context, obj *netpol.NetworkPolicyRule) (*team.Team, error)
	Mutual(ctx context.Context, obj *netpol.NetworkPolicyRule) (bool, error)
}
type OpenSearchResolver interface {
	Team(ctx context.Context, obj *opensearch.OpenSearch) (*team.Team, error)
	Environment(ctx context.Context, obj *opensearch.OpenSearch) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *opensearch.OpenSearch) (*team.TeamEnvironment, error)

	Workload(ctx context.Context, obj *opensearch.OpenSearch) (workload.Workload, error)
	Access(ctx context.Context, obj *opensearch.OpenSearch, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *opensearch.OpenSearchAccessOrder) (*pagination.Connection[*opensearch.OpenSearchAccess], error)
	Cost(ctx context.Context, obj *opensearch.OpenSearch) (*cost.OpenSearchCost, error)
}
type OpenSearchAccessResolver interface {
	Workload(ctx context.Context, obj *opensearch.OpenSearchAccess) (workload.Workload, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id ident.Ident) (model.Node, error)
	Roles(ctx context.Context, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*authz.Role], error)
	Environments(ctx context.Context, orderBy *environment.EnvironmentOrder) (*pagination.Connection[*environment.Environment], error)
	Environment(ctx context.Context, name string) (*environment.Environment, error)
	Features(ctx context.Context) (*feature.Features, error)
	Reconcilers(ctx context.Context, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*reconciler.Reconciler], error)
	Search(ctx context.Context, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter search.SearchFilter) (*pagination.Connection[search.SearchNode], error)
	ServiceAccounts(ctx context.Context, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*serviceaccount.ServiceAccount], error)
	ServiceAccount(ctx context.Context, id ident.Ident) (*serviceaccount.ServiceAccount, error)
	Teams(ctx context.Context, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.TeamOrder) (*pagination.Connection[*team.Team], error)
	Team(ctx context.Context, slug slug.Slug) (*team.Team, error)
	Users(ctx context.Context, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *user.UserOrder) (*pagination.Connection[*user.User], error)
	User(ctx context.Context, email *string) (*user.User, error)
	Me(ctx context.Context) (authz.AuthenticatedUser, error)
	UserSyncLog(ctx context.Context, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[usersync.UserSyncLogEntry], error)
	TeamsUtilization(ctx context.Context, resourceType utilization.UtilizationResourceType) ([]*utilization.TeamUtilizationData, error)
}
type ReconcilerResolver interface {
	Config(ctx context.Context, obj *reconciler.Reconciler) ([]*reconciler.ReconcilerConfig, error)
	Configured(ctx context.Context, obj *reconciler.Reconciler) (bool, error)
	Errors(ctx context.Context, obj *reconciler.Reconciler, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*reconciler.ReconcilerError], error)
	ActivityLog(ctx context.Context, obj *reconciler.Reconciler, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[activitylog.ActivityLogEntry], error)
}
type ReconcilerErrorResolver interface {
	Team(ctx context.Context, obj *reconciler.ReconcilerError) (*team.Team, error)
}
type RedisInstanceResolver interface {
	Team(ctx context.Context, obj *redis.RedisInstance) (*team.Team, error)
	Environment(ctx context.Context, obj *redis.RedisInstance) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *redis.RedisInstance) (*team.TeamEnvironment, error)
	Access(ctx context.Context, obj *redis.RedisInstance, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *redis.RedisInstanceAccessOrder) (*pagination.Connection[*redis.RedisInstanceAccess], error)
	Workload(ctx context.Context, obj *redis.RedisInstance) (workload.Workload, error)

	Cost(ctx context.Context, obj *redis.RedisInstance) (*cost.RedisInstanceCost, error)
}
type RedisInstanceAccessResolver interface {
	Workload(ctx context.Context, obj *redis.RedisInstanceAccess) (workload.Workload, error)
}
type RemoveTeamMemberPayloadResolver interface {
	User(ctx context.Context, obj *team.RemoveTeamMemberPayload) (*user.User, error)
	Team(ctx context.Context, obj *team.RemoveTeamMemberPayload) (*team.Team, error)
}
type RepositoryResolver interface {
	Team(ctx context.Context, obj *repository.Repository) (*team.Team, error)
}
type RestartApplicationPayloadResolver interface {
	Application(ctx context.Context, obj *application.RestartApplicationPayload) (*application.Application, error)
}
type SecretResolver interface {
	Environment(ctx context.Context, obj *secret.Secret) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *secret.Secret) (*team.TeamEnvironment, error)
	Team(ctx context.Context, obj *secret.Secret) (*team.Team, error)
	Values(ctx context.Context, obj *secret.Secret) ([]*secret.SecretValue, error)
	Applications(ctx context.Context, obj *secret.Secret, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*application.Application], error)
	Jobs(ctx context.Context, obj *secret.Secret, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*job.Job], error)
	Workloads(ctx context.Context, obj *secret.Secret, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[workload.Workload], error)

	LastModifiedBy(ctx context.Context, obj *secret.Secret) (*user.User, error)
}
type ServiceAccountResolver interface {
	LastUsedAt(ctx context.Context, obj *serviceaccount.ServiceAccount) (*time.Time, error)
	Team(ctx context.Context, obj *serviceaccount.ServiceAccount) (*team.Team, error)
	Roles(ctx context.Context, obj *serviceaccount.ServiceAccount, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*authz.Role], error)
	Tokens(ctx context.Context, obj *serviceaccount.ServiceAccount, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*serviceaccount.ServiceAccountToken], error)
}
type SqlDatabaseResolver interface {
	Team(ctx context.Context, obj *sqlinstance.SQLDatabase) (*team.Team, error)
	Environment(ctx context.Context, obj *sqlinstance.SQLDatabase) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *sqlinstance.SQLDatabase) (*team.TeamEnvironment, error)
}
type SqlInstanceResolver interface {
	Team(ctx context.Context, obj *sqlinstance.SQLInstance) (*team.Team, error)
	Environment(ctx context.Context, obj *sqlinstance.SQLInstance) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *sqlinstance.SQLInstance) (*team.TeamEnvironment, error)
	Workload(ctx context.Context, obj *sqlinstance.SQLInstance) (workload.Workload, error)

	Database(ctx context.Context, obj *sqlinstance.SQLInstance) (*sqlinstance.SQLDatabase, error)
	Flags(ctx context.Context, obj *sqlinstance.SQLInstance, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*sqlinstance.SQLInstanceFlag], error)
	Users(ctx context.Context, obj *sqlinstance.SQLInstance, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *sqlinstance.SQLInstanceUserOrder) (*pagination.Connection[*sqlinstance.SQLInstanceUser], error)
	Metrics(ctx context.Context, obj *sqlinstance.SQLInstance) (*sqlinstance.SQLInstanceMetrics, error)
	State(ctx context.Context, obj *sqlinstance.SQLInstance) (sqlinstance.SQLInstanceState, error)
	Cost(ctx context.Context, obj *sqlinstance.SQLInstance) (*cost.SQLInstanceCost, error)
}
type SqlInstanceMetricsResolver interface {
	CPU(ctx context.Context, obj *sqlinstance.SQLInstanceMetrics) (*sqlinstance.SQLInstanceCPU, error)
	Memory(ctx context.Context, obj *sqlinstance.SQLInstanceMetrics) (*sqlinstance.SQLInstanceMemory, error)
	Disk(ctx context.Context, obj *sqlinstance.SQLInstanceMetrics) (*sqlinstance.SQLInstanceDisk, error)
}
type SubscriptionResolver interface {
	WorkloadLog(ctx context.Context, filter podlog.WorkloadLogSubscriptionFilter) (<-chan *podlog.WorkloadLogLine, error)
}
type TeamResolver interface {
	Member(ctx context.Context, obj *team.Team, email string) (*team.TeamMember, error)
	Members(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.TeamMemberOrder) (*pagination.Connection[*team.TeamMember], error)

	ViewerIsOwner(ctx context.Context, obj *team.Team) (bool, error)
	ViewerIsMember(ctx context.Context, obj *team.Team) (bool, error)
	Environments(ctx context.Context, obj *team.Team) ([]*team.TeamEnvironment, error)
	Environment(ctx context.Context, obj *team.Team, name string) (*team.TeamEnvironment, error)
	DeleteKey(ctx context.Context, obj *team.Team, key string) (*team.TeamDeleteKey, error)
	InventoryCounts(ctx context.Context, obj *team.Team) (*team.TeamInventoryCounts, error)
	ActivityLog(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[activitylog.ActivityLogEntry], error)
	Applications(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *application.ApplicationOrder, filter *application.TeamApplicationsFilter) (*pagination.Connection[*application.Application], error)
	BigQueryDatasets(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bigquery.BigQueryDatasetOrder) (*pagination.Connection[*bigquery.BigQueryDataset], error)
	Buckets(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *bucket.BucketOrder) (*pagination.Connection[*bucket.Bucket], error)
	Cost(ctx context.Context, obj *team.Team) (*cost.TeamCost, error)
	DeploymentKey(ctx context.Context, obj *team.Team) (*deployment.DeploymentKey, error)
	Deployments(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*deployment.Deployment], error)
	Jobs(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *job.JobOrder, filter *job.TeamJobsFilter) (*pagination.Connection[*job.Job], error)
	KafkaTopics(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *kafkatopic.KafkaTopicOrder) (*pagination.Connection[*kafkatopic.KafkaTopic], error)
	OpenSearchInstances(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *opensearch.OpenSearchOrder) (*pagination.Connection[*opensearch.OpenSearch], error)
	RedisInstances(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *redis.RedisInstanceOrder) (*pagination.Connection[*redis.RedisInstance], error)
	Repositories(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *repository.RepositoryOrder, filter *repository.TeamRepositoryFilter) (*pagination.Connection[*repository.Repository], error)
	Secrets(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *secret.SecretOrder, filter *secret.SecretFilter) (*pagination.Connection[*secret.Secret], error)
	SQLInstances(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *sqlinstance.SQLInstanceOrder) (*pagination.Connection[*sqlinstance.SQLInstance], error)
	Unleash(ctx context.Context, obj *team.Team) (*unleash.UnleashInstance, error)
	WorkloadUtilization(ctx context.Context, obj *team.Team, resourceType utilization.UtilizationResourceType) ([]*utilization.WorkloadUtilizationData, error)
	ServiceUtilization(ctx context.Context, obj *team.Team) (*utilization.TeamServiceUtilization, error)
	ValkeyInstances(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *valkey.ValkeyInstanceOrder) (*pagination.Connection[*valkey.ValkeyInstance], error)
	VulnerabilitySummary(ctx context.Context, obj *team.Team, filter *vulnerability.TeamVulnerabilitySummaryFilter) (*vulnerability.TeamVulnerabilitySummary, error)
	Workloads(ctx context.Context, obj *team.Team, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *workload.WorkloadOrder, filter *workload.TeamWorkloadsFilter) (*pagination.Connection[workload.Workload], error)
}
type TeamCostResolver interface {
	Daily(ctx context.Context, obj *cost.TeamCost, from scalar.Date, to scalar.Date, filter *cost.TeamCostDailyFilter) (*cost.TeamCostPeriod, error)
	MonthlySummary(ctx context.Context, obj *cost.TeamCost) (*cost.TeamCostMonthlySummary, error)
}
type TeamDeleteKeyResolver interface {
	CreatedBy(ctx context.Context, obj *team.TeamDeleteKey) (*user.User, error)
	Team(ctx context.Context, obj *team.TeamDeleteKey) (*team.Team, error)
}
type TeamEnvironmentResolver interface {
	Team(ctx context.Context, obj *team.TeamEnvironment) (*team.Team, error)
	Application(ctx context.Context, obj *team.TeamEnvironment, name string) (*application.Application, error)
	BigQueryDataset(ctx context.Context, obj *team.TeamEnvironment, name string) (*bigquery.BigQueryDataset, error)
	Bucket(ctx context.Context, obj *team.TeamEnvironment, name string) (*bucket.Bucket, error)
	Cost(ctx context.Context, obj *team.TeamEnvironment) (*cost.TeamEnvironmentCost, error)
	Environment(ctx context.Context, obj *team.TeamEnvironment) (*environment.Environment, error)
	Job(ctx context.Context, obj *team.TeamEnvironment, name string) (*job.Job, error)
	KafkaTopic(ctx context.Context, obj *team.TeamEnvironment, name string) (*kafkatopic.KafkaTopic, error)
	OpenSearchInstance(ctx context.Context, obj *team.TeamEnvironment, name string) (*opensearch.OpenSearch, error)
	RedisInstance(ctx context.Context, obj *team.TeamEnvironment, name string) (*redis.RedisInstance, error)
	Secret(ctx context.Context, obj *team.TeamEnvironment, name string) (*secret.Secret, error)
	SQLInstance(ctx context.Context, obj *team.TeamEnvironment, name string) (*sqlinstance.SQLInstance, error)
	ValkeyInstance(ctx context.Context, obj *team.TeamEnvironment, name string) (*valkey.ValkeyInstance, error)
	Workload(ctx context.Context, obj *team.TeamEnvironment, name string) (workload.Workload, error)
}
type TeamEnvironmentCostResolver interface {
	Daily(ctx context.Context, obj *cost.TeamEnvironmentCost, from scalar.Date, to scalar.Date) (*cost.TeamEnvironmentCostPeriod, error)
}
type TeamInventoryCountApplicationsResolver interface {
	NotNais(ctx context.Context, obj *application.TeamInventoryCountApplications) (int, error)
}
type TeamInventoryCountJobsResolver interface {
	NotNais(ctx context.Context, obj *job.TeamInventoryCountJobs) (int, error)
}
type TeamInventoryCountsResolver interface {
	Applications(ctx context.Context, obj *team.TeamInventoryCounts) (*application.TeamInventoryCountApplications, error)
	BigQueryDatasets(ctx context.Context, obj *team.TeamInventoryCounts) (*bigquery.TeamInventoryCountBigQueryDatasets, error)
	Buckets(ctx context.Context, obj *team.TeamInventoryCounts) (*bucket.TeamInventoryCountBuckets, error)
	Jobs(ctx context.Context, obj *team.TeamInventoryCounts) (*job.TeamInventoryCountJobs, error)
	KafkaTopics(ctx context.Context, obj *team.TeamInventoryCounts) (*kafkatopic.TeamInventoryCountKafkaTopics, error)
	OpenSearchInstances(ctx context.Context, obj *team.TeamInventoryCounts) (*opensearch.TeamInventoryCountOpenSearchInstances, error)
	RedisInstances(ctx context.Context, obj *team.TeamInventoryCounts) (*redis.TeamInventoryCountRedisInstances, error)
	SQLInstances(ctx context.Context, obj *team.TeamInventoryCounts) (*sqlinstance.TeamInventoryCountSQLInstances, error)
	ValkeyInstances(ctx context.Context, obj *team.TeamInventoryCounts) (*valkey.TeamInventoryCountValkeyInstances, error)
}
type TeamMemberResolver interface {
	Team(ctx context.Context, obj *team.TeamMember) (*team.Team, error)
	User(ctx context.Context, obj *team.TeamMember) (*user.User, error)
}
type TeamServiceUtilizationResolver interface {
	SQLInstances(ctx context.Context, obj *utilization.TeamServiceUtilization) (*sqlinstance.TeamServiceUtilizationSQLInstances, error)
}
type TeamServiceUtilizationSqlInstancesResolver interface {
	CPU(ctx context.Context, obj *sqlinstance.TeamServiceUtilizationSQLInstances) (*sqlinstance.TeamServiceUtilizationSQLInstancesCPU, error)
	Memory(ctx context.Context, obj *sqlinstance.TeamServiceUtilizationSQLInstances) (*sqlinstance.TeamServiceUtilizationSQLInstancesMemory, error)
	Disk(ctx context.Context, obj *sqlinstance.TeamServiceUtilizationSQLInstances) (*sqlinstance.TeamServiceUtilizationSQLInstancesDisk, error)
}
type TeamUtilizationDataResolver interface {
	Team(ctx context.Context, obj *utilization.TeamUtilizationData) (*team.Team, error)

	Environment(ctx context.Context, obj *utilization.TeamUtilizationData) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *utilization.TeamUtilizationData) (*team.TeamEnvironment, error)
}
type TeamVulnerabilitySummaryResolver interface {
	Ranking(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRanking, error)
	RiskScoreTrend(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRiskScoreTrend, error)
	Status(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) ([]*vulnerability.TeamVulnerabilityStatus, error)
}
type TriggerJobPayloadResolver interface {
	Job(ctx context.Context, obj *job.TriggerJobPayload) (*job.Job, error)
}
type UnleashInstanceResolver interface {
	AllowedTeams(ctx context.Context, obj *unleash.UnleashInstance, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*team.Team], error)
}
type UnleashInstanceMetricsResolver interface {
	Toggles(ctx context.Context, obj *unleash.UnleashInstanceMetrics) (int, error)
	APITokens(ctx context.Context, obj *unleash.UnleashInstanceMetrics) (int, error)
	CPUUtilization(ctx context.Context, obj *unleash.UnleashInstanceMetrics) (float64, error)

	MemoryUtilization(ctx context.Context, obj *unleash.UnleashInstanceMetrics) (float64, error)
}
type UpdateTeamEnvironmentPayloadResolver interface {
	Environment(ctx context.Context, obj *team.UpdateTeamEnvironmentPayload) (*team.TeamEnvironment, error)
}
type UserResolver interface {
	Teams(ctx context.Context, obj *user.User, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *team.UserTeamOrder) (*pagination.Connection[*team.TeamMember], error)
}
type ValkeyInstanceResolver interface {
	Team(ctx context.Context, obj *valkey.ValkeyInstance) (*team.Team, error)
	Environment(ctx context.Context, obj *valkey.ValkeyInstance) (*team.TeamEnvironment, error)
	TeamEnvironment(ctx context.Context, obj *valkey.ValkeyInstance) (*team.TeamEnvironment, error)
	Access(ctx context.Context, obj *valkey.ValkeyInstance, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *valkey.ValkeyInstanceAccessOrder) (*pagination.Connection[*valkey.ValkeyInstanceAccess], error)
	Workload(ctx context.Context, obj *valkey.ValkeyInstance) (workload.Workload, error)

	Cost(ctx context.Context, obj *valkey.ValkeyInstance) (*cost.ValkeyInstanceCost, error)
}
type ValkeyInstanceAccessResolver interface {
	Workload(ctx context.Context, obj *valkey.ValkeyInstanceAccess) (workload.Workload, error)
}
type WorkloadCostResolver interface {
	Daily(ctx context.Context, obj *cost.WorkloadCost, from scalar.Date, to scalar.Date) (*cost.WorkloadCostPeriod, error)
	Monthly(ctx context.Context, obj *cost.WorkloadCost) (*cost.WorkloadCostPeriod, error)
}
type WorkloadCostSampleResolver interface {
	Workload(ctx context.Context, obj *cost.WorkloadCostSample) (workload.Workload, error)
}
type WorkloadUtilizationResolver interface {
	Current(ctx context.Context, obj *utilization.WorkloadUtilization, resourceType utilization.UtilizationResourceType) (float64, error)
	Requested(ctx context.Context, obj *utilization.WorkloadUtilization, resourceType utilization.UtilizationResourceType) (float64, error)
	Limit(ctx context.Context, obj *utilization.WorkloadUtilization, resourceType utilization.UtilizationResourceType) (*float64, error)
	Series(ctx context.Context, obj *utilization.WorkloadUtilization, input utilization.WorkloadUtilizationSeriesInput) ([]*utilization.UtilizationSample, error)
}
type WorkloadUtilizationDataResolver interface {
	Workload(ctx context.Context, obj *utilization.WorkloadUtilizationData) (workload.Workload, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "ActivityLogEntryConnection.edges":
		if e.complexity.ActivityLogEntryConnection.Edges == nil {
			break
		}

		return e.complexity.ActivityLogEntryConnection.Edges(childComplexity), true

	case "ActivityLogEntryConnection.nodes":
		if e.complexity.ActivityLogEntryConnection.Nodes == nil {
			break
		}

		return e.complexity.ActivityLogEntryConnection.Nodes(childComplexity), true

	case "ActivityLogEntryConnection.pageInfo":
		if e.complexity.ActivityLogEntryConnection.PageInfo == nil {
			break
		}

		return e.complexity.ActivityLogEntryConnection.PageInfo(childComplexity), true

	case "ActivityLogEntryEdge.cursor":
		if e.complexity.ActivityLogEntryEdge.Cursor == nil {
			break
		}

		return e.complexity.ActivityLogEntryEdge.Cursor(childComplexity), true

	case "ActivityLogEntryEdge.node":
		if e.complexity.ActivityLogEntryEdge.Node == nil {
			break
		}

		return e.complexity.ActivityLogEntryEdge.Node(childComplexity), true

	case "AddRepositoryToTeamPayload.repository":
		if e.complexity.AddRepositoryToTeamPayload.Repository == nil {
			break
		}

		return e.complexity.AddRepositoryToTeamPayload.Repository(childComplexity), true

	case "AddSecretValuePayload.secret":
		if e.complexity.AddSecretValuePayload.Secret == nil {
			break
		}

		return e.complexity.AddSecretValuePayload.Secret(childComplexity), true

	case "AddTeamMemberPayload.member":
		if e.complexity.AddTeamMemberPayload.Member == nil {
			break
		}

		return e.complexity.AddTeamMemberPayload.Member(childComplexity), true

	case "AllowTeamAccessToUnleashPayload.unleash":
		if e.complexity.AllowTeamAccessToUnleashPayload.Unleash == nil {
			break
		}

		return e.complexity.AllowTeamAccessToUnleashPayload.Unleash(childComplexity), true

	case "Application.authIntegrations":
		if e.complexity.Application.AuthIntegrations == nil {
			break
		}

		return e.complexity.Application.AuthIntegrations(childComplexity), true

	case "Application.bigQueryDatasets":
		if e.complexity.Application.BigQueryDatasets == nil {
			break
		}

		args, err := ec.field_Application_bigQueryDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.BigQueryDatasets(childComplexity, args["orderBy"].(*bigquery.BigQueryDatasetOrder)), true

	case "Application.buckets":
		if e.complexity.Application.Buckets == nil {
			break
		}

		args, err := ec.field_Application_buckets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.Buckets(childComplexity, args["orderBy"].(*bucket.BucketOrder)), true

	case "Application.cost":
		if e.complexity.Application.Cost == nil {
			break
		}

		return e.complexity.Application.Cost(childComplexity), true

	case "Application.deletionStartedAt":
		if e.complexity.Application.DeletionStartedAt == nil {
			break
		}

		return e.complexity.Application.DeletionStartedAt(childComplexity), true

	case "Application.deployments":
		if e.complexity.Application.Deployments == nil {
			break
		}

		args, err := ec.field_Application_deployments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.Deployments(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Application.environment":
		if e.complexity.Application.Environment == nil {
			break
		}

		return e.complexity.Application.Environment(childComplexity), true

	case "Application.id":
		if e.complexity.Application.ID == nil {
			break
		}

		return e.complexity.Application.ID(childComplexity), true

	case "Application.image":
		if e.complexity.Application.Image == nil {
			break
		}

		return e.complexity.Application.Image(childComplexity), true

	case "Application.ingresses":
		if e.complexity.Application.Ingresses == nil {
			break
		}

		return e.complexity.Application.Ingresses(childComplexity), true

	case "Application.instances":
		if e.complexity.Application.Instances == nil {
			break
		}

		args, err := ec.field_Application_instances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.Instances(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Application.kafkaTopicAcls":
		if e.complexity.Application.KafkaTopicAcls == nil {
			break
		}

		args, err := ec.field_Application_kafkaTopicAcls_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.KafkaTopicAcls(childComplexity, args["orderBy"].(*kafkatopic.KafkaTopicACLOrder)), true

	case "Application.logDestinations":
		if e.complexity.Application.LogDestinations == nil {
			break
		}

		return e.complexity.Application.LogDestinations(childComplexity), true

	case "Application.manifest":
		if e.complexity.Application.Manifest == nil {
			break
		}

		return e.complexity.Application.Manifest(childComplexity), true

	case "Application.name":
		if e.complexity.Application.Name == nil {
			break
		}

		return e.complexity.Application.Name(childComplexity), true

	case "Application.networkPolicy":
		if e.complexity.Application.NetworkPolicy == nil {
			break
		}

		return e.complexity.Application.NetworkPolicy(childComplexity), true

	case "Application.openSearch":
		if e.complexity.Application.OpenSearch == nil {
			break
		}

		return e.complexity.Application.OpenSearch(childComplexity), true

	case "Application.redisInstances":
		if e.complexity.Application.RedisInstances == nil {
			break
		}

		args, err := ec.field_Application_redisInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.RedisInstances(childComplexity, args["orderBy"].(*redis.RedisInstanceOrder)), true

	case "Application.resources":
		if e.complexity.Application.Resources == nil {
			break
		}

		return e.complexity.Application.Resources(childComplexity), true

	case "Application.sqlInstances":
		if e.complexity.Application.SQLInstances == nil {
			break
		}

		args, err := ec.field_Application_sqlInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.SQLInstances(childComplexity, args["orderBy"].(*sqlinstance.SQLInstanceOrder)), true

	case "Application.secrets":
		if e.complexity.Application.Secrets == nil {
			break
		}

		args, err := ec.field_Application_secrets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.Secrets(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Application.status":
		if e.complexity.Application.Status == nil {
			break
		}

		return e.complexity.Application.Status(childComplexity), true

	case "Application.team":
		if e.complexity.Application.Team == nil {
			break
		}

		return e.complexity.Application.Team(childComplexity), true

	case "Application.teamEnvironment":
		if e.complexity.Application.TeamEnvironment == nil {
			break
		}

		return e.complexity.Application.TeamEnvironment(childComplexity), true

	case "Application.utilization":
		if e.complexity.Application.Utilization == nil {
			break
		}

		return e.complexity.Application.Utilization(childComplexity), true

	case "Application.valkeyInstances":
		if e.complexity.Application.ValkeyInstances == nil {
			break
		}

		args, err := ec.field_Application_valkeyInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.ValkeyInstances(childComplexity, args["orderBy"].(*valkey.ValkeyInstanceOrder)), true

	case "ApplicationConnection.edges":
		if e.complexity.ApplicationConnection.Edges == nil {
			break
		}

		return e.complexity.ApplicationConnection.Edges(childComplexity), true

	case "ApplicationConnection.nodes":
		if e.complexity.ApplicationConnection.Nodes == nil {
			break
		}

		return e.complexity.ApplicationConnection.Nodes(childComplexity), true

	case "ApplicationConnection.pageInfo":
		if e.complexity.ApplicationConnection.PageInfo == nil {
			break
		}

		return e.complexity.ApplicationConnection.PageInfo(childComplexity), true

	case "ApplicationDeletedActivityLogEntry.actor":
		if e.complexity.ApplicationDeletedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.ApplicationDeletedActivityLogEntry.Actor(childComplexity), true

	case "ApplicationDeletedActivityLogEntry.createdAt":
		if e.complexity.ApplicationDeletedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.ApplicationDeletedActivityLogEntry.CreatedAt(childComplexity), true

	case "ApplicationDeletedActivityLogEntry.environmentName":
		if e.complexity.ApplicationDeletedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.ApplicationDeletedActivityLogEntry.EnvironmentName(childComplexity), true

	case "ApplicationDeletedActivityLogEntry.id":
		if e.complexity.ApplicationDeletedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.ApplicationDeletedActivityLogEntry.ID(childComplexity), true

	case "ApplicationDeletedActivityLogEntry.message":
		if e.complexity.ApplicationDeletedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.ApplicationDeletedActivityLogEntry.Message(childComplexity), true

	case "ApplicationDeletedActivityLogEntry.resourceName":
		if e.complexity.ApplicationDeletedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.ApplicationDeletedActivityLogEntry.ResourceName(childComplexity), true

	case "ApplicationDeletedActivityLogEntry.resourceType":
		if e.complexity.ApplicationDeletedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.ApplicationDeletedActivityLogEntry.ResourceType(childComplexity), true

	case "ApplicationDeletedActivityLogEntry.teamSlug":
		if e.complexity.ApplicationDeletedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.ApplicationDeletedActivityLogEntry.TeamSlug(childComplexity), true

	case "ApplicationEdge.cursor":
		if e.complexity.ApplicationEdge.Cursor == nil {
			break
		}

		return e.complexity.ApplicationEdge.Cursor(childComplexity), true

	case "ApplicationEdge.node":
		if e.complexity.ApplicationEdge.Node == nil {
			break
		}

		return e.complexity.ApplicationEdge.Node(childComplexity), true

	case "ApplicationInstance.created":
		if e.complexity.ApplicationInstance.Created == nil {
			break
		}

		return e.complexity.ApplicationInstance.Created(childComplexity), true

	case "ApplicationInstance.id":
		if e.complexity.ApplicationInstance.ID == nil {
			break
		}

		return e.complexity.ApplicationInstance.ID(childComplexity), true

	case "ApplicationInstance.image":
		if e.complexity.ApplicationInstance.Image == nil {
			break
		}

		return e.complexity.ApplicationInstance.Image(childComplexity), true

	case "ApplicationInstance.name":
		if e.complexity.ApplicationInstance.Name == nil {
			break
		}

		return e.complexity.ApplicationInstance.Name(childComplexity), true

	case "ApplicationInstance.restarts":
		if e.complexity.ApplicationInstance.Restarts == nil {
			break
		}

		return e.complexity.ApplicationInstance.Restarts(childComplexity), true

	case "ApplicationInstance.status":
		if e.complexity.ApplicationInstance.Status == nil {
			break
		}

		return e.complexity.ApplicationInstance.Status(childComplexity), true

	case "ApplicationInstanceConnection.edges":
		if e.complexity.ApplicationInstanceConnection.Edges == nil {
			break
		}

		return e.complexity.ApplicationInstanceConnection.Edges(childComplexity), true

	case "ApplicationInstanceConnection.nodes":
		if e.complexity.ApplicationInstanceConnection.Nodes == nil {
			break
		}

		return e.complexity.ApplicationInstanceConnection.Nodes(childComplexity), true

	case "ApplicationInstanceConnection.pageInfo":
		if e.complexity.ApplicationInstanceConnection.PageInfo == nil {
			break
		}

		return e.complexity.ApplicationInstanceConnection.PageInfo(childComplexity), true

	case "ApplicationInstanceEdge.cursor":
		if e.complexity.ApplicationInstanceEdge.Cursor == nil {
			break
		}

		return e.complexity.ApplicationInstanceEdge.Cursor(childComplexity), true

	case "ApplicationInstanceEdge.node":
		if e.complexity.ApplicationInstanceEdge.Node == nil {
			break
		}

		return e.complexity.ApplicationInstanceEdge.Node(childComplexity), true

	case "ApplicationInstanceStatus.message":
		if e.complexity.ApplicationInstanceStatus.Message == nil {
			break
		}

		return e.complexity.ApplicationInstanceStatus.Message(childComplexity), true

	case "ApplicationInstanceStatus.state":
		if e.complexity.ApplicationInstanceStatus.State == nil {
			break
		}

		return e.complexity.ApplicationInstanceStatus.State(childComplexity), true

	case "ApplicationManifest.content":
		if e.complexity.ApplicationManifest.Content == nil {
			break
		}

		return e.complexity.ApplicationManifest.Content(childComplexity), true

	case "ApplicationResources.limits":
		if e.complexity.ApplicationResources.Limits == nil {
			break
		}

		return e.complexity.ApplicationResources.Limits(childComplexity), true

	case "ApplicationResources.requests":
		if e.complexity.ApplicationResources.Requests == nil {
			break
		}

		return e.complexity.ApplicationResources.Requests(childComplexity), true

	case "ApplicationResources.scaling":
		if e.complexity.ApplicationResources.Scaling == nil {
			break
		}

		return e.complexity.ApplicationResources.Scaling(childComplexity), true

	case "ApplicationRestartedActivityLogEntry.actor":
		if e.complexity.ApplicationRestartedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.ApplicationRestartedActivityLogEntry.Actor(childComplexity), true

	case "ApplicationRestartedActivityLogEntry.createdAt":
		if e.complexity.ApplicationRestartedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.ApplicationRestartedActivityLogEntry.CreatedAt(childComplexity), true

	case "ApplicationRestartedActivityLogEntry.environmentName":
		if e.complexity.ApplicationRestartedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.ApplicationRestartedActivityLogEntry.EnvironmentName(childComplexity), true

	case "ApplicationRestartedActivityLogEntry.id":
		if e.complexity.ApplicationRestartedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.ApplicationRestartedActivityLogEntry.ID(childComplexity), true

	case "ApplicationRestartedActivityLogEntry.message":
		if e.complexity.ApplicationRestartedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.ApplicationRestartedActivityLogEntry.Message(childComplexity), true

	case "ApplicationRestartedActivityLogEntry.resourceName":
		if e.complexity.ApplicationRestartedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.ApplicationRestartedActivityLogEntry.ResourceName(childComplexity), true

	case "ApplicationRestartedActivityLogEntry.resourceType":
		if e.complexity.ApplicationRestartedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.ApplicationRestartedActivityLogEntry.ResourceType(childComplexity), true

	case "ApplicationRestartedActivityLogEntry.teamSlug":
		if e.complexity.ApplicationRestartedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.ApplicationRestartedActivityLogEntry.TeamSlug(childComplexity), true

	case "ApplicationScaling.maxInstances":
		if e.complexity.ApplicationScaling.MaxInstances == nil {
			break
		}

		return e.complexity.ApplicationScaling.MaxInstances(childComplexity), true

	case "ApplicationScaling.minInstances":
		if e.complexity.ApplicationScaling.MinInstances == nil {
			break
		}

		return e.complexity.ApplicationScaling.MinInstances(childComplexity), true

	case "ApplicationScaling.strategies":
		if e.complexity.ApplicationScaling.Strategies == nil {
			break
		}

		return e.complexity.ApplicationScaling.Strategies(childComplexity), true

	case "AssignRoleToServiceAccountPayload.serviceAccount":
		if e.complexity.AssignRoleToServiceAccountPayload.ServiceAccount == nil {
			break
		}

		return e.complexity.AssignRoleToServiceAccountPayload.ServiceAccount(childComplexity), true

	case "BigQueryDataset.access":
		if e.complexity.BigQueryDataset.Access == nil {
			break
		}

		args, err := ec.field_BigQueryDataset_access_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.BigQueryDataset.Access(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*bigquery.BigQueryDatasetAccessOrder)), true

	case "BigQueryDataset.cascadingDelete":
		if e.complexity.BigQueryDataset.CascadingDelete == nil {
			break
		}

		return e.complexity.BigQueryDataset.CascadingDelete(childComplexity), true

	case "BigQueryDataset.cost":
		if e.complexity.BigQueryDataset.Cost == nil {
			break
		}

		return e.complexity.BigQueryDataset.Cost(childComplexity), true

	case "BigQueryDataset.description":
		if e.complexity.BigQueryDataset.Description == nil {
			break
		}

		return e.complexity.BigQueryDataset.Description(childComplexity), true

	case "BigQueryDataset.environment":
		if e.complexity.BigQueryDataset.Environment == nil {
			break
		}

		return e.complexity.BigQueryDataset.Environment(childComplexity), true

	case "BigQueryDataset.id":
		if e.complexity.BigQueryDataset.ID == nil {
			break
		}

		return e.complexity.BigQueryDataset.ID(childComplexity), true

	case "BigQueryDataset.name":
		if e.complexity.BigQueryDataset.Name == nil {
			break
		}

		return e.complexity.BigQueryDataset.Name(childComplexity), true

	case "BigQueryDataset.status":
		if e.complexity.BigQueryDataset.Status == nil {
			break
		}

		return e.complexity.BigQueryDataset.Status(childComplexity), true

	case "BigQueryDataset.team":
		if e.complexity.BigQueryDataset.Team == nil {
			break
		}

		return e.complexity.BigQueryDataset.Team(childComplexity), true

	case "BigQueryDataset.teamEnvironment":
		if e.complexity.BigQueryDataset.TeamEnvironment == nil {
			break
		}

		return e.complexity.BigQueryDataset.TeamEnvironment(childComplexity), true

	case "BigQueryDataset.workload":
		if e.complexity.BigQueryDataset.Workload == nil {
			break
		}

		return e.complexity.BigQueryDataset.Workload(childComplexity), true

	case "BigQueryDatasetAccess.email":
		if e.complexity.BigQueryDatasetAccess.Email == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccess.Email(childComplexity), true

	case "BigQueryDatasetAccess.role":
		if e.complexity.BigQueryDatasetAccess.Role == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccess.Role(childComplexity), true

	case "BigQueryDatasetAccessConnection.edges":
		if e.complexity.BigQueryDatasetAccessConnection.Edges == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccessConnection.Edges(childComplexity), true

	case "BigQueryDatasetAccessConnection.nodes":
		if e.complexity.BigQueryDatasetAccessConnection.Nodes == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccessConnection.Nodes(childComplexity), true

	case "BigQueryDatasetAccessConnection.pageInfo":
		if e.complexity.BigQueryDatasetAccessConnection.PageInfo == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccessConnection.PageInfo(childComplexity), true

	case "BigQueryDatasetAccessEdge.cursor":
		if e.complexity.BigQueryDatasetAccessEdge.Cursor == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccessEdge.Cursor(childComplexity), true

	case "BigQueryDatasetAccessEdge.node":
		if e.complexity.BigQueryDatasetAccessEdge.Node == nil {
			break
		}

		return e.complexity.BigQueryDatasetAccessEdge.Node(childComplexity), true

	case "BigQueryDatasetConnection.edges":
		if e.complexity.BigQueryDatasetConnection.Edges == nil {
			break
		}

		return e.complexity.BigQueryDatasetConnection.Edges(childComplexity), true

	case "BigQueryDatasetConnection.nodes":
		if e.complexity.BigQueryDatasetConnection.Nodes == nil {
			break
		}

		return e.complexity.BigQueryDatasetConnection.Nodes(childComplexity), true

	case "BigQueryDatasetConnection.pageInfo":
		if e.complexity.BigQueryDatasetConnection.PageInfo == nil {
			break
		}

		return e.complexity.BigQueryDatasetConnection.PageInfo(childComplexity), true

	case "BigQueryDatasetCost.sum":
		if e.complexity.BigQueryDatasetCost.Sum == nil {
			break
		}

		return e.complexity.BigQueryDatasetCost.Sum(childComplexity), true

	case "BigQueryDatasetEdge.cursor":
		if e.complexity.BigQueryDatasetEdge.Cursor == nil {
			break
		}

		return e.complexity.BigQueryDatasetEdge.Cursor(childComplexity), true

	case "BigQueryDatasetEdge.node":
		if e.complexity.BigQueryDatasetEdge.Node == nil {
			break
		}

		return e.complexity.BigQueryDatasetEdge.Node(childComplexity), true

	case "BigQueryDatasetStatus.creationTime":
		if e.complexity.BigQueryDatasetStatus.CreationTime == nil {
			break
		}

		return e.complexity.BigQueryDatasetStatus.CreationTime(childComplexity), true

	case "BigQueryDatasetStatus.lastModifiedTime":
		if e.complexity.BigQueryDatasetStatus.LastModifiedTime == nil {
			break
		}

		return e.complexity.BigQueryDatasetStatus.LastModifiedTime(childComplexity), true

	case "Bucket.cascadingDelete":
		if e.complexity.Bucket.CascadingDelete == nil {
			break
		}

		return e.complexity.Bucket.CascadingDelete(childComplexity), true

	case "Bucket.environment":
		if e.complexity.Bucket.Environment == nil {
			break
		}

		return e.complexity.Bucket.Environment(childComplexity), true

	case "Bucket.id":
		if e.complexity.Bucket.ID == nil {
			break
		}

		return e.complexity.Bucket.ID(childComplexity), true

	case "Bucket.name":
		if e.complexity.Bucket.Name == nil {
			break
		}

		return e.complexity.Bucket.Name(childComplexity), true

	case "Bucket.publicAccessPrevention":
		if e.complexity.Bucket.PublicAccessPrevention == nil {
			break
		}

		return e.complexity.Bucket.PublicAccessPrevention(childComplexity), true

	case "Bucket.status":
		if e.complexity.Bucket.Status == nil {
			break
		}

		return e.complexity.Bucket.Status(childComplexity), true

	case "Bucket.team":
		if e.complexity.Bucket.Team == nil {
			break
		}

		return e.complexity.Bucket.Team(childComplexity), true

	case "Bucket.teamEnvironment":
		if e.complexity.Bucket.TeamEnvironment == nil {
			break
		}

		return e.complexity.Bucket.TeamEnvironment(childComplexity), true

	case "Bucket.uniformBucketLevelAccess":
		if e.complexity.Bucket.UniformBucketLevelAccess == nil {
			break
		}

		return e.complexity.Bucket.UniformBucketLevelAccess(childComplexity), true

	case "Bucket.workload":
		if e.complexity.Bucket.Workload == nil {
			break
		}

		return e.complexity.Bucket.Workload(childComplexity), true

	case "BucketConnection.edges":
		if e.complexity.BucketConnection.Edges == nil {
			break
		}

		return e.complexity.BucketConnection.Edges(childComplexity), true

	case "BucketConnection.nodes":
		if e.complexity.BucketConnection.Nodes == nil {
			break
		}

		return e.complexity.BucketConnection.Nodes(childComplexity), true

	case "BucketConnection.pageInfo":
		if e.complexity.BucketConnection.PageInfo == nil {
			break
		}

		return e.complexity.BucketConnection.PageInfo(childComplexity), true

	case "BucketEdge.cursor":
		if e.complexity.BucketEdge.Cursor == nil {
			break
		}

		return e.complexity.BucketEdge.Cursor(childComplexity), true

	case "BucketEdge.node":
		if e.complexity.BucketEdge.Node == nil {
			break
		}

		return e.complexity.BucketEdge.Node(childComplexity), true

	case "BucketError.details":
		if e.complexity.BucketError.Details == nil {
			break
		}

		return e.complexity.BucketError.Details(childComplexity), true

	case "BucketError.message":
		if e.complexity.BucketError.Message == nil {
			break
		}

		return e.complexity.BucketError.Message(childComplexity), true

	case "BucketStatus.errors":
		if e.complexity.BucketStatus.Errors == nil {
			break
		}

		return e.complexity.BucketStatus.Errors(childComplexity), true

	case "BucketStatus.state":
		if e.complexity.BucketStatus.State == nil {
			break
		}

		return e.complexity.BucketStatus.State(childComplexity), true

	case "CPUScalingStrategy.threshold":
		if e.complexity.CPUScalingStrategy.Threshold == nil {
			break
		}

		return e.complexity.CPUScalingStrategy.Threshold(childComplexity), true

	case "ChangeDeploymentKeyPayload.deploymentKey":
		if e.complexity.ChangeDeploymentKeyPayload.DeploymentKey == nil {
			break
		}

		return e.complexity.ChangeDeploymentKeyPayload.DeploymentKey(childComplexity), true

	case "ConfirmTeamDeletionPayload.deletionStarted":
		if e.complexity.ConfirmTeamDeletionPayload.DeletionStarted == nil {
			break
		}

		return e.complexity.ConfirmTeamDeletionPayload.DeletionStarted(childComplexity), true

	case "ContainerImage.hasSBOM":
		if e.complexity.ContainerImage.HasSbom == nil {
			break
		}

		return e.complexity.ContainerImage.HasSbom(childComplexity), true

	case "ContainerImage.id":
		if e.complexity.ContainerImage.ID == nil {
			break
		}

		return e.complexity.ContainerImage.ID(childComplexity), true

	case "ContainerImage.name":
		if e.complexity.ContainerImage.Name == nil {
			break
		}

		return e.complexity.ContainerImage.Name(childComplexity), true

	case "ContainerImage.tag":
		if e.complexity.ContainerImage.Tag == nil {
			break
		}

		return e.complexity.ContainerImage.Tag(childComplexity), true

	case "ContainerImage.vulnerabilities":
		if e.complexity.ContainerImage.Vulnerabilities == nil {
			break
		}

		args, err := ec.field_ContainerImage_vulnerabilities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ContainerImage.Vulnerabilities(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*vulnerability.ImageVulnerabilityOrder)), true

	case "ContainerImage.vulnerabilitySummary":
		if e.complexity.ContainerImage.VulnerabilitySummary == nil {
			break
		}

		return e.complexity.ContainerImage.VulnerabilitySummary(childComplexity), true

	case "ContainerImage.workloadReferences":
		if e.complexity.ContainerImage.WorkloadReferences == nil {
			break
		}

		args, err := ec.field_ContainerImage_workloadReferences_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ContainerImage.WorkloadReferences(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "ContainerImageWorkloadReference.workload":
		if e.complexity.ContainerImageWorkloadReference.Workload == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReference.Workload(childComplexity), true

	case "ContainerImageWorkloadReferenceConnection.edges":
		if e.complexity.ContainerImageWorkloadReferenceConnection.Edges == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReferenceConnection.Edges(childComplexity), true

	case "ContainerImageWorkloadReferenceConnection.nodes":
		if e.complexity.ContainerImageWorkloadReferenceConnection.Nodes == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReferenceConnection.Nodes(childComplexity), true

	case "ContainerImageWorkloadReferenceConnection.pageInfo":
		if e.complexity.ContainerImageWorkloadReferenceConnection.PageInfo == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReferenceConnection.PageInfo(childComplexity), true

	case "ContainerImageWorkloadReferenceEdge.cursor":
		if e.complexity.ContainerImageWorkloadReferenceEdge.Cursor == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReferenceEdge.Cursor(childComplexity), true

	case "ContainerImageWorkloadReferenceEdge.node":
		if e.complexity.ContainerImageWorkloadReferenceEdge.Node == nil {
			break
		}

		return e.complexity.ContainerImageWorkloadReferenceEdge.Node(childComplexity), true

	case "CreateSecretPayload.secret":
		if e.complexity.CreateSecretPayload.Secret == nil {
			break
		}

		return e.complexity.CreateSecretPayload.Secret(childComplexity), true

	case "CreateServiceAccountPayload.serviceAccount":
		if e.complexity.CreateServiceAccountPayload.ServiceAccount == nil {
			break
		}

		return e.complexity.CreateServiceAccountPayload.ServiceAccount(childComplexity), true

	case "CreateServiceAccountTokenPayload.secret":
		if e.complexity.CreateServiceAccountTokenPayload.Secret == nil {
			break
		}

		return e.complexity.CreateServiceAccountTokenPayload.Secret(childComplexity), true

	case "CreateServiceAccountTokenPayload.serviceAccount":
		if e.complexity.CreateServiceAccountTokenPayload.ServiceAccount == nil {
			break
		}

		return e.complexity.CreateServiceAccountTokenPayload.ServiceAccount(childComplexity), true

	case "CreateServiceAccountTokenPayload.serviceAccountToken":
		if e.complexity.CreateServiceAccountTokenPayload.ServiceAccountToken == nil {
			break
		}

		return e.complexity.CreateServiceAccountTokenPayload.ServiceAccountToken(childComplexity), true

	case "CreateTeamPayload.team":
		if e.complexity.CreateTeamPayload.Team == nil {
			break
		}

		return e.complexity.CreateTeamPayload.Team(childComplexity), true

	case "CreateUnleashForTeamPayload.unleash":
		if e.complexity.CreateUnleashForTeamPayload.Unleash == nil {
			break
		}

		return e.complexity.CreateUnleashForTeamPayload.Unleash(childComplexity), true

	case "DeleteApplicationPayload.success":
		if e.complexity.DeleteApplicationPayload.Success == nil {
			break
		}

		return e.complexity.DeleteApplicationPayload.Success(childComplexity), true

	case "DeleteApplicationPayload.team":
		if e.complexity.DeleteApplicationPayload.Team == nil {
			break
		}

		return e.complexity.DeleteApplicationPayload.Team(childComplexity), true

	case "DeleteJobPayload.success":
		if e.complexity.DeleteJobPayload.Success == nil {
			break
		}

		return e.complexity.DeleteJobPayload.Success(childComplexity), true

	case "DeleteJobPayload.team":
		if e.complexity.DeleteJobPayload.Team == nil {
			break
		}

		return e.complexity.DeleteJobPayload.Team(childComplexity), true

	case "DeleteSecretPayload.secretDeleted":
		if e.complexity.DeleteSecretPayload.SecretDeleted == nil {
			break
		}

		return e.complexity.DeleteSecretPayload.SecretDeleted(childComplexity), true

	case "DeleteServiceAccountPayload.serviceAccountDeleted":
		if e.complexity.DeleteServiceAccountPayload.ServiceAccountDeleted == nil {
			break
		}

		return e.complexity.DeleteServiceAccountPayload.ServiceAccountDeleted(childComplexity), true

	case "DeleteServiceAccountTokenPayload.serviceAccount":
		if e.complexity.DeleteServiceAccountTokenPayload.ServiceAccount == nil {
			break
		}

		return e.complexity.DeleteServiceAccountTokenPayload.ServiceAccount(childComplexity), true

	case "DeleteServiceAccountTokenPayload.serviceAccountTokenDeleted":
		if e.complexity.DeleteServiceAccountTokenPayload.ServiceAccountTokenDeleted == nil {
			break
		}

		return e.complexity.DeleteServiceAccountTokenPayload.ServiceAccountTokenDeleted(childComplexity), true

	case "Deployment.commitSha":
		if e.complexity.Deployment.CommitSha == nil {
			break
		}

		return e.complexity.Deployment.CommitSha(childComplexity), true

	case "Deployment.createdAt":
		if e.complexity.Deployment.CreatedAt == nil {
			break
		}

		return e.complexity.Deployment.CreatedAt(childComplexity), true

	case "Deployment.deployerUsername":
		if e.complexity.Deployment.DeployerUsername == nil {
			break
		}

		return e.complexity.Deployment.DeployerUsername(childComplexity), true

	case "Deployment.environmentName":
		if e.complexity.Deployment.EnvironmentName == nil {
			break
		}

		return e.complexity.Deployment.EnvironmentName(childComplexity), true

	case "Deployment.id":
		if e.complexity.Deployment.ID == nil {
			break
		}

		return e.complexity.Deployment.ID(childComplexity), true

	case "Deployment.repository":
		if e.complexity.Deployment.Repository == nil {
			break
		}

		return e.complexity.Deployment.Repository(childComplexity), true

	case "Deployment.resources":
		if e.complexity.Deployment.Resources == nil {
			break
		}

		args, err := ec.field_Deployment_resources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Deployment.Resources(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Deployment.statuses":
		if e.complexity.Deployment.Statuses == nil {
			break
		}

		args, err := ec.field_Deployment_statuses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Deployment.Statuses(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Deployment.teamSlug":
		if e.complexity.Deployment.TeamSlug == nil {
			break
		}

		return e.complexity.Deployment.TeamSlug(childComplexity), true

	case "Deployment.triggerUrl":
		if e.complexity.Deployment.TriggerUrl == nil {
			break
		}

		return e.complexity.Deployment.TriggerUrl(childComplexity), true

	case "DeploymentConnection.edges":
		if e.complexity.DeploymentConnection.Edges == nil {
			break
		}

		return e.complexity.DeploymentConnection.Edges(childComplexity), true

	case "DeploymentConnection.nodes":
		if e.complexity.DeploymentConnection.Nodes == nil {
			break
		}

		return e.complexity.DeploymentConnection.Nodes(childComplexity), true

	case "DeploymentConnection.pageInfo":
		if e.complexity.DeploymentConnection.PageInfo == nil {
			break
		}

		return e.complexity.DeploymentConnection.PageInfo(childComplexity), true

	case "DeploymentEdge.cursor":
		if e.complexity.DeploymentEdge.Cursor == nil {
			break
		}

		return e.complexity.DeploymentEdge.Cursor(childComplexity), true

	case "DeploymentEdge.node":
		if e.complexity.DeploymentEdge.Node == nil {
			break
		}

		return e.complexity.DeploymentEdge.Node(childComplexity), true

	case "DeploymentKey.created":
		if e.complexity.DeploymentKey.Created == nil {
			break
		}

		return e.complexity.DeploymentKey.Created(childComplexity), true

	case "DeploymentKey.expires":
		if e.complexity.DeploymentKey.Expires == nil {
			break
		}

		return e.complexity.DeploymentKey.Expires(childComplexity), true

	case "DeploymentKey.id":
		if e.complexity.DeploymentKey.ID == nil {
			break
		}

		return e.complexity.DeploymentKey.ID(childComplexity), true

	case "DeploymentKey.key":
		if e.complexity.DeploymentKey.Key == nil {
			break
		}

		return e.complexity.DeploymentKey.Key(childComplexity), true

	case "DeploymentResource.id":
		if e.complexity.DeploymentResource.ID == nil {
			break
		}

		return e.complexity.DeploymentResource.ID(childComplexity), true

	case "DeploymentResource.kind":
		if e.complexity.DeploymentResource.Kind == nil {
			break
		}

		return e.complexity.DeploymentResource.Kind(childComplexity), true

	case "DeploymentResource.name":
		if e.complexity.DeploymentResource.Name == nil {
			break
		}

		return e.complexity.DeploymentResource.Name(childComplexity), true

	case "DeploymentResourceConnection.edges":
		if e.complexity.DeploymentResourceConnection.Edges == nil {
			break
		}

		return e.complexity.DeploymentResourceConnection.Edges(childComplexity), true

	case "DeploymentResourceConnection.nodes":
		if e.complexity.DeploymentResourceConnection.Nodes == nil {
			break
		}

		return e.complexity.DeploymentResourceConnection.Nodes(childComplexity), true

	case "DeploymentResourceConnection.pageInfo":
		if e.complexity.DeploymentResourceConnection.PageInfo == nil {
			break
		}

		return e.complexity.DeploymentResourceConnection.PageInfo(childComplexity), true

	case "DeploymentResourceEdge.cursor":
		if e.complexity.DeploymentResourceEdge.Cursor == nil {
			break
		}

		return e.complexity.DeploymentResourceEdge.Cursor(childComplexity), true

	case "DeploymentResourceEdge.node":
		if e.complexity.DeploymentResourceEdge.Node == nil {
			break
		}

		return e.complexity.DeploymentResourceEdge.Node(childComplexity), true

	case "DeploymentStatus.createdAt":
		if e.complexity.DeploymentStatus.CreatedAt == nil {
			break
		}

		return e.complexity.DeploymentStatus.CreatedAt(childComplexity), true

	case "DeploymentStatus.id":
		if e.complexity.DeploymentStatus.ID == nil {
			break
		}

		return e.complexity.DeploymentStatus.ID(childComplexity), true

	case "DeploymentStatus.message":
		if e.complexity.DeploymentStatus.Message == nil {
			break
		}

		return e.complexity.DeploymentStatus.Message(childComplexity), true

	case "DeploymentStatus.state":
		if e.complexity.DeploymentStatus.State == nil {
			break
		}

		return e.complexity.DeploymentStatus.State(childComplexity), true

	case "DeploymentStatusConnection.edges":
		if e.complexity.DeploymentStatusConnection.Edges == nil {
			break
		}

		return e.complexity.DeploymentStatusConnection.Edges(childComplexity), true

	case "DeploymentStatusConnection.nodes":
		if e.complexity.DeploymentStatusConnection.Nodes == nil {
			break
		}

		return e.complexity.DeploymentStatusConnection.Nodes(childComplexity), true

	case "DeploymentStatusConnection.pageInfo":
		if e.complexity.DeploymentStatusConnection.PageInfo == nil {
			break
		}

		return e.complexity.DeploymentStatusConnection.PageInfo(childComplexity), true

	case "DeploymentStatusEdge.cursor":
		if e.complexity.DeploymentStatusEdge.Cursor == nil {
			break
		}

		return e.complexity.DeploymentStatusEdge.Cursor(childComplexity), true

	case "DeploymentStatusEdge.node":
		if e.complexity.DeploymentStatusEdge.Node == nil {
			break
		}

		return e.complexity.DeploymentStatusEdge.Node(childComplexity), true

	case "EntraIDAuthIntegration.name":
		if e.complexity.EntraIDAuthIntegration.Name == nil {
			break
		}

		return e.complexity.EntraIDAuthIntegration.Name(childComplexity), true

	case "Environment.id":
		if e.complexity.Environment.ID == nil {
			break
		}

		return e.complexity.Environment.ID(childComplexity), true

	case "Environment.name":
		if e.complexity.Environment.Name == nil {
			break
		}

		return e.complexity.Environment.Name(childComplexity), true

	case "Environment.workloads":
		if e.complexity.Environment.Workloads == nil {
			break
		}

		args, err := ec.field_Environment_workloads_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Environment.Workloads(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*workload.EnvironmentWorkloadOrder)), true

	case "EnvironmentConnection.edges":
		if e.complexity.EnvironmentConnection.Edges == nil {
			break
		}

		return e.complexity.EnvironmentConnection.Edges(childComplexity), true

	case "EnvironmentConnection.nodes":
		if e.complexity.EnvironmentConnection.Nodes == nil {
			break
		}

		return e.complexity.EnvironmentConnection.Nodes(childComplexity), true

	case "EnvironmentConnection.pageInfo":
		if e.complexity.EnvironmentConnection.PageInfo == nil {
			break
		}

		return e.complexity.EnvironmentConnection.PageInfo(childComplexity), true

	case "EnvironmentEdge.cursor":
		if e.complexity.EnvironmentEdge.Cursor == nil {
			break
		}

		return e.complexity.EnvironmentEdge.Cursor(childComplexity), true

	case "EnvironmentEdge.node":
		if e.complexity.EnvironmentEdge.Node == nil {
			break
		}

		return e.complexity.EnvironmentEdge.Node(childComplexity), true

	case "ExternalNetworkPolicyHost.ports":
		if e.complexity.ExternalNetworkPolicyHost.Ports == nil {
			break
		}

		return e.complexity.ExternalNetworkPolicyHost.Ports(childComplexity), true

	case "ExternalNetworkPolicyHost.target":
		if e.complexity.ExternalNetworkPolicyHost.Target == nil {
			break
		}

		return e.complexity.ExternalNetworkPolicyHost.Target(childComplexity), true

	case "ExternalNetworkPolicyIpv4.ports":
		if e.complexity.ExternalNetworkPolicyIpv4.Ports == nil {
			break
		}

		return e.complexity.ExternalNetworkPolicyIpv4.Ports(childComplexity), true

	case "ExternalNetworkPolicyIpv4.target":
		if e.complexity.ExternalNetworkPolicyIpv4.Target == nil {
			break
		}

		return e.complexity.ExternalNetworkPolicyIpv4.Target(childComplexity), true

	case "FeatureKafka.enabled":
		if e.complexity.FeatureKafka.Enabled == nil {
			break
		}

		return e.complexity.FeatureKafka.Enabled(childComplexity), true

	case "FeatureKafka.id":
		if e.complexity.FeatureKafka.ID == nil {
			break
		}

		return e.complexity.FeatureKafka.ID(childComplexity), true

	case "FeatureOpenSearch.enabled":
		if e.complexity.FeatureOpenSearch.Enabled == nil {
			break
		}

		return e.complexity.FeatureOpenSearch.Enabled(childComplexity), true

	case "FeatureOpenSearch.id":
		if e.complexity.FeatureOpenSearch.ID == nil {
			break
		}

		return e.complexity.FeatureOpenSearch.ID(childComplexity), true

	case "FeatureRedis.enabled":
		if e.complexity.FeatureRedis.Enabled == nil {
			break
		}

		return e.complexity.FeatureRedis.Enabled(childComplexity), true

	case "FeatureRedis.id":
		if e.complexity.FeatureRedis.ID == nil {
			break
		}

		return e.complexity.FeatureRedis.ID(childComplexity), true

	case "FeatureUnleash.enabled":
		if e.complexity.FeatureUnleash.Enabled == nil {
			break
		}

		return e.complexity.FeatureUnleash.Enabled(childComplexity), true

	case "FeatureUnleash.id":
		if e.complexity.FeatureUnleash.ID == nil {
			break
		}

		return e.complexity.FeatureUnleash.ID(childComplexity), true

	case "FeatureValkey.enabled":
		if e.complexity.FeatureValkey.Enabled == nil {
			break
		}

		return e.complexity.FeatureValkey.Enabled(childComplexity), true

	case "FeatureValkey.id":
		if e.complexity.FeatureValkey.ID == nil {
			break
		}

		return e.complexity.FeatureValkey.ID(childComplexity), true

	case "Features.id":
		if e.complexity.Features.ID == nil {
			break
		}

		return e.complexity.Features.ID(childComplexity), true

	case "Features.kafka":
		if e.complexity.Features.Kafka == nil {
			break
		}

		return e.complexity.Features.Kafka(childComplexity), true

	case "Features.openSearch":
		if e.complexity.Features.OpenSearch == nil {
			break
		}

		return e.complexity.Features.OpenSearch(childComplexity), true

	case "Features.redis":
		if e.complexity.Features.Redis == nil {
			break
		}

		return e.complexity.Features.Redis(childComplexity), true

	case "Features.unleash":
		if e.complexity.Features.Unleash == nil {
			break
		}

		return e.complexity.Features.Unleash(childComplexity), true

	case "Features.valkey":
		if e.complexity.Features.Valkey == nil {
			break
		}

		return e.complexity.Features.Valkey(childComplexity), true

	case "IDPortenAuthIntegration.name":
		if e.complexity.IDPortenAuthIntegration.Name == nil {
			break
		}

		return e.complexity.IDPortenAuthIntegration.Name(childComplexity), true

	case "ImageVulnerability.analysisTrail":
		if e.complexity.ImageVulnerability.AnalysisTrail == nil {
			break
		}

		return e.complexity.ImageVulnerability.AnalysisTrail(childComplexity), true

	case "ImageVulnerability.description":
		if e.complexity.ImageVulnerability.Description == nil {
			break
		}

		return e.complexity.ImageVulnerability.Description(childComplexity), true

	case "ImageVulnerability.id":
		if e.complexity.ImageVulnerability.ID == nil {
			break
		}

		return e.complexity.ImageVulnerability.ID(childComplexity), true

	case "ImageVulnerability.identifier":
		if e.complexity.ImageVulnerability.Identifier == nil {
			break
		}

		return e.complexity.ImageVulnerability.Identifier(childComplexity), true

	case "ImageVulnerability.package":
		if e.complexity.ImageVulnerability.Package == nil {
			break
		}

		return e.complexity.ImageVulnerability.Package(childComplexity), true

	case "ImageVulnerability.severity":
		if e.complexity.ImageVulnerability.Severity == nil {
			break
		}

		return e.complexity.ImageVulnerability.Severity(childComplexity), true

	case "ImageVulnerability.state":
		if e.complexity.ImageVulnerability.State == nil {
			break
		}

		return e.complexity.ImageVulnerability.State(childComplexity), true

	case "ImageVulnerabilityAnalysisComment.comment":
		if e.complexity.ImageVulnerabilityAnalysisComment.Comment == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisComment.Comment(childComplexity), true

	case "ImageVulnerabilityAnalysisComment.onBehalfOf":
		if e.complexity.ImageVulnerabilityAnalysisComment.OnBehalfOf == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisComment.OnBehalfOf(childComplexity), true

	case "ImageVulnerabilityAnalysisComment.state":
		if e.complexity.ImageVulnerabilityAnalysisComment.State == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisComment.State(childComplexity), true

	case "ImageVulnerabilityAnalysisComment.suppressed":
		if e.complexity.ImageVulnerabilityAnalysisComment.Suppressed == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisComment.Suppressed(childComplexity), true

	case "ImageVulnerabilityAnalysisComment.timestamp":
		if e.complexity.ImageVulnerabilityAnalysisComment.Timestamp == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisComment.Timestamp(childComplexity), true

	case "ImageVulnerabilityAnalysisCommentConnection.edges":
		if e.complexity.ImageVulnerabilityAnalysisCommentConnection.Edges == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisCommentConnection.Edges(childComplexity), true

	case "ImageVulnerabilityAnalysisCommentConnection.nodes":
		if e.complexity.ImageVulnerabilityAnalysisCommentConnection.Nodes == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisCommentConnection.Nodes(childComplexity), true

	case "ImageVulnerabilityAnalysisCommentConnection.pageInfo":
		if e.complexity.ImageVulnerabilityAnalysisCommentConnection.PageInfo == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisCommentConnection.PageInfo(childComplexity), true

	case "ImageVulnerabilityAnalysisCommentEdge.cursor":
		if e.complexity.ImageVulnerabilityAnalysisCommentEdge.Cursor == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisCommentEdge.Cursor(childComplexity), true

	case "ImageVulnerabilityAnalysisCommentEdge.node":
		if e.complexity.ImageVulnerabilityAnalysisCommentEdge.Node == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisCommentEdge.Node(childComplexity), true

	case "ImageVulnerabilityAnalysisTrail.comments":
		if e.complexity.ImageVulnerabilityAnalysisTrail.Comments == nil {
			break
		}

		args, err := ec.field_ImageVulnerabilityAnalysisTrail_comments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ImageVulnerabilityAnalysisTrail.Comments(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "ImageVulnerabilityAnalysisTrail.state":
		if e.complexity.ImageVulnerabilityAnalysisTrail.State == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisTrail.State(childComplexity), true

	case "ImageVulnerabilityAnalysisTrail.suppressed":
		if e.complexity.ImageVulnerabilityAnalysisTrail.Suppressed == nil {
			break
		}

		return e.complexity.ImageVulnerabilityAnalysisTrail.Suppressed(childComplexity), true

	case "ImageVulnerabilityConnection.edges":
		if e.complexity.ImageVulnerabilityConnection.Edges == nil {
			break
		}

		return e.complexity.ImageVulnerabilityConnection.Edges(childComplexity), true

	case "ImageVulnerabilityConnection.nodes":
		if e.complexity.ImageVulnerabilityConnection.Nodes == nil {
			break
		}

		return e.complexity.ImageVulnerabilityConnection.Nodes(childComplexity), true

	case "ImageVulnerabilityConnection.pageInfo":
		if e.complexity.ImageVulnerabilityConnection.PageInfo == nil {
			break
		}

		return e.complexity.ImageVulnerabilityConnection.PageInfo(childComplexity), true

	case "ImageVulnerabilityEdge.cursor":
		if e.complexity.ImageVulnerabilityEdge.Cursor == nil {
			break
		}

		return e.complexity.ImageVulnerabilityEdge.Cursor(childComplexity), true

	case "ImageVulnerabilityEdge.node":
		if e.complexity.ImageVulnerabilityEdge.Node == nil {
			break
		}

		return e.complexity.ImageVulnerabilityEdge.Node(childComplexity), true

	case "ImageVulnerabilitySummary.critical":
		if e.complexity.ImageVulnerabilitySummary.Critical == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.Critical(childComplexity), true

	case "ImageVulnerabilitySummary.high":
		if e.complexity.ImageVulnerabilitySummary.High == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.High(childComplexity), true

	case "ImageVulnerabilitySummary.low":
		if e.complexity.ImageVulnerabilitySummary.Low == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.Low(childComplexity), true

	case "ImageVulnerabilitySummary.medium":
		if e.complexity.ImageVulnerabilitySummary.Medium == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.Medium(childComplexity), true

	case "ImageVulnerabilitySummary.riskScore":
		if e.complexity.ImageVulnerabilitySummary.RiskScore == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.RiskScore(childComplexity), true

	case "ImageVulnerabilitySummary.total":
		if e.complexity.ImageVulnerabilitySummary.Total == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.Total(childComplexity), true

	case "ImageVulnerabilitySummary.unassigned":
		if e.complexity.ImageVulnerabilitySummary.Unassigned == nil {
			break
		}

		return e.complexity.ImageVulnerabilitySummary.Unassigned(childComplexity), true

	case "InboundNetworkPolicy.rules":
		if e.complexity.InboundNetworkPolicy.Rules == nil {
			break
		}

		return e.complexity.InboundNetworkPolicy.Rules(childComplexity), true

	case "Ingress.type":
		if e.complexity.Ingress.Type == nil {
			break
		}

		return e.complexity.Ingress.Type(childComplexity), true

	case "Ingress.url":
		if e.complexity.Ingress.URL == nil {
			break
		}

		return e.complexity.Ingress.URL(childComplexity), true

	case "Job.authIntegrations":
		if e.complexity.Job.AuthIntegrations == nil {
			break
		}

		return e.complexity.Job.AuthIntegrations(childComplexity), true

	case "Job.bigQueryDatasets":
		if e.complexity.Job.BigQueryDatasets == nil {
			break
		}

		args, err := ec.field_Job_bigQueryDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.BigQueryDatasets(childComplexity, args["orderBy"].(*bigquery.BigQueryDatasetOrder)), true

	case "Job.buckets":
		if e.complexity.Job.Buckets == nil {
			break
		}

		args, err := ec.field_Job_buckets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.Buckets(childComplexity, args["orderBy"].(*bucket.BucketOrder)), true

	case "Job.cost":
		if e.complexity.Job.Cost == nil {
			break
		}

		return e.complexity.Job.Cost(childComplexity), true

	case "Job.deletionStartedAt":
		if e.complexity.Job.DeletionStartedAt == nil {
			break
		}

		return e.complexity.Job.DeletionStartedAt(childComplexity), true

	case "Job.deployments":
		if e.complexity.Job.Deployments == nil {
			break
		}

		args, err := ec.field_Job_deployments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.Deployments(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Job.environment":
		if e.complexity.Job.Environment == nil {
			break
		}

		return e.complexity.Job.Environment(childComplexity), true

	case "Job.id":
		if e.complexity.Job.ID == nil {
			break
		}

		return e.complexity.Job.ID(childComplexity), true

	case "Job.image":
		if e.complexity.Job.Image == nil {
			break
		}

		return e.complexity.Job.Image(childComplexity), true

	case "Job.kafkaTopicAcls":
		if e.complexity.Job.KafkaTopicAcls == nil {
			break
		}

		args, err := ec.field_Job_kafkaTopicAcls_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.KafkaTopicAcls(childComplexity, args["orderBy"].(*kafkatopic.KafkaTopicACLOrder)), true

	case "Job.logDestinations":
		if e.complexity.Job.LogDestinations == nil {
			break
		}

		return e.complexity.Job.LogDestinations(childComplexity), true

	case "Job.manifest":
		if e.complexity.Job.Manifest == nil {
			break
		}

		return e.complexity.Job.Manifest(childComplexity), true

	case "Job.name":
		if e.complexity.Job.Name == nil {
			break
		}

		return e.complexity.Job.Name(childComplexity), true

	case "Job.networkPolicy":
		if e.complexity.Job.NetworkPolicy == nil {
			break
		}

		return e.complexity.Job.NetworkPolicy(childComplexity), true

	case "Job.openSearch":
		if e.complexity.Job.OpenSearch == nil {
			break
		}

		return e.complexity.Job.OpenSearch(childComplexity), true

	case "Job.redisInstances":
		if e.complexity.Job.RedisInstances == nil {
			break
		}

		args, err := ec.field_Job_redisInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.RedisInstances(childComplexity, args["orderBy"].(*redis.RedisInstanceOrder)), true

	case "Job.resources":
		if e.complexity.Job.Resources == nil {
			break
		}

		return e.complexity.Job.Resources(childComplexity), true

	case "Job.runs":
		if e.complexity.Job.Runs == nil {
			break
		}

		args, err := ec.field_Job_runs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.Runs(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Job.sqlInstances":
		if e.complexity.Job.SQLInstances == nil {
			break
		}

		args, err := ec.field_Job_sqlInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.SQLInstances(childComplexity, args["orderBy"].(*sqlinstance.SQLInstanceOrder)), true

	case "Job.schedule":
		if e.complexity.Job.Schedule == nil {
			break
		}

		return e.complexity.Job.Schedule(childComplexity), true

	case "Job.secrets":
		if e.complexity.Job.Secrets == nil {
			break
		}

		args, err := ec.field_Job_secrets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.Secrets(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Job.status":
		if e.complexity.Job.Status == nil {
			break
		}

		return e.complexity.Job.Status(childComplexity), true

	case "Job.team":
		if e.complexity.Job.Team == nil {
			break
		}

		return e.complexity.Job.Team(childComplexity), true

	case "Job.teamEnvironment":
		if e.complexity.Job.TeamEnvironment == nil {
			break
		}

		return e.complexity.Job.TeamEnvironment(childComplexity), true

	case "Job.valkeyInstances":
		if e.complexity.Job.ValkeyInstances == nil {
			break
		}

		args, err := ec.field_Job_valkeyInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.ValkeyInstances(childComplexity, args["orderBy"].(*valkey.ValkeyInstanceOrder)), true

	case "JobConnection.edges":
		if e.complexity.JobConnection.Edges == nil {
			break
		}

		return e.complexity.JobConnection.Edges(childComplexity), true

	case "JobConnection.nodes":
		if e.complexity.JobConnection.Nodes == nil {
			break
		}

		return e.complexity.JobConnection.Nodes(childComplexity), true

	case "JobConnection.pageInfo":
		if e.complexity.JobConnection.PageInfo == nil {
			break
		}

		return e.complexity.JobConnection.PageInfo(childComplexity), true

	case "JobDeletedActivityLogEntry.actor":
		if e.complexity.JobDeletedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.JobDeletedActivityLogEntry.Actor(childComplexity), true

	case "JobDeletedActivityLogEntry.createdAt":
		if e.complexity.JobDeletedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.JobDeletedActivityLogEntry.CreatedAt(childComplexity), true

	case "JobDeletedActivityLogEntry.environmentName":
		if e.complexity.JobDeletedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.JobDeletedActivityLogEntry.EnvironmentName(childComplexity), true

	case "JobDeletedActivityLogEntry.id":
		if e.complexity.JobDeletedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.JobDeletedActivityLogEntry.ID(childComplexity), true

	case "JobDeletedActivityLogEntry.message":
		if e.complexity.JobDeletedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.JobDeletedActivityLogEntry.Message(childComplexity), true

	case "JobDeletedActivityLogEntry.resourceName":
		if e.complexity.JobDeletedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.JobDeletedActivityLogEntry.ResourceName(childComplexity), true

	case "JobDeletedActivityLogEntry.resourceType":
		if e.complexity.JobDeletedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.JobDeletedActivityLogEntry.ResourceType(childComplexity), true

	case "JobDeletedActivityLogEntry.teamSlug":
		if e.complexity.JobDeletedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.JobDeletedActivityLogEntry.TeamSlug(childComplexity), true

	case "JobEdge.cursor":
		if e.complexity.JobEdge.Cursor == nil {
			break
		}

		return e.complexity.JobEdge.Cursor(childComplexity), true

	case "JobEdge.node":
		if e.complexity.JobEdge.Node == nil {
			break
		}

		return e.complexity.JobEdge.Node(childComplexity), true

	case "JobManifest.content":
		if e.complexity.JobManifest.Content == nil {
			break
		}

		return e.complexity.JobManifest.Content(childComplexity), true

	case "JobResources.limits":
		if e.complexity.JobResources.Limits == nil {
			break
		}

		return e.complexity.JobResources.Limits(childComplexity), true

	case "JobResources.requests":
		if e.complexity.JobResources.Requests == nil {
			break
		}

		return e.complexity.JobResources.Requests(childComplexity), true

	case "JobRun.completionTime":
		if e.complexity.JobRun.CompletionTime == nil {
			break
		}

		return e.complexity.JobRun.CompletionTime(childComplexity), true

	case "JobRun.duration":
		if e.complexity.JobRun.Duration == nil {
			break
		}

		return e.complexity.JobRun.Duration(childComplexity), true

	case "JobRun.id":
		if e.complexity.JobRun.ID == nil {
			break
		}

		return e.complexity.JobRun.ID(childComplexity), true

	case "JobRun.image":
		if e.complexity.JobRun.Image == nil {
			break
		}

		return e.complexity.JobRun.Image(childComplexity), true

	case "JobRun.instances":
		if e.complexity.JobRun.Instances == nil {
			break
		}

		args, err := ec.field_JobRun_instances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.JobRun.Instances(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "JobRun.name":
		if e.complexity.JobRun.Name == nil {
			break
		}

		return e.complexity.JobRun.Name(childComplexity), true

	case "JobRun.startTime":
		if e.complexity.JobRun.StartTime == nil {
			break
		}

		return e.complexity.JobRun.StartTime(childComplexity), true

	case "JobRun.status":
		if e.complexity.JobRun.Status == nil {
			break
		}

		return e.complexity.JobRun.Status(childComplexity), true

	case "JobRun.trigger":
		if e.complexity.JobRun.Trigger == nil {
			break
		}

		return e.complexity.JobRun.Trigger(childComplexity), true

	case "JobRunConnection.edges":
		if e.complexity.JobRunConnection.Edges == nil {
			break
		}

		return e.complexity.JobRunConnection.Edges(childComplexity), true

	case "JobRunConnection.nodes":
		if e.complexity.JobRunConnection.Nodes == nil {
			break
		}

		return e.complexity.JobRunConnection.Nodes(childComplexity), true

	case "JobRunConnection.pageInfo":
		if e.complexity.JobRunConnection.PageInfo == nil {
			break
		}

		return e.complexity.JobRunConnection.PageInfo(childComplexity), true

	case "JobRunEdge.cursor":
		if e.complexity.JobRunEdge.Cursor == nil {
			break
		}

		return e.complexity.JobRunEdge.Cursor(childComplexity), true

	case "JobRunEdge.node":
		if e.complexity.JobRunEdge.Node == nil {
			break
		}

		return e.complexity.JobRunEdge.Node(childComplexity), true

	case "JobRunInstance.id":
		if e.complexity.JobRunInstance.ID == nil {
			break
		}

		return e.complexity.JobRunInstance.ID(childComplexity), true

	case "JobRunInstance.name":
		if e.complexity.JobRunInstance.Name == nil {
			break
		}

		return e.complexity.JobRunInstance.Name(childComplexity), true

	case "JobRunInstanceConnection.edges":
		if e.complexity.JobRunInstanceConnection.Edges == nil {
			break
		}

		return e.complexity.JobRunInstanceConnection.Edges(childComplexity), true

	case "JobRunInstanceConnection.nodes":
		if e.complexity.JobRunInstanceConnection.Nodes == nil {
			break
		}

		return e.complexity.JobRunInstanceConnection.Nodes(childComplexity), true

	case "JobRunInstanceConnection.pageInfo":
		if e.complexity.JobRunInstanceConnection.PageInfo == nil {
			break
		}

		return e.complexity.JobRunInstanceConnection.PageInfo(childComplexity), true

	case "JobRunInstanceEdge.cursor":
		if e.complexity.JobRunInstanceEdge.Cursor == nil {
			break
		}

		return e.complexity.JobRunInstanceEdge.Cursor(childComplexity), true

	case "JobRunInstanceEdge.node":
		if e.complexity.JobRunInstanceEdge.Node == nil {
			break
		}

		return e.complexity.JobRunInstanceEdge.Node(childComplexity), true

	case "JobRunStatus.message":
		if e.complexity.JobRunStatus.Message == nil {
			break
		}

		return e.complexity.JobRunStatus.Message(childComplexity), true

	case "JobRunStatus.state":
		if e.complexity.JobRunStatus.State == nil {
			break
		}

		return e.complexity.JobRunStatus.State(childComplexity), true

	case "JobRunTrigger.actor":
		if e.complexity.JobRunTrigger.Actor == nil {
			break
		}

		return e.complexity.JobRunTrigger.Actor(childComplexity), true

	case "JobRunTrigger.type":
		if e.complexity.JobRunTrigger.Type == nil {
			break
		}

		return e.complexity.JobRunTrigger.Type(childComplexity), true

	case "JobSchedule.expression":
		if e.complexity.JobSchedule.Expression == nil {
			break
		}

		return e.complexity.JobSchedule.Expression(childComplexity), true

	case "JobSchedule.timeZone":
		if e.complexity.JobSchedule.TimeZone == nil {
			break
		}

		return e.complexity.JobSchedule.TimeZone(childComplexity), true

	case "JobTriggeredActivityLogEntry.actor":
		if e.complexity.JobTriggeredActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.JobTriggeredActivityLogEntry.Actor(childComplexity), true

	case "JobTriggeredActivityLogEntry.createdAt":
		if e.complexity.JobTriggeredActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.JobTriggeredActivityLogEntry.CreatedAt(childComplexity), true

	case "JobTriggeredActivityLogEntry.environmentName":
		if e.complexity.JobTriggeredActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.JobTriggeredActivityLogEntry.EnvironmentName(childComplexity), true

	case "JobTriggeredActivityLogEntry.id":
		if e.complexity.JobTriggeredActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.JobTriggeredActivityLogEntry.ID(childComplexity), true

	case "JobTriggeredActivityLogEntry.message":
		if e.complexity.JobTriggeredActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.JobTriggeredActivityLogEntry.Message(childComplexity), true

	case "JobTriggeredActivityLogEntry.resourceName":
		if e.complexity.JobTriggeredActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.JobTriggeredActivityLogEntry.ResourceName(childComplexity), true

	case "JobTriggeredActivityLogEntry.resourceType":
		if e.complexity.JobTriggeredActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.JobTriggeredActivityLogEntry.ResourceType(childComplexity), true

	case "JobTriggeredActivityLogEntry.teamSlug":
		if e.complexity.JobTriggeredActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.JobTriggeredActivityLogEntry.TeamSlug(childComplexity), true

	case "KafkaLagScalingStrategy.consumerGroup":
		if e.complexity.KafkaLagScalingStrategy.ConsumerGroup == nil {
			break
		}

		return e.complexity.KafkaLagScalingStrategy.ConsumerGroup(childComplexity), true

	case "KafkaLagScalingStrategy.threshold":
		if e.complexity.KafkaLagScalingStrategy.Threshold == nil {
			break
		}

		return e.complexity.KafkaLagScalingStrategy.Threshold(childComplexity), true

	case "KafkaLagScalingStrategy.topicName":
		if e.complexity.KafkaLagScalingStrategy.TopicName == nil {
			break
		}

		return e.complexity.KafkaLagScalingStrategy.TopicName(childComplexity), true

	case "KafkaTopic.acl":
		if e.complexity.KafkaTopic.ACL == nil {
			break
		}

		args, err := ec.field_KafkaTopic_acl_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KafkaTopic.ACL(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["filter"].(*kafkatopic.KafkaTopicACLFilter), args["orderBy"].(*kafkatopic.KafkaTopicACLOrder)), true

	case "KafkaTopic.configuration":
		if e.complexity.KafkaTopic.Configuration == nil {
			break
		}

		return e.complexity.KafkaTopic.Configuration(childComplexity), true

	case "KafkaTopic.environment":
		if e.complexity.KafkaTopic.Environment == nil {
			break
		}

		return e.complexity.KafkaTopic.Environment(childComplexity), true

	case "KafkaTopic.id":
		if e.complexity.KafkaTopic.ID == nil {
			break
		}

		return e.complexity.KafkaTopic.ID(childComplexity), true

	case "KafkaTopic.name":
		if e.complexity.KafkaTopic.Name == nil {
			break
		}

		return e.complexity.KafkaTopic.Name(childComplexity), true

	case "KafkaTopic.pool":
		if e.complexity.KafkaTopic.Pool == nil {
			break
		}

		return e.complexity.KafkaTopic.Pool(childComplexity), true

	case "KafkaTopic.team":
		if e.complexity.KafkaTopic.Team == nil {
			break
		}

		return e.complexity.KafkaTopic.Team(childComplexity), true

	case "KafkaTopic.teamEnvironment":
		if e.complexity.KafkaTopic.TeamEnvironment == nil {
			break
		}

		return e.complexity.KafkaTopic.TeamEnvironment(childComplexity), true

	case "KafkaTopicAcl.access":
		if e.complexity.KafkaTopicAcl.Access == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.Access(childComplexity), true

	case "KafkaTopicAcl.team":
		if e.complexity.KafkaTopicAcl.Team == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.Team(childComplexity), true

	case "KafkaTopicAcl.teamName":
		if e.complexity.KafkaTopicAcl.TeamName == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.TeamName(childComplexity), true

	case "KafkaTopicAcl.topic":
		if e.complexity.KafkaTopicAcl.Topic == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.Topic(childComplexity), true

	case "KafkaTopicAcl.workload":
		if e.complexity.KafkaTopicAcl.Workload == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.Workload(childComplexity), true

	case "KafkaTopicAcl.workloadName":
		if e.complexity.KafkaTopicAcl.WorkloadName == nil {
			break
		}

		return e.complexity.KafkaTopicAcl.WorkloadName(childComplexity), true

	case "KafkaTopicAclConnection.edges":
		if e.complexity.KafkaTopicAclConnection.Edges == nil {
			break
		}

		return e.complexity.KafkaTopicAclConnection.Edges(childComplexity), true

	case "KafkaTopicAclConnection.nodes":
		if e.complexity.KafkaTopicAclConnection.Nodes == nil {
			break
		}

		return e.complexity.KafkaTopicAclConnection.Nodes(childComplexity), true

	case "KafkaTopicAclConnection.pageInfo":
		if e.complexity.KafkaTopicAclConnection.PageInfo == nil {
			break
		}

		return e.complexity.KafkaTopicAclConnection.PageInfo(childComplexity), true

	case "KafkaTopicAclEdge.cursor":
		if e.complexity.KafkaTopicAclEdge.Cursor == nil {
			break
		}

		return e.complexity.KafkaTopicAclEdge.Cursor(childComplexity), true

	case "KafkaTopicAclEdge.node":
		if e.complexity.KafkaTopicAclEdge.Node == nil {
			break
		}

		return e.complexity.KafkaTopicAclEdge.Node(childComplexity), true

	case "KafkaTopicConfiguration.cleanupPolicy":
		if e.complexity.KafkaTopicConfiguration.CleanupPolicy == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.CleanupPolicy(childComplexity), true

	case "KafkaTopicConfiguration.maxMessageBytes":
		if e.complexity.KafkaTopicConfiguration.MaxMessageBytes == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.MaxMessageBytes(childComplexity), true

	case "KafkaTopicConfiguration.minimumInSyncReplicas":
		if e.complexity.KafkaTopicConfiguration.MinimumInSyncReplicas == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.MinimumInSyncReplicas(childComplexity), true

	case "KafkaTopicConfiguration.partitions":
		if e.complexity.KafkaTopicConfiguration.Partitions == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.Partitions(childComplexity), true

	case "KafkaTopicConfiguration.replication":
		if e.complexity.KafkaTopicConfiguration.Replication == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.Replication(childComplexity), true

	case "KafkaTopicConfiguration.retentionBytes":
		if e.complexity.KafkaTopicConfiguration.RetentionBytes == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.RetentionBytes(childComplexity), true

	case "KafkaTopicConfiguration.retentionHours":
		if e.complexity.KafkaTopicConfiguration.RetentionHours == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.RetentionHours(childComplexity), true

	case "KafkaTopicConfiguration.segmentHours":
		if e.complexity.KafkaTopicConfiguration.SegmentHours == nil {
			break
		}

		return e.complexity.KafkaTopicConfiguration.SegmentHours(childComplexity), true

	case "KafkaTopicConnection.edges":
		if e.complexity.KafkaTopicConnection.Edges == nil {
			break
		}

		return e.complexity.KafkaTopicConnection.Edges(childComplexity), true

	case "KafkaTopicConnection.nodes":
		if e.complexity.KafkaTopicConnection.Nodes == nil {
			break
		}

		return e.complexity.KafkaTopicConnection.Nodes(childComplexity), true

	case "KafkaTopicConnection.pageInfo":
		if e.complexity.KafkaTopicConnection.PageInfo == nil {
			break
		}

		return e.complexity.KafkaTopicConnection.PageInfo(childComplexity), true

	case "KafkaTopicEdge.cursor":
		if e.complexity.KafkaTopicEdge.Cursor == nil {
			break
		}

		return e.complexity.KafkaTopicEdge.Cursor(childComplexity), true

	case "KafkaTopicEdge.node":
		if e.complexity.KafkaTopicEdge.Node == nil {
			break
		}

		return e.complexity.KafkaTopicEdge.Node(childComplexity), true

	case "LogDestinationLoki.grafanaURL":
		if e.complexity.LogDestinationLoki.GrafanaURL == nil {
			break
		}

		return e.complexity.LogDestinationLoki.GrafanaURL(childComplexity), true

	case "LogDestinationLoki.id":
		if e.complexity.LogDestinationLoki.ID == nil {
			break
		}

		return e.complexity.LogDestinationLoki.ID(childComplexity), true

	case "LogDestinationSecureLogs.id":
		if e.complexity.LogDestinationSecureLogs.ID == nil {
			break
		}

		return e.complexity.LogDestinationSecureLogs.ID(childComplexity), true

	case "MaskinportenAuthIntegration.name":
		if e.complexity.MaskinportenAuthIntegration.Name == nil {
			break
		}

		return e.complexity.MaskinportenAuthIntegration.Name(childComplexity), true

	case "Mutation.addRepositoryToTeam":
		if e.complexity.Mutation.AddRepositoryToTeam == nil {
			break
		}

		args, err := ec.field_Mutation_addRepositoryToTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRepositoryToTeam(childComplexity, args["input"].(repository.AddRepositoryToTeamInput)), true

	case "Mutation.addSecretValue":
		if e.complexity.Mutation.AddSecretValue == nil {
			break
		}

		args, err := ec.field_Mutation_addSecretValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddSecretValue(childComplexity, args["input"].(secret.AddSecretValueInput)), true

	case "Mutation.addTeamMember":
		if e.complexity.Mutation.AddTeamMember == nil {
			break
		}

		args, err := ec.field_Mutation_addTeamMember_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTeamMember(childComplexity, args["input"].(team.AddTeamMemberInput)), true

	case "Mutation.allowTeamAccessToUnleash":
		if e.complexity.Mutation.AllowTeamAccessToUnleash == nil {
			break
		}

		args, err := ec.field_Mutation_allowTeamAccessToUnleash_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AllowTeamAccessToUnleash(childComplexity, args["input"].(unleash.AllowTeamAccessToUnleashInput)), true

	case "Mutation.assignRoleToServiceAccount":
		if e.complexity.Mutation.AssignRoleToServiceAccount == nil {
			break
		}

		args, err := ec.field_Mutation_assignRoleToServiceAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AssignRoleToServiceAccount(childComplexity, args["input"].(serviceaccount.AssignRoleToServiceAccountInput)), true

	case "Mutation.changeDeploymentKey":
		if e.complexity.Mutation.ChangeDeploymentKey == nil {
			break
		}

		args, err := ec.field_Mutation_changeDeploymentKey_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChangeDeploymentKey(childComplexity, args["input"].(deployment.ChangeDeploymentKeyInput)), true

	case "Mutation.configureReconciler":
		if e.complexity.Mutation.ConfigureReconciler == nil {
			break
		}

		args, err := ec.field_Mutation_configureReconciler_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfigureReconciler(childComplexity, args["input"].(reconciler.ConfigureReconcilerInput)), true

	case "Mutation.confirmTeamDeletion":
		if e.complexity.Mutation.ConfirmTeamDeletion == nil {
			break
		}

		args, err := ec.field_Mutation_confirmTeamDeletion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmTeamDeletion(childComplexity, args["input"].(team.ConfirmTeamDeletionInput)), true

	case "Mutation.createSecret":
		if e.complexity.Mutation.CreateSecret == nil {
			break
		}

		args, err := ec.field_Mutation_createSecret_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSecret(childComplexity, args["input"].(secret.CreateSecretInput)), true

	case "Mutation.createServiceAccount":
		if e.complexity.Mutation.CreateServiceAccount == nil {
			break
		}

		args, err := ec.field_Mutation_createServiceAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateServiceAccount(childComplexity, args["input"].(serviceaccount.CreateServiceAccountInput)), true

	case "Mutation.createServiceAccountToken":
		if e.complexity.Mutation.CreateServiceAccountToken == nil {
			break
		}

		args, err := ec.field_Mutation_createServiceAccountToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateServiceAccountToken(childComplexity, args["input"].(serviceaccount.CreateServiceAccountTokenInput)), true

	case "Mutation.createTeam":
		if e.complexity.Mutation.CreateTeam == nil {
			break
		}

		args, err := ec.field_Mutation_createTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTeam(childComplexity, args["input"].(team.CreateTeamInput)), true

	case "Mutation.createUnleashForTeam":
		if e.complexity.Mutation.CreateUnleashForTeam == nil {
			break
		}

		args, err := ec.field_Mutation_createUnleashForTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUnleashForTeam(childComplexity, args["input"].(unleash.CreateUnleashForTeamInput)), true

	case "Mutation.deleteApplication":
		if e.complexity.Mutation.DeleteApplication == nil {
			break
		}

		args, err := ec.field_Mutation_deleteApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteApplication(childComplexity, args["input"].(application.DeleteApplicationInput)), true

	case "Mutation.deleteJob":
		if e.complexity.Mutation.DeleteJob == nil {
			break
		}

		args, err := ec.field_Mutation_deleteJob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteJob(childComplexity, args["input"].(job.DeleteJobInput)), true

	case "Mutation.deleteSecret":
		if e.complexity.Mutation.DeleteSecret == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSecret_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSecret(childComplexity, args["input"].(secret.DeleteSecretInput)), true

	case "Mutation.deleteServiceAccount":
		if e.complexity.Mutation.DeleteServiceAccount == nil {
			break
		}

		args, err := ec.field_Mutation_deleteServiceAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteServiceAccount(childComplexity, args["input"].(serviceaccount.DeleteServiceAccountInput)), true

	case "Mutation.deleteServiceAccountToken":
		if e.complexity.Mutation.DeleteServiceAccountToken == nil {
			break
		}

		args, err := ec.field_Mutation_deleteServiceAccountToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteServiceAccountToken(childComplexity, args["input"].(serviceaccount.DeleteServiceAccountTokenInput)), true

	case "Mutation.disableReconciler":
		if e.complexity.Mutation.DisableReconciler == nil {
			break
		}

		args, err := ec.field_Mutation_disableReconciler_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisableReconciler(childComplexity, args["input"].(reconciler.DisableReconcilerInput)), true

	case "Mutation.enableReconciler":
		if e.complexity.Mutation.EnableReconciler == nil {
			break
		}

		args, err := ec.field_Mutation_enableReconciler_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnableReconciler(childComplexity, args["input"].(reconciler.EnableReconcilerInput)), true

	case "Mutation.removeRepositoryFromTeam":
		if e.complexity.Mutation.RemoveRepositoryFromTeam == nil {
			break
		}

		args, err := ec.field_Mutation_removeRepositoryFromTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveRepositoryFromTeam(childComplexity, args["input"].(repository.RemoveRepositoryFromTeamInput)), true

	case "Mutation.removeSecretValue":
		if e.complexity.Mutation.RemoveSecretValue == nil {
			break
		}

		args, err := ec.field_Mutation_removeSecretValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveSecretValue(childComplexity, args["input"].(secret.RemoveSecretValueInput)), true

	case "Mutation.removeTeamMember":
		if e.complexity.Mutation.RemoveTeamMember == nil {
			break
		}

		args, err := ec.field_Mutation_removeTeamMember_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveTeamMember(childComplexity, args["input"].(team.RemoveTeamMemberInput)), true

	case "Mutation.requestTeamDeletion":
		if e.complexity.Mutation.RequestTeamDeletion == nil {
			break
		}

		args, err := ec.field_Mutation_requestTeamDeletion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestTeamDeletion(childComplexity, args["input"].(team.RequestTeamDeletionInput)), true

	case "Mutation.restartApplication":
		if e.complexity.Mutation.RestartApplication == nil {
			break
		}

		args, err := ec.field_Mutation_restartApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartApplication(childComplexity, args["input"].(application.RestartApplicationInput)), true

	case "Mutation.revokeRoleFromServiceAccount":
		if e.complexity.Mutation.RevokeRoleFromServiceAccount == nil {
			break
		}

		args, err := ec.field_Mutation_revokeRoleFromServiceAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeRoleFromServiceAccount(childComplexity, args["input"].(serviceaccount.RevokeRoleFromServiceAccountInput)), true

	case "Mutation.revokeTeamAccessToUnleash":
		if e.complexity.Mutation.RevokeTeamAccessToUnleash == nil {
			break
		}

		args, err := ec.field_Mutation_revokeTeamAccessToUnleash_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeTeamAccessToUnleash(childComplexity, args["input"].(unleash.RevokeTeamAccessToUnleashInput)), true

	case "Mutation.setTeamMemberRole":
		if e.complexity.Mutation.SetTeamMemberRole == nil {
			break
		}

		args, err := ec.field_Mutation_setTeamMemberRole_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTeamMemberRole(childComplexity, args["input"].(team.SetTeamMemberRoleInput)), true

	case "Mutation.triggerJob":
		if e.complexity.Mutation.TriggerJob == nil {
			break
		}

		args, err := ec.field_Mutation_triggerJob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TriggerJob(childComplexity, args["input"].(job.TriggerJobInput)), true

	case "Mutation.updateImageVulnerability":
		if e.complexity.Mutation.UpdateImageVulnerability == nil {
			break
		}

		args, err := ec.field_Mutation_updateImageVulnerability_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateImageVulnerability(childComplexity, args["input"].(vulnerability.UpdateImageVulnerabilityInput)), true

	case "Mutation.updateSecretValue":
		if e.complexity.Mutation.UpdateSecretValue == nil {
			break
		}

		args, err := ec.field_Mutation_updateSecretValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSecretValue(childComplexity, args["input"].(secret.UpdateSecretValueInput)), true

	case "Mutation.updateServiceAccount":
		if e.complexity.Mutation.UpdateServiceAccount == nil {
			break
		}

		args, err := ec.field_Mutation_updateServiceAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateServiceAccount(childComplexity, args["input"].(serviceaccount.UpdateServiceAccountInput)), true

	case "Mutation.updateServiceAccountToken":
		if e.complexity.Mutation.UpdateServiceAccountToken == nil {
			break
		}

		args, err := ec.field_Mutation_updateServiceAccountToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateServiceAccountToken(childComplexity, args["input"].(serviceaccount.UpdateServiceAccountTokenInput)), true

	case "Mutation.updateTeam":
		if e.complexity.Mutation.UpdateTeam == nil {
			break
		}

		args, err := ec.field_Mutation_updateTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTeam(childComplexity, args["input"].(team.UpdateTeamInput)), true

	case "Mutation.updateTeamEnvironment":
		if e.complexity.Mutation.UpdateTeamEnvironment == nil {
			break
		}

		args, err := ec.field_Mutation_updateTeamEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTeamEnvironment(childComplexity, args["input"].(team.UpdateTeamEnvironmentInput)), true

	case "NetworkPolicy.inbound":
		if e.complexity.NetworkPolicy.Inbound == nil {
			break
		}

		return e.complexity.NetworkPolicy.Inbound(childComplexity), true

	case "NetworkPolicy.outbound":
		if e.complexity.NetworkPolicy.Outbound == nil {
			break
		}

		return e.complexity.NetworkPolicy.Outbound(childComplexity), true

	case "NetworkPolicyRule.mutual":
		if e.complexity.NetworkPolicyRule.Mutual == nil {
			break
		}

		return e.complexity.NetworkPolicyRule.Mutual(childComplexity), true

	case "NetworkPolicyRule.targetTeam":
		if e.complexity.NetworkPolicyRule.TargetTeam == nil {
			break
		}

		return e.complexity.NetworkPolicyRule.TargetTeam(childComplexity), true

	case "NetworkPolicyRule.targetTeamSlug":
		if e.complexity.NetworkPolicyRule.TargetTeamSlug == nil {
			break
		}

		return e.complexity.NetworkPolicyRule.TargetTeamSlug(childComplexity), true

	case "NetworkPolicyRule.targetWorkload":
		if e.complexity.NetworkPolicyRule.TargetWorkload == nil {
			break
		}

		return e.complexity.NetworkPolicyRule.TargetWorkload(childComplexity), true

	case "NetworkPolicyRule.targetWorkloadName":
		if e.complexity.NetworkPolicyRule.TargetWorkloadName == nil {
			break
		}

		return e.complexity.NetworkPolicyRule.TargetWorkloadName(childComplexity), true

	case "OpenSearch.access":
		if e.complexity.OpenSearch.Access == nil {
			break
		}

		args, err := ec.field_OpenSearch_access_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.OpenSearch.Access(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*opensearch.OpenSearchAccessOrder)), true

	case "OpenSearch.cost":
		if e.complexity.OpenSearch.Cost == nil {
			break
		}

		return e.complexity.OpenSearch.Cost(childComplexity), true

	case "OpenSearch.environment":
		if e.complexity.OpenSearch.Environment == nil {
			break
		}

		return e.complexity.OpenSearch.Environment(childComplexity), true

	case "OpenSearch.id":
		if e.complexity.OpenSearch.ID == nil {
			break
		}

		return e.complexity.OpenSearch.ID(childComplexity), true

	case "OpenSearch.name":
		if e.complexity.OpenSearch.Name == nil {
			break
		}

		return e.complexity.OpenSearch.Name(childComplexity), true

	case "OpenSearch.status":
		if e.complexity.OpenSearch.Status == nil {
			break
		}

		return e.complexity.OpenSearch.Status(childComplexity), true

	case "OpenSearch.team":
		if e.complexity.OpenSearch.Team == nil {
			break
		}

		return e.complexity.OpenSearch.Team(childComplexity), true

	case "OpenSearch.teamEnvironment":
		if e.complexity.OpenSearch.TeamEnvironment == nil {
			break
		}

		return e.complexity.OpenSearch.TeamEnvironment(childComplexity), true

	case "OpenSearch.workload":
		if e.complexity.OpenSearch.Workload == nil {
			break
		}

		return e.complexity.OpenSearch.Workload(childComplexity), true

	case "OpenSearchAccess.access":
		if e.complexity.OpenSearchAccess.Access == nil {
			break
		}

		return e.complexity.OpenSearchAccess.Access(childComplexity), true

	case "OpenSearchAccess.workload":
		if e.complexity.OpenSearchAccess.Workload == nil {
			break
		}

		return e.complexity.OpenSearchAccess.Workload(childComplexity), true

	case "OpenSearchAccessConnection.edges":
		if e.complexity.OpenSearchAccessConnection.Edges == nil {
			break
		}

		return e.complexity.OpenSearchAccessConnection.Edges(childComplexity), true

	case "OpenSearchAccessConnection.nodes":
		if e.complexity.OpenSearchAccessConnection.Nodes == nil {
			break
		}

		return e.complexity.OpenSearchAccessConnection.Nodes(childComplexity), true

	case "OpenSearchAccessConnection.pageInfo":
		if e.complexity.OpenSearchAccessConnection.PageInfo == nil {
			break
		}

		return e.complexity.OpenSearchAccessConnection.PageInfo(childComplexity), true

	case "OpenSearchAccessEdge.cursor":
		if e.complexity.OpenSearchAccessEdge.Cursor == nil {
			break
		}

		return e.complexity.OpenSearchAccessEdge.Cursor(childComplexity), true

	case "OpenSearchAccessEdge.node":
		if e.complexity.OpenSearchAccessEdge.Node == nil {
			break
		}

		return e.complexity.OpenSearchAccessEdge.Node(childComplexity), true

	case "OpenSearchConnection.edges":
		if e.complexity.OpenSearchConnection.Edges == nil {
			break
		}

		return e.complexity.OpenSearchConnection.Edges(childComplexity), true

	case "OpenSearchConnection.nodes":
		if e.complexity.OpenSearchConnection.Nodes == nil {
			break
		}

		return e.complexity.OpenSearchConnection.Nodes(childComplexity), true

	case "OpenSearchConnection.pageInfo":
		if e.complexity.OpenSearchConnection.PageInfo == nil {
			break
		}

		return e.complexity.OpenSearchConnection.PageInfo(childComplexity), true

	case "OpenSearchCost.sum":
		if e.complexity.OpenSearchCost.Sum == nil {
			break
		}

		return e.complexity.OpenSearchCost.Sum(childComplexity), true

	case "OpenSearchEdge.cursor":
		if e.complexity.OpenSearchEdge.Cursor == nil {
			break
		}

		return e.complexity.OpenSearchEdge.Cursor(childComplexity), true

	case "OpenSearchEdge.node":
		if e.complexity.OpenSearchEdge.Node == nil {
			break
		}

		return e.complexity.OpenSearchEdge.Node(childComplexity), true

	case "OpenSearchStatus.state":
		if e.complexity.OpenSearchStatus.State == nil {
			break
		}

		return e.complexity.OpenSearchStatus.State(childComplexity), true

	case "OutboundNetworkPolicy.external":
		if e.complexity.OutboundNetworkPolicy.External == nil {
			break
		}

		return e.complexity.OutboundNetworkPolicy.External(childComplexity), true

	case "OutboundNetworkPolicy.rules":
		if e.complexity.OutboundNetworkPolicy.Rules == nil {
			break
		}

		return e.complexity.OutboundNetworkPolicy.Rules(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.pageEnd":
		if e.complexity.PageInfo.PageEnd == nil {
			break
		}

		return e.complexity.PageInfo.PageEnd(childComplexity), true

	case "PageInfo.pageStart":
		if e.complexity.PageInfo.PageStart == nil {
			break
		}

		return e.complexity.PageInfo.PageStart(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PageInfo.totalCount":
		if e.complexity.PageInfo.TotalCount == nil {
			break
		}

		return e.complexity.PageInfo.TotalCount(childComplexity), true

	case "Query.environment":
		if e.complexity.Query.Environment == nil {
			break
		}

		args, err := ec.field_Query_environment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Environment(childComplexity, args["name"].(string)), true

	case "Query.environments":
		if e.complexity.Query.Environments == nil {
			break
		}

		args, err := ec.field_Query_environments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Environments(childComplexity, args["orderBy"].(*environment.EnvironmentOrder)), true

	case "Query.features":
		if e.complexity.Query.Features == nil {
			break
		}

		return e.complexity.Query.Features(childComplexity), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(ident.Ident)), true

	case "Query.reconcilers":
		if e.complexity.Query.Reconcilers == nil {
			break
		}

		args, err := ec.field_Query_reconcilers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Reconcilers(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Query.roles":
		if e.complexity.Query.Roles == nil {
			break
		}

		args, err := ec.field_Query_roles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Roles(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Query.search":
		if e.complexity.Query.Search == nil {
			break
		}

		args, err := ec.field_Query_search_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Search(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["filter"].(search.SearchFilter)), true

	case "Query.serviceAccount":
		if e.complexity.Query.ServiceAccount == nil {
			break
		}

		args, err := ec.field_Query_serviceAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceAccount(childComplexity, args["id"].(ident.Ident)), true

	case "Query.serviceAccounts":
		if e.complexity.Query.ServiceAccounts == nil {
			break
		}

		args, err := ec.field_Query_serviceAccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceAccounts(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Query.team":
		if e.complexity.Query.Team == nil {
			break
		}

		args, err := ec.field_Query_team_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Team(childComplexity, args["slug"].(slug.Slug)), true

	case "Query.teams":
		if e.complexity.Query.Teams == nil {
			break
		}

		args, err := ec.field_Query_teams_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Teams(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*team.TeamOrder)), true

	case "Query.teamsUtilization":
		if e.complexity.Query.TeamsUtilization == nil {
			break
		}

		args, err := ec.field_Query_teamsUtilization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TeamsUtilization(childComplexity, args["resourceType"].(utilization.UtilizationResourceType)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["email"].(*string)), true

	case "Query.userSyncLog":
		if e.complexity.Query.UserSyncLog == nil {
			break
		}

		args, err := ec.field_Query_userSyncLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserSyncLog(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*user.UserOrder)), true

	case "Reconciler.activityLog":
		if e.complexity.Reconciler.ActivityLog == nil {
			break
		}

		args, err := ec.field_Reconciler_activityLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Reconciler.ActivityLog(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Reconciler.config":
		if e.complexity.Reconciler.Config == nil {
			break
		}

		return e.complexity.Reconciler.Config(childComplexity), true

	case "Reconciler.configured":
		if e.complexity.Reconciler.Configured == nil {
			break
		}

		return e.complexity.Reconciler.Configured(childComplexity), true

	case "Reconciler.description":
		if e.complexity.Reconciler.Description == nil {
			break
		}

		return e.complexity.Reconciler.Description(childComplexity), true

	case "Reconciler.displayName":
		if e.complexity.Reconciler.DisplayName == nil {
			break
		}

		return e.complexity.Reconciler.DisplayName(childComplexity), true

	case "Reconciler.enabled":
		if e.complexity.Reconciler.Enabled == nil {
			break
		}

		return e.complexity.Reconciler.Enabled(childComplexity), true

	case "Reconciler.errors":
		if e.complexity.Reconciler.Errors == nil {
			break
		}

		args, err := ec.field_Reconciler_errors_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Reconciler.Errors(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Reconciler.id":
		if e.complexity.Reconciler.ID == nil {
			break
		}

		return e.complexity.Reconciler.ID(childComplexity), true

	case "Reconciler.name":
		if e.complexity.Reconciler.Name == nil {
			break
		}

		return e.complexity.Reconciler.Name(childComplexity), true

	case "ReconcilerConfig.configured":
		if e.complexity.ReconcilerConfig.Configured == nil {
			break
		}

		return e.complexity.ReconcilerConfig.Configured(childComplexity), true

	case "ReconcilerConfig.description":
		if e.complexity.ReconcilerConfig.Description == nil {
			break
		}

		return e.complexity.ReconcilerConfig.Description(childComplexity), true

	case "ReconcilerConfig.displayName":
		if e.complexity.ReconcilerConfig.DisplayName == nil {
			break
		}

		return e.complexity.ReconcilerConfig.DisplayName(childComplexity), true

	case "ReconcilerConfig.key":
		if e.complexity.ReconcilerConfig.Key == nil {
			break
		}

		return e.complexity.ReconcilerConfig.Key(childComplexity), true

	case "ReconcilerConfig.secret":
		if e.complexity.ReconcilerConfig.Secret == nil {
			break
		}

		return e.complexity.ReconcilerConfig.Secret(childComplexity), true

	case "ReconcilerConfig.value":
		if e.complexity.ReconcilerConfig.Value == nil {
			break
		}

		return e.complexity.ReconcilerConfig.Value(childComplexity), true

	case "ReconcilerConfiguredActivityLogEntry.actor":
		if e.complexity.ReconcilerConfiguredActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.ReconcilerConfiguredActivityLogEntry.Actor(childComplexity), true

	case "ReconcilerConfiguredActivityLogEntry.createdAt":
		if e.complexity.ReconcilerConfiguredActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.ReconcilerConfiguredActivityLogEntry.CreatedAt(childComplexity), true

	case "ReconcilerConfiguredActivityLogEntry.data":
		if e.complexity.ReconcilerConfiguredActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.ReconcilerConfiguredActivityLogEntry.Data(childComplexity), true

	case "ReconcilerConfiguredActivityLogEntry.environmentName":
		if e.complexity.ReconcilerConfiguredActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.ReconcilerConfiguredActivityLogEntry.EnvironmentName(childComplexity), true

	case "ReconcilerConfiguredActivityLogEntry.id":
		if e.complexity.ReconcilerConfiguredActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.ReconcilerConfiguredActivityLogEntry.ID(childComplexity), true

	case "ReconcilerConfiguredActivityLogEntry.message":
		if e.complexity.ReconcilerConfiguredActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.ReconcilerConfiguredActivityLogEntry.Message(childComplexity), true

	case "ReconcilerConfiguredActivityLogEntry.resourceName":
		if e.complexity.ReconcilerConfiguredActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.ReconcilerConfiguredActivityLogEntry.ResourceName(childComplexity), true

	case "ReconcilerConfiguredActivityLogEntry.resourceType":
		if e.complexity.ReconcilerConfiguredActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.ReconcilerConfiguredActivityLogEntry.ResourceType(childComplexity), true

	case "ReconcilerConfiguredActivityLogEntry.teamSlug":
		if e.complexity.ReconcilerConfiguredActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.ReconcilerConfiguredActivityLogEntry.TeamSlug(childComplexity), true

	case "ReconcilerConfiguredActivityLogEntryData.updatedKeys":
		if e.complexity.ReconcilerConfiguredActivityLogEntryData.UpdatedKeys == nil {
			break
		}

		return e.complexity.ReconcilerConfiguredActivityLogEntryData.UpdatedKeys(childComplexity), true

	case "ReconcilerConnection.edges":
		if e.complexity.ReconcilerConnection.Edges == nil {
			break
		}

		return e.complexity.ReconcilerConnection.Edges(childComplexity), true

	case "ReconcilerConnection.nodes":
		if e.complexity.ReconcilerConnection.Nodes == nil {
			break
		}

		return e.complexity.ReconcilerConnection.Nodes(childComplexity), true

	case "ReconcilerConnection.pageInfo":
		if e.complexity.ReconcilerConnection.PageInfo == nil {
			break
		}

		return e.complexity.ReconcilerConnection.PageInfo(childComplexity), true

	case "ReconcilerDisabledActivityLogEntry.actor":
		if e.complexity.ReconcilerDisabledActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.ReconcilerDisabledActivityLogEntry.Actor(childComplexity), true

	case "ReconcilerDisabledActivityLogEntry.createdAt":
		if e.complexity.ReconcilerDisabledActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.ReconcilerDisabledActivityLogEntry.CreatedAt(childComplexity), true

	case "ReconcilerDisabledActivityLogEntry.environmentName":
		if e.complexity.ReconcilerDisabledActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.ReconcilerDisabledActivityLogEntry.EnvironmentName(childComplexity), true

	case "ReconcilerDisabledActivityLogEntry.id":
		if e.complexity.ReconcilerDisabledActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.ReconcilerDisabledActivityLogEntry.ID(childComplexity), true

	case "ReconcilerDisabledActivityLogEntry.message":
		if e.complexity.ReconcilerDisabledActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.ReconcilerDisabledActivityLogEntry.Message(childComplexity), true

	case "ReconcilerDisabledActivityLogEntry.resourceName":
		if e.complexity.ReconcilerDisabledActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.ReconcilerDisabledActivityLogEntry.ResourceName(childComplexity), true

	case "ReconcilerDisabledActivityLogEntry.resourceType":
		if e.complexity.ReconcilerDisabledActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.ReconcilerDisabledActivityLogEntry.ResourceType(childComplexity), true

	case "ReconcilerDisabledActivityLogEntry.teamSlug":
		if e.complexity.ReconcilerDisabledActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.ReconcilerDisabledActivityLogEntry.TeamSlug(childComplexity), true

	case "ReconcilerEdge.cursor":
		if e.complexity.ReconcilerEdge.Cursor == nil {
			break
		}

		return e.complexity.ReconcilerEdge.Cursor(childComplexity), true

	case "ReconcilerEdge.node":
		if e.complexity.ReconcilerEdge.Node == nil {
			break
		}

		return e.complexity.ReconcilerEdge.Node(childComplexity), true

	case "ReconcilerEnabledActivityLogEntry.actor":
		if e.complexity.ReconcilerEnabledActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.ReconcilerEnabledActivityLogEntry.Actor(childComplexity), true

	case "ReconcilerEnabledActivityLogEntry.createdAt":
		if e.complexity.ReconcilerEnabledActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.ReconcilerEnabledActivityLogEntry.CreatedAt(childComplexity), true

	case "ReconcilerEnabledActivityLogEntry.environmentName":
		if e.complexity.ReconcilerEnabledActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.ReconcilerEnabledActivityLogEntry.EnvironmentName(childComplexity), true

	case "ReconcilerEnabledActivityLogEntry.id":
		if e.complexity.ReconcilerEnabledActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.ReconcilerEnabledActivityLogEntry.ID(childComplexity), true

	case "ReconcilerEnabledActivityLogEntry.message":
		if e.complexity.ReconcilerEnabledActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.ReconcilerEnabledActivityLogEntry.Message(childComplexity), true

	case "ReconcilerEnabledActivityLogEntry.resourceName":
		if e.complexity.ReconcilerEnabledActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.ReconcilerEnabledActivityLogEntry.ResourceName(childComplexity), true

	case "ReconcilerEnabledActivityLogEntry.resourceType":
		if e.complexity.ReconcilerEnabledActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.ReconcilerEnabledActivityLogEntry.ResourceType(childComplexity), true

	case "ReconcilerEnabledActivityLogEntry.teamSlug":
		if e.complexity.ReconcilerEnabledActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.ReconcilerEnabledActivityLogEntry.TeamSlug(childComplexity), true

	case "ReconcilerError.correlationID":
		if e.complexity.ReconcilerError.CorrelationID == nil {
			break
		}

		return e.complexity.ReconcilerError.CorrelationID(childComplexity), true

	case "ReconcilerError.createdAt":
		if e.complexity.ReconcilerError.CreatedAt == nil {
			break
		}

		return e.complexity.ReconcilerError.CreatedAt(childComplexity), true

	case "ReconcilerError.id":
		if e.complexity.ReconcilerError.ID == nil {
			break
		}

		return e.complexity.ReconcilerError.ID(childComplexity), true

	case "ReconcilerError.message":
		if e.complexity.ReconcilerError.Message == nil {
			break
		}

		return e.complexity.ReconcilerError.Message(childComplexity), true

	case "ReconcilerError.team":
		if e.complexity.ReconcilerError.Team == nil {
			break
		}

		return e.complexity.ReconcilerError.Team(childComplexity), true

	case "ReconcilerErrorConnection.edges":
		if e.complexity.ReconcilerErrorConnection.Edges == nil {
			break
		}

		return e.complexity.ReconcilerErrorConnection.Edges(childComplexity), true

	case "ReconcilerErrorConnection.nodes":
		if e.complexity.ReconcilerErrorConnection.Nodes == nil {
			break
		}

		return e.complexity.ReconcilerErrorConnection.Nodes(childComplexity), true

	case "ReconcilerErrorConnection.pageInfo":
		if e.complexity.ReconcilerErrorConnection.PageInfo == nil {
			break
		}

		return e.complexity.ReconcilerErrorConnection.PageInfo(childComplexity), true

	case "ReconcilerErrorEdge.cursor":
		if e.complexity.ReconcilerErrorEdge.Cursor == nil {
			break
		}

		return e.complexity.ReconcilerErrorEdge.Cursor(childComplexity), true

	case "ReconcilerErrorEdge.node":
		if e.complexity.ReconcilerErrorEdge.Node == nil {
			break
		}

		return e.complexity.ReconcilerErrorEdge.Node(childComplexity), true

	case "RedisInstance.access":
		if e.complexity.RedisInstance.Access == nil {
			break
		}

		args, err := ec.field_RedisInstance_access_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RedisInstance.Access(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*redis.RedisInstanceAccessOrder)), true

	case "RedisInstance.cost":
		if e.complexity.RedisInstance.Cost == nil {
			break
		}

		return e.complexity.RedisInstance.Cost(childComplexity), true

	case "RedisInstance.environment":
		if e.complexity.RedisInstance.Environment == nil {
			break
		}

		return e.complexity.RedisInstance.Environment(childComplexity), true

	case "RedisInstance.id":
		if e.complexity.RedisInstance.ID == nil {
			break
		}

		return e.complexity.RedisInstance.ID(childComplexity), true

	case "RedisInstance.name":
		if e.complexity.RedisInstance.Name == nil {
			break
		}

		return e.complexity.RedisInstance.Name(childComplexity), true

	case "RedisInstance.status":
		if e.complexity.RedisInstance.Status == nil {
			break
		}

		return e.complexity.RedisInstance.Status(childComplexity), true

	case "RedisInstance.team":
		if e.complexity.RedisInstance.Team == nil {
			break
		}

		return e.complexity.RedisInstance.Team(childComplexity), true

	case "RedisInstance.teamEnvironment":
		if e.complexity.RedisInstance.TeamEnvironment == nil {
			break
		}

		return e.complexity.RedisInstance.TeamEnvironment(childComplexity), true

	case "RedisInstance.workload":
		if e.complexity.RedisInstance.Workload == nil {
			break
		}

		return e.complexity.RedisInstance.Workload(childComplexity), true

	case "RedisInstanceAccess.access":
		if e.complexity.RedisInstanceAccess.Access == nil {
			break
		}

		return e.complexity.RedisInstanceAccess.Access(childComplexity), true

	case "RedisInstanceAccess.workload":
		if e.complexity.RedisInstanceAccess.Workload == nil {
			break
		}

		return e.complexity.RedisInstanceAccess.Workload(childComplexity), true

	case "RedisInstanceAccessConnection.edges":
		if e.complexity.RedisInstanceAccessConnection.Edges == nil {
			break
		}

		return e.complexity.RedisInstanceAccessConnection.Edges(childComplexity), true

	case "RedisInstanceAccessConnection.nodes":
		if e.complexity.RedisInstanceAccessConnection.Nodes == nil {
			break
		}

		return e.complexity.RedisInstanceAccessConnection.Nodes(childComplexity), true

	case "RedisInstanceAccessConnection.pageInfo":
		if e.complexity.RedisInstanceAccessConnection.PageInfo == nil {
			break
		}

		return e.complexity.RedisInstanceAccessConnection.PageInfo(childComplexity), true

	case "RedisInstanceAccessEdge.cursor":
		if e.complexity.RedisInstanceAccessEdge.Cursor == nil {
			break
		}

		return e.complexity.RedisInstanceAccessEdge.Cursor(childComplexity), true

	case "RedisInstanceAccessEdge.node":
		if e.complexity.RedisInstanceAccessEdge.Node == nil {
			break
		}

		return e.complexity.RedisInstanceAccessEdge.Node(childComplexity), true

	case "RedisInstanceConnection.edges":
		if e.complexity.RedisInstanceConnection.Edges == nil {
			break
		}

		return e.complexity.RedisInstanceConnection.Edges(childComplexity), true

	case "RedisInstanceConnection.nodes":
		if e.complexity.RedisInstanceConnection.Nodes == nil {
			break
		}

		return e.complexity.RedisInstanceConnection.Nodes(childComplexity), true

	case "RedisInstanceConnection.pageInfo":
		if e.complexity.RedisInstanceConnection.PageInfo == nil {
			break
		}

		return e.complexity.RedisInstanceConnection.PageInfo(childComplexity), true

	case "RedisInstanceCost.sum":
		if e.complexity.RedisInstanceCost.Sum == nil {
			break
		}

		return e.complexity.RedisInstanceCost.Sum(childComplexity), true

	case "RedisInstanceEdge.cursor":
		if e.complexity.RedisInstanceEdge.Cursor == nil {
			break
		}

		return e.complexity.RedisInstanceEdge.Cursor(childComplexity), true

	case "RedisInstanceEdge.node":
		if e.complexity.RedisInstanceEdge.Node == nil {
			break
		}

		return e.complexity.RedisInstanceEdge.Node(childComplexity), true

	case "RedisInstanceStatus.state":
		if e.complexity.RedisInstanceStatus.State == nil {
			break
		}

		return e.complexity.RedisInstanceStatus.State(childComplexity), true

	case "RemoveRepositoryFromTeamPayload.success":
		if e.complexity.RemoveRepositoryFromTeamPayload.Success == nil {
			break
		}

		return e.complexity.RemoveRepositoryFromTeamPayload.Success(childComplexity), true

	case "RemoveSecretValuePayload.secret":
		if e.complexity.RemoveSecretValuePayload.Secret == nil {
			break
		}

		return e.complexity.RemoveSecretValuePayload.Secret(childComplexity), true

	case "RemoveTeamMemberPayload.team":
		if e.complexity.RemoveTeamMemberPayload.Team == nil {
			break
		}

		return e.complexity.RemoveTeamMemberPayload.Team(childComplexity), true

	case "RemoveTeamMemberPayload.user":
		if e.complexity.RemoveTeamMemberPayload.User == nil {
			break
		}

		return e.complexity.RemoveTeamMemberPayload.User(childComplexity), true

	case "Repository.id":
		if e.complexity.Repository.ID == nil {
			break
		}

		return e.complexity.Repository.ID(childComplexity), true

	case "Repository.name":
		if e.complexity.Repository.Name == nil {
			break
		}

		return e.complexity.Repository.Name(childComplexity), true

	case "Repository.team":
		if e.complexity.Repository.Team == nil {
			break
		}

		return e.complexity.Repository.Team(childComplexity), true

	case "RepositoryAddedActivityLogEntry.actor":
		if e.complexity.RepositoryAddedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.RepositoryAddedActivityLogEntry.Actor(childComplexity), true

	case "RepositoryAddedActivityLogEntry.createdAt":
		if e.complexity.RepositoryAddedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.RepositoryAddedActivityLogEntry.CreatedAt(childComplexity), true

	case "RepositoryAddedActivityLogEntry.environmentName":
		if e.complexity.RepositoryAddedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.RepositoryAddedActivityLogEntry.EnvironmentName(childComplexity), true

	case "RepositoryAddedActivityLogEntry.id":
		if e.complexity.RepositoryAddedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.RepositoryAddedActivityLogEntry.ID(childComplexity), true

	case "RepositoryAddedActivityLogEntry.message":
		if e.complexity.RepositoryAddedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.RepositoryAddedActivityLogEntry.Message(childComplexity), true

	case "RepositoryAddedActivityLogEntry.resourceName":
		if e.complexity.RepositoryAddedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.RepositoryAddedActivityLogEntry.ResourceName(childComplexity), true

	case "RepositoryAddedActivityLogEntry.resourceType":
		if e.complexity.RepositoryAddedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.RepositoryAddedActivityLogEntry.ResourceType(childComplexity), true

	case "RepositoryAddedActivityLogEntry.teamSlug":
		if e.complexity.RepositoryAddedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.RepositoryAddedActivityLogEntry.TeamSlug(childComplexity), true

	case "RepositoryConnection.edges":
		if e.complexity.RepositoryConnection.Edges == nil {
			break
		}

		return e.complexity.RepositoryConnection.Edges(childComplexity), true

	case "RepositoryConnection.nodes":
		if e.complexity.RepositoryConnection.Nodes == nil {
			break
		}

		return e.complexity.RepositoryConnection.Nodes(childComplexity), true

	case "RepositoryConnection.pageInfo":
		if e.complexity.RepositoryConnection.PageInfo == nil {
			break
		}

		return e.complexity.RepositoryConnection.PageInfo(childComplexity), true

	case "RepositoryEdge.cursor":
		if e.complexity.RepositoryEdge.Cursor == nil {
			break
		}

		return e.complexity.RepositoryEdge.Cursor(childComplexity), true

	case "RepositoryEdge.node":
		if e.complexity.RepositoryEdge.Node == nil {
			break
		}

		return e.complexity.RepositoryEdge.Node(childComplexity), true

	case "RepositoryRemovedActivityLogEntry.actor":
		if e.complexity.RepositoryRemovedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.RepositoryRemovedActivityLogEntry.Actor(childComplexity), true

	case "RepositoryRemovedActivityLogEntry.createdAt":
		if e.complexity.RepositoryRemovedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.RepositoryRemovedActivityLogEntry.CreatedAt(childComplexity), true

	case "RepositoryRemovedActivityLogEntry.environmentName":
		if e.complexity.RepositoryRemovedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.RepositoryRemovedActivityLogEntry.EnvironmentName(childComplexity), true

	case "RepositoryRemovedActivityLogEntry.id":
		if e.complexity.RepositoryRemovedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.RepositoryRemovedActivityLogEntry.ID(childComplexity), true

	case "RepositoryRemovedActivityLogEntry.message":
		if e.complexity.RepositoryRemovedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.RepositoryRemovedActivityLogEntry.Message(childComplexity), true

	case "RepositoryRemovedActivityLogEntry.resourceName":
		if e.complexity.RepositoryRemovedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.RepositoryRemovedActivityLogEntry.ResourceName(childComplexity), true

	case "RepositoryRemovedActivityLogEntry.resourceType":
		if e.complexity.RepositoryRemovedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.RepositoryRemovedActivityLogEntry.ResourceType(childComplexity), true

	case "RepositoryRemovedActivityLogEntry.teamSlug":
		if e.complexity.RepositoryRemovedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.RepositoryRemovedActivityLogEntry.TeamSlug(childComplexity), true

	case "RequestTeamDeletionPayload.key":
		if e.complexity.RequestTeamDeletionPayload.Key == nil {
			break
		}

		return e.complexity.RequestTeamDeletionPayload.Key(childComplexity), true

	case "RestartApplicationPayload.application":
		if e.complexity.RestartApplicationPayload.Application == nil {
			break
		}

		return e.complexity.RestartApplicationPayload.Application(childComplexity), true

	case "RevokeRoleFromServiceAccountPayload.serviceAccount":
		if e.complexity.RevokeRoleFromServiceAccountPayload.ServiceAccount == nil {
			break
		}

		return e.complexity.RevokeRoleFromServiceAccountPayload.ServiceAccount(childComplexity), true

	case "RevokeTeamAccessToUnleashPayload.unleash":
		if e.complexity.RevokeTeamAccessToUnleashPayload.Unleash == nil {
			break
		}

		return e.complexity.RevokeTeamAccessToUnleashPayload.Unleash(childComplexity), true

	case "Role.description":
		if e.complexity.Role.Description == nil {
			break
		}

		return e.complexity.Role.Description(childComplexity), true

	case "Role.id":
		if e.complexity.Role.ID == nil {
			break
		}

		return e.complexity.Role.ID(childComplexity), true

	case "Role.name":
		if e.complexity.Role.Name == nil {
			break
		}

		return e.complexity.Role.Name(childComplexity), true

	case "RoleAssignedToServiceAccountActivityLogEntry.actor":
		if e.complexity.RoleAssignedToServiceAccountActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.RoleAssignedToServiceAccountActivityLogEntry.Actor(childComplexity), true

	case "RoleAssignedToServiceAccountActivityLogEntry.createdAt":
		if e.complexity.RoleAssignedToServiceAccountActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.RoleAssignedToServiceAccountActivityLogEntry.CreatedAt(childComplexity), true

	case "RoleAssignedToServiceAccountActivityLogEntry.data":
		if e.complexity.RoleAssignedToServiceAccountActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.RoleAssignedToServiceAccountActivityLogEntry.Data(childComplexity), true

	case "RoleAssignedToServiceAccountActivityLogEntry.environmentName":
		if e.complexity.RoleAssignedToServiceAccountActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.RoleAssignedToServiceAccountActivityLogEntry.EnvironmentName(childComplexity), true

	case "RoleAssignedToServiceAccountActivityLogEntry.id":
		if e.complexity.RoleAssignedToServiceAccountActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.RoleAssignedToServiceAccountActivityLogEntry.ID(childComplexity), true

	case "RoleAssignedToServiceAccountActivityLogEntry.message":
		if e.complexity.RoleAssignedToServiceAccountActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.RoleAssignedToServiceAccountActivityLogEntry.Message(childComplexity), true

	case "RoleAssignedToServiceAccountActivityLogEntry.resourceName":
		if e.complexity.RoleAssignedToServiceAccountActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.RoleAssignedToServiceAccountActivityLogEntry.ResourceName(childComplexity), true

	case "RoleAssignedToServiceAccountActivityLogEntry.resourceType":
		if e.complexity.RoleAssignedToServiceAccountActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.RoleAssignedToServiceAccountActivityLogEntry.ResourceType(childComplexity), true

	case "RoleAssignedToServiceAccountActivityLogEntry.teamSlug":
		if e.complexity.RoleAssignedToServiceAccountActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.RoleAssignedToServiceAccountActivityLogEntry.TeamSlug(childComplexity), true

	case "RoleAssignedToServiceAccountActivityLogEntryData.roleName":
		if e.complexity.RoleAssignedToServiceAccountActivityLogEntryData.RoleName == nil {
			break
		}

		return e.complexity.RoleAssignedToServiceAccountActivityLogEntryData.RoleName(childComplexity), true

	case "RoleAssignedUserSyncLogEntry.createdAt":
		if e.complexity.RoleAssignedUserSyncLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.RoleAssignedUserSyncLogEntry.CreatedAt(childComplexity), true

	case "RoleAssignedUserSyncLogEntry.id":
		if e.complexity.RoleAssignedUserSyncLogEntry.ID == nil {
			break
		}

		return e.complexity.RoleAssignedUserSyncLogEntry.ID(childComplexity), true

	case "RoleAssignedUserSyncLogEntry.message":
		if e.complexity.RoleAssignedUserSyncLogEntry.Message == nil {
			break
		}

		return e.complexity.RoleAssignedUserSyncLogEntry.Message(childComplexity), true

	case "RoleAssignedUserSyncLogEntry.roleName":
		if e.complexity.RoleAssignedUserSyncLogEntry.RoleName == nil {
			break
		}

		return e.complexity.RoleAssignedUserSyncLogEntry.RoleName(childComplexity), true

	case "RoleAssignedUserSyncLogEntry.userEmail":
		if e.complexity.RoleAssignedUserSyncLogEntry.UserEmail == nil {
			break
		}

		return e.complexity.RoleAssignedUserSyncLogEntry.UserEmail(childComplexity), true

	case "RoleAssignedUserSyncLogEntry.userID":
		if e.complexity.RoleAssignedUserSyncLogEntry.UserID == nil {
			break
		}

		return e.complexity.RoleAssignedUserSyncLogEntry.UserID(childComplexity), true

	case "RoleAssignedUserSyncLogEntry.userName":
		if e.complexity.RoleAssignedUserSyncLogEntry.UserName == nil {
			break
		}

		return e.complexity.RoleAssignedUserSyncLogEntry.UserName(childComplexity), true

	case "RoleConnection.edges":
		if e.complexity.RoleConnection.Edges == nil {
			break
		}

		return e.complexity.RoleConnection.Edges(childComplexity), true

	case "RoleConnection.nodes":
		if e.complexity.RoleConnection.Nodes == nil {
			break
		}

		return e.complexity.RoleConnection.Nodes(childComplexity), true

	case "RoleConnection.pageInfo":
		if e.complexity.RoleConnection.PageInfo == nil {
			break
		}

		return e.complexity.RoleConnection.PageInfo(childComplexity), true

	case "RoleEdge.cursor":
		if e.complexity.RoleEdge.Cursor == nil {
			break
		}

		return e.complexity.RoleEdge.Cursor(childComplexity), true

	case "RoleEdge.node":
		if e.complexity.RoleEdge.Node == nil {
			break
		}

		return e.complexity.RoleEdge.Node(childComplexity), true

	case "RoleRevokedFromServiceAccountActivityLogEntry.actor":
		if e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.Actor(childComplexity), true

	case "RoleRevokedFromServiceAccountActivityLogEntry.createdAt":
		if e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.CreatedAt(childComplexity), true

	case "RoleRevokedFromServiceAccountActivityLogEntry.data":
		if e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.Data(childComplexity), true

	case "RoleRevokedFromServiceAccountActivityLogEntry.environmentName":
		if e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.EnvironmentName(childComplexity), true

	case "RoleRevokedFromServiceAccountActivityLogEntry.id":
		if e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.ID(childComplexity), true

	case "RoleRevokedFromServiceAccountActivityLogEntry.message":
		if e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.Message(childComplexity), true

	case "RoleRevokedFromServiceAccountActivityLogEntry.resourceName":
		if e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.ResourceName(childComplexity), true

	case "RoleRevokedFromServiceAccountActivityLogEntry.resourceType":
		if e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.ResourceType(childComplexity), true

	case "RoleRevokedFromServiceAccountActivityLogEntry.teamSlug":
		if e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.RoleRevokedFromServiceAccountActivityLogEntry.TeamSlug(childComplexity), true

	case "RoleRevokedFromServiceAccountActivityLogEntryData.roleName":
		if e.complexity.RoleRevokedFromServiceAccountActivityLogEntryData.RoleName == nil {
			break
		}

		return e.complexity.RoleRevokedFromServiceAccountActivityLogEntryData.RoleName(childComplexity), true

	case "RoleRevokedUserSyncLogEntry.createdAt":
		if e.complexity.RoleRevokedUserSyncLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.RoleRevokedUserSyncLogEntry.CreatedAt(childComplexity), true

	case "RoleRevokedUserSyncLogEntry.id":
		if e.complexity.RoleRevokedUserSyncLogEntry.ID == nil {
			break
		}

		return e.complexity.RoleRevokedUserSyncLogEntry.ID(childComplexity), true

	case "RoleRevokedUserSyncLogEntry.message":
		if e.complexity.RoleRevokedUserSyncLogEntry.Message == nil {
			break
		}

		return e.complexity.RoleRevokedUserSyncLogEntry.Message(childComplexity), true

	case "RoleRevokedUserSyncLogEntry.roleName":
		if e.complexity.RoleRevokedUserSyncLogEntry.RoleName == nil {
			break
		}

		return e.complexity.RoleRevokedUserSyncLogEntry.RoleName(childComplexity), true

	case "RoleRevokedUserSyncLogEntry.userEmail":
		if e.complexity.RoleRevokedUserSyncLogEntry.UserEmail == nil {
			break
		}

		return e.complexity.RoleRevokedUserSyncLogEntry.UserEmail(childComplexity), true

	case "RoleRevokedUserSyncLogEntry.userID":
		if e.complexity.RoleRevokedUserSyncLogEntry.UserID == nil {
			break
		}

		return e.complexity.RoleRevokedUserSyncLogEntry.UserID(childComplexity), true

	case "RoleRevokedUserSyncLogEntry.userName":
		if e.complexity.RoleRevokedUserSyncLogEntry.UserName == nil {
			break
		}

		return e.complexity.RoleRevokedUserSyncLogEntry.UserName(childComplexity), true

	case "SearchNodeConnection.edges":
		if e.complexity.SearchNodeConnection.Edges == nil {
			break
		}

		return e.complexity.SearchNodeConnection.Edges(childComplexity), true

	case "SearchNodeConnection.nodes":
		if e.complexity.SearchNodeConnection.Nodes == nil {
			break
		}

		return e.complexity.SearchNodeConnection.Nodes(childComplexity), true

	case "SearchNodeConnection.pageInfo":
		if e.complexity.SearchNodeConnection.PageInfo == nil {
			break
		}

		return e.complexity.SearchNodeConnection.PageInfo(childComplexity), true

	case "SearchNodeEdge.cursor":
		if e.complexity.SearchNodeEdge.Cursor == nil {
			break
		}

		return e.complexity.SearchNodeEdge.Cursor(childComplexity), true

	case "SearchNodeEdge.node":
		if e.complexity.SearchNodeEdge.Node == nil {
			break
		}

		return e.complexity.SearchNodeEdge.Node(childComplexity), true

	case "Secret.applications":
		if e.complexity.Secret.Applications == nil {
			break
		}

		args, err := ec.field_Secret_applications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Secret.Applications(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Secret.environment":
		if e.complexity.Secret.Environment == nil {
			break
		}

		return e.complexity.Secret.Environment(childComplexity), true

	case "Secret.id":
		if e.complexity.Secret.ID == nil {
			break
		}

		return e.complexity.Secret.ID(childComplexity), true

	case "Secret.jobs":
		if e.complexity.Secret.Jobs == nil {
			break
		}

		args, err := ec.field_Secret_jobs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Secret.Jobs(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Secret.lastModifiedAt":
		if e.complexity.Secret.LastModifiedAt == nil {
			break
		}

		return e.complexity.Secret.LastModifiedAt(childComplexity), true

	case "Secret.lastModifiedBy":
		if e.complexity.Secret.LastModifiedBy == nil {
			break
		}

		return e.complexity.Secret.LastModifiedBy(childComplexity), true

	case "Secret.name":
		if e.complexity.Secret.Name == nil {
			break
		}

		return e.complexity.Secret.Name(childComplexity), true

	case "Secret.team":
		if e.complexity.Secret.Team == nil {
			break
		}

		return e.complexity.Secret.Team(childComplexity), true

	case "Secret.teamEnvironment":
		if e.complexity.Secret.TeamEnvironment == nil {
			break
		}

		return e.complexity.Secret.TeamEnvironment(childComplexity), true

	case "Secret.values":
		if e.complexity.Secret.Values == nil {
			break
		}

		return e.complexity.Secret.Values(childComplexity), true

	case "Secret.workloads":
		if e.complexity.Secret.Workloads == nil {
			break
		}

		args, err := ec.field_Secret_workloads_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Secret.Workloads(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "SecretConnection.edges":
		if e.complexity.SecretConnection.Edges == nil {
			break
		}

		return e.complexity.SecretConnection.Edges(childComplexity), true

	case "SecretConnection.nodes":
		if e.complexity.SecretConnection.Nodes == nil {
			break
		}

		return e.complexity.SecretConnection.Nodes(childComplexity), true

	case "SecretConnection.pageInfo":
		if e.complexity.SecretConnection.PageInfo == nil {
			break
		}

		return e.complexity.SecretConnection.PageInfo(childComplexity), true

	case "SecretCreatedActivityLogEntry.actor":
		if e.complexity.SecretCreatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.SecretCreatedActivityLogEntry.Actor(childComplexity), true

	case "SecretCreatedActivityLogEntry.createdAt":
		if e.complexity.SecretCreatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.SecretCreatedActivityLogEntry.CreatedAt(childComplexity), true

	case "SecretCreatedActivityLogEntry.environmentName":
		if e.complexity.SecretCreatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.SecretCreatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "SecretCreatedActivityLogEntry.id":
		if e.complexity.SecretCreatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.SecretCreatedActivityLogEntry.ID(childComplexity), true

	case "SecretCreatedActivityLogEntry.message":
		if e.complexity.SecretCreatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.SecretCreatedActivityLogEntry.Message(childComplexity), true

	case "SecretCreatedActivityLogEntry.resourceName":
		if e.complexity.SecretCreatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.SecretCreatedActivityLogEntry.ResourceName(childComplexity), true

	case "SecretCreatedActivityLogEntry.resourceType":
		if e.complexity.SecretCreatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.SecretCreatedActivityLogEntry.ResourceType(childComplexity), true

	case "SecretCreatedActivityLogEntry.teamSlug":
		if e.complexity.SecretCreatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.SecretCreatedActivityLogEntry.TeamSlug(childComplexity), true

	case "SecretDeletedActivityLogEntry.actor":
		if e.complexity.SecretDeletedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.SecretDeletedActivityLogEntry.Actor(childComplexity), true

	case "SecretDeletedActivityLogEntry.createdAt":
		if e.complexity.SecretDeletedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.SecretDeletedActivityLogEntry.CreatedAt(childComplexity), true

	case "SecretDeletedActivityLogEntry.environmentName":
		if e.complexity.SecretDeletedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.SecretDeletedActivityLogEntry.EnvironmentName(childComplexity), true

	case "SecretDeletedActivityLogEntry.id":
		if e.complexity.SecretDeletedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.SecretDeletedActivityLogEntry.ID(childComplexity), true

	case "SecretDeletedActivityLogEntry.message":
		if e.complexity.SecretDeletedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.SecretDeletedActivityLogEntry.Message(childComplexity), true

	case "SecretDeletedActivityLogEntry.resourceName":
		if e.complexity.SecretDeletedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.SecretDeletedActivityLogEntry.ResourceName(childComplexity), true

	case "SecretDeletedActivityLogEntry.resourceType":
		if e.complexity.SecretDeletedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.SecretDeletedActivityLogEntry.ResourceType(childComplexity), true

	case "SecretDeletedActivityLogEntry.teamSlug":
		if e.complexity.SecretDeletedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.SecretDeletedActivityLogEntry.TeamSlug(childComplexity), true

	case "SecretEdge.cursor":
		if e.complexity.SecretEdge.Cursor == nil {
			break
		}

		return e.complexity.SecretEdge.Cursor(childComplexity), true

	case "SecretEdge.node":
		if e.complexity.SecretEdge.Node == nil {
			break
		}

		return e.complexity.SecretEdge.Node(childComplexity), true

	case "SecretValue.name":
		if e.complexity.SecretValue.Name == nil {
			break
		}

		return e.complexity.SecretValue.Name(childComplexity), true

	case "SecretValue.value":
		if e.complexity.SecretValue.Value == nil {
			break
		}

		return e.complexity.SecretValue.Value(childComplexity), true

	case "SecretValueAddedActivityLogEntry.actor":
		if e.complexity.SecretValueAddedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.SecretValueAddedActivityLogEntry.Actor(childComplexity), true

	case "SecretValueAddedActivityLogEntry.createdAt":
		if e.complexity.SecretValueAddedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.SecretValueAddedActivityLogEntry.CreatedAt(childComplexity), true

	case "SecretValueAddedActivityLogEntry.data":
		if e.complexity.SecretValueAddedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.SecretValueAddedActivityLogEntry.Data(childComplexity), true

	case "SecretValueAddedActivityLogEntry.environmentName":
		if e.complexity.SecretValueAddedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.SecretValueAddedActivityLogEntry.EnvironmentName(childComplexity), true

	case "SecretValueAddedActivityLogEntry.id":
		if e.complexity.SecretValueAddedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.SecretValueAddedActivityLogEntry.ID(childComplexity), true

	case "SecretValueAddedActivityLogEntry.message":
		if e.complexity.SecretValueAddedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.SecretValueAddedActivityLogEntry.Message(childComplexity), true

	case "SecretValueAddedActivityLogEntry.resourceName":
		if e.complexity.SecretValueAddedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.SecretValueAddedActivityLogEntry.ResourceName(childComplexity), true

	case "SecretValueAddedActivityLogEntry.resourceType":
		if e.complexity.SecretValueAddedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.SecretValueAddedActivityLogEntry.ResourceType(childComplexity), true

	case "SecretValueAddedActivityLogEntry.teamSlug":
		if e.complexity.SecretValueAddedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.SecretValueAddedActivityLogEntry.TeamSlug(childComplexity), true

	case "SecretValueAddedActivityLogEntryData.valueName":
		if e.complexity.SecretValueAddedActivityLogEntryData.ValueName == nil {
			break
		}

		return e.complexity.SecretValueAddedActivityLogEntryData.ValueName(childComplexity), true

	case "SecretValueRemovedActivityLogEntry.actor":
		if e.complexity.SecretValueRemovedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.SecretValueRemovedActivityLogEntry.Actor(childComplexity), true

	case "SecretValueRemovedActivityLogEntry.createdAt":
		if e.complexity.SecretValueRemovedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.SecretValueRemovedActivityLogEntry.CreatedAt(childComplexity), true

	case "SecretValueRemovedActivityLogEntry.data":
		if e.complexity.SecretValueRemovedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.SecretValueRemovedActivityLogEntry.Data(childComplexity), true

	case "SecretValueRemovedActivityLogEntry.environmentName":
		if e.complexity.SecretValueRemovedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.SecretValueRemovedActivityLogEntry.EnvironmentName(childComplexity), true

	case "SecretValueRemovedActivityLogEntry.id":
		if e.complexity.SecretValueRemovedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.SecretValueRemovedActivityLogEntry.ID(childComplexity), true

	case "SecretValueRemovedActivityLogEntry.message":
		if e.complexity.SecretValueRemovedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.SecretValueRemovedActivityLogEntry.Message(childComplexity), true

	case "SecretValueRemovedActivityLogEntry.resourceName":
		if e.complexity.SecretValueRemovedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.SecretValueRemovedActivityLogEntry.ResourceName(childComplexity), true

	case "SecretValueRemovedActivityLogEntry.resourceType":
		if e.complexity.SecretValueRemovedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.SecretValueRemovedActivityLogEntry.ResourceType(childComplexity), true

	case "SecretValueRemovedActivityLogEntry.teamSlug":
		if e.complexity.SecretValueRemovedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.SecretValueRemovedActivityLogEntry.TeamSlug(childComplexity), true

	case "SecretValueRemovedActivityLogEntryData.valueName":
		if e.complexity.SecretValueRemovedActivityLogEntryData.ValueName == nil {
			break
		}

		return e.complexity.SecretValueRemovedActivityLogEntryData.ValueName(childComplexity), true

	case "SecretValueUpdatedActivityLogEntry.actor":
		if e.complexity.SecretValueUpdatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.SecretValueUpdatedActivityLogEntry.Actor(childComplexity), true

	case "SecretValueUpdatedActivityLogEntry.createdAt":
		if e.complexity.SecretValueUpdatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.SecretValueUpdatedActivityLogEntry.CreatedAt(childComplexity), true

	case "SecretValueUpdatedActivityLogEntry.data":
		if e.complexity.SecretValueUpdatedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.SecretValueUpdatedActivityLogEntry.Data(childComplexity), true

	case "SecretValueUpdatedActivityLogEntry.environmentName":
		if e.complexity.SecretValueUpdatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.SecretValueUpdatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "SecretValueUpdatedActivityLogEntry.id":
		if e.complexity.SecretValueUpdatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.SecretValueUpdatedActivityLogEntry.ID(childComplexity), true

	case "SecretValueUpdatedActivityLogEntry.message":
		if e.complexity.SecretValueUpdatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.SecretValueUpdatedActivityLogEntry.Message(childComplexity), true

	case "SecretValueUpdatedActivityLogEntry.resourceName":
		if e.complexity.SecretValueUpdatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.SecretValueUpdatedActivityLogEntry.ResourceName(childComplexity), true

	case "SecretValueUpdatedActivityLogEntry.resourceType":
		if e.complexity.SecretValueUpdatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.SecretValueUpdatedActivityLogEntry.ResourceType(childComplexity), true

	case "SecretValueUpdatedActivityLogEntry.teamSlug":
		if e.complexity.SecretValueUpdatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.SecretValueUpdatedActivityLogEntry.TeamSlug(childComplexity), true

	case "SecretValueUpdatedActivityLogEntryData.valueName":
		if e.complexity.SecretValueUpdatedActivityLogEntryData.ValueName == nil {
			break
		}

		return e.complexity.SecretValueUpdatedActivityLogEntryData.ValueName(childComplexity), true

	case "ServiceAccount.createdAt":
		if e.complexity.ServiceAccount.CreatedAt == nil {
			break
		}

		return e.complexity.ServiceAccount.CreatedAt(childComplexity), true

	case "ServiceAccount.description":
		if e.complexity.ServiceAccount.Description == nil {
			break
		}

		return e.complexity.ServiceAccount.Description(childComplexity), true

	case "ServiceAccount.id":
		if e.complexity.ServiceAccount.ID == nil {
			break
		}

		return e.complexity.ServiceAccount.ID(childComplexity), true

	case "ServiceAccount.lastUsedAt":
		if e.complexity.ServiceAccount.LastUsedAt == nil {
			break
		}

		return e.complexity.ServiceAccount.LastUsedAt(childComplexity), true

	case "ServiceAccount.name":
		if e.complexity.ServiceAccount.Name == nil {
			break
		}

		return e.complexity.ServiceAccount.Name(childComplexity), true

	case "ServiceAccount.roles":
		if e.complexity.ServiceAccount.Roles == nil {
			break
		}

		args, err := ec.field_ServiceAccount_roles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ServiceAccount.Roles(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "ServiceAccount.team":
		if e.complexity.ServiceAccount.Team == nil {
			break
		}

		return e.complexity.ServiceAccount.Team(childComplexity), true

	case "ServiceAccount.tokens":
		if e.complexity.ServiceAccount.Tokens == nil {
			break
		}

		args, err := ec.field_ServiceAccount_tokens_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ServiceAccount.Tokens(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "ServiceAccount.updatedAt":
		if e.complexity.ServiceAccount.UpdatedAt == nil {
			break
		}

		return e.complexity.ServiceAccount.UpdatedAt(childComplexity), true

	case "ServiceAccountConnection.edges":
		if e.complexity.ServiceAccountConnection.Edges == nil {
			break
		}

		return e.complexity.ServiceAccountConnection.Edges(childComplexity), true

	case "ServiceAccountConnection.nodes":
		if e.complexity.ServiceAccountConnection.Nodes == nil {
			break
		}

		return e.complexity.ServiceAccountConnection.Nodes(childComplexity), true

	case "ServiceAccountConnection.pageInfo":
		if e.complexity.ServiceAccountConnection.PageInfo == nil {
			break
		}

		return e.complexity.ServiceAccountConnection.PageInfo(childComplexity), true

	case "ServiceAccountCreatedActivityLogEntry.actor":
		if e.complexity.ServiceAccountCreatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.ServiceAccountCreatedActivityLogEntry.Actor(childComplexity), true

	case "ServiceAccountCreatedActivityLogEntry.createdAt":
		if e.complexity.ServiceAccountCreatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.ServiceAccountCreatedActivityLogEntry.CreatedAt(childComplexity), true

	case "ServiceAccountCreatedActivityLogEntry.environmentName":
		if e.complexity.ServiceAccountCreatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.ServiceAccountCreatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "ServiceAccountCreatedActivityLogEntry.id":
		if e.complexity.ServiceAccountCreatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.ServiceAccountCreatedActivityLogEntry.ID(childComplexity), true

	case "ServiceAccountCreatedActivityLogEntry.message":
		if e.complexity.ServiceAccountCreatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.ServiceAccountCreatedActivityLogEntry.Message(childComplexity), true

	case "ServiceAccountCreatedActivityLogEntry.resourceName":
		if e.complexity.ServiceAccountCreatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.ServiceAccountCreatedActivityLogEntry.ResourceName(childComplexity), true

	case "ServiceAccountCreatedActivityLogEntry.resourceType":
		if e.complexity.ServiceAccountCreatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.ServiceAccountCreatedActivityLogEntry.ResourceType(childComplexity), true

	case "ServiceAccountCreatedActivityLogEntry.teamSlug":
		if e.complexity.ServiceAccountCreatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.ServiceAccountCreatedActivityLogEntry.TeamSlug(childComplexity), true

	case "ServiceAccountDeletedActivityLogEntry.actor":
		if e.complexity.ServiceAccountDeletedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.ServiceAccountDeletedActivityLogEntry.Actor(childComplexity), true

	case "ServiceAccountDeletedActivityLogEntry.createdAt":
		if e.complexity.ServiceAccountDeletedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.ServiceAccountDeletedActivityLogEntry.CreatedAt(childComplexity), true

	case "ServiceAccountDeletedActivityLogEntry.environmentName":
		if e.complexity.ServiceAccountDeletedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.ServiceAccountDeletedActivityLogEntry.EnvironmentName(childComplexity), true

	case "ServiceAccountDeletedActivityLogEntry.id":
		if e.complexity.ServiceAccountDeletedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.ServiceAccountDeletedActivityLogEntry.ID(childComplexity), true

	case "ServiceAccountDeletedActivityLogEntry.message":
		if e.complexity.ServiceAccountDeletedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.ServiceAccountDeletedActivityLogEntry.Message(childComplexity), true

	case "ServiceAccountDeletedActivityLogEntry.resourceName":
		if e.complexity.ServiceAccountDeletedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.ServiceAccountDeletedActivityLogEntry.ResourceName(childComplexity), true

	case "ServiceAccountDeletedActivityLogEntry.resourceType":
		if e.complexity.ServiceAccountDeletedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.ServiceAccountDeletedActivityLogEntry.ResourceType(childComplexity), true

	case "ServiceAccountDeletedActivityLogEntry.teamSlug":
		if e.complexity.ServiceAccountDeletedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.ServiceAccountDeletedActivityLogEntry.TeamSlug(childComplexity), true

	case "ServiceAccountEdge.cursor":
		if e.complexity.ServiceAccountEdge.Cursor == nil {
			break
		}

		return e.complexity.ServiceAccountEdge.Cursor(childComplexity), true

	case "ServiceAccountEdge.node":
		if e.complexity.ServiceAccountEdge.Node == nil {
			break
		}

		return e.complexity.ServiceAccountEdge.Node(childComplexity), true

	case "ServiceAccountToken.createdAt":
		if e.complexity.ServiceAccountToken.CreatedAt == nil {
			break
		}

		return e.complexity.ServiceAccountToken.CreatedAt(childComplexity), true

	case "ServiceAccountToken.description":
		if e.complexity.ServiceAccountToken.Description == nil {
			break
		}

		return e.complexity.ServiceAccountToken.Description(childComplexity), true

	case "ServiceAccountToken.expiresAt":
		if e.complexity.ServiceAccountToken.ExpiresAt == nil {
			break
		}

		return e.complexity.ServiceAccountToken.ExpiresAt(childComplexity), true

	case "ServiceAccountToken.id":
		if e.complexity.ServiceAccountToken.ID == nil {
			break
		}

		return e.complexity.ServiceAccountToken.ID(childComplexity), true

	case "ServiceAccountToken.lastUsedAt":
		if e.complexity.ServiceAccountToken.LastUsedAt == nil {
			break
		}

		return e.complexity.ServiceAccountToken.LastUsedAt(childComplexity), true

	case "ServiceAccountToken.name":
		if e.complexity.ServiceAccountToken.Name == nil {
			break
		}

		return e.complexity.ServiceAccountToken.Name(childComplexity), true

	case "ServiceAccountToken.updatedAt":
		if e.complexity.ServiceAccountToken.UpdatedAt == nil {
			break
		}

		return e.complexity.ServiceAccountToken.UpdatedAt(childComplexity), true

	case "ServiceAccountTokenConnection.edges":
		if e.complexity.ServiceAccountTokenConnection.Edges == nil {
			break
		}

		return e.complexity.ServiceAccountTokenConnection.Edges(childComplexity), true

	case "ServiceAccountTokenConnection.nodes":
		if e.complexity.ServiceAccountTokenConnection.Nodes == nil {
			break
		}

		return e.complexity.ServiceAccountTokenConnection.Nodes(childComplexity), true

	case "ServiceAccountTokenConnection.pageInfo":
		if e.complexity.ServiceAccountTokenConnection.PageInfo == nil {
			break
		}

		return e.complexity.ServiceAccountTokenConnection.PageInfo(childComplexity), true

	case "ServiceAccountTokenCreatedActivityLogEntry.actor":
		if e.complexity.ServiceAccountTokenCreatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.ServiceAccountTokenCreatedActivityLogEntry.Actor(childComplexity), true

	case "ServiceAccountTokenCreatedActivityLogEntry.createdAt":
		if e.complexity.ServiceAccountTokenCreatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.ServiceAccountTokenCreatedActivityLogEntry.CreatedAt(childComplexity), true

	case "ServiceAccountTokenCreatedActivityLogEntry.data":
		if e.complexity.ServiceAccountTokenCreatedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.ServiceAccountTokenCreatedActivityLogEntry.Data(childComplexity), true

	case "ServiceAccountTokenCreatedActivityLogEntry.environmentName":
		if e.complexity.ServiceAccountTokenCreatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.ServiceAccountTokenCreatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "ServiceAccountTokenCreatedActivityLogEntry.id":
		if e.complexity.ServiceAccountTokenCreatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.ServiceAccountTokenCreatedActivityLogEntry.ID(childComplexity), true

	case "ServiceAccountTokenCreatedActivityLogEntry.message":
		if e.complexity.ServiceAccountTokenCreatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.ServiceAccountTokenCreatedActivityLogEntry.Message(childComplexity), true

	case "ServiceAccountTokenCreatedActivityLogEntry.resourceName":
		if e.complexity.ServiceAccountTokenCreatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.ServiceAccountTokenCreatedActivityLogEntry.ResourceName(childComplexity), true

	case "ServiceAccountTokenCreatedActivityLogEntry.resourceType":
		if e.complexity.ServiceAccountTokenCreatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.ServiceAccountTokenCreatedActivityLogEntry.ResourceType(childComplexity), true

	case "ServiceAccountTokenCreatedActivityLogEntry.teamSlug":
		if e.complexity.ServiceAccountTokenCreatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.ServiceAccountTokenCreatedActivityLogEntry.TeamSlug(childComplexity), true

	case "ServiceAccountTokenCreatedActivityLogEntryData.tokenName":
		if e.complexity.ServiceAccountTokenCreatedActivityLogEntryData.TokenName == nil {
			break
		}

		return e.complexity.ServiceAccountTokenCreatedActivityLogEntryData.TokenName(childComplexity), true

	case "ServiceAccountTokenDeletedActivityLogEntry.actor":
		if e.complexity.ServiceAccountTokenDeletedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.ServiceAccountTokenDeletedActivityLogEntry.Actor(childComplexity), true

	case "ServiceAccountTokenDeletedActivityLogEntry.createdAt":
		if e.complexity.ServiceAccountTokenDeletedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.ServiceAccountTokenDeletedActivityLogEntry.CreatedAt(childComplexity), true

	case "ServiceAccountTokenDeletedActivityLogEntry.data":
		if e.complexity.ServiceAccountTokenDeletedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.ServiceAccountTokenDeletedActivityLogEntry.Data(childComplexity), true

	case "ServiceAccountTokenDeletedActivityLogEntry.environmentName":
		if e.complexity.ServiceAccountTokenDeletedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.ServiceAccountTokenDeletedActivityLogEntry.EnvironmentName(childComplexity), true

	case "ServiceAccountTokenDeletedActivityLogEntry.id":
		if e.complexity.ServiceAccountTokenDeletedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.ServiceAccountTokenDeletedActivityLogEntry.ID(childComplexity), true

	case "ServiceAccountTokenDeletedActivityLogEntry.message":
		if e.complexity.ServiceAccountTokenDeletedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.ServiceAccountTokenDeletedActivityLogEntry.Message(childComplexity), true

	case "ServiceAccountTokenDeletedActivityLogEntry.resourceName":
		if e.complexity.ServiceAccountTokenDeletedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.ServiceAccountTokenDeletedActivityLogEntry.ResourceName(childComplexity), true

	case "ServiceAccountTokenDeletedActivityLogEntry.resourceType":
		if e.complexity.ServiceAccountTokenDeletedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.ServiceAccountTokenDeletedActivityLogEntry.ResourceType(childComplexity), true

	case "ServiceAccountTokenDeletedActivityLogEntry.teamSlug":
		if e.complexity.ServiceAccountTokenDeletedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.ServiceAccountTokenDeletedActivityLogEntry.TeamSlug(childComplexity), true

	case "ServiceAccountTokenDeletedActivityLogEntryData.tokenName":
		if e.complexity.ServiceAccountTokenDeletedActivityLogEntryData.TokenName == nil {
			break
		}

		return e.complexity.ServiceAccountTokenDeletedActivityLogEntryData.TokenName(childComplexity), true

	case "ServiceAccountTokenEdge.cursor":
		if e.complexity.ServiceAccountTokenEdge.Cursor == nil {
			break
		}

		return e.complexity.ServiceAccountTokenEdge.Cursor(childComplexity), true

	case "ServiceAccountTokenEdge.node":
		if e.complexity.ServiceAccountTokenEdge.Node == nil {
			break
		}

		return e.complexity.ServiceAccountTokenEdge.Node(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntry.actor":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.Actor(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntry.createdAt":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.CreatedAt(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntry.data":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.Data(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntry.environmentName":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntry.id":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.ID(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntry.message":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.Message(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntry.resourceName":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.ResourceName(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntry.resourceType":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.ResourceType(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntry.teamSlug":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntry.TeamSlug(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntryData.updatedFields":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntryData.UpdatedFields == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntryData.UpdatedFields(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField.field":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField.Field == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField.Field(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField.newValue":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField.NewValue == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField.NewValue(childComplexity), true

	case "ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField.oldValue":
		if e.complexity.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField.OldValue == nil {
			break
		}

		return e.complexity.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField.OldValue(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntry.actor":
		if e.complexity.ServiceAccountUpdatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntry.Actor(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntry.createdAt":
		if e.complexity.ServiceAccountUpdatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntry.CreatedAt(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntry.data":
		if e.complexity.ServiceAccountUpdatedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntry.Data(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntry.environmentName":
		if e.complexity.ServiceAccountUpdatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntry.id":
		if e.complexity.ServiceAccountUpdatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntry.ID(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntry.message":
		if e.complexity.ServiceAccountUpdatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntry.Message(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntry.resourceName":
		if e.complexity.ServiceAccountUpdatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntry.ResourceName(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntry.resourceType":
		if e.complexity.ServiceAccountUpdatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntry.ResourceType(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntry.teamSlug":
		if e.complexity.ServiceAccountUpdatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntry.TeamSlug(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntryData.updatedFields":
		if e.complexity.ServiceAccountUpdatedActivityLogEntryData.UpdatedFields == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntryData.UpdatedFields(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntryDataUpdatedField.field":
		if e.complexity.ServiceAccountUpdatedActivityLogEntryDataUpdatedField.Field == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntryDataUpdatedField.Field(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntryDataUpdatedField.newValue":
		if e.complexity.ServiceAccountUpdatedActivityLogEntryDataUpdatedField.NewValue == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntryDataUpdatedField.NewValue(childComplexity), true

	case "ServiceAccountUpdatedActivityLogEntryDataUpdatedField.oldValue":
		if e.complexity.ServiceAccountUpdatedActivityLogEntryDataUpdatedField.OldValue == nil {
			break
		}

		return e.complexity.ServiceAccountUpdatedActivityLogEntryDataUpdatedField.OldValue(childComplexity), true

	case "ServiceCostSample.cost":
		if e.complexity.ServiceCostSample.Cost == nil {
			break
		}

		return e.complexity.ServiceCostSample.Cost(childComplexity), true

	case "ServiceCostSample.service":
		if e.complexity.ServiceCostSample.Service == nil {
			break
		}

		return e.complexity.ServiceCostSample.Service(childComplexity), true

	case "ServiceCostSeries.date":
		if e.complexity.ServiceCostSeries.Date == nil {
			break
		}

		return e.complexity.ServiceCostSeries.Date(childComplexity), true

	case "ServiceCostSeries.services":
		if e.complexity.ServiceCostSeries.Services == nil {
			break
		}

		return e.complexity.ServiceCostSeries.Services(childComplexity), true

	case "ServiceCostSeries.sum":
		if e.complexity.ServiceCostSeries.Sum == nil {
			break
		}

		return e.complexity.ServiceCostSeries.Sum(childComplexity), true

	case "SetTeamMemberRolePayload.member":
		if e.complexity.SetTeamMemberRolePayload.Member == nil {
			break
		}

		return e.complexity.SetTeamMemberRolePayload.Member(childComplexity), true

	case "SqlDatabase.charset":
		if e.complexity.SqlDatabase.Charset == nil {
			break
		}

		return e.complexity.SqlDatabase.Charset(childComplexity), true

	case "SqlDatabase.collation":
		if e.complexity.SqlDatabase.Collation == nil {
			break
		}

		return e.complexity.SqlDatabase.Collation(childComplexity), true

	case "SqlDatabase.deletionPolicy":
		if e.complexity.SqlDatabase.DeletionPolicy == nil {
			break
		}

		return e.complexity.SqlDatabase.DeletionPolicy(childComplexity), true

	case "SqlDatabase.environment":
		if e.complexity.SqlDatabase.Environment == nil {
			break
		}

		return e.complexity.SqlDatabase.Environment(childComplexity), true

	case "SqlDatabase.healthy":
		if e.complexity.SqlDatabase.Healthy == nil {
			break
		}

		return e.complexity.SqlDatabase.Healthy(childComplexity), true

	case "SqlDatabase.id":
		if e.complexity.SqlDatabase.ID == nil {
			break
		}

		return e.complexity.SqlDatabase.ID(childComplexity), true

	case "SqlDatabase.name":
		if e.complexity.SqlDatabase.Name == nil {
			break
		}

		return e.complexity.SqlDatabase.Name(childComplexity), true

	case "SqlDatabase.team":
		if e.complexity.SqlDatabase.Team == nil {
			break
		}

		return e.complexity.SqlDatabase.Team(childComplexity), true

	case "SqlDatabase.teamEnvironment":
		if e.complexity.SqlDatabase.TeamEnvironment == nil {
			break
		}

		return e.complexity.SqlDatabase.TeamEnvironment(childComplexity), true

	case "SqlInstance.backupConfiguration":
		if e.complexity.SqlInstance.BackupConfiguration == nil {
			break
		}

		return e.complexity.SqlInstance.BackupConfiguration(childComplexity), true

	case "SqlInstance.cascadingDelete":
		if e.complexity.SqlInstance.CascadingDelete == nil {
			break
		}

		return e.complexity.SqlInstance.CascadingDelete(childComplexity), true

	case "SqlInstance.connectionName":
		if e.complexity.SqlInstance.ConnectionName == nil {
			break
		}

		return e.complexity.SqlInstance.ConnectionName(childComplexity), true

	case "SqlInstance.cost":
		if e.complexity.SqlInstance.Cost == nil {
			break
		}

		return e.complexity.SqlInstance.Cost(childComplexity), true

	case "SqlInstance.database":
		if e.complexity.SqlInstance.Database == nil {
			break
		}

		return e.complexity.SqlInstance.Database(childComplexity), true

	case "SqlInstance.diskAutoresize":
		if e.complexity.SqlInstance.DiskAutoresize == nil {
			break
		}

		return e.complexity.SqlInstance.DiskAutoresize(childComplexity), true

	case "SqlInstance.diskAutoresizeLimit":
		if e.complexity.SqlInstance.DiskAutoresizeLimit == nil {
			break
		}

		return e.complexity.SqlInstance.DiskAutoresizeLimit(childComplexity), true

	case "SqlInstance.environment":
		if e.complexity.SqlInstance.Environment == nil {
			break
		}

		return e.complexity.SqlInstance.Environment(childComplexity), true

	case "SqlInstance.flags":
		if e.complexity.SqlInstance.Flags == nil {
			break
		}

		args, err := ec.field_SqlInstance_flags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SqlInstance.Flags(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "SqlInstance.healthy":
		if e.complexity.SqlInstance.Healthy == nil {
			break
		}

		return e.complexity.SqlInstance.Healthy(childComplexity), true

	case "SqlInstance.highAvailability":
		if e.complexity.SqlInstance.HighAvailability == nil {
			break
		}

		return e.complexity.SqlInstance.HighAvailability(childComplexity), true

	case "SqlInstance.id":
		if e.complexity.SqlInstance.ID == nil {
			break
		}

		return e.complexity.SqlInstance.ID(childComplexity), true

	case "SqlInstance.maintenanceVersion":
		if e.complexity.SqlInstance.MaintenanceVersion == nil {
			break
		}

		return e.complexity.SqlInstance.MaintenanceVersion(childComplexity), true

	case "SqlInstance.maintenanceWindow":
		if e.complexity.SqlInstance.MaintenanceWindow == nil {
			break
		}

		return e.complexity.SqlInstance.MaintenanceWindow(childComplexity), true

	case "SqlInstance.metrics":
		if e.complexity.SqlInstance.Metrics == nil {
			break
		}

		return e.complexity.SqlInstance.Metrics(childComplexity), true

	case "SqlInstance.name":
		if e.complexity.SqlInstance.Name == nil {
			break
		}

		return e.complexity.SqlInstance.Name(childComplexity), true

	case "SqlInstance.projectID":
		if e.complexity.SqlInstance.ProjectID == nil {
			break
		}

		return e.complexity.SqlInstance.ProjectID(childComplexity), true

	case "SqlInstance.state":
		if e.complexity.SqlInstance.State == nil {
			break
		}

		return e.complexity.SqlInstance.State(childComplexity), true

	case "SqlInstance.status":
		if e.complexity.SqlInstance.Status == nil {
			break
		}

		return e.complexity.SqlInstance.Status(childComplexity), true

	case "SqlInstance.team":
		if e.complexity.SqlInstance.Team == nil {
			break
		}

		return e.complexity.SqlInstance.Team(childComplexity), true

	case "SqlInstance.teamEnvironment":
		if e.complexity.SqlInstance.TeamEnvironment == nil {
			break
		}

		return e.complexity.SqlInstance.TeamEnvironment(childComplexity), true

	case "SqlInstance.tier":
		if e.complexity.SqlInstance.Tier == nil {
			break
		}

		return e.complexity.SqlInstance.Tier(childComplexity), true

	case "SqlInstance.users":
		if e.complexity.SqlInstance.Users == nil {
			break
		}

		args, err := ec.field_SqlInstance_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SqlInstance.Users(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*sqlinstance.SQLInstanceUserOrder)), true

	case "SqlInstance.version":
		if e.complexity.SqlInstance.Version == nil {
			break
		}

		return e.complexity.SqlInstance.Version(childComplexity), true

	case "SqlInstance.workload":
		if e.complexity.SqlInstance.Workload == nil {
			break
		}

		return e.complexity.SqlInstance.Workload(childComplexity), true

	case "SqlInstanceBackupConfiguration.enabled":
		if e.complexity.SqlInstanceBackupConfiguration.Enabled == nil {
			break
		}

		return e.complexity.SqlInstanceBackupConfiguration.Enabled(childComplexity), true

	case "SqlInstanceBackupConfiguration.pointInTimeRecovery":
		if e.complexity.SqlInstanceBackupConfiguration.PointInTimeRecovery == nil {
			break
		}

		return e.complexity.SqlInstanceBackupConfiguration.PointInTimeRecovery(childComplexity), true

	case "SqlInstanceBackupConfiguration.retainedBackups":
		if e.complexity.SqlInstanceBackupConfiguration.RetainedBackups == nil {
			break
		}

		return e.complexity.SqlInstanceBackupConfiguration.RetainedBackups(childComplexity), true

	case "SqlInstanceBackupConfiguration.startTime":
		if e.complexity.SqlInstanceBackupConfiguration.StartTime == nil {
			break
		}

		return e.complexity.SqlInstanceBackupConfiguration.StartTime(childComplexity), true

	case "SqlInstanceBackupConfiguration.transactionLogRetentionDays":
		if e.complexity.SqlInstanceBackupConfiguration.TransactionLogRetentionDays == nil {
			break
		}

		return e.complexity.SqlInstanceBackupConfiguration.TransactionLogRetentionDays(childComplexity), true

	case "SqlInstanceConnection.edges":
		if e.complexity.SqlInstanceConnection.Edges == nil {
			break
		}

		return e.complexity.SqlInstanceConnection.Edges(childComplexity), true

	case "SqlInstanceConnection.nodes":
		if e.complexity.SqlInstanceConnection.Nodes == nil {
			break
		}

		return e.complexity.SqlInstanceConnection.Nodes(childComplexity), true

	case "SqlInstanceConnection.pageInfo":
		if e.complexity.SqlInstanceConnection.PageInfo == nil {
			break
		}

		return e.complexity.SqlInstanceConnection.PageInfo(childComplexity), true

	case "SqlInstanceCost.sum":
		if e.complexity.SqlInstanceCost.Sum == nil {
			break
		}

		return e.complexity.SqlInstanceCost.Sum(childComplexity), true

	case "SqlInstanceCpu.cores":
		if e.complexity.SqlInstanceCpu.Cores == nil {
			break
		}

		return e.complexity.SqlInstanceCpu.Cores(childComplexity), true

	case "SqlInstanceCpu.utilization":
		if e.complexity.SqlInstanceCpu.Utilization == nil {
			break
		}

		return e.complexity.SqlInstanceCpu.Utilization(childComplexity), true

	case "SqlInstanceDisk.quotaBytes":
		if e.complexity.SqlInstanceDisk.QuotaBytes == nil {
			break
		}

		return e.complexity.SqlInstanceDisk.QuotaBytes(childComplexity), true

	case "SqlInstanceDisk.utilization":
		if e.complexity.SqlInstanceDisk.Utilization == nil {
			break
		}

		return e.complexity.SqlInstanceDisk.Utilization(childComplexity), true

	case "SqlInstanceEdge.cursor":
		if e.complexity.SqlInstanceEdge.Cursor == nil {
			break
		}

		return e.complexity.SqlInstanceEdge.Cursor(childComplexity), true

	case "SqlInstanceEdge.node":
		if e.complexity.SqlInstanceEdge.Node == nil {
			break
		}

		return e.complexity.SqlInstanceEdge.Node(childComplexity), true

	case "SqlInstanceFlag.name":
		if e.complexity.SqlInstanceFlag.Name == nil {
			break
		}

		return e.complexity.SqlInstanceFlag.Name(childComplexity), true

	case "SqlInstanceFlag.value":
		if e.complexity.SqlInstanceFlag.Value == nil {
			break
		}

		return e.complexity.SqlInstanceFlag.Value(childComplexity), true

	case "SqlInstanceFlagConnection.edges":
		if e.complexity.SqlInstanceFlagConnection.Edges == nil {
			break
		}

		return e.complexity.SqlInstanceFlagConnection.Edges(childComplexity), true

	case "SqlInstanceFlagConnection.nodes":
		if e.complexity.SqlInstanceFlagConnection.Nodes == nil {
			break
		}

		return e.complexity.SqlInstanceFlagConnection.Nodes(childComplexity), true

	case "SqlInstanceFlagConnection.pageInfo":
		if e.complexity.SqlInstanceFlagConnection.PageInfo == nil {
			break
		}

		return e.complexity.SqlInstanceFlagConnection.PageInfo(childComplexity), true

	case "SqlInstanceFlagEdge.cursor":
		if e.complexity.SqlInstanceFlagEdge.Cursor == nil {
			break
		}

		return e.complexity.SqlInstanceFlagEdge.Cursor(childComplexity), true

	case "SqlInstanceFlagEdge.node":
		if e.complexity.SqlInstanceFlagEdge.Node == nil {
			break
		}

		return e.complexity.SqlInstanceFlagEdge.Node(childComplexity), true

	case "SqlInstanceMaintenanceWindow.day":
		if e.complexity.SqlInstanceMaintenanceWindow.Day == nil {
			break
		}

		return e.complexity.SqlInstanceMaintenanceWindow.Day(childComplexity), true

	case "SqlInstanceMaintenanceWindow.hour":
		if e.complexity.SqlInstanceMaintenanceWindow.Hour == nil {
			break
		}

		return e.complexity.SqlInstanceMaintenanceWindow.Hour(childComplexity), true

	case "SqlInstanceMemory.quotaBytes":
		if e.complexity.SqlInstanceMemory.QuotaBytes == nil {
			break
		}

		return e.complexity.SqlInstanceMemory.QuotaBytes(childComplexity), true

	case "SqlInstanceMemory.utilization":
		if e.complexity.SqlInstanceMemory.Utilization == nil {
			break
		}

		return e.complexity.SqlInstanceMemory.Utilization(childComplexity), true

	case "SqlInstanceMetrics.cpu":
		if e.complexity.SqlInstanceMetrics.CPU == nil {
			break
		}

		return e.complexity.SqlInstanceMetrics.CPU(childComplexity), true

	case "SqlInstanceMetrics.disk":
		if e.complexity.SqlInstanceMetrics.Disk == nil {
			break
		}

		return e.complexity.SqlInstanceMetrics.Disk(childComplexity), true

	case "SqlInstanceMetrics.memory":
		if e.complexity.SqlInstanceMetrics.Memory == nil {
			break
		}

		return e.complexity.SqlInstanceMetrics.Memory(childComplexity), true

	case "SqlInstanceStatus.privateIpAddress":
		if e.complexity.SqlInstanceStatus.PrivateIPAddress == nil {
			break
		}

		return e.complexity.SqlInstanceStatus.PrivateIPAddress(childComplexity), true

	case "SqlInstanceStatus.publicIpAddress":
		if e.complexity.SqlInstanceStatus.PublicIPAddress == nil {
			break
		}

		return e.complexity.SqlInstanceStatus.PublicIPAddress(childComplexity), true

	case "SqlInstanceUser.authentication":
		if e.complexity.SqlInstanceUser.Authentication == nil {
			break
		}

		return e.complexity.SqlInstanceUser.Authentication(childComplexity), true

	case "SqlInstanceUser.name":
		if e.complexity.SqlInstanceUser.Name == nil {
			break
		}

		return e.complexity.SqlInstanceUser.Name(childComplexity), true

	case "SqlInstanceUserConnection.edges":
		if e.complexity.SqlInstanceUserConnection.Edges == nil {
			break
		}

		return e.complexity.SqlInstanceUserConnection.Edges(childComplexity), true

	case "SqlInstanceUserConnection.nodes":
		if e.complexity.SqlInstanceUserConnection.Nodes == nil {
			break
		}

		return e.complexity.SqlInstanceUserConnection.Nodes(childComplexity), true

	case "SqlInstanceUserConnection.pageInfo":
		if e.complexity.SqlInstanceUserConnection.PageInfo == nil {
			break
		}

		return e.complexity.SqlInstanceUserConnection.PageInfo(childComplexity), true

	case "SqlInstanceUserEdge.cursor":
		if e.complexity.SqlInstanceUserEdge.Cursor == nil {
			break
		}

		return e.complexity.SqlInstanceUserEdge.Cursor(childComplexity), true

	case "SqlInstanceUserEdge.node":
		if e.complexity.SqlInstanceUserEdge.Node == nil {
			break
		}

		return e.complexity.SqlInstanceUserEdge.Node(childComplexity), true

	case "Subscription.workloadLog":
		if e.complexity.Subscription.WorkloadLog == nil {
			break
		}

		args, err := ec.field_Subscription_workloadLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.WorkloadLog(childComplexity, args["filter"].(podlog.WorkloadLogSubscriptionFilter)), true

	case "Team.activityLog":
		if e.complexity.Team.ActivityLog == nil {
			break
		}

		args, err := ec.field_Team_activityLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.ActivityLog(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Team.applications":
		if e.complexity.Team.Applications == nil {
			break
		}

		args, err := ec.field_Team_applications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Applications(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*application.ApplicationOrder), args["filter"].(*application.TeamApplicationsFilter)), true

	case "Team.bigQueryDatasets":
		if e.complexity.Team.BigQueryDatasets == nil {
			break
		}

		args, err := ec.field_Team_bigQueryDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.BigQueryDatasets(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*bigquery.BigQueryDatasetOrder)), true

	case "Team.buckets":
		if e.complexity.Team.Buckets == nil {
			break
		}

		args, err := ec.field_Team_buckets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Buckets(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*bucket.BucketOrder)), true

	case "Team.cost":
		if e.complexity.Team.Cost == nil {
			break
		}

		return e.complexity.Team.Cost(childComplexity), true

	case "Team.deleteKey":
		if e.complexity.Team.DeleteKey == nil {
			break
		}

		args, err := ec.field_Team_deleteKey_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.DeleteKey(childComplexity, args["key"].(string)), true

	case "Team.deletionInProgress":
		if e.complexity.Team.DeletionInProgress == nil {
			break
		}

		return e.complexity.Team.DeletionInProgress(childComplexity), true

	case "Team.deploymentKey":
		if e.complexity.Team.DeploymentKey == nil {
			break
		}

		return e.complexity.Team.DeploymentKey(childComplexity), true

	case "Team.deployments":
		if e.complexity.Team.Deployments == nil {
			break
		}

		args, err := ec.field_Team_deployments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Deployments(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "Team.environment":
		if e.complexity.Team.Environment == nil {
			break
		}

		args, err := ec.field_Team_environment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Environment(childComplexity, args["name"].(string)), true

	case "Team.environments":
		if e.complexity.Team.Environments == nil {
			break
		}

		return e.complexity.Team.Environments(childComplexity), true

	case "Team.externalResources":
		if e.complexity.Team.ExternalResources == nil {
			break
		}

		return e.complexity.Team.ExternalResources(childComplexity), true

	case "Team.id":
		if e.complexity.Team.ID == nil {
			break
		}

		return e.complexity.Team.ID(childComplexity), true

	case "Team.inventoryCounts":
		if e.complexity.Team.InventoryCounts == nil {
			break
		}

		return e.complexity.Team.InventoryCounts(childComplexity), true

	case "Team.jobs":
		if e.complexity.Team.Jobs == nil {
			break
		}

		args, err := ec.field_Team_jobs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Jobs(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*job.JobOrder), args["filter"].(*job.TeamJobsFilter)), true

	case "Team.kafkaTopics":
		if e.complexity.Team.KafkaTopics == nil {
			break
		}

		args, err := ec.field_Team_kafkaTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.KafkaTopics(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*kafkatopic.KafkaTopicOrder)), true

	case "Team.lastSuccessfulSync":
		if e.complexity.Team.LastSuccessfulSync == nil {
			break
		}

		return e.complexity.Team.LastSuccessfulSync(childComplexity), true

	case "Team.member":
		if e.complexity.Team.Member == nil {
			break
		}

		args, err := ec.field_Team_member_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Member(childComplexity, args["email"].(string)), true

	case "Team.members":
		if e.complexity.Team.Members == nil {
			break
		}

		args, err := ec.field_Team_members_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Members(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*team.TeamMemberOrder)), true

	case "Team.openSearchInstances":
		if e.complexity.Team.OpenSearchInstances == nil {
			break
		}

		args, err := ec.field_Team_openSearchInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.OpenSearchInstances(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*opensearch.OpenSearchOrder)), true

	case "Team.purpose":
		if e.complexity.Team.Purpose == nil {
			break
		}

		return e.complexity.Team.Purpose(childComplexity), true

	case "Team.redisInstances":
		if e.complexity.Team.RedisInstances == nil {
			break
		}

		args, err := ec.field_Team_redisInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.RedisInstances(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*redis.RedisInstanceOrder)), true

	case "Team.repositories":
		if e.complexity.Team.Repositories == nil {
			break
		}

		args, err := ec.field_Team_repositories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Repositories(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*repository.RepositoryOrder), args["filter"].(*repository.TeamRepositoryFilter)), true

	case "Team.sqlInstances":
		if e.complexity.Team.SQLInstances == nil {
			break
		}

		args, err := ec.field_Team_sqlInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.SQLInstances(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*sqlinstance.SQLInstanceOrder)), true

	case "Team.secrets":
		if e.complexity.Team.Secrets == nil {
			break
		}

		args, err := ec.field_Team_secrets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Secrets(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*secret.SecretOrder), args["filter"].(*secret.SecretFilter)), true

	case "Team.serviceUtilization":
		if e.complexity.Team.ServiceUtilization == nil {
			break
		}

		return e.complexity.Team.ServiceUtilization(childComplexity), true

	case "Team.slackChannel":
		if e.complexity.Team.SlackChannel == nil {
			break
		}

		return e.complexity.Team.SlackChannel(childComplexity), true

	case "Team.slug":
		if e.complexity.Team.Slug == nil {
			break
		}

		return e.complexity.Team.Slug(childComplexity), true

	case "Team.unleash":
		if e.complexity.Team.Unleash == nil {
			break
		}

		return e.complexity.Team.Unleash(childComplexity), true

	case "Team.valkeyInstances":
		if e.complexity.Team.ValkeyInstances == nil {
			break
		}

		args, err := ec.field_Team_valkeyInstances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.ValkeyInstances(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*valkey.ValkeyInstanceOrder)), true

	case "Team.viewerIsMember":
		if e.complexity.Team.ViewerIsMember == nil {
			break
		}

		return e.complexity.Team.ViewerIsMember(childComplexity), true

	case "Team.viewerIsOwner":
		if e.complexity.Team.ViewerIsOwner == nil {
			break
		}

		return e.complexity.Team.ViewerIsOwner(childComplexity), true

	case "Team.vulnerabilitySummary":
		if e.complexity.Team.VulnerabilitySummary == nil {
			break
		}

		args, err := ec.field_Team_vulnerabilitySummary_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.VulnerabilitySummary(childComplexity, args["filter"].(*vulnerability.TeamVulnerabilitySummaryFilter)), true

	case "Team.workloadUtilization":
		if e.complexity.Team.WorkloadUtilization == nil {
			break
		}

		args, err := ec.field_Team_workloadUtilization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.WorkloadUtilization(childComplexity, args["resourceType"].(utilization.UtilizationResourceType)), true

	case "Team.workloads":
		if e.complexity.Team.Workloads == nil {
			break
		}

		args, err := ec.field_Team_workloads_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Team.Workloads(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*workload.WorkloadOrder), args["filter"].(*workload.TeamWorkloadsFilter)), true

	case "TeamCDN.bucket":
		if e.complexity.TeamCDN.Bucket == nil {
			break
		}

		return e.complexity.TeamCDN.Bucket(childComplexity), true

	case "TeamConfirmDeleteKeyActivityLogEntry.actor":
		if e.complexity.TeamConfirmDeleteKeyActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyActivityLogEntry.Actor(childComplexity), true

	case "TeamConfirmDeleteKeyActivityLogEntry.createdAt":
		if e.complexity.TeamConfirmDeleteKeyActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyActivityLogEntry.CreatedAt(childComplexity), true

	case "TeamConfirmDeleteKeyActivityLogEntry.environmentName":
		if e.complexity.TeamConfirmDeleteKeyActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyActivityLogEntry.EnvironmentName(childComplexity), true

	case "TeamConfirmDeleteKeyActivityLogEntry.id":
		if e.complexity.TeamConfirmDeleteKeyActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyActivityLogEntry.ID(childComplexity), true

	case "TeamConfirmDeleteKeyActivityLogEntry.message":
		if e.complexity.TeamConfirmDeleteKeyActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyActivityLogEntry.Message(childComplexity), true

	case "TeamConfirmDeleteKeyActivityLogEntry.resourceName":
		if e.complexity.TeamConfirmDeleteKeyActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyActivityLogEntry.ResourceName(childComplexity), true

	case "TeamConfirmDeleteKeyActivityLogEntry.resourceType":
		if e.complexity.TeamConfirmDeleteKeyActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyActivityLogEntry.ResourceType(childComplexity), true

	case "TeamConfirmDeleteKeyActivityLogEntry.teamSlug":
		if e.complexity.TeamConfirmDeleteKeyActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamConfirmDeleteKeyActivityLogEntry.TeamSlug(childComplexity), true

	case "TeamConnection.edges":
		if e.complexity.TeamConnection.Edges == nil {
			break
		}

		return e.complexity.TeamConnection.Edges(childComplexity), true

	case "TeamConnection.nodes":
		if e.complexity.TeamConnection.Nodes == nil {
			break
		}

		return e.complexity.TeamConnection.Nodes(childComplexity), true

	case "TeamConnection.pageInfo":
		if e.complexity.TeamConnection.PageInfo == nil {
			break
		}

		return e.complexity.TeamConnection.PageInfo(childComplexity), true

	case "TeamCost.daily":
		if e.complexity.TeamCost.Daily == nil {
			break
		}

		args, err := ec.field_TeamCost_daily_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamCost.Daily(childComplexity, args["from"].(scalar.Date), args["to"].(scalar.Date), args["filter"].(*cost.TeamCostDailyFilter)), true

	case "TeamCost.monthlySummary":
		if e.complexity.TeamCost.MonthlySummary == nil {
			break
		}

		return e.complexity.TeamCost.MonthlySummary(childComplexity), true

	case "TeamCostMonthlySample.cost":
		if e.complexity.TeamCostMonthlySample.Cost == nil {
			break
		}

		return e.complexity.TeamCostMonthlySample.Cost(childComplexity), true

	case "TeamCostMonthlySample.date":
		if e.complexity.TeamCostMonthlySample.Date == nil {
			break
		}

		return e.complexity.TeamCostMonthlySample.Date(childComplexity), true

	case "TeamCostMonthlySummary.series":
		if e.complexity.TeamCostMonthlySummary.Series == nil {
			break
		}

		return e.complexity.TeamCostMonthlySummary.Series(childComplexity), true

	case "TeamCostMonthlySummary.sum":
		if e.complexity.TeamCostMonthlySummary.Sum == nil {
			break
		}

		return e.complexity.TeamCostMonthlySummary.Sum(childComplexity), true

	case "TeamCostPeriod.series":
		if e.complexity.TeamCostPeriod.Series == nil {
			break
		}

		return e.complexity.TeamCostPeriod.Series(childComplexity), true

	case "TeamCostPeriod.sum":
		if e.complexity.TeamCostPeriod.Sum == nil {
			break
		}

		return e.complexity.TeamCostPeriod.Sum(childComplexity), true

	case "TeamCreateDeleteKeyActivityLogEntry.actor":
		if e.complexity.TeamCreateDeleteKeyActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyActivityLogEntry.Actor(childComplexity), true

	case "TeamCreateDeleteKeyActivityLogEntry.createdAt":
		if e.complexity.TeamCreateDeleteKeyActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyActivityLogEntry.CreatedAt(childComplexity), true

	case "TeamCreateDeleteKeyActivityLogEntry.environmentName":
		if e.complexity.TeamCreateDeleteKeyActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyActivityLogEntry.EnvironmentName(childComplexity), true

	case "TeamCreateDeleteKeyActivityLogEntry.id":
		if e.complexity.TeamCreateDeleteKeyActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyActivityLogEntry.ID(childComplexity), true

	case "TeamCreateDeleteKeyActivityLogEntry.message":
		if e.complexity.TeamCreateDeleteKeyActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyActivityLogEntry.Message(childComplexity), true

	case "TeamCreateDeleteKeyActivityLogEntry.resourceName":
		if e.complexity.TeamCreateDeleteKeyActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyActivityLogEntry.ResourceName(childComplexity), true

	case "TeamCreateDeleteKeyActivityLogEntry.resourceType":
		if e.complexity.TeamCreateDeleteKeyActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyActivityLogEntry.ResourceType(childComplexity), true

	case "TeamCreateDeleteKeyActivityLogEntry.teamSlug":
		if e.complexity.TeamCreateDeleteKeyActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamCreateDeleteKeyActivityLogEntry.TeamSlug(childComplexity), true

	case "TeamCreatedActivityLogEntry.actor":
		if e.complexity.TeamCreatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.TeamCreatedActivityLogEntry.Actor(childComplexity), true

	case "TeamCreatedActivityLogEntry.createdAt":
		if e.complexity.TeamCreatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamCreatedActivityLogEntry.CreatedAt(childComplexity), true

	case "TeamCreatedActivityLogEntry.environmentName":
		if e.complexity.TeamCreatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamCreatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "TeamCreatedActivityLogEntry.id":
		if e.complexity.TeamCreatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.TeamCreatedActivityLogEntry.ID(childComplexity), true

	case "TeamCreatedActivityLogEntry.message":
		if e.complexity.TeamCreatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.TeamCreatedActivityLogEntry.Message(childComplexity), true

	case "TeamCreatedActivityLogEntry.resourceName":
		if e.complexity.TeamCreatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamCreatedActivityLogEntry.ResourceName(childComplexity), true

	case "TeamCreatedActivityLogEntry.resourceType":
		if e.complexity.TeamCreatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamCreatedActivityLogEntry.ResourceType(childComplexity), true

	case "TeamCreatedActivityLogEntry.teamSlug":
		if e.complexity.TeamCreatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamCreatedActivityLogEntry.TeamSlug(childComplexity), true

	case "TeamDeleteKey.createdAt":
		if e.complexity.TeamDeleteKey.CreatedAt == nil {
			break
		}

		return e.complexity.TeamDeleteKey.CreatedAt(childComplexity), true

	case "TeamDeleteKey.createdBy":
		if e.complexity.TeamDeleteKey.CreatedBy == nil {
			break
		}

		return e.complexity.TeamDeleteKey.CreatedBy(childComplexity), true

	case "TeamDeleteKey.expires":
		if e.complexity.TeamDeleteKey.Expires == nil {
			break
		}

		return e.complexity.TeamDeleteKey.Expires(childComplexity), true

	case "TeamDeleteKey.key":
		if e.complexity.TeamDeleteKey.Key == nil {
			break
		}

		return e.complexity.TeamDeleteKey.Key(childComplexity), true

	case "TeamDeleteKey.team":
		if e.complexity.TeamDeleteKey.Team == nil {
			break
		}

		return e.complexity.TeamDeleteKey.Team(childComplexity), true

	case "TeamDeployKeyUpdatedActivityLogEntry.actor":
		if e.complexity.TeamDeployKeyUpdatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.TeamDeployKeyUpdatedActivityLogEntry.Actor(childComplexity), true

	case "TeamDeployKeyUpdatedActivityLogEntry.createdAt":
		if e.complexity.TeamDeployKeyUpdatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamDeployKeyUpdatedActivityLogEntry.CreatedAt(childComplexity), true

	case "TeamDeployKeyUpdatedActivityLogEntry.environmentName":
		if e.complexity.TeamDeployKeyUpdatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamDeployKeyUpdatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "TeamDeployKeyUpdatedActivityLogEntry.id":
		if e.complexity.TeamDeployKeyUpdatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.TeamDeployKeyUpdatedActivityLogEntry.ID(childComplexity), true

	case "TeamDeployKeyUpdatedActivityLogEntry.message":
		if e.complexity.TeamDeployKeyUpdatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.TeamDeployKeyUpdatedActivityLogEntry.Message(childComplexity), true

	case "TeamDeployKeyUpdatedActivityLogEntry.resourceName":
		if e.complexity.TeamDeployKeyUpdatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamDeployKeyUpdatedActivityLogEntry.ResourceName(childComplexity), true

	case "TeamDeployKeyUpdatedActivityLogEntry.resourceType":
		if e.complexity.TeamDeployKeyUpdatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamDeployKeyUpdatedActivityLogEntry.ResourceType(childComplexity), true

	case "TeamDeployKeyUpdatedActivityLogEntry.teamSlug":
		if e.complexity.TeamDeployKeyUpdatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamDeployKeyUpdatedActivityLogEntry.TeamSlug(childComplexity), true

	case "TeamEdge.cursor":
		if e.complexity.TeamEdge.Cursor == nil {
			break
		}

		return e.complexity.TeamEdge.Cursor(childComplexity), true

	case "TeamEdge.node":
		if e.complexity.TeamEdge.Node == nil {
			break
		}

		return e.complexity.TeamEdge.Node(childComplexity), true

	case "TeamEntraIDGroup.groupID":
		if e.complexity.TeamEntraIDGroup.GroupID == nil {
			break
		}

		return e.complexity.TeamEntraIDGroup.GroupID(childComplexity), true

	case "TeamEnvironment.application":
		if e.complexity.TeamEnvironment.Application == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_application_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.Application(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.bigQueryDataset":
		if e.complexity.TeamEnvironment.BigQueryDataset == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_bigQueryDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.BigQueryDataset(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.bucket":
		if e.complexity.TeamEnvironment.Bucket == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_bucket_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.Bucket(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.cost":
		if e.complexity.TeamEnvironment.Cost == nil {
			break
		}

		return e.complexity.TeamEnvironment.Cost(childComplexity), true

	case "TeamEnvironment.environment":
		if e.complexity.TeamEnvironment.Environment == nil {
			break
		}

		return e.complexity.TeamEnvironment.Environment(childComplexity), true

	case "TeamEnvironment.gcpProjectID":
		if e.complexity.TeamEnvironment.GCPProjectID == nil {
			break
		}

		return e.complexity.TeamEnvironment.GCPProjectID(childComplexity), true

	case "TeamEnvironment.id":
		if e.complexity.TeamEnvironment.ID == nil {
			break
		}

		return e.complexity.TeamEnvironment.ID(childComplexity), true

	case "TeamEnvironment.job":
		if e.complexity.TeamEnvironment.Job == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_job_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.Job(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.kafkaTopic":
		if e.complexity.TeamEnvironment.KafkaTopic == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_kafkaTopic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.KafkaTopic(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.name":
		if e.complexity.TeamEnvironment.Name == nil {
			break
		}

		return e.complexity.TeamEnvironment.Name(childComplexity), true

	case "TeamEnvironment.openSearchInstance":
		if e.complexity.TeamEnvironment.OpenSearchInstance == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_openSearchInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.OpenSearchInstance(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.redisInstance":
		if e.complexity.TeamEnvironment.RedisInstance == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_redisInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.RedisInstance(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.sqlInstance":
		if e.complexity.TeamEnvironment.SQLInstance == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_sqlInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.SQLInstance(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.secret":
		if e.complexity.TeamEnvironment.Secret == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_secret_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.Secret(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.slackAlertsChannel":
		if e.complexity.TeamEnvironment.SlackAlertsChannel == nil {
			break
		}

		return e.complexity.TeamEnvironment.SlackAlertsChannel(childComplexity), true

	case "TeamEnvironment.team":
		if e.complexity.TeamEnvironment.Team == nil {
			break
		}

		return e.complexity.TeamEnvironment.Team(childComplexity), true

	case "TeamEnvironment.valkeyInstance":
		if e.complexity.TeamEnvironment.ValkeyInstance == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_valkeyInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.ValkeyInstance(childComplexity, args["name"].(string)), true

	case "TeamEnvironment.workload":
		if e.complexity.TeamEnvironment.Workload == nil {
			break
		}

		args, err := ec.field_TeamEnvironment_workload_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironment.Workload(childComplexity, args["name"].(string)), true

	case "TeamEnvironmentCost.daily":
		if e.complexity.TeamEnvironmentCost.Daily == nil {
			break
		}

		args, err := ec.field_TeamEnvironmentCost_daily_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TeamEnvironmentCost.Daily(childComplexity, args["from"].(scalar.Date), args["to"].(scalar.Date)), true

	case "TeamEnvironmentCostPeriod.series":
		if e.complexity.TeamEnvironmentCostPeriod.Series == nil {
			break
		}

		return e.complexity.TeamEnvironmentCostPeriod.Series(childComplexity), true

	case "TeamEnvironmentCostPeriod.sum":
		if e.complexity.TeamEnvironmentCostPeriod.Sum == nil {
			break
		}

		return e.complexity.TeamEnvironmentCostPeriod.Sum(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntry.actor":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntry.Actor(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntry.createdAt":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntry.CreatedAt(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntry.data":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntry.Data(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntry.environmentName":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntry.id":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntry.ID(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntry.message":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntry.Message(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntry.resourceName":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntry.ResourceName(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntry.resourceType":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntry.ResourceType(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntry.teamSlug":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntry.TeamSlug(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntryData.updatedFields":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntryData.UpdatedFields == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntryData.UpdatedFields(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField.field":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField.Field == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField.Field(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField.newValue":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField.NewValue == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField.NewValue(childComplexity), true

	case "TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField.oldValue":
		if e.complexity.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField.OldValue == nil {
			break
		}

		return e.complexity.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField.OldValue(childComplexity), true

	case "TeamExternalResources.cdn":
		if e.complexity.TeamExternalResources.CDN == nil {
			break
		}

		return e.complexity.TeamExternalResources.CDN(childComplexity), true

	case "TeamExternalResources.entraIDGroup":
		if e.complexity.TeamExternalResources.EntraIDGroup == nil {
			break
		}

		return e.complexity.TeamExternalResources.EntraIDGroup(childComplexity), true

	case "TeamExternalResources.gitHubTeam":
		if e.complexity.TeamExternalResources.GitHubTeam == nil {
			break
		}

		return e.complexity.TeamExternalResources.GitHubTeam(childComplexity), true

	case "TeamExternalResources.googleArtifactRegistry":
		if e.complexity.TeamExternalResources.GoogleArtifactRegistry == nil {
			break
		}

		return e.complexity.TeamExternalResources.GoogleArtifactRegistry(childComplexity), true

	case "TeamExternalResources.googleGroup":
		if e.complexity.TeamExternalResources.GoogleGroup == nil {
			break
		}

		return e.complexity.TeamExternalResources.GoogleGroup(childComplexity), true

	case "TeamGitHubTeam.slug":
		if e.complexity.TeamGitHubTeam.Slug == nil {
			break
		}

		return e.complexity.TeamGitHubTeam.Slug(childComplexity), true

	case "TeamGoogleArtifactRegistry.repository":
		if e.complexity.TeamGoogleArtifactRegistry.Repository == nil {
			break
		}

		return e.complexity.TeamGoogleArtifactRegistry.Repository(childComplexity), true

	case "TeamGoogleGroup.email":
		if e.complexity.TeamGoogleGroup.Email == nil {
			break
		}

		return e.complexity.TeamGoogleGroup.Email(childComplexity), true

	case "TeamInventoryCountApplications.notNais":
		if e.complexity.TeamInventoryCountApplications.NotNais == nil {
			break
		}

		return e.complexity.TeamInventoryCountApplications.NotNais(childComplexity), true

	case "TeamInventoryCountApplications.total":
		if e.complexity.TeamInventoryCountApplications.Total == nil {
			break
		}

		return e.complexity.TeamInventoryCountApplications.Total(childComplexity), true

	case "TeamInventoryCountBigQueryDatasets.total":
		if e.complexity.TeamInventoryCountBigQueryDatasets.Total == nil {
			break
		}

		return e.complexity.TeamInventoryCountBigQueryDatasets.Total(childComplexity), true

	case "TeamInventoryCountBuckets.total":
		if e.complexity.TeamInventoryCountBuckets.Total == nil {
			break
		}

		return e.complexity.TeamInventoryCountBuckets.Total(childComplexity), true

	case "TeamInventoryCountJobs.notNais":
		if e.complexity.TeamInventoryCountJobs.NotNais == nil {
			break
		}

		return e.complexity.TeamInventoryCountJobs.NotNais(childComplexity), true

	case "TeamInventoryCountJobs.total":
		if e.complexity.TeamInventoryCountJobs.Total == nil {
			break
		}

		return e.complexity.TeamInventoryCountJobs.Total(childComplexity), true

	case "TeamInventoryCountKafkaTopics.total":
		if e.complexity.TeamInventoryCountKafkaTopics.Total == nil {
			break
		}

		return e.complexity.TeamInventoryCountKafkaTopics.Total(childComplexity), true

	case "TeamInventoryCountOpenSearchInstances.total":
		if e.complexity.TeamInventoryCountOpenSearchInstances.Total == nil {
			break
		}

		return e.complexity.TeamInventoryCountOpenSearchInstances.Total(childComplexity), true

	case "TeamInventoryCountRedisInstances.total":
		if e.complexity.TeamInventoryCountRedisInstances.Total == nil {
			break
		}

		return e.complexity.TeamInventoryCountRedisInstances.Total(childComplexity), true

	case "TeamInventoryCountSqlInstances.total":
		if e.complexity.TeamInventoryCountSqlInstances.Total == nil {
			break
		}

		return e.complexity.TeamInventoryCountSqlInstances.Total(childComplexity), true

	case "TeamInventoryCountValkeyInstances.total":
		if e.complexity.TeamInventoryCountValkeyInstances.Total == nil {
			break
		}

		return e.complexity.TeamInventoryCountValkeyInstances.Total(childComplexity), true

	case "TeamInventoryCounts.applications":
		if e.complexity.TeamInventoryCounts.Applications == nil {
			break
		}

		return e.complexity.TeamInventoryCounts.Applications(childComplexity), true

	case "TeamInventoryCounts.bigQueryDatasets":
		if e.complexity.TeamInventoryCounts.BigQueryDatasets == nil {
			break
		}

		return e.complexity.TeamInventoryCounts.BigQueryDatasets(childComplexity), true

	case "TeamInventoryCounts.buckets":
		if e.complexity.TeamInventoryCounts.Buckets == nil {
			break
		}

		return e.complexity.TeamInventoryCounts.Buckets(childComplexity), true

	case "TeamInventoryCounts.jobs":
		if e.complexity.TeamInventoryCounts.Jobs == nil {
			break
		}

		return e.complexity.TeamInventoryCounts.Jobs(childComplexity), true

	case "TeamInventoryCounts.kafkaTopics":
		if e.complexity.TeamInventoryCounts.KafkaTopics == nil {
			break
		}

		return e.complexity.TeamInventoryCounts.KafkaTopics(childComplexity), true

	case "TeamInventoryCounts.openSearchInstances":
		if e.complexity.TeamInventoryCounts.OpenSearchInstances == nil {
			break
		}

		return e.complexity.TeamInventoryCounts.OpenSearchInstances(childComplexity), true

	case "TeamInventoryCounts.redisInstances":
		if e.complexity.TeamInventoryCounts.RedisInstances == nil {
			break
		}

		return e.complexity.TeamInventoryCounts.RedisInstances(childComplexity), true

	case "TeamInventoryCounts.sqlInstances":
		if e.complexity.TeamInventoryCounts.SQLInstances == nil {
			break
		}

		return e.complexity.TeamInventoryCounts.SQLInstances(childComplexity), true

	case "TeamInventoryCounts.valkeyInstances":
		if e.complexity.TeamInventoryCounts.ValkeyInstances == nil {
			break
		}

		return e.complexity.TeamInventoryCounts.ValkeyInstances(childComplexity), true

	case "TeamMember.role":
		if e.complexity.TeamMember.Role == nil {
			break
		}

		return e.complexity.TeamMember.Role(childComplexity), true

	case "TeamMember.team":
		if e.complexity.TeamMember.Team == nil {
			break
		}

		return e.complexity.TeamMember.Team(childComplexity), true

	case "TeamMember.user":
		if e.complexity.TeamMember.User == nil {
			break
		}

		return e.complexity.TeamMember.User(childComplexity), true

	case "TeamMemberAddedActivityLogEntry.actor":
		if e.complexity.TeamMemberAddedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntry.Actor(childComplexity), true

	case "TeamMemberAddedActivityLogEntry.createdAt":
		if e.complexity.TeamMemberAddedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntry.CreatedAt(childComplexity), true

	case "TeamMemberAddedActivityLogEntry.data":
		if e.complexity.TeamMemberAddedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntry.Data(childComplexity), true

	case "TeamMemberAddedActivityLogEntry.environmentName":
		if e.complexity.TeamMemberAddedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntry.EnvironmentName(childComplexity), true

	case "TeamMemberAddedActivityLogEntry.id":
		if e.complexity.TeamMemberAddedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntry.ID(childComplexity), true

	case "TeamMemberAddedActivityLogEntry.message":
		if e.complexity.TeamMemberAddedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntry.Message(childComplexity), true

	case "TeamMemberAddedActivityLogEntry.resourceName":
		if e.complexity.TeamMemberAddedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntry.ResourceName(childComplexity), true

	case "TeamMemberAddedActivityLogEntry.resourceType":
		if e.complexity.TeamMemberAddedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntry.ResourceType(childComplexity), true

	case "TeamMemberAddedActivityLogEntry.teamSlug":
		if e.complexity.TeamMemberAddedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntry.TeamSlug(childComplexity), true

	case "TeamMemberAddedActivityLogEntryData.role":
		if e.complexity.TeamMemberAddedActivityLogEntryData.Role == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntryData.Role(childComplexity), true

	case "TeamMemberAddedActivityLogEntryData.userEmail":
		if e.complexity.TeamMemberAddedActivityLogEntryData.UserEmail == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntryData.UserEmail(childComplexity), true

	case "TeamMemberAddedActivityLogEntryData.userID":
		if e.complexity.TeamMemberAddedActivityLogEntryData.UserID == nil {
			break
		}

		return e.complexity.TeamMemberAddedActivityLogEntryData.UserID(childComplexity), true

	case "TeamMemberConnection.edges":
		if e.complexity.TeamMemberConnection.Edges == nil {
			break
		}

		return e.complexity.TeamMemberConnection.Edges(childComplexity), true

	case "TeamMemberConnection.nodes":
		if e.complexity.TeamMemberConnection.Nodes == nil {
			break
		}

		return e.complexity.TeamMemberConnection.Nodes(childComplexity), true

	case "TeamMemberConnection.pageInfo":
		if e.complexity.TeamMemberConnection.PageInfo == nil {
			break
		}

		return e.complexity.TeamMemberConnection.PageInfo(childComplexity), true

	case "TeamMemberEdge.cursor":
		if e.complexity.TeamMemberEdge.Cursor == nil {
			break
		}

		return e.complexity.TeamMemberEdge.Cursor(childComplexity), true

	case "TeamMemberEdge.node":
		if e.complexity.TeamMemberEdge.Node == nil {
			break
		}

		return e.complexity.TeamMemberEdge.Node(childComplexity), true

	case "TeamMemberRemovedActivityLogEntry.actor":
		if e.complexity.TeamMemberRemovedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.TeamMemberRemovedActivityLogEntry.Actor(childComplexity), true

	case "TeamMemberRemovedActivityLogEntry.createdAt":
		if e.complexity.TeamMemberRemovedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamMemberRemovedActivityLogEntry.CreatedAt(childComplexity), true

	case "TeamMemberRemovedActivityLogEntry.data":
		if e.complexity.TeamMemberRemovedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.TeamMemberRemovedActivityLogEntry.Data(childComplexity), true

	case "TeamMemberRemovedActivityLogEntry.environmentName":
		if e.complexity.TeamMemberRemovedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamMemberRemovedActivityLogEntry.EnvironmentName(childComplexity), true

	case "TeamMemberRemovedActivityLogEntry.id":
		if e.complexity.TeamMemberRemovedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.TeamMemberRemovedActivityLogEntry.ID(childComplexity), true

	case "TeamMemberRemovedActivityLogEntry.message":
		if e.complexity.TeamMemberRemovedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.TeamMemberRemovedActivityLogEntry.Message(childComplexity), true

	case "TeamMemberRemovedActivityLogEntry.resourceName":
		if e.complexity.TeamMemberRemovedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamMemberRemovedActivityLogEntry.ResourceName(childComplexity), true

	case "TeamMemberRemovedActivityLogEntry.resourceType":
		if e.complexity.TeamMemberRemovedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamMemberRemovedActivityLogEntry.ResourceType(childComplexity), true

	case "TeamMemberRemovedActivityLogEntry.teamSlug":
		if e.complexity.TeamMemberRemovedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamMemberRemovedActivityLogEntry.TeamSlug(childComplexity), true

	case "TeamMemberRemovedActivityLogEntryData.userEmail":
		if e.complexity.TeamMemberRemovedActivityLogEntryData.UserEmail == nil {
			break
		}

		return e.complexity.TeamMemberRemovedActivityLogEntryData.UserEmail(childComplexity), true

	case "TeamMemberRemovedActivityLogEntryData.userID":
		if e.complexity.TeamMemberRemovedActivityLogEntryData.UserID == nil {
			break
		}

		return e.complexity.TeamMemberRemovedActivityLogEntryData.UserID(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntry.actor":
		if e.complexity.TeamMemberSetRoleActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntry.Actor(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntry.createdAt":
		if e.complexity.TeamMemberSetRoleActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntry.CreatedAt(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntry.data":
		if e.complexity.TeamMemberSetRoleActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntry.Data(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntry.environmentName":
		if e.complexity.TeamMemberSetRoleActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntry.EnvironmentName(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntry.id":
		if e.complexity.TeamMemberSetRoleActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntry.ID(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntry.message":
		if e.complexity.TeamMemberSetRoleActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntry.Message(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntry.resourceName":
		if e.complexity.TeamMemberSetRoleActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntry.ResourceName(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntry.resourceType":
		if e.complexity.TeamMemberSetRoleActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntry.ResourceType(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntry.teamSlug":
		if e.complexity.TeamMemberSetRoleActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntry.TeamSlug(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntryData.role":
		if e.complexity.TeamMemberSetRoleActivityLogEntryData.Role == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntryData.Role(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntryData.userEmail":
		if e.complexity.TeamMemberSetRoleActivityLogEntryData.UserEmail == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntryData.UserEmail(childComplexity), true

	case "TeamMemberSetRoleActivityLogEntryData.userID":
		if e.complexity.TeamMemberSetRoleActivityLogEntryData.UserID == nil {
			break
		}

		return e.complexity.TeamMemberSetRoleActivityLogEntryData.UserID(childComplexity), true

	case "TeamServiceUtilization.sqlInstances":
		if e.complexity.TeamServiceUtilization.SQLInstances == nil {
			break
		}

		return e.complexity.TeamServiceUtilization.SQLInstances(childComplexity), true

	case "TeamServiceUtilizationSqlInstances.cpu":
		if e.complexity.TeamServiceUtilizationSqlInstances.CPU == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstances.CPU(childComplexity), true

	case "TeamServiceUtilizationSqlInstances.disk":
		if e.complexity.TeamServiceUtilizationSqlInstances.Disk == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstances.Disk(childComplexity), true

	case "TeamServiceUtilizationSqlInstances.memory":
		if e.complexity.TeamServiceUtilizationSqlInstances.Memory == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstances.Memory(childComplexity), true

	case "TeamServiceUtilizationSqlInstancesCPU.requested":
		if e.complexity.TeamServiceUtilizationSqlInstancesCPU.Requested == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstancesCPU.Requested(childComplexity), true

	case "TeamServiceUtilizationSqlInstancesCPU.used":
		if e.complexity.TeamServiceUtilizationSqlInstancesCPU.Used == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstancesCPU.Used(childComplexity), true

	case "TeamServiceUtilizationSqlInstancesCPU.utilization":
		if e.complexity.TeamServiceUtilizationSqlInstancesCPU.Utilization == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstancesCPU.Utilization(childComplexity), true

	case "TeamServiceUtilizationSqlInstancesDisk.requested":
		if e.complexity.TeamServiceUtilizationSqlInstancesDisk.Requested == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstancesDisk.Requested(childComplexity), true

	case "TeamServiceUtilizationSqlInstancesDisk.used":
		if e.complexity.TeamServiceUtilizationSqlInstancesDisk.Used == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstancesDisk.Used(childComplexity), true

	case "TeamServiceUtilizationSqlInstancesDisk.utilization":
		if e.complexity.TeamServiceUtilizationSqlInstancesDisk.Utilization == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstancesDisk.Utilization(childComplexity), true

	case "TeamServiceUtilizationSqlInstancesMemory.requested":
		if e.complexity.TeamServiceUtilizationSqlInstancesMemory.Requested == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstancesMemory.Requested(childComplexity), true

	case "TeamServiceUtilizationSqlInstancesMemory.used":
		if e.complexity.TeamServiceUtilizationSqlInstancesMemory.Used == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstancesMemory.Used(childComplexity), true

	case "TeamServiceUtilizationSqlInstancesMemory.utilization":
		if e.complexity.TeamServiceUtilizationSqlInstancesMemory.Utilization == nil {
			break
		}

		return e.complexity.TeamServiceUtilizationSqlInstancesMemory.Utilization(childComplexity), true

	case "TeamUpdatedActivityLogEntry.actor":
		if e.complexity.TeamUpdatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntry.Actor(childComplexity), true

	case "TeamUpdatedActivityLogEntry.createdAt":
		if e.complexity.TeamUpdatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntry.CreatedAt(childComplexity), true

	case "TeamUpdatedActivityLogEntry.data":
		if e.complexity.TeamUpdatedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntry.Data(childComplexity), true

	case "TeamUpdatedActivityLogEntry.environmentName":
		if e.complexity.TeamUpdatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "TeamUpdatedActivityLogEntry.id":
		if e.complexity.TeamUpdatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntry.ID(childComplexity), true

	case "TeamUpdatedActivityLogEntry.message":
		if e.complexity.TeamUpdatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntry.Message(childComplexity), true

	case "TeamUpdatedActivityLogEntry.resourceName":
		if e.complexity.TeamUpdatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntry.ResourceName(childComplexity), true

	case "TeamUpdatedActivityLogEntry.resourceType":
		if e.complexity.TeamUpdatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntry.ResourceType(childComplexity), true

	case "TeamUpdatedActivityLogEntry.teamSlug":
		if e.complexity.TeamUpdatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntry.TeamSlug(childComplexity), true

	case "TeamUpdatedActivityLogEntryData.updatedFields":
		if e.complexity.TeamUpdatedActivityLogEntryData.UpdatedFields == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntryData.UpdatedFields(childComplexity), true

	case "TeamUpdatedActivityLogEntryDataUpdatedField.field":
		if e.complexity.TeamUpdatedActivityLogEntryDataUpdatedField.Field == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntryDataUpdatedField.Field(childComplexity), true

	case "TeamUpdatedActivityLogEntryDataUpdatedField.newValue":
		if e.complexity.TeamUpdatedActivityLogEntryDataUpdatedField.NewValue == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntryDataUpdatedField.NewValue(childComplexity), true

	case "TeamUpdatedActivityLogEntryDataUpdatedField.oldValue":
		if e.complexity.TeamUpdatedActivityLogEntryDataUpdatedField.OldValue == nil {
			break
		}

		return e.complexity.TeamUpdatedActivityLogEntryDataUpdatedField.OldValue(childComplexity), true

	case "TeamUtilizationData.environment":
		if e.complexity.TeamUtilizationData.Environment == nil {
			break
		}

		return e.complexity.TeamUtilizationData.Environment(childComplexity), true

	case "TeamUtilizationData.requested":
		if e.complexity.TeamUtilizationData.Requested == nil {
			break
		}

		return e.complexity.TeamUtilizationData.Requested(childComplexity), true

	case "TeamUtilizationData.team":
		if e.complexity.TeamUtilizationData.Team == nil {
			break
		}

		return e.complexity.TeamUtilizationData.Team(childComplexity), true

	case "TeamUtilizationData.teamEnvironment":
		if e.complexity.TeamUtilizationData.TeamEnvironment == nil {
			break
		}

		return e.complexity.TeamUtilizationData.TeamEnvironment(childComplexity), true

	case "TeamUtilizationData.used":
		if e.complexity.TeamUtilizationData.Used == nil {
			break
		}

		return e.complexity.TeamUtilizationData.Used(childComplexity), true

	case "TeamVulnerabilityStatus.description":
		if e.complexity.TeamVulnerabilityStatus.Description == nil {
			break
		}

		return e.complexity.TeamVulnerabilityStatus.Description(childComplexity), true

	case "TeamVulnerabilityStatus.state":
		if e.complexity.TeamVulnerabilityStatus.State == nil {
			break
		}

		return e.complexity.TeamVulnerabilityStatus.State(childComplexity), true

	case "TeamVulnerabilityStatus.title":
		if e.complexity.TeamVulnerabilityStatus.Title == nil {
			break
		}

		return e.complexity.TeamVulnerabilityStatus.Title(childComplexity), true

	case "TeamVulnerabilitySummary.bomCount":
		if e.complexity.TeamVulnerabilitySummary.BomCount == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.BomCount(childComplexity), true

	case "TeamVulnerabilitySummary.coverage":
		if e.complexity.TeamVulnerabilitySummary.Coverage == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Coverage(childComplexity), true

	case "TeamVulnerabilitySummary.critical":
		if e.complexity.TeamVulnerabilitySummary.Critical == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Critical(childComplexity), true

	case "TeamVulnerabilitySummary.high":
		if e.complexity.TeamVulnerabilitySummary.High == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.High(childComplexity), true

	case "TeamVulnerabilitySummary.low":
		if e.complexity.TeamVulnerabilitySummary.Low == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Low(childComplexity), true

	case "TeamVulnerabilitySummary.medium":
		if e.complexity.TeamVulnerabilitySummary.Medium == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Medium(childComplexity), true

	case "TeamVulnerabilitySummary.ranking":
		if e.complexity.TeamVulnerabilitySummary.Ranking == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Ranking(childComplexity), true

	case "TeamVulnerabilitySummary.riskScore":
		if e.complexity.TeamVulnerabilitySummary.RiskScore == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.RiskScore(childComplexity), true

	case "TeamVulnerabilitySummary.riskScoreTrend":
		if e.complexity.TeamVulnerabilitySummary.RiskScoreTrend == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.RiskScoreTrend(childComplexity), true

	case "TeamVulnerabilitySummary.status":
		if e.complexity.TeamVulnerabilitySummary.Status == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Status(childComplexity), true

	case "TeamVulnerabilitySummary.unassigned":
		if e.complexity.TeamVulnerabilitySummary.Unassigned == nil {
			break
		}

		return e.complexity.TeamVulnerabilitySummary.Unassigned(childComplexity), true

	case "TokenXAuthIntegration.name":
		if e.complexity.TokenXAuthIntegration.Name == nil {
			break
		}

		return e.complexity.TokenXAuthIntegration.Name(childComplexity), true

	case "TriggerJobPayload.job":
		if e.complexity.TriggerJobPayload.Job == nil {
			break
		}

		return e.complexity.TriggerJobPayload.Job(childComplexity), true

	case "TriggerJobPayload.jobRun":
		if e.complexity.TriggerJobPayload.JobRun == nil {
			break
		}

		return e.complexity.TriggerJobPayload.JobRun(childComplexity), true

	case "UnleashInstance.apiIngress":
		if e.complexity.UnleashInstance.APIIngress == nil {
			break
		}

		return e.complexity.UnleashInstance.APIIngress(childComplexity), true

	case "UnleashInstance.allowedTeams":
		if e.complexity.UnleashInstance.AllowedTeams == nil {
			break
		}

		args, err := ec.field_UnleashInstance_allowedTeams_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UnleashInstance.AllowedTeams(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor)), true

	case "UnleashInstance.id":
		if e.complexity.UnleashInstance.ID == nil {
			break
		}

		return e.complexity.UnleashInstance.ID(childComplexity), true

	case "UnleashInstance.metrics":
		if e.complexity.UnleashInstance.Metrics == nil {
			break
		}

		return e.complexity.UnleashInstance.Metrics(childComplexity), true

	case "UnleashInstance.name":
		if e.complexity.UnleashInstance.Name == nil {
			break
		}

		return e.complexity.UnleashInstance.Name(childComplexity), true

	case "UnleashInstance.ready":
		if e.complexity.UnleashInstance.Ready == nil {
			break
		}

		return e.complexity.UnleashInstance.Ready(childComplexity), true

	case "UnleashInstance.version":
		if e.complexity.UnleashInstance.Version == nil {
			break
		}

		return e.complexity.UnleashInstance.Version(childComplexity), true

	case "UnleashInstance.webIngress":
		if e.complexity.UnleashInstance.WebIngress == nil {
			break
		}

		return e.complexity.UnleashInstance.WebIngress(childComplexity), true

	case "UnleashInstanceCreatedActivityLogEntry.actor":
		if e.complexity.UnleashInstanceCreatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.UnleashInstanceCreatedActivityLogEntry.Actor(childComplexity), true

	case "UnleashInstanceCreatedActivityLogEntry.createdAt":
		if e.complexity.UnleashInstanceCreatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.UnleashInstanceCreatedActivityLogEntry.CreatedAt(childComplexity), true

	case "UnleashInstanceCreatedActivityLogEntry.environmentName":
		if e.complexity.UnleashInstanceCreatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.UnleashInstanceCreatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "UnleashInstanceCreatedActivityLogEntry.id":
		if e.complexity.UnleashInstanceCreatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.UnleashInstanceCreatedActivityLogEntry.ID(childComplexity), true

	case "UnleashInstanceCreatedActivityLogEntry.message":
		if e.complexity.UnleashInstanceCreatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.UnleashInstanceCreatedActivityLogEntry.Message(childComplexity), true

	case "UnleashInstanceCreatedActivityLogEntry.resourceName":
		if e.complexity.UnleashInstanceCreatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.UnleashInstanceCreatedActivityLogEntry.ResourceName(childComplexity), true

	case "UnleashInstanceCreatedActivityLogEntry.resourceType":
		if e.complexity.UnleashInstanceCreatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.UnleashInstanceCreatedActivityLogEntry.ResourceType(childComplexity), true

	case "UnleashInstanceCreatedActivityLogEntry.teamSlug":
		if e.complexity.UnleashInstanceCreatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.UnleashInstanceCreatedActivityLogEntry.TeamSlug(childComplexity), true

	case "UnleashInstanceMetrics.apiTokens":
		if e.complexity.UnleashInstanceMetrics.APITokens == nil {
			break
		}

		return e.complexity.UnleashInstanceMetrics.APITokens(childComplexity), true

	case "UnleashInstanceMetrics.cpuRequests":
		if e.complexity.UnleashInstanceMetrics.CPURequests == nil {
			break
		}

		return e.complexity.UnleashInstanceMetrics.CPURequests(childComplexity), true

	case "UnleashInstanceMetrics.cpuUtilization":
		if e.complexity.UnleashInstanceMetrics.CPUUtilization == nil {
			break
		}

		return e.complexity.UnleashInstanceMetrics.CPUUtilization(childComplexity), true

	case "UnleashInstanceMetrics.memoryRequests":
		if e.complexity.UnleashInstanceMetrics.MemoryRequests == nil {
			break
		}

		return e.complexity.UnleashInstanceMetrics.MemoryRequests(childComplexity), true

	case "UnleashInstanceMetrics.memoryUtilization":
		if e.complexity.UnleashInstanceMetrics.MemoryUtilization == nil {
			break
		}

		return e.complexity.UnleashInstanceMetrics.MemoryUtilization(childComplexity), true

	case "UnleashInstanceMetrics.toggles":
		if e.complexity.UnleashInstanceMetrics.Toggles == nil {
			break
		}

		return e.complexity.UnleashInstanceMetrics.Toggles(childComplexity), true

	case "UnleashInstanceUpdatedActivityLogEntry.actor":
		if e.complexity.UnleashInstanceUpdatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.UnleashInstanceUpdatedActivityLogEntry.Actor(childComplexity), true

	case "UnleashInstanceUpdatedActivityLogEntry.createdAt":
		if e.complexity.UnleashInstanceUpdatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.UnleashInstanceUpdatedActivityLogEntry.CreatedAt(childComplexity), true

	case "UnleashInstanceUpdatedActivityLogEntry.data":
		if e.complexity.UnleashInstanceUpdatedActivityLogEntry.Data == nil {
			break
		}

		return e.complexity.UnleashInstanceUpdatedActivityLogEntry.Data(childComplexity), true

	case "UnleashInstanceUpdatedActivityLogEntry.environmentName":
		if e.complexity.UnleashInstanceUpdatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.UnleashInstanceUpdatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "UnleashInstanceUpdatedActivityLogEntry.id":
		if e.complexity.UnleashInstanceUpdatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.UnleashInstanceUpdatedActivityLogEntry.ID(childComplexity), true

	case "UnleashInstanceUpdatedActivityLogEntry.message":
		if e.complexity.UnleashInstanceUpdatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.UnleashInstanceUpdatedActivityLogEntry.Message(childComplexity), true

	case "UnleashInstanceUpdatedActivityLogEntry.resourceName":
		if e.complexity.UnleashInstanceUpdatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.UnleashInstanceUpdatedActivityLogEntry.ResourceName(childComplexity), true

	case "UnleashInstanceUpdatedActivityLogEntry.resourceType":
		if e.complexity.UnleashInstanceUpdatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.UnleashInstanceUpdatedActivityLogEntry.ResourceType(childComplexity), true

	case "UnleashInstanceUpdatedActivityLogEntry.teamSlug":
		if e.complexity.UnleashInstanceUpdatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.UnleashInstanceUpdatedActivityLogEntry.TeamSlug(childComplexity), true

	case "UnleashInstanceUpdatedActivityLogEntryData.allowedTeamSlug":
		if e.complexity.UnleashInstanceUpdatedActivityLogEntryData.AllowedTeamSlug == nil {
			break
		}

		return e.complexity.UnleashInstanceUpdatedActivityLogEntryData.AllowedTeamSlug(childComplexity), true

	case "UnleashInstanceUpdatedActivityLogEntryData.revokedTeamSlug":
		if e.complexity.UnleashInstanceUpdatedActivityLogEntryData.RevokedTeamSlug == nil {
			break
		}

		return e.complexity.UnleashInstanceUpdatedActivityLogEntryData.RevokedTeamSlug(childComplexity), true

	case "UpdateImageVulnerabilityPayload.vulnerability":
		if e.complexity.UpdateImageVulnerabilityPayload.Vulnerability == nil {
			break
		}

		return e.complexity.UpdateImageVulnerabilityPayload.Vulnerability(childComplexity), true

	case "UpdateSecretValuePayload.secret":
		if e.complexity.UpdateSecretValuePayload.Secret == nil {
			break
		}

		return e.complexity.UpdateSecretValuePayload.Secret(childComplexity), true

	case "UpdateServiceAccountPayload.serviceAccount":
		if e.complexity.UpdateServiceAccountPayload.ServiceAccount == nil {
			break
		}

		return e.complexity.UpdateServiceAccountPayload.ServiceAccount(childComplexity), true

	case "UpdateServiceAccountTokenPayload.serviceAccount":
		if e.complexity.UpdateServiceAccountTokenPayload.ServiceAccount == nil {
			break
		}

		return e.complexity.UpdateServiceAccountTokenPayload.ServiceAccount(childComplexity), true

	case "UpdateServiceAccountTokenPayload.serviceAccountToken":
		if e.complexity.UpdateServiceAccountTokenPayload.ServiceAccountToken == nil {
			break
		}

		return e.complexity.UpdateServiceAccountTokenPayload.ServiceAccountToken(childComplexity), true

	case "UpdateTeamEnvironmentPayload.environment":
		if e.complexity.UpdateTeamEnvironmentPayload.Environment == nil {
			break
		}

		return e.complexity.UpdateTeamEnvironmentPayload.Environment(childComplexity), true

	case "UpdateTeamEnvironmentPayload.teamEnvironment":
		if e.complexity.UpdateTeamEnvironmentPayload.TeamEnvironment == nil {
			break
		}

		return e.complexity.UpdateTeamEnvironmentPayload.TeamEnvironment(childComplexity), true

	case "UpdateTeamPayload.team":
		if e.complexity.UpdateTeamPayload.Team == nil {
			break
		}

		return e.complexity.UpdateTeamPayload.Team(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.externalID":
		if e.complexity.User.ExternalID == nil {
			break
		}

		return e.complexity.User.ExternalID(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.isAdmin":
		if e.complexity.User.IsAdmin == nil {
			break
		}

		return e.complexity.User.IsAdmin(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.teams":
		if e.complexity.User.Teams == nil {
			break
		}

		args, err := ec.field_User_teams_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Teams(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*team.UserTeamOrder)), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.nodes":
		if e.complexity.UserConnection.Nodes == nil {
			break
		}

		return e.complexity.UserConnection.Nodes(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserCreatedUserSyncLogEntry.createdAt":
		if e.complexity.UserCreatedUserSyncLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.UserCreatedUserSyncLogEntry.CreatedAt(childComplexity), true

	case "UserCreatedUserSyncLogEntry.id":
		if e.complexity.UserCreatedUserSyncLogEntry.ID == nil {
			break
		}

		return e.complexity.UserCreatedUserSyncLogEntry.ID(childComplexity), true

	case "UserCreatedUserSyncLogEntry.message":
		if e.complexity.UserCreatedUserSyncLogEntry.Message == nil {
			break
		}

		return e.complexity.UserCreatedUserSyncLogEntry.Message(childComplexity), true

	case "UserCreatedUserSyncLogEntry.userEmail":
		if e.complexity.UserCreatedUserSyncLogEntry.UserEmail == nil {
			break
		}

		return e.complexity.UserCreatedUserSyncLogEntry.UserEmail(childComplexity), true

	case "UserCreatedUserSyncLogEntry.userID":
		if e.complexity.UserCreatedUserSyncLogEntry.UserID == nil {
			break
		}

		return e.complexity.UserCreatedUserSyncLogEntry.UserID(childComplexity), true

	case "UserCreatedUserSyncLogEntry.userName":
		if e.complexity.UserCreatedUserSyncLogEntry.UserName == nil {
			break
		}

		return e.complexity.UserCreatedUserSyncLogEntry.UserName(childComplexity), true

	case "UserDeletedUserSyncLogEntry.createdAt":
		if e.complexity.UserDeletedUserSyncLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.UserDeletedUserSyncLogEntry.CreatedAt(childComplexity), true

	case "UserDeletedUserSyncLogEntry.id":
		if e.complexity.UserDeletedUserSyncLogEntry.ID == nil {
			break
		}

		return e.complexity.UserDeletedUserSyncLogEntry.ID(childComplexity), true

	case "UserDeletedUserSyncLogEntry.message":
		if e.complexity.UserDeletedUserSyncLogEntry.Message == nil {
			break
		}

		return e.complexity.UserDeletedUserSyncLogEntry.Message(childComplexity), true

	case "UserDeletedUserSyncLogEntry.userEmail":
		if e.complexity.UserDeletedUserSyncLogEntry.UserEmail == nil {
			break
		}

		return e.complexity.UserDeletedUserSyncLogEntry.UserEmail(childComplexity), true

	case "UserDeletedUserSyncLogEntry.userID":
		if e.complexity.UserDeletedUserSyncLogEntry.UserID == nil {
			break
		}

		return e.complexity.UserDeletedUserSyncLogEntry.UserID(childComplexity), true

	case "UserDeletedUserSyncLogEntry.userName":
		if e.complexity.UserDeletedUserSyncLogEntry.UserName == nil {
			break
		}

		return e.complexity.UserDeletedUserSyncLogEntry.UserName(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	case "UserSyncLogEntryConnection.edges":
		if e.complexity.UserSyncLogEntryConnection.Edges == nil {
			break
		}

		return e.complexity.UserSyncLogEntryConnection.Edges(childComplexity), true

	case "UserSyncLogEntryConnection.nodes":
		if e.complexity.UserSyncLogEntryConnection.Nodes == nil {
			break
		}

		return e.complexity.UserSyncLogEntryConnection.Nodes(childComplexity), true

	case "UserSyncLogEntryConnection.pageInfo":
		if e.complexity.UserSyncLogEntryConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserSyncLogEntryConnection.PageInfo(childComplexity), true

	case "UserSyncLogEntryEdge.cursor":
		if e.complexity.UserSyncLogEntryEdge.Cursor == nil {
			break
		}

		return e.complexity.UserSyncLogEntryEdge.Cursor(childComplexity), true

	case "UserSyncLogEntryEdge.node":
		if e.complexity.UserSyncLogEntryEdge.Node == nil {
			break
		}

		return e.complexity.UserSyncLogEntryEdge.Node(childComplexity), true

	case "UserUpdatedUserSyncLogEntry.createdAt":
		if e.complexity.UserUpdatedUserSyncLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.UserUpdatedUserSyncLogEntry.CreatedAt(childComplexity), true

	case "UserUpdatedUserSyncLogEntry.id":
		if e.complexity.UserUpdatedUserSyncLogEntry.ID == nil {
			break
		}

		return e.complexity.UserUpdatedUserSyncLogEntry.ID(childComplexity), true

	case "UserUpdatedUserSyncLogEntry.message":
		if e.complexity.UserUpdatedUserSyncLogEntry.Message == nil {
			break
		}

		return e.complexity.UserUpdatedUserSyncLogEntry.Message(childComplexity), true

	case "UserUpdatedUserSyncLogEntry.oldUserEmail":
		if e.complexity.UserUpdatedUserSyncLogEntry.OldUserEmail == nil {
			break
		}

		return e.complexity.UserUpdatedUserSyncLogEntry.OldUserEmail(childComplexity), true

	case "UserUpdatedUserSyncLogEntry.oldUserName":
		if e.complexity.UserUpdatedUserSyncLogEntry.OldUserName == nil {
			break
		}

		return e.complexity.UserUpdatedUserSyncLogEntry.OldUserName(childComplexity), true

	case "UserUpdatedUserSyncLogEntry.userEmail":
		if e.complexity.UserUpdatedUserSyncLogEntry.UserEmail == nil {
			break
		}

		return e.complexity.UserUpdatedUserSyncLogEntry.UserEmail(childComplexity), true

	case "UserUpdatedUserSyncLogEntry.userID":
		if e.complexity.UserUpdatedUserSyncLogEntry.UserID == nil {
			break
		}

		return e.complexity.UserUpdatedUserSyncLogEntry.UserID(childComplexity), true

	case "UserUpdatedUserSyncLogEntry.userName":
		if e.complexity.UserUpdatedUserSyncLogEntry.UserName == nil {
			break
		}

		return e.complexity.UserUpdatedUserSyncLogEntry.UserName(childComplexity), true

	case "UtilizationSample.instance":
		if e.complexity.UtilizationSample.Instance == nil {
			break
		}

		return e.complexity.UtilizationSample.Instance(childComplexity), true

	case "UtilizationSample.timestamp":
		if e.complexity.UtilizationSample.Timestamp == nil {
			break
		}

		return e.complexity.UtilizationSample.Timestamp(childComplexity), true

	case "UtilizationSample.value":
		if e.complexity.UtilizationSample.Value == nil {
			break
		}

		return e.complexity.UtilizationSample.Value(childComplexity), true

	case "ValkeyInstance.access":
		if e.complexity.ValkeyInstance.Access == nil {
			break
		}

		args, err := ec.field_ValkeyInstance_access_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValkeyInstance.Access(childComplexity, args["first"].(*int), args["after"].(*pagination.Cursor), args["last"].(*int), args["before"].(*pagination.Cursor), args["orderBy"].(*valkey.ValkeyInstanceAccessOrder)), true

	case "ValkeyInstance.cost":
		if e.complexity.ValkeyInstance.Cost == nil {
			break
		}

		return e.complexity.ValkeyInstance.Cost(childComplexity), true

	case "ValkeyInstance.environment":
		if e.complexity.ValkeyInstance.Environment == nil {
			break
		}

		return e.complexity.ValkeyInstance.Environment(childComplexity), true

	case "ValkeyInstance.id":
		if e.complexity.ValkeyInstance.ID == nil {
			break
		}

		return e.complexity.ValkeyInstance.ID(childComplexity), true

	case "ValkeyInstance.name":
		if e.complexity.ValkeyInstance.Name == nil {
			break
		}

		return e.complexity.ValkeyInstance.Name(childComplexity), true

	case "ValkeyInstance.status":
		if e.complexity.ValkeyInstance.Status == nil {
			break
		}

		return e.complexity.ValkeyInstance.Status(childComplexity), true

	case "ValkeyInstance.team":
		if e.complexity.ValkeyInstance.Team == nil {
			break
		}

		return e.complexity.ValkeyInstance.Team(childComplexity), true

	case "ValkeyInstance.teamEnvironment":
		if e.complexity.ValkeyInstance.TeamEnvironment == nil {
			break
		}

		return e.complexity.ValkeyInstance.TeamEnvironment(childComplexity), true

	case "ValkeyInstance.workload":
		if e.complexity.ValkeyInstance.Workload == nil {
			break
		}

		return e.complexity.ValkeyInstance.Workload(childComplexity), true

	case "ValkeyInstanceAccess.access":
		if e.complexity.ValkeyInstanceAccess.Access == nil {
			break
		}

		return e.complexity.ValkeyInstanceAccess.Access(childComplexity), true

	case "ValkeyInstanceAccess.workload":
		if e.complexity.ValkeyInstanceAccess.Workload == nil {
			break
		}

		return e.complexity.ValkeyInstanceAccess.Workload(childComplexity), true

	case "ValkeyInstanceAccessConnection.edges":
		if e.complexity.ValkeyInstanceAccessConnection.Edges == nil {
			break
		}

		return e.complexity.ValkeyInstanceAccessConnection.Edges(childComplexity), true

	case "ValkeyInstanceAccessConnection.nodes":
		if e.complexity.ValkeyInstanceAccessConnection.Nodes == nil {
			break
		}

		return e.complexity.ValkeyInstanceAccessConnection.Nodes(childComplexity), true

	case "ValkeyInstanceAccessConnection.pageInfo":
		if e.complexity.ValkeyInstanceAccessConnection.PageInfo == nil {
			break
		}

		return e.complexity.ValkeyInstanceAccessConnection.PageInfo(childComplexity), true

	case "ValkeyInstanceAccessEdge.cursor":
		if e.complexity.ValkeyInstanceAccessEdge.Cursor == nil {
			break
		}

		return e.complexity.ValkeyInstanceAccessEdge.Cursor(childComplexity), true

	case "ValkeyInstanceAccessEdge.node":
		if e.complexity.ValkeyInstanceAccessEdge.Node == nil {
			break
		}

		return e.complexity.ValkeyInstanceAccessEdge.Node(childComplexity), true

	case "ValkeyInstanceConnection.edges":
		if e.complexity.ValkeyInstanceConnection.Edges == nil {
			break
		}

		return e.complexity.ValkeyInstanceConnection.Edges(childComplexity), true

	case "ValkeyInstanceConnection.nodes":
		if e.complexity.ValkeyInstanceConnection.Nodes == nil {
			break
		}

		return e.complexity.ValkeyInstanceConnection.Nodes(childComplexity), true

	case "ValkeyInstanceConnection.pageInfo":
		if e.complexity.ValkeyInstanceConnection.PageInfo == nil {
			break
		}

		return e.complexity.ValkeyInstanceConnection.PageInfo(childComplexity), true

	case "ValkeyInstanceCost.sum":
		if e.complexity.ValkeyInstanceCost.Sum == nil {
			break
		}

		return e.complexity.ValkeyInstanceCost.Sum(childComplexity), true

	case "ValkeyInstanceEdge.cursor":
		if e.complexity.ValkeyInstanceEdge.Cursor == nil {
			break
		}

		return e.complexity.ValkeyInstanceEdge.Cursor(childComplexity), true

	case "ValkeyInstanceEdge.node":
		if e.complexity.ValkeyInstanceEdge.Node == nil {
			break
		}

		return e.complexity.ValkeyInstanceEdge.Node(childComplexity), true

	case "ValkeyInstanceStatus.state":
		if e.complexity.ValkeyInstanceStatus.State == nil {
			break
		}

		return e.complexity.ValkeyInstanceStatus.State(childComplexity), true

	case "VulnerabilityUpdatedActivityLogEntry.actor":
		if e.complexity.VulnerabilityUpdatedActivityLogEntry.Actor == nil {
			break
		}

		return e.complexity.VulnerabilityUpdatedActivityLogEntry.Actor(childComplexity), true

	case "VulnerabilityUpdatedActivityLogEntry.createdAt":
		if e.complexity.VulnerabilityUpdatedActivityLogEntry.CreatedAt == nil {
			break
		}

		return e.complexity.VulnerabilityUpdatedActivityLogEntry.CreatedAt(childComplexity), true

	case "VulnerabilityUpdatedActivityLogEntry.environmentName":
		if e.complexity.VulnerabilityUpdatedActivityLogEntry.EnvironmentName == nil {
			break
		}

		return e.complexity.VulnerabilityUpdatedActivityLogEntry.EnvironmentName(childComplexity), true

	case "VulnerabilityUpdatedActivityLogEntry.id":
		if e.complexity.VulnerabilityUpdatedActivityLogEntry.ID == nil {
			break
		}

		return e.complexity.VulnerabilityUpdatedActivityLogEntry.ID(childComplexity), true

	case "VulnerabilityUpdatedActivityLogEntry.message":
		if e.complexity.VulnerabilityUpdatedActivityLogEntry.Message == nil {
			break
		}

		return e.complexity.VulnerabilityUpdatedActivityLogEntry.Message(childComplexity), true

	case "VulnerabilityUpdatedActivityLogEntry.resourceName":
		if e.complexity.VulnerabilityUpdatedActivityLogEntry.ResourceName == nil {
			break
		}

		return e.complexity.VulnerabilityUpdatedActivityLogEntry.ResourceName(childComplexity), true

	case "VulnerabilityUpdatedActivityLogEntry.resourceType":
		if e.complexity.VulnerabilityUpdatedActivityLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.VulnerabilityUpdatedActivityLogEntry.ResourceType(childComplexity), true

	case "VulnerabilityUpdatedActivityLogEntry.teamSlug":
		if e.complexity.VulnerabilityUpdatedActivityLogEntry.TeamSlug == nil {
			break
		}

		return e.complexity.VulnerabilityUpdatedActivityLogEntry.TeamSlug(childComplexity), true

	case "WorkloadConnection.edges":
		if e.complexity.WorkloadConnection.Edges == nil {
			break
		}

		return e.complexity.WorkloadConnection.Edges(childComplexity), true

	case "WorkloadConnection.nodes":
		if e.complexity.WorkloadConnection.Nodes == nil {
			break
		}

		return e.complexity.WorkloadConnection.Nodes(childComplexity), true

	case "WorkloadConnection.pageInfo":
		if e.complexity.WorkloadConnection.PageInfo == nil {
			break
		}

		return e.complexity.WorkloadConnection.PageInfo(childComplexity), true

	case "WorkloadCost.daily":
		if e.complexity.WorkloadCost.Daily == nil {
			break
		}

		args, err := ec.field_WorkloadCost_daily_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkloadCost.Daily(childComplexity, args["from"].(scalar.Date), args["to"].(scalar.Date)), true

	case "WorkloadCost.monthly":
		if e.complexity.WorkloadCost.Monthly == nil {
			break
		}

		return e.complexity.WorkloadCost.Monthly(childComplexity), true

	case "WorkloadCostPeriod.series":
		if e.complexity.WorkloadCostPeriod.Series == nil {
			break
		}

		return e.complexity.WorkloadCostPeriod.Series(childComplexity), true

	case "WorkloadCostPeriod.sum":
		if e.complexity.WorkloadCostPeriod.Sum == nil {
			break
		}

		return e.complexity.WorkloadCostPeriod.Sum(childComplexity), true

	case "WorkloadCostSample.cost":
		if e.complexity.WorkloadCostSample.Cost == nil {
			break
		}

		return e.complexity.WorkloadCostSample.Cost(childComplexity), true

	case "WorkloadCostSample.workload":
		if e.complexity.WorkloadCostSample.Workload == nil {
			break
		}

		return e.complexity.WorkloadCostSample.Workload(childComplexity), true

	case "WorkloadCostSample.workloadName":
		if e.complexity.WorkloadCostSample.WorkloadName == nil {
			break
		}

		return e.complexity.WorkloadCostSample.WorkloadName(childComplexity), true

	case "WorkloadCostSeries.date":
		if e.complexity.WorkloadCostSeries.Date == nil {
			break
		}

		return e.complexity.WorkloadCostSeries.Date(childComplexity), true

	case "WorkloadCostSeries.sum":
		if e.complexity.WorkloadCostSeries.Sum == nil {
			break
		}

		return e.complexity.WorkloadCostSeries.Sum(childComplexity), true

	case "WorkloadCostSeries.workloads":
		if e.complexity.WorkloadCostSeries.Workloads == nil {
			break
		}

		return e.complexity.WorkloadCostSeries.Workloads(childComplexity), true

	case "WorkloadEdge.cursor":
		if e.complexity.WorkloadEdge.Cursor == nil {
			break
		}

		return e.complexity.WorkloadEdge.Cursor(childComplexity), true

	case "WorkloadEdge.node":
		if e.complexity.WorkloadEdge.Node == nil {
			break
		}

		return e.complexity.WorkloadEdge.Node(childComplexity), true

	case "WorkloadLogLine.instance":
		if e.complexity.WorkloadLogLine.Instance == nil {
			break
		}

		return e.complexity.WorkloadLogLine.Instance(childComplexity), true

	case "WorkloadLogLine.message":
		if e.complexity.WorkloadLogLine.Message == nil {
			break
		}

		return e.complexity.WorkloadLogLine.Message(childComplexity), true

	case "WorkloadLogLine.time":
		if e.complexity.WorkloadLogLine.Time == nil {
			break
		}

		return e.complexity.WorkloadLogLine.Time(childComplexity), true

	case "WorkloadResourceQuantity.cpu":
		if e.complexity.WorkloadResourceQuantity.CPU == nil {
			break
		}

		return e.complexity.WorkloadResourceQuantity.CPU(childComplexity), true

	case "WorkloadResourceQuantity.memory":
		if e.complexity.WorkloadResourceQuantity.Memory == nil {
			break
		}

		return e.complexity.WorkloadResourceQuantity.Memory(childComplexity), true

	case "WorkloadStatus.errors":
		if e.complexity.WorkloadStatus.Errors == nil {
			break
		}

		return e.complexity.WorkloadStatus.Errors(childComplexity), true

	case "WorkloadStatus.state":
		if e.complexity.WorkloadStatus.State == nil {
			break
		}

		return e.complexity.WorkloadStatus.State(childComplexity), true

	case "WorkloadStatusDeprecatedIngress.ingress":
		if e.complexity.WorkloadStatusDeprecatedIngress.Ingress == nil {
			break
		}

		return e.complexity.WorkloadStatusDeprecatedIngress.Ingress(childComplexity), true

	case "WorkloadStatusDeprecatedIngress.level":
		if e.complexity.WorkloadStatusDeprecatedIngress.Level == nil {
			break
		}

		return e.complexity.WorkloadStatusDeprecatedIngress.Level(childComplexity), true

	case "WorkloadStatusDeprecatedRegistry.level":
		if e.complexity.WorkloadStatusDeprecatedRegistry.Level == nil {
			break
		}

		return e.complexity.WorkloadStatusDeprecatedRegistry.Level(childComplexity), true

	case "WorkloadStatusDeprecatedRegistry.name":
		if e.complexity.WorkloadStatusDeprecatedRegistry.Name == nil {
			break
		}

		return e.complexity.WorkloadStatusDeprecatedRegistry.Name(childComplexity), true

	case "WorkloadStatusDeprecatedRegistry.registry":
		if e.complexity.WorkloadStatusDeprecatedRegistry.Registry == nil {
			break
		}

		return e.complexity.WorkloadStatusDeprecatedRegistry.Registry(childComplexity), true

	case "WorkloadStatusDeprecatedRegistry.repository":
		if e.complexity.WorkloadStatusDeprecatedRegistry.Repository == nil {
			break
		}

		return e.complexity.WorkloadStatusDeprecatedRegistry.Repository(childComplexity), true

	case "WorkloadStatusDeprecatedRegistry.tag":
		if e.complexity.WorkloadStatusDeprecatedRegistry.Tag == nil {
			break
		}

		return e.complexity.WorkloadStatusDeprecatedRegistry.Tag(childComplexity), true

	case "WorkloadStatusFailedRun.detail":
		if e.complexity.WorkloadStatusFailedRun.Detail == nil {
			break
		}

		return e.complexity.WorkloadStatusFailedRun.Detail(childComplexity), true

	case "WorkloadStatusFailedRun.level":
		if e.complexity.WorkloadStatusFailedRun.Level == nil {
			break
		}

		return e.complexity.WorkloadStatusFailedRun.Level(childComplexity), true

	case "WorkloadStatusFailedRun.name":
		if e.complexity.WorkloadStatusFailedRun.Name == nil {
			break
		}

		return e.complexity.WorkloadStatusFailedRun.Name(childComplexity), true

	case "WorkloadStatusInboundNetwork.level":
		if e.complexity.WorkloadStatusInboundNetwork.Level == nil {
			break
		}

		return e.complexity.WorkloadStatusInboundNetwork.Level(childComplexity), true

	case "WorkloadStatusInboundNetwork.policy":
		if e.complexity.WorkloadStatusInboundNetwork.Policy == nil {
			break
		}

		return e.complexity.WorkloadStatusInboundNetwork.Policy(childComplexity), true

	case "WorkloadStatusInvalidNaisYaml.detail":
		if e.complexity.WorkloadStatusInvalidNaisYaml.Detail == nil {
			break
		}

		return e.complexity.WorkloadStatusInvalidNaisYaml.Detail(childComplexity), true

	case "WorkloadStatusInvalidNaisYaml.level":
		if e.complexity.WorkloadStatusInvalidNaisYaml.Level == nil {
			break
		}

		return e.complexity.WorkloadStatusInvalidNaisYaml.Level(childComplexity), true

	case "WorkloadStatusMissingSBOM.level":
		if e.complexity.WorkloadStatusMissingSBOM.Level == nil {
			break
		}

		return e.complexity.WorkloadStatusMissingSBOM.Level(childComplexity), true

	case "WorkloadStatusNewInstancesFailing.failingInstances":
		if e.complexity.WorkloadStatusNewInstancesFailing.FailingInstances == nil {
			break
		}

		return e.complexity.WorkloadStatusNewInstancesFailing.FailingInstances(childComplexity), true

	case "WorkloadStatusNewInstancesFailing.level":
		if e.complexity.WorkloadStatusNewInstancesFailing.Level == nil {
			break
		}

		return e.complexity.WorkloadStatusNewInstancesFailing.Level(childComplexity), true

	case "WorkloadStatusNoRunningInstances.level":
		if e.complexity.WorkloadStatusNoRunningInstances.Level == nil {
			break
		}

		return e.complexity.WorkloadStatusNoRunningInstances.Level(childComplexity), true

	case "WorkloadStatusOutboundNetwork.level":
		if e.complexity.WorkloadStatusOutboundNetwork.Level == nil {
			break
		}

		return e.complexity.WorkloadStatusOutboundNetwork.Level(childComplexity), true

	case "WorkloadStatusOutboundNetwork.policy":
		if e.complexity.WorkloadStatusOutboundNetwork.Policy == nil {
			break
		}

		return e.complexity.WorkloadStatusOutboundNetwork.Policy(childComplexity), true

	case "WorkloadStatusSynchronizationFailing.detail":
		if e.complexity.WorkloadStatusSynchronizationFailing.Detail == nil {
			break
		}

		return e.complexity.WorkloadStatusSynchronizationFailing.Detail(childComplexity), true

	case "WorkloadStatusSynchronizationFailing.level":
		if e.complexity.WorkloadStatusSynchronizationFailing.Level == nil {
			break
		}

		return e.complexity.WorkloadStatusSynchronizationFailing.Level(childComplexity), true

	case "WorkloadStatusVulnerable.level":
		if e.complexity.WorkloadStatusVulnerable.Level == nil {
			break
		}

		return e.complexity.WorkloadStatusVulnerable.Level(childComplexity), true

	case "WorkloadStatusVulnerable.summary":
		if e.complexity.WorkloadStatusVulnerable.Summary == nil {
			break
		}

		return e.complexity.WorkloadStatusVulnerable.Summary(childComplexity), true

	case "WorkloadUtilization.current":
		if e.complexity.WorkloadUtilization.Current == nil {
			break
		}

		args, err := ec.field_WorkloadUtilization_current_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkloadUtilization.Current(childComplexity, args["resourceType"].(utilization.UtilizationResourceType)), true

	case "WorkloadUtilization.limit":
		if e.complexity.WorkloadUtilization.Limit == nil {
			break
		}

		args, err := ec.field_WorkloadUtilization_limit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkloadUtilization.Limit(childComplexity, args["resourceType"].(utilization.UtilizationResourceType)), true

	case "WorkloadUtilization.requested":
		if e.complexity.WorkloadUtilization.Requested == nil {
			break
		}

		args, err := ec.field_WorkloadUtilization_requested_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkloadUtilization.Requested(childComplexity, args["resourceType"].(utilization.UtilizationResourceType)), true

	case "WorkloadUtilization.series":
		if e.complexity.WorkloadUtilization.Series == nil {
			break
		}

		args, err := ec.field_WorkloadUtilization_series_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkloadUtilization.Series(childComplexity, args["input"].(utilization.WorkloadUtilizationSeriesInput)), true

	case "WorkloadUtilizationData.requested":
		if e.complexity.WorkloadUtilizationData.Requested == nil {
			break
		}

		return e.complexity.WorkloadUtilizationData.Requested(childComplexity), true

	case "WorkloadUtilizationData.used":
		if e.complexity.WorkloadUtilizationData.Used == nil {
			break
		}

		return e.complexity.WorkloadUtilizationData.Used(childComplexity), true

	case "WorkloadUtilizationData.workload":
		if e.complexity.WorkloadUtilizationData.Workload == nil {
			break
		}

		return e.complexity.WorkloadUtilizationData.Workload(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddRepositoryToTeamInput,
		ec.unmarshalInputAddSecretValueInput,
		ec.unmarshalInputAddTeamMemberInput,
		ec.unmarshalInputAllowTeamAccessToUnleashInput,
		ec.unmarshalInputApplicationOrder,
		ec.unmarshalInputAssignRoleToServiceAccountInput,
		ec.unmarshalInputBigQueryDatasetAccessOrder,
		ec.unmarshalInputBigQueryDatasetOrder,
		ec.unmarshalInputBucketOrder,
		ec.unmarshalInputChangeDeploymentKeyInput,
		ec.unmarshalInputConfigureReconcilerInput,
		ec.unmarshalInputConfirmTeamDeletionInput,
		ec.unmarshalInputCreateSecretInput,
		ec.unmarshalInputCreateServiceAccountInput,
		ec.unmarshalInputCreateServiceAccountTokenInput,
		ec.unmarshalInputCreateTeamInput,
		ec.unmarshalInputCreateUnleashForTeamInput,
		ec.unmarshalInputDeleteApplicationInput,
		ec.unmarshalInputDeleteJobInput,
		ec.unmarshalInputDeleteSecretInput,
		ec.unmarshalInputDeleteServiceAccountInput,
		ec.unmarshalInputDeleteServiceAccountTokenInput,
		ec.unmarshalInputDisableReconcilerInput,
		ec.unmarshalInputEnableReconcilerInput,
		ec.unmarshalInputEnvironmentOrder,
		ec.unmarshalInputEnvironmentWorkloadOrder,
		ec.unmarshalInputImageVulnerabilityOrder,
		ec.unmarshalInputJobOrder,
		ec.unmarshalInputKafkaTopicAclFilter,
		ec.unmarshalInputKafkaTopicAclOrder,
		ec.unmarshalInputKafkaTopicOrder,
		ec.unmarshalInputOpenSearchAccessOrder,
		ec.unmarshalInputOpenSearchOrder,
		ec.unmarshalInputReconcilerConfigInput,
		ec.unmarshalInputRedisInstanceAccessOrder,
		ec.unmarshalInputRedisInstanceOrder,
		ec.unmarshalInputRemoveRepositoryFromTeamInput,
		ec.unmarshalInputRemoveSecretValueInput,
		ec.unmarshalInputRemoveTeamMemberInput,
		ec.unmarshalInputRepositoryOrder,
		ec.unmarshalInputRequestTeamDeletionInput,
		ec.unmarshalInputRestartApplicationInput,
		ec.unmarshalInputRevokeRoleFromServiceAccountInput,
		ec.unmarshalInputRevokeTeamAccessToUnleashInput,
		ec.unmarshalInputSearchFilter,
		ec.unmarshalInputSecretFilter,
		ec.unmarshalInputSecretOrder,
		ec.unmarshalInputSecretValueInput,
		ec.unmarshalInputSetTeamMemberRoleInput,
		ec.unmarshalInputSqlInstanceOrder,
		ec.unmarshalInputSqlInstanceUserOrder,
		ec.unmarshalInputTeamApplicationsFilter,
		ec.unmarshalInputTeamCostDailyFilter,
		ec.unmarshalInputTeamJobsFilter,
		ec.unmarshalInputTeamMemberOrder,
		ec.unmarshalInputTeamOrder,
		ec.unmarshalInputTeamRepositoryFilter,
		ec.unmarshalInputTeamVulnerabilitySummaryFilter,
		ec.unmarshalInputTeamWorkloadsFilter,
		ec.unmarshalInputTriggerJobInput,
		ec.unmarshalInputUpdateImageVulnerabilityInput,
		ec.unmarshalInputUpdateSecretValueInput,
		ec.unmarshalInputUpdateServiceAccountInput,
		ec.unmarshalInputUpdateServiceAccountTokenInput,
		ec.unmarshalInputUpdateTeamEnvironmentInput,
		ec.unmarshalInputUpdateTeamInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserTeamOrder,
		ec.unmarshalInputValkeyInstanceAccessOrder,
		ec.unmarshalInputValkeyInstanceOrder,
		ec.unmarshalInputWorkloadLogSubscriptionFilter,
		ec.unmarshalInputWorkloadOrder,
		ec.unmarshalInputWorkloadUtilizationSeriesInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/activitylog.graphqls", Input: `extend type Team {
	"""
	Activity log associated with the team.
	"""
	activityLog(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor
	): ActivityLogEntryConnection!
}

extend type Reconciler {
	"""
	Activity log associated with the reconciler.
	"""
	activityLog(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor
	): ActivityLogEntryConnection!
}

"""
Interface for activity log entries.
"""
interface ActivityLogEntry implements Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
	"""
	actor: String!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the entry.
	"""
	message: String!

	"""
	Type of the resource that was affected by the action.
	"""
	resourceType: ActivityLogEntryResourceType!

	"""
	Name of the resource that was affected by the action.
	"""
	resourceName: String!

	"""
	The team slug that the entry belongs to.
	"""
	teamSlug: Slug

	"""
	The environment name that the entry belongs to.
	"""
	environmentName: String
}

"""
The type of the resource that was affected by the activity.
"""
enum ActivityLogEntryResourceType {
	"""
	Unknown type.
	"""
	UNKNOWN
}

"""
Activity log connection.
"""
type ActivityLogEntryConnection {
	"""
	Pagination information.
	"""
	pageInfo: PageInfo!

	"""
	List of nodes.
	"""
	nodes: [ActivityLogEntry!]!

	"""
	List of edges.
	"""
	edges: [ActivityLogEntryEdge!]!
}

"""
Activity log edge.
"""
type ActivityLogEntryEdge {
	"""
	Cursor for this edge that can be used for pagination.
	"""
	cursor: Cursor!

	"""
	The log entry.
	"""
	node: ActivityLogEntry!
}
`, BuiltIn: false},
	{Name: "../schema/applications.graphqls", Input: `extend type Team {
	"""
	Nais applications owned by the team.
	"""
	applications(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor

		"""
		Ordering options for items returned from the connection.
		"""
		orderBy: ApplicationOrder

		"""
		Filtering options for items returned from the connection.
		"""
		filter: TeamApplicationsFilter
	): ApplicationConnection!
}

extend type TeamEnvironment {
	"""
	Nais application in the team environment.
	"""
	application(
		"""
		The name of the application.
		"""
		name: String!
	): Application!
}

extend type Mutation {
	"""
	Delete an application.
	"""
	deleteApplication(
		"""
		Input for deleting an application.
		"""
		input: DeleteApplicationInput!
	): DeleteApplicationPayload!

	"""
	Restart an application.
	"""
	restartApplication(
		"""
		Input for restarting an application.
		"""
		input: RestartApplicationInput!
	): RestartApplicationPayload!
}

extend type TeamInventoryCounts {
	"""
	Application inventory count for a team.
	"""
	applications: TeamInventoryCountApplications!
}

"""
Application inventory count for a team.
"""
type TeamInventoryCountApplications {
	"""
	Total number of applications.
	"""
	total: Int!

	"""
	Number of applications considered "not nais". When an application is considered "not nais", it means that the
	application might not be working as expected, or that it is not following the Nais guidelines.
	"""
	notNais: Int!
}

"""
An application lets you run one or more instances of a container image on the [Nais platform](https://nais.io/).

Learn more about how to create and configure your applications in the [Nais documentation](https://docs.nais.io/workloads/application/).
"""
type Application implements Node & Workload {
	"""
	The globally unique ID of the application.
	"""
	id: ID!

	"""
	The name of the application.
	"""
	name: String!

	"""
	The team that owns the application.
	"""
	team: Team!

	"""
	The environment the application is deployed in.
	"""
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")

	"""
	The team environment for the application.
	"""
	teamEnvironment: TeamEnvironment!

	"""
	The container image of the application.
	"""
	image: ContainerImage!

	"""
	Resources for the application.
	"""
	resources: ApplicationResources!

	"""
	List of ingresses for the application.
	"""
	ingresses: [Ingress!]!

	"""
	List of authentication and authorization for the application.
	"""
	authIntegrations: [ApplicationAuthIntegrations!]!

	"""
	The application manifest.
	"""
	manifest: ApplicationManifest!

	"""
	The application instances.
	"""
	instances(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor
	): ApplicationInstanceConnection!

	"""
	If set, when the application was marked for deletion.
	"""
	deletionStartedAt: Time
}

"""
Input for filtering the applications of a team.
"""
input TeamApplicationsFilter {
	"""
	Filter by the name of the application.
	"""
	name: String

	"""
	Filter by the name of the environment.
	"""
	environments: [String!]
}

"""
The manifest that describes the application.
"""
type ApplicationManifest implements WorkloadManifest {
	"""
	The manifest content, serialized as a YAML document.
	"""
	content: String!
}

"""
Authentication integrations for the application.
"""
union ApplicationAuthIntegrations =
	| EntraIDAuthIntegration
	| IDPortenAuthIntegration
	| MaskinportenAuthIntegration
	| TokenXAuthIntegration

type ApplicationResources implements WorkloadResources {
	"""
	Instances using resources above this threshold will be killed.
	"""
	limits: WorkloadResourceQuantity!

	"""
	How many resources are allocated to each instance.
	"""
	requests: WorkloadResourceQuantity!

	"""
	Scaling strategies for the application.
	"""
	scaling: ApplicationScaling!
}

"""
The scaling configuration of an application.
"""
type ApplicationScaling {
	"""
	The minimum number of application instances.
	"""
	minInstances: Int!

	"""
	The maximum number of application instances.
	"""
	maxInstances: Int!

	"""
	Scaling strategies for the application.
	"""
	strategies: [ScalingStrategy!]!
}

"""
Types of scaling strategies.
"""
union ScalingStrategy = CPUScalingStrategy | KafkaLagScalingStrategy

"""
A scaling strategy based on CPU usage

Read more: https://docs.nais.io/workloads/application/reference/automatic-scaling/#cpu-based-scaling
"""
type CPUScalingStrategy {
	"""
	The threshold that must be met for the scaling to trigger.
	"""
	threshold: Int!
}

type KafkaLagScalingStrategy {
	"""
	The threshold that must be met for the scaling to trigger.
	"""
	threshold: Int!

	"""
	The consumer group of the topic.
	"""
	consumerGroup: String!

	"""
	The name of the Kafka topic.
	"""
	topicName: String!
}

"""
Application connection.
"""
type ApplicationConnection {
	"""
	Pagination information.
	"""
	pageInfo: PageInfo!

	"""
	List of nodes.
	"""
	nodes: [Application!]!

	"""
	List of edges.
	"""
	edges: [ApplicationEdge!]!
}

"""
Application edge.
"""
type ApplicationEdge {
	"""
	Cursor for this edge that can be used for pagination.
	"""
	cursor: Cursor!

	"""
	The application.
	"""
	node: Application!
}

"""
Ordering options when fetching applications.
"""
input ApplicationOrder {
	"""
	The field to order items by.
	"""
	field: ApplicationOrderField!

	"""
	The direction to order items by.
	"""
	direction: OrderDirection!
}

"""
Fields to order applications by.
"""
enum ApplicationOrderField {
	"""
	Order applications by name.
	"""
	NAME

	"""
	Order applications by the name of the environment.
	"""
	ENVIRONMENT
}

extend union SearchNode = Application

extend enum SearchType {
	"""
	Search for applications.
	"""
	APPLICATION
}

input DeleteApplicationInput {
	"""
	Name of the application.
	"""
	name: String!

	"""
	Slug of the team that owns the application.
	"""
	teamSlug: Slug!

	"""
	Name of the environment where the application runs.
	"""
	environmentName: String!
}

type DeleteApplicationPayload {
	"""
	The team that owned the deleted application.
	"""
	team: Team

	"""
	Whether or not the application was deleted.
	"""
	success: Boolean
}

input RestartApplicationInput {
	"""
	Name of the application.
	"""
	name: String!

	"""
	Slug of the team that owns the application.
	"""
	teamSlug: Slug!

	"""
	Name of the environment where the application runs.
	"""
	environmentName: String!
}

type RestartApplicationPayload {
	"""
	The application that was restarted.
	"""
	application: Application
}

type Ingress {
	"""
	URL for the ingress.
	"""
	url: String!

	"""
	Type of ingress.
	"""
	type: IngressType!
}

enum IngressType {
	UNKNOWN
	EXTERNAL
	INTERNAL
	AUTHENTICATED
}

type ApplicationInstance implements Node {
	id: ID!
	name: String!
	image: ContainerImage!
	restarts: Int!
	created: Time!
	status: ApplicationInstanceStatus!
}

type ApplicationInstanceStatus {
	state: ApplicationInstanceState!
	message: String!
}

enum ApplicationInstanceState {
	RUNNING
	FAILING
	UNKNOWN
}

type ApplicationInstanceConnection {
	"""
	Pagination information.
	"""
	pageInfo: PageInfo!

	"""
	List of nodes.
	"""
	nodes: [ApplicationInstance!]!

	"""
	List of edges.
	"""
	edges: [ApplicationInstanceEdge!]!
}

type ApplicationInstanceEdge {
	"""
	Cursor for this edge that can be used for pagination.
	"""
	cursor: Cursor!

	"""
	The instance.
	"""
	node: ApplicationInstance!
}

extend enum ActivityLogEntryResourceType {
	"All activity log entries related to applications will use this resource type."
	APP
}

type ApplicationDeletedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type ApplicationRestartedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}
`, BuiltIn: false},
	{Name: "../schema/authz.graphqls", Input: `type Role implements Node {
	"""
	The globally unique ID of the role.
	"""
	id: ID!

	"""
	Name of the role.
	"""
	name: String!

	"""
	Description of the role.
	"""
	description: String!
}

extend type Query {
	roles(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): RoleConnection!
}

type RoleConnection {
	"""
	A list of roles.
	"""
	nodes: [Role!]!

	"""
	A list of role edges.
	"""
	edges: [RoleEdge!]!

	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
}

type RoleEdge {
	"""
	The role.
	"""
	node: Role!

	"""
	A cursor for use in pagination.
	"""
	cursor: Cursor!
}
`, BuiltIn: false},
	{Name: "../schema/bigquery.graphqls", Input: `extend type Team {
	"BigQuery datasets owned by the team."
	bigQueryDatasets(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: BigQueryDatasetOrder
	): BigQueryDatasetConnection!
}

extend type TeamEnvironment {
	"BigQuery datasets in the team environment."
	bigQueryDataset(name: String!): BigQueryDataset!
}

extend interface Workload {
	"BigQuery datasets referenced by the workload. This does not currently support pagination, but will return all available datasets."
	bigQueryDatasets(
		"Ordering options for items returned from the connection."
		orderBy: BigQueryDatasetOrder
	): BigQueryDatasetConnection!
}

extend type Application {
	"BigQuery datasets referenced by the application. This does not currently support pagination, but will return all available datasets."
	bigQueryDatasets(
		"Ordering options for items returned from the connection."
		orderBy: BigQueryDatasetOrder
	): BigQueryDatasetConnection!
}

extend type Job {
	"BigQuery datasets referenced by the job. This does not currently support pagination, but will return all available datasets."
	bigQueryDatasets(
		"Ordering options for items returned from the connection."
		orderBy: BigQueryDatasetOrder
	): BigQueryDatasetConnection!
}

extend type TeamInventoryCounts {
	bigQueryDatasets: TeamInventoryCountBigQueryDatasets!
}

type TeamInventoryCountBigQueryDatasets {
	"Total number of BigQuery datasets."
	total: Int!
}

type BigQueryDataset implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")
	teamEnvironment: TeamEnvironment!
	cascadingDelete: Boolean!
	description: String
	access(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		orderBy: BigQueryDatasetAccessOrder
	): BigQueryDatasetAccessConnection!
	status: BigQueryDatasetStatus!
	workload: Workload
}

type BigQueryDatasetAccess {
	role: String!
	email: String!
}

type BigQueryDatasetStatus {
	creationTime: Time!
	lastModifiedTime: Time
}

type BigQueryDatasetAccessConnection {
	pageInfo: PageInfo!
	nodes: [BigQueryDatasetAccess!]!
	edges: [BigQueryDatasetAccessEdge!]!
}

type BigQueryDatasetConnection {
	pageInfo: PageInfo!
	nodes: [BigQueryDataset!]!
	edges: [BigQueryDatasetEdge!]!
}

type BigQueryDatasetAccessEdge {
	cursor: Cursor!
	node: BigQueryDatasetAccess!
}

type BigQueryDatasetEdge {
	cursor: Cursor!
	node: BigQueryDataset!
}

input BigQueryDatasetAccessOrder {
	field: BigQueryDatasetAccessOrderField!
	direction: OrderDirection!
}

input BigQueryDatasetOrder {
	field: BigQueryDatasetOrderField!
	direction: OrderDirection!
}

enum BigQueryDatasetAccessOrderField {
	ROLE
	EMAIL
}

enum BigQueryDatasetOrderField {
	NAME
	ENVIRONMENT
}

extend union SearchNode = BigQueryDataset

extend enum SearchType {
	BIGQUERY_DATASET
}
`, BuiltIn: false},
	{Name: "../schema/bucket.graphqls", Input: `extend type Team {
	"Google Cloud Storage buckets owned by the team."
	buckets(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: BucketOrder
	): BucketConnection!
}

extend type TeamEnvironment {
	"Storage bucket in the team environment."
	bucket(name: String!): Bucket!
}

extend interface Workload {
	"Google Cloud Storage referenced by the workload. This does not currently support pagination, but will return all available buckets."
	buckets(
		"Ordering options for items returned from the connection."
		orderBy: BucketOrder
	): BucketConnection!
}

extend type Application {
	"Google Cloud Storage referenced by the application. This does not currently support pagination, but will return all available buckets."
	buckets(
		"Ordering options for items returned from the connection."
		orderBy: BucketOrder
	): BucketConnection!
}

extend type Job {
	"Google Cloud Storage referenced by the job. This does not currently support pagination, but will return all available buckets."
	buckets(
		"Ordering options for items returned from the connection."
		orderBy: BucketOrder
	): BucketConnection!
}

extend type TeamInventoryCounts {
	buckets: TeamInventoryCountBuckets!
}

type TeamInventoryCountBuckets {
	"Total number of Google Cloud Storage buckets."
	total: Int!
}

type Bucket implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")
	teamEnvironment: TeamEnvironment!
	cascadingDelete: Boolean!
	publicAccessPrevention: String!
	uniformBucketLevelAccess: Boolean!
	workload: Workload
	status: BucketStatus!
}

enum BucketState {
	HEALTHY
	ERROR
	UNKNOWN
}

type BucketStatus {
	state: BucketState!
	errors: [BucketError!]!
}

type BucketError {
	message: String!
	details: String
}

type BucketConnection {
	pageInfo: PageInfo!
	nodes: [Bucket!]!
	edges: [BucketEdge!]!
}

type BucketEdge {
	cursor: Cursor!
	node: Bucket!
}

input BucketOrder {
	field: BucketOrderField!
	direction: OrderDirection!
}

enum BucketOrderField {
	NAME
	ENVIRONMENT
}

extend union SearchNode = Bucket

extend enum SearchType {
	BUCKET
}
`, BuiltIn: false},
	{Name: "../schema/cost.graphqls", Input: `extend type Team {
	"The cost for the team."
	cost: TeamCost!
}

extend type TeamEnvironment {
	"The cost for the team environment."
	cost: TeamEnvironmentCost!
}

type TeamCost {
	daily(
		"Start date of the period, inclusive."
		from: Date!

		"End date of the period, inclusive."
		to: Date!

		"Filter the results."
		filter: TeamCostDailyFilter
	): TeamCostPeriod!

	monthlySummary: TeamCostMonthlySummary!
}

input TeamCostDailyFilter {
	"Services to include in the summary."
	services: [String!]
}

type TeamEnvironmentCost {
	daily(
		"Start date of the period, inclusive."
		from: Date!

		"End date of the period, inclusive."
		to: Date!
	): TeamEnvironmentCostPeriod!
}

type TeamCostMonthlySummary {
	"The total cost for the last 12 months."
	sum: Float!

	"The cost series."
	series: [TeamCostMonthlySample!]!
}

type TeamCostMonthlySample {
	"The last date with cost data in the month."
	date: Date!

	"The total cost for the month."
	cost: Float!
}

type TeamCostPeriod {
	"The total cost for the period."
	sum: Float!

	"The cost series."
	series: [ServiceCostSeries!]!
}

type TeamEnvironmentCostPeriod {
	"The total cost for the period."
	sum: Float!

	"The cost series."
	series: [WorkloadCostSeries!]!
}

extend interface Workload {
	"The cost for a workload."
	cost: WorkloadCost!
}

extend type Application {
	"The cost for the application."
	cost: WorkloadCost!
}

extend type Job {
	"The cost for the job."
	cost: WorkloadCost!
}

type WorkloadCost {
	"Get the cost for a workload within a time period."
	daily(
		"Start date of the period, inclusive."
		from: Date!

		"End date of the period, inclusive."
		to: Date!
	): WorkloadCostPeriod!

	"The cost for the last 12 months."
	monthly: WorkloadCostPeriod!
}

type WorkloadCostPeriod {
	"The total cost for the period."
	sum: Float!

	"The cost series."
	series: [ServiceCostSeries!]!
}

type ServiceCostSeries {
	"The date for the cost. When calculating the cost for a monthly period, the date will be the last day of the month that has cost data."
	date: Date!

	"The sum of the cost across all services."
	sum: Float!

	"The cost for the services used by the workload."
	services: [ServiceCostSample!]!
}

type WorkloadCostSeries {
	"The date for the cost. When calculating the cost for a monthly period, the date will be the last day of the month that has cost data."
	date: Date!

	"The sum of the cost across all workloads."
	sum: Float!

	"The cost for the workloads in the environment."
	workloads: [WorkloadCostSample!]!
}

type ServiceCostSample {
	"The name of the service."
	service: String!

	"The cost in euros."
	cost: Float!
}

type WorkloadCostSample {
	"The workload."
	workload: Workload

	"The name of the workload."
	workloadName: String!

	"The cost in euros."
	cost: Float!
}

extend type OpenSearch {
	cost: OpenSearchCost!
}

type OpenSearchCost {
	sum: Float!
}

extend type RedisInstance {
	cost: RedisInstanceCost! @deprecated(reason: "We are switching to Valkey")
}

type RedisInstanceCost {
	sum: Float! @deprecated(reason: "We are switching to Valkey")
}

extend type ValkeyInstance {
	cost: ValkeyInstanceCost!
}

type ValkeyInstanceCost {
	sum: Float!
}

extend type BigQueryDataset {
	cost: BigQueryDatasetCost!
}

type BigQueryDatasetCost {
	sum: Float!
}

extend type SqlInstance {
	cost: SqlInstanceCost!
}

type SqlInstanceCost {
	sum: Float!
}
`, BuiltIn: false},
	{Name: "../schema/deployment.graphqls", Input: `extend type Team {
	"""
	Deployment key for the team.
	"""
	deploymentKey: DeploymentKey

	"""
	List deployments for a team.
	"""
	deployments(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): DeploymentConnection!
}

extend interface Workload {
	"""
	List of deployments for the workload.
	"""
	deployments(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): DeploymentConnection!
}

extend type Application {
	"""
	List of deployments for the application.
	"""
	deployments(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): DeploymentConnection!
}

extend type Job {
	"""
	List of deployments for the job.
	"""
	deployments(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): DeploymentConnection!
}

extend type Mutation {
	"Update the deploy key of a team. Returns the updated deploy key."
	changeDeploymentKey(input: ChangeDeploymentKeyInput!): ChangeDeploymentKeyPayload!
}

input ChangeDeploymentKeyInput {
	"The name of the team to update the deploy key for."
	teamSlug: Slug!
}

type ChangeDeploymentKeyPayload {
	"The updated deploy key."
	deploymentKey: DeploymentKey
}

"Deployment key type."
type DeploymentKey implements Node {
	"The unique identifier of the deployment key."
	id: ID!

	"The actual key."
	key: String!

	"The date the deployment key was created."
	created: Time!

	"The date the deployment key expires."
	expires: Time!
}

type DeploymentConnection {
	"""
	Pagination information.
	"""
	pageInfo: PageInfo!

	"""
	List of nodes.
	"""
	nodes: [Deployment!]!

	"""
	List of edges.
	"""
	edges: [DeploymentEdge!]!
}

type DeploymentStatusConnection {
	"""
	Pagination information.
	"""
	pageInfo: PageInfo!

	"""
	List of nodes.
	"""
	nodes: [DeploymentStatus!]!

	"""
	List of edges.
	"""
	edges: [DeploymentStatusEdge!]!
}

type DeploymentResourceConnection {
	"""
	Pagination information.
	"""
	pageInfo: PageInfo!

	"""
	List of nodes.
	"""
	nodes: [DeploymentResource!]!

	"""
	List of edges.
	"""
	edges: [DeploymentResourceEdge!]!
}

type DeploymentEdge {
	"""
	Cursor for this edge that can be used for pagination.
	"""
	cursor: Cursor!

	"""
	The deployment.
	"""
	node: Deployment!
}

type DeploymentStatusEdge {
	"""
	Cursor for this edge that can be used for pagination.
	"""
	cursor: Cursor!

	"""
	The deployment status.
	"""
	node: DeploymentStatus!
}

type DeploymentResourceEdge {
	"""
	Cursor for this edge that can be used for pagination.
	"""
	cursor: Cursor!

	"""
	The deployment resource.
	"""
	node: DeploymentResource!
}

"""
Description of a deployment.
"""
type Deployment implements Node {
	"""
	ID of the deployment.
	"""
	id: ID!

	"""
	Creation timestamp of the deployment.
	"""
	createdAt: Time!

	"""
	Team slug that the deployment belongs to.
	"""
	teamSlug: Slug!

	"""
	Name of the environment that the deployment belongs to.
	"""
	environmentName: String!

	"""
	The repository that triggered the deployment.
	"""
	repository: String

	"""
	Username of the actor who initiated the deployment.
	"""
	deployerUsername: String

	"""
	The git commit SHA that was deployed.
	"""
	commitSha: String

	"""
	The URL of the workflow that triggered the deployment.
	"""
	triggerUrl: String

	"""
	Resources that were deployed.
	"""
	resources(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): DeploymentResourceConnection!

	"""
	Statuses of the deployment.
	"""
	statuses(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): DeploymentStatusConnection!
}

"""
Resource connected to a deployment.
"""
type DeploymentResource implements Node {
	"""
	Globally unique ID of the deployment resource.
	"""
	id: ID!

	"""
	Deployment resource kind.
	"""
	kind: String!

	"""
	The name of the resource.
	"""
	name: String!
}

"""
Resource connected to a deployment.
"""
type DeploymentStatus implements Node {
	"""
	Globally unique ID of the deployment resource.
	"""
	id: ID!

	"""
	Creation timestamp of the deployment status.
	"""
	createdAt: Time!

	"""
	State of the deployment.
	"""
	state: DeploymentStatusState!

	"""
	Message describing the deployment status.
	"""
	message: String!
}

"""
Possible states of a deployment status.
"""
enum DeploymentStatusState {
	SUCCESS
	ERROR
	FAILURE
	INACTIVE
	IN_PROGRESS
	QUEUED
	PENDING
}

extend enum ApplicationOrderField {
	"Order applications by the deployment time."
	DEPLOYMENT_TIME
}

extend enum JobOrderField {
	"Order applications by the deployment time."
	DEPLOYMENT_TIME
}

extend enum ActivityLogEntryResourceType {
	"All activity log entries related to deploy keys will use this resource type."
	DEPLOY_KEY
}

type TeamDeployKeyUpdatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}
`, BuiltIn: false},
	{Name: "../schema/environments.graphqls", Input: `extend type Query {
	"""
	Get a list of environments.
	"""
	environments(
		"""
		Ordering options for environments.
		"""
		orderBy: EnvironmentOrder
	): EnvironmentConnection!

	"""
	Get a single environment.
	"""
	environment(
		"""
		The name of the environment to get.
		"""
		name: String!
	): Environment!
}

"""
Environment connection.
"""
type EnvironmentConnection {
	"""
	Pagination information.
	"""
	pageInfo: PageInfo!

	"""
	List of nodes.
	"""
	nodes: [Environment!]!

	"""
	List of edges.
	"""
	edges: [EnvironmentEdge!]!
}

"""
Environment edge.
"""
type EnvironmentEdge {
	"""
	Cursor for this edge that can be used for pagination.
	"""
	cursor: Cursor!

	"""
	The Environment.
	"""
	node: Environment!
}

"""
Ordering options when fetching environments.
"""
input EnvironmentOrder {
	"""
	The field to order by.
	"""
	field: EnvironmentOrderField!

	"""
	The direction to order in.
	"""
	direction: OrderDirection!
}

"""
Fields to order environments by.
"""
enum EnvironmentOrderField {
	"""
	Order by name.
	"""
	NAME
}

"""
An environment represents a runtime environment for workloads.

Learn more in the [official Nais documentation](https://docs.nais.io/workloads/explanations/environment/).
"""
type Environment implements Node {
	"""
	The globally unique ID of the team.
	"""
	id: ID!

	"""
	Unique name of the environment.
	"""
	name: String!
}

extend type TeamEnvironment {
	"""
	Get the environment.
	"""
	environment: Environment!
}
`, BuiltIn: false},
	{Name: "../schema/feature.graphqls", Input: `type Features implements Node {
	"""
	Unique identifier for the feature container.
	"""
	id: ID!

	"""
	Information about Unleash feature.
	"""
	unleash: FeatureUnleash!

	"""
	Information about Redis feature.
	"""
	redis: FeatureRedis! @deprecated(reason: "We are switching to Valkey")

	"""
	Information about Valkey feature.
	"""
	valkey: FeatureValkey!

	"""
	Information about Kafka feature.
	"""
	kafka: FeatureKafka!

	"""
	Information about OpenSearch feature.
	"""
	openSearch: FeatureOpenSearch!
}

extend type Query {
	"""
	Feature flags.
	"""
	features: Features!
}

type FeatureUnleash implements Node {
	"""
	Unique identifier for the feature.
	"""
	id: ID!

	"""
	Wether Unleash is enabled or not.
	"""
	enabled: Boolean!
}

type FeatureRedis implements Node {
	"""
	Unique identifier for the feature.
	"""
	id: ID!

	"""
	Wether Redis is enabled or not.
	"""
	enabled: Boolean!
}

type FeatureValkey implements Node {
	"""
	Unique identifier for the feature.
	"""
	id: ID!

	"""
	Wether Valkey is enabled or not.
	"""
	enabled: Boolean!
}

type FeatureKafka implements Node {
	"""
	Unique identifier for the feature.
	"""
	id: ID!

	"""
	Wether Kafka is enabled or not.
	"""
	enabled: Boolean!
}

type FeatureOpenSearch implements Node {
	"""
	Unique identifier for the feature.
	"""
	id: ID!

	"""
	Wether OpenSearch is enabled or not.
	"""
	enabled: Boolean!
}
`, BuiltIn: false},
	{Name: "../schema/jobs.graphqls", Input: `extend type Team {
	"Nais jobs owned by the team."
	jobs(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: JobOrder

		"Filtering options for items returned from the connection."
		filter: TeamJobsFilter
	): JobConnection!
}

extend type Mutation {
	"Delete a job."
	deleteJob(input: DeleteJobInput!): DeleteJobPayload!

	"Trigger a job"
	triggerJob(input: TriggerJobInput!): TriggerJobPayload!
}

extend type TeamEnvironment {
	"Nais job in the team environment."
	job(name: String!): Job!
}

extend type TeamInventoryCounts {
	jobs: TeamInventoryCountJobs!
}

extend enum ActivityLogEntryResourceType {
	"All activity log entries related to jobs will use this resource type."
	JOB
}

input TeamJobsFilter {
	"""
	Filter by the name of the application.
	"""
	name: String!

	"""
	Filter by the name of the environment.
	"""
	environments: [String!]
}
type Job implements Node & Workload {
	"The globally unique ID of the job."
	id: ID!

	"The name of the job."
	name: String!

	"The team that owns the job."
	team: Team!

	"The environment the job is deployed in."
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")

	"The team environment for the job."
	teamEnvironment: TeamEnvironment!

	"The container image of the job."
	image: ContainerImage!

	"Resources for the job."
	resources: JobResources!

	"List of authentication and authorization for the job."
	authIntegrations: [JobAuthIntegrations!]!

	"Optional schedule for the job. Jobs with no schedule are run once."
	schedule: JobSchedule

	"The job runs."
	runs(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): JobRunConnection!

	"The job manifest."
	manifest: JobManifest!

	"""
	If set, when the job was marked for deletion.
	"""
	deletionStartedAt: Time
}

type JobManifest implements WorkloadManifest {
	"The manifest content, serialized as a YAML document."
	content: String!
}

type JobSchedule {
	"The cron expression for the job."
	expression: String!

	"The time zone for the job. Defaults to UTC."
	timeZone: String!
}

union JobAuthIntegrations = EntraIDAuthIntegration | MaskinportenAuthIntegration

type JobResources implements WorkloadResources {
	limits: WorkloadResourceQuantity!
	requests: WorkloadResourceQuantity!
}

enum JobRunTriggerType {
	# Triggered by a cron job or schedule
	AUTOMATIC
	# Triggered by a user
	MANUAL
}

type JobRunTrigger {
	"The type of trigger that started the job."
	type: JobRunTriggerType!

	"The actor/user who triggered the job run manually, if applicable."
	actor: String
}

type JobRun implements Node {
	"The globally unique ID of the job run."
	id: ID!

	"The name of the job run."
	name: String!

	"The start time of the job."
	startTime: Time

	"The completion time of the job."
	completionTime: Time

	"The status of the job run."
	status: JobRunStatus!

	"The container image of the job run."
	image: ContainerImage!

	"Duration of the job in seconds."
	duration: Int!

	"Job run instances."
	instances(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): JobRunInstanceConnection!

	trigger: JobRunTrigger!
}

type JobRunInstance implements Node {
	"The globally unique ID of the job run instance."
	id: ID!

	"The name of the job run instance."
	name: String!
}

type JobRunStatus {
	"The state of the job run."
	state: JobRunState!

	"Human readable job run status."
	message: String!
}

enum JobRunState {
	"Job run is pending."
	PENDING

	"Job run is running."
	RUNNING

	"Job run is succeeded."
	SUCCEEDED

	"Job run is failed."
	FAILED

	"Job run is unknown."
	UNKNOWN
}

type JobConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Job!]!

	"List of edges."
	edges: [JobEdge!]!
}

type JobRunInstanceConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [JobRunInstance!]!

	"List of edges."
	edges: [JobRunInstanceEdge!]!
}

type JobRunConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [JobRun!]!

	"List of edges."
	edges: [JobRunEdge!]!
}

type JobEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The job."
	node: Job!
}

type JobRunEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The job run."
	node: JobRun!
}

type JobRunInstanceEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The instance."
	node: JobRunInstance!
}

type TeamInventoryCountJobs {
	"Total number of jobs."
	total: Int!

	"Number of jobs considered not nais."
	notNais: Int!
}

input JobOrder {
	"The field to order items by."
	field: JobOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

enum JobOrderField {
	"Order jobs by name."
	NAME

	"Order jobs by the name of the environment."
	ENVIRONMENT
}

extend union SearchNode = Job
extend enum SearchType {
	JOB
}

input DeleteJobInput {
	"Name of the job."
	name: String!

	"Slug of the team that owns the job."
	teamSlug: Slug!

	"Name of the environment where the job runs."
	environmentName: String!
}

type DeleteJobPayload {
	"The team that owned the deleted job."
	team: Team

	"Whether or not the application was deleted."
	success: Boolean
}

input TriggerJobInput {
	"Name of the job."
	name: String!

	"Slug of the team that owns the job."
	teamSlug: Slug!

	"Name of the environment where the job runs."
	environmentName: String!

	"Name of the new run. Must be unique within the team."
	runName: String!
}

type TriggerJobPayload {
	"The job that was triggered."
	job: Job

	"The new job run."
	jobRun: JobRun
}

type JobDeletedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type JobTriggeredActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}
`, BuiltIn: false},
	{Name: "../schema/kafka.graphqls", Input: `extend type Team {
	"Kafka topics owned by the team."
	kafkaTopics(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: KafkaTopicOrder
	): KafkaTopicConnection!
}

extend type TeamEnvironment {
	"Kafka topic in the team environment."
	kafkaTopic(name: String!): KafkaTopic!
}

extend interface Workload {
	"Kafka topics the workload has access to. This does not currently support pagination, but will return all available Kafka topics."
	kafkaTopicAcls(
		"Ordering options for items returned from the connection."
		orderBy: KafkaTopicAclOrder
	): KafkaTopicAclConnection!
}

extend type Application {
	"Kafka topics the application has access to. This does not currently support pagination, but will return all available Kafka topics."
	kafkaTopicAcls(
		"Ordering options for items returned from the connection."
		orderBy: KafkaTopicAclOrder
	): KafkaTopicAclConnection!
}

extend type Job {
	"Kafka topics the job has access to. This does not currently support pagination, but will return all available Kafka topics."
	kafkaTopicAcls(
		"Ordering options for items returned from the connection."
		orderBy: KafkaTopicAclOrder
	): KafkaTopicAclConnection!
}

extend type TeamInventoryCounts {
	kafkaTopics: TeamInventoryCountKafkaTopics!
}

type TeamInventoryCountKafkaTopics {
	"Total number of Kafka topics."
	total: Int!
}

type KafkaTopic implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")
	teamEnvironment: TeamEnvironment!
	acl(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		filter: KafkaTopicAclFilter
		orderBy: KafkaTopicAclOrder
	): KafkaTopicAclConnection!
	configuration: KafkaTopicConfiguration
	pool: String!
}

type KafkaTopicAcl {
	access: String!
	workloadName: String!
	teamName: String!
	team: Team
	workload: Workload
	topic: KafkaTopic!
}

type KafkaTopicConfiguration {
	cleanupPolicy: String
	maxMessageBytes: Int
	minimumInSyncReplicas: Int
	partitions: Int
	replication: Int
	retentionBytes: Int
	retentionHours: Int
	segmentHours: Int
}

type KafkaTopicConnection {
	pageInfo: PageInfo!
	nodes: [KafkaTopic!]!
	edges: [KafkaTopicEdge!]!
}

type KafkaTopicAclConnection {
	pageInfo: PageInfo!
	nodes: [KafkaTopicAcl!]!
	edges: [KafkaTopicAclEdge!]!
}

type KafkaTopicEdge {
	cursor: Cursor!
	node: KafkaTopic!
}

type KafkaTopicAclEdge {
	cursor: Cursor!
	node: KafkaTopicAcl!
}

input KafkaTopicAclFilter {
	team: Slug
	workload: String
	validWorkloads: Boolean
}

input KafkaTopicOrder {
	field: KafkaTopicOrderField!
	direction: OrderDirection!
}

input KafkaTopicAclOrder {
	field: KafkaTopicAclOrderField!
	direction: OrderDirection!
}

enum KafkaTopicOrderField {
	NAME
	ENVIRONMENT
}

enum KafkaTopicAclOrderField {
	TOPIC_NAME
	TEAM_SLUG
	CONSUMER
	ACCESS
}

extend union SearchNode = KafkaTopic

extend enum SearchType {
	KAFKA_TOPIC
}
`, BuiltIn: false},
	{Name: "../schema/logging.graphqls", Input: `extend interface Workload {
	"List of log destinations for the workload."
	logDestinations: [LogDestination!]!
}

extend type Application {
	"List of log destinations for the application."
	logDestinations: [LogDestination!]!
}

extend type Job {
	"List of log destinations for the job."
	logDestinations: [LogDestination!]!
}

interface LogDestination implements Node {
	"The globally unique ID of the log destination."
	id: ID!
}

type LogDestinationLoki implements LogDestination & Node {
	"The globally unique ID of the log destination."
	id: ID!
	"Grafana URL to view the logs."
	grafanaURL: String!
}

type LogDestinationSecureLogs implements LogDestination & Node {
	"The globally unique ID of the log destination."
	id: ID!
}
`, BuiltIn: false},
	{Name: "../schema/netpol.graphqls", Input: `extend interface Workload {
	"Network policies for the workload."
	networkPolicy: NetworkPolicy!
}

extend type Application {
	"Network policies for the application."
	networkPolicy: NetworkPolicy!
}

extend type Job {
	"Network policies for the job."
	networkPolicy: NetworkPolicy!
}

interface ExternalNetworkPolicyTarget {
	target: String!
	ports: [Int!]!
}

type ExternalNetworkPolicyHost implements ExternalNetworkPolicyTarget {
	target: String!
	ports: [Int!]!
}

type ExternalNetworkPolicyIpv4 implements ExternalNetworkPolicyTarget {
	target: String!
	ports: [Int!]!
}

type NetworkPolicyRule {
	targetWorkloadName: String!
	targetWorkload: Workload
	targetTeamSlug: Slug!
	targetTeam: Team
	mutual: Boolean!
}

type InboundNetworkPolicy {
	rules: [NetworkPolicyRule!]!
}

type OutboundNetworkPolicy {
	rules: [NetworkPolicyRule!]!
	external: [ExternalNetworkPolicyTarget!]!
}

type NetworkPolicy {
	inbound: InboundNetworkPolicy!
	outbound: OutboundNetworkPolicy!
}
`, BuiltIn: false},
	{Name: "../schema/opensearch.graphqls", Input: `extend type Team {
	"OpenSearch instances owned by the team."
	openSearchInstances(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: OpenSearchOrder
	): OpenSearchConnection!
}

extend type TeamEnvironment {
	"OpenSearch instance in the team environment."
	openSearchInstance(name: String!): OpenSearch!
}

extend interface Workload {
	"OpenSearch instance referenced by the workload."
	openSearch: OpenSearch
}

extend type Application {
	"OpenSearch instance referenced by the workload."
	openSearch: OpenSearch
}

extend type Job {
	"OpenSearch instance referenced by the workload."
	openSearch: OpenSearch
}

extend type TeamInventoryCounts {
	openSearchInstances: TeamInventoryCountOpenSearchInstances!
}

type TeamInventoryCountOpenSearchInstances {
	"Total number of OpenSearch instances."
	total: Int!
}

type OpenSearch implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")
	teamEnvironment: TeamEnvironment!
	status: OpenSearchStatus!
	workload: Workload
	access(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		orderBy: OpenSearchAccessOrder
	): OpenSearchAccessConnection!
}

type OpenSearchAccess {
	workload: Workload!
	access: String!
}

type OpenSearchStatus {
	state: String!
}

type OpenSearchAccessConnection {
	pageInfo: PageInfo!
	nodes: [OpenSearchAccess!]!
	edges: [OpenSearchAccessEdge!]!
}

type OpenSearchConnection {
	pageInfo: PageInfo!
	nodes: [OpenSearch!]!
	edges: [OpenSearchEdge!]!
}

type OpenSearchAccessEdge {
	cursor: Cursor!
	node: OpenSearchAccess!
}

type OpenSearchEdge {
	cursor: Cursor!
	node: OpenSearch!
}

input OpenSearchAccessOrder {
	field: OpenSearchAccessOrderField!
	direction: OrderDirection!
}

input OpenSearchOrder {
	field: OpenSearchOrderField!
	direction: OrderDirection!
}

enum OpenSearchAccessOrderField {
	ACCESS
	WORKLOAD
}

enum OpenSearchOrderField {
	NAME
	ENVIRONMENT
}

extend union SearchNode = OpenSearch

extend enum SearchType {
	OPENSEARCH
}
`, BuiltIn: false},
	{Name: "../schema/persistence.graphqls", Input: `interface Persistence implements Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")
	teamEnvironment: TeamEnvironment!
}
`, BuiltIn: false},
	{Name: "../schema/podlog.graphqls", Input: `type Subscription {
	"""
	Subscribe to workload logs

	This subscription is used to stream logs from a specific workload. When filtering logs you must either specify an
	application or a job owned by a team that is running in a specific environment. You can also filter logs on instance
	name(s).
	"""
	workloadLog(filter: WorkloadLogSubscriptionFilter!): WorkloadLogLine!
}

input WorkloadLogSubscriptionFilter {
	"Filter logs to a specific team."
	team: Slug!

	"Filter logs to a specific environment."
	environment: String!

	"Filter logs to a specific application."
	application: String

	"Filter logs to a specific job."
	job: String

	"Filter logs to a set of specific instance names."
	instances: [String!]
}

type WorkloadLogLine {
	"The timestamp of the log line."
	time: Time!

	"The log message."
	message: String!

	"The name of the instance that generated the log line."
	instance: String!
}
`, BuiltIn: false},
	{Name: "../schema/reconcilers.graphqls", Input: `extend type Mutation {
	"""
	Enable a reconciler

	A reconciler must be fully configured before it can be enabled.
	"""
	enableReconciler(input: EnableReconcilerInput!): Reconciler!

	"""
	Disable a reconciler

	The reconciler configuration will be left intact.
	"""
	disableReconciler(input: DisableReconcilerInput!): Reconciler!

	"Configure a reconciler."
	configureReconciler(input: ConfigureReconcilerInput!): Reconciler!
}

extend type Query {
	"Get a collection of reconcilers."
	reconcilers(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): ReconcilerConnection!
}

extend enum ActivityLogEntryResourceType {
	"All activity log entries related to reconcilers will use this resource type."
	RECONCILER
}

type ReconcilerConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Reconciler!]!

	"List of edges."
	edges: [ReconcilerEdge!]!
}

type ReconcilerEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The reconciler."
	node: Reconciler!
}

"Reconciler type."
type Reconciler implements Node {
	"Unique identifier for the reconciler."
	id: ID!

	"The name of the reconciler."
	name: String!

	"The human-friendly name of the reconciler."
	displayName: String!

	"Description of what the reconciler is responsible for."
	description: String!

	"Whether or not the reconciler is enabled."
	enabled: Boolean!

	"Reconciler configuration keys and descriptions."
	config: [ReconcilerConfig!]!

	"Whether or not the reconciler is fully configured and ready to be enabled."
	configured: Boolean!

	"Potential errors that have occurred during the reconciler's operation."
	errors(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): ReconcilerErrorConnection!
}

type ReconcilerErrorConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [ReconcilerError!]!

	"List of edges."
	edges: [ReconcilerErrorEdge!]!
}

type ReconcilerErrorEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The reconcilerError."
	node: ReconcilerError!
}

type ReconcilerError implements Node {
	"""
	Unique identifier for the reconciler error.
	"""
	id: ID!

	"""
	The correlation ID for the reconciler error.
	"""
	correlationID: String!

	"""
	Creation timestamp of the reconciler error.
	"""
	createdAt: Time!

	"""
	The error message itself.
	"""
	message: String!

	"""
	The team that the error belongs to.
	"""
	team: Team!
}

"Reconciler configuration type."
type ReconcilerConfig {
	"Configuration key."
	key: String!

	"The human-friendly name of the configuration key."
	displayName: String!

	"Configuration description."
	description: String!

	"Whether or not the configuration key has a value."
	configured: Boolean!

	"Whether or not the configuration value is considered a secret. Secret values will not be exposed through the API."
	secret: Boolean!

	"Configuration value. This will be set to null if the value is considered a secret."
	value: String
}

"Reconciler configuration input."
input ReconcilerConfigInput {
	"Configuration key."
	key: String!

	"Configuration value."
	value: String!
}

type ReconcilerEnabledActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type ReconcilerDisabledActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type ReconcilerConfiguredActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the update."
	data: ReconcilerConfiguredActivityLogEntryData!
}

type ReconcilerConfiguredActivityLogEntryData {
	"Keys that were updated."
	updatedKeys: [String!]!
}

input EnableReconcilerInput {
	"The name of the reconciler to enable."
	name: String!
}

input DisableReconcilerInput {
	"The name of the reconciler to disable."
	name: String!
}

input ConfigureReconcilerInput {
	"The name of the reconciler to configure."
	name: String!

	"List of reconciler config inputs."
	config: [ReconcilerConfigInput!]!
}
`, BuiltIn: false},
	{Name: "../schema/redis.graphqls", Input: `extend type Team {
	"Redis instances owned by the team."
	redisInstances(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: RedisInstanceOrder
	): RedisInstanceConnection! @deprecated(reason: "We are switching to Valkey")
}

extend type TeamEnvironment {
	"Redis instance in the team environment."
	redisInstance(name: String!): RedisInstance! @deprecated(reason: "We are switching to Valkey")
}

extend interface Workload {
	"Redis instances referenced by the workload. This does not currently support pagination, but will return all available Redis instances."
	redisInstances(
		"Ordering options for items returned from the connection."
		orderBy: RedisInstanceOrder
	): RedisInstanceConnection! @deprecated(reason: "We are switching to Valkey")
}

extend type Application {
	"Redis instances referenced by the application. This does not currently support pagination, but will return all available Redis instances."
	redisInstances(
		"Ordering options for items returned from the connection."
		orderBy: RedisInstanceOrder
	): RedisInstanceConnection! @deprecated(reason: "We are switching to Valkey")
}

extend type Job {
	"Redis instances referenced by the job. This does not currently support pagination, but will return all available Redis instances."
	redisInstances(
		"Ordering options for items returned from the connection."
		orderBy: RedisInstanceOrder
	): RedisInstanceConnection! @deprecated(reason: "We are switching to Valkey")
}

extend type TeamInventoryCounts {
	redisInstances: TeamInventoryCountRedisInstances!
		@deprecated(reason: "We are switching to Valkey")
}

type TeamInventoryCountRedisInstances {
	"Total number of Redis instances."
	total: Int!
}

type RedisInstance implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")
	teamEnvironment: TeamEnvironment!
	access(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		orderBy: RedisInstanceAccessOrder
	): RedisInstanceAccessConnection!
	workload: Workload
	status: RedisInstanceStatus!
}

type RedisInstanceAccess {
	workload: Workload!
	access: String!
}

type RedisInstanceStatus {
	state: String!
}

type RedisInstanceAccessConnection {
	pageInfo: PageInfo!
	nodes: [RedisInstanceAccess!]!
	edges: [RedisInstanceAccessEdge!]!
}

type RedisInstanceConnection {
	pageInfo: PageInfo!
	nodes: [RedisInstance!]!
	edges: [RedisInstanceEdge!]!
}

type RedisInstanceAccessEdge {
	cursor: Cursor!
	node: RedisInstanceAccess!
}

type RedisInstanceEdge {
	cursor: Cursor!
	node: RedisInstance!
}

input RedisInstanceAccessOrder {
	field: RedisInstanceAccessOrderField! @deprecated(reason: "We are switching to Valkey")
	direction: OrderDirection!
}

input RedisInstanceOrder {
	field: RedisInstanceOrderField! @deprecated(reason: "We are switching to Valkey")
	direction: OrderDirection!
}

enum RedisInstanceAccessOrderField {
	ACCESS @deprecated(reason: "We are switching to Valkey")
	WORKLOAD @deprecated(reason: "We are switching to Valkey")
}

enum RedisInstanceOrderField {
	NAME @deprecated(reason: "We are switching to Valkey")
	ENVIRONMENT @deprecated(reason: "We are switching to Valkey")
}

extend union SearchNode = RedisInstance

extend enum SearchType {
	REDIS_INSTANCE @deprecated(reason: "We are switching to Valkey")
}
`, BuiltIn: false},
	{Name: "../schema/repository.graphqls", Input: `extend type Team {
	repositories(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: RepositoryOrder

		filter: TeamRepositoryFilter
	): RepositoryConnection!
}

extend type Mutation {
	"Add a team repository."
	addRepositoryToTeam(input: AddRepositoryToTeamInput!): AddRepositoryToTeamPayload!

	"Remove a team repository."
	removeRepositoryFromTeam(input: RemoveRepositoryFromTeamInput!): RemoveRepositoryFromTeamPayload!
}

extend enum ActivityLogEntryResourceType {
	"All activity log entries related to repositories will use this resource type."
	REPOSITORY
}

input AddRepositoryToTeamInput {
	"Slug of the team to add the repository to."
	teamSlug: Slug!

	"Name of the repository, with the org prefix, for instance 'org/repo'."
	repositoryName: String!
}

type AddRepositoryToTeamPayload {
	"Repository that was added to the team."
	repository: Repository
}

input RemoveRepositoryFromTeamInput {
	"Slug of the team to remove the repository from."
	teamSlug: Slug!

	"Name of the repository, with the org prefix, for instance 'org/repo'."
	repositoryName: String!
}

type RemoveRepositoryFromTeamPayload {
	"Whether or not the repository was removed from the team."
	success: Boolean
}

type RepositoryConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Repository!]!

	"List of edges."
	edges: [RepositoryEdge!]!
}

type RepositoryEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The GitHub repository."
	node: Repository!
}

type Repository implements Node {
	"ID of the repository."
	id: ID!

	"Name of the repository, with the organization prefix."
	name: String!

	"Team this repository is connected to."
	team: Team!
}

input TeamRepositoryFilter {
	"Filter by repository name containing the phrase."
	name: String
}

"Ordering options when fetching repositories."
input RepositoryOrder {
	"The field to order items by."
	field: RepositoryOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

enum RepositoryOrderField {
	"Order repositories by name."
	NAME
}

type RepositoryAddedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type RepositoryRemovedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}
`, BuiltIn: false},
	{Name: "../schema/scalars.graphqls", Input: `"""
Time is a string in [RFC 3339](https://rfc-editor.org/rfc/rfc3339.html) format, with sub-second precision added if present.
"""
scalar Time

"""
Date type in YYYY-MM-DD format.
"""
scalar Date

"""
The slug must:

- contain only lowercase alphanumeric characters or hyphens
- contain at least 3 characters and at most 30 characters
- start with an alphabetic character
- end with an alphanumeric character
- not contain two hyphens in a row

Examples of valid slugs:

- ` + "`" + `some-value` + "`" + `
- ` + "`" + `someothervalue` + "`" + `
- ` + "`" + `my-team-123` + "`" + `
"""
scalar Slug

"""
A cursor for use in pagination

Cursors are opaque strings that are returned by the server for paginated results, and used when performing backwards / forwards pagination.
"""
scalar Cursor
`, BuiltIn: false},
	{Name: "../schema/schema.graphqls", Input: `"""
The query root for the Nais GraphQL API.
"""
type Query {
	"""
	Fetch an object using its globally unique ID.
	"""
	node(
		"""
		The ID of the object to fetch.
		"""
		id: ID!
	): Node
}

"""
The mutation root for the Nais GraphQL API.
"""
type Mutation

"""
This interface is implemented by types that supports the [Global Object Identification specification](https://graphql.org/learn/global-object-identification/).
"""
interface Node {
	"""
	Globally unique ID of the object.
	"""
	id: ID!
}

"""
This type is used for paginating the connection

Learn more about how we have implemented pagination in the [GraphQL Best Practices documentation](https://graphql.org/learn/pagination/).
"""
type PageInfo {
	"""
	Whether or not there exists a next page in the connection.
	"""
	hasNextPage: Boolean!

	"""
	The cursor for the last item in the edges. This cursor is used when paginating forwards.
	"""
	endCursor: Cursor

	"""
	Whether or not there exists a previous page in the connection.
	"""
	hasPreviousPage: Boolean!

	"""
	The cursor for the first item in the edges. This cursor is used when paginating backwards.
	"""
	startCursor: Cursor

	"""
	The total amount of items in the connection.
	"""
	totalCount: Int!

	"""
	The offset of the first item in the connection.
	"""
	pageStart: Int!

	"""
	The offset of the last item in the connection.
	"""
	pageEnd: Int!
}

"""
Possible directions in which to order a list of items.
"""
enum OrderDirection {
	"""
	Ascending sort order.
	"""
	ASC

	"""
	Descending sort order.
	"""
	DESC
}
`, BuiltIn: false},
	{Name: "../schema/search.graphqls", Input: `extend type Query {
	"""
	Search for entities.
	"""
	search(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor

		"""
		Filter the search results.
		"""
		filter: SearchFilter!
	): SearchNodeConnection!
}

"""
Types that can be searched for.
"""
union SearchNode = Team

"""
Search filter for filtering search results.
"""
input SearchFilter {
	"""
	The query string.
	"""
	query: String!

	"""
	The type of entities to search for. If not specified, all types will be searched.
	"""
	type: SearchType
}

"""
Search node connection.
"""
type SearchNodeConnection {
	"""
	Pagination information.
	"""
	pageInfo: PageInfo!

	"""
	List of nodes.
	"""
	nodes: [SearchNode!]!

	"""
	List of edges.
	"""
	edges: [SearchNodeEdge!]!
}

"""
Search node edge.
"""
type SearchNodeEdge {
	"""
	Cursor for this edge that can be used for pagination.
	"""
	cursor: Cursor!

	"""
	The SearchNode.
	"""
	node: SearchNode!
}

"""
A list of possible search types.
"""
enum SearchType {
	"""
	Search for teams.
	"""
	TEAM
}
`, BuiltIn: false},
	{Name: "../schema/secret.graphqls", Input: `extend type Mutation {
	"Create a new secret."
	createSecret(input: CreateSecretInput!): CreateSecretPayload!

	"Add a secret value to a secret."
	addSecretValue(input: AddSecretValueInput!): AddSecretValuePayload!

	"Update a secret value within a secret."
	updateSecretValue(input: UpdateSecretValueInput!): UpdateSecretValuePayload!

	"Remove a secret value from a secret."
	removeSecretValue(input: RemoveSecretValueInput!): RemoveSecretValuePayload!

	"Delete a secret, and the values it contains."
	deleteSecret(input: DeleteSecretInput!): DeleteSecretPayload!
}

extend type Team {
	"Secrets owned by the team."
	secrets(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: SecretOrder

		"Filtering options for items returned from the connection."
		filter: SecretFilter
	): SecretConnection!
}

"""
Input for filtering the secrets of a team.
"""
input SecretFilter {
	"""
	Filter by usage of the secret.
	"""
	inUse: Boolean
}

extend type TeamEnvironment {
	"Get a secret by name."
	secret(name: String!): Secret!
}

extend interface Workload {
	"Secrets used by the workload."
	secrets(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): SecretConnection!
}

extend type Application {
	"Secrets used by the application."
	secrets(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): SecretConnection!
}

extend type Job {
	"Secrets used by the job."
	secrets(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): SecretConnection!
}

"A secret is a collection of secret values."
type Secret implements Node {
	"The globally unique ID of the secret."
	id: ID!

	"The name of the secret."
	name: String!

	"The environment the secret exists in."
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")

	"The environment the secret exists in."
	teamEnvironment: TeamEnvironment!

	"The team that owns the secret."
	team: Team!

	"The secret values contained within the secret."
	values: [SecretValue!]!

	"Applications that use the secret."
	applications(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): ApplicationConnection!

	"Jobs that use the secret."
	jobs(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): JobConnection!

	"Workloads that use the secret."
	workloads(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): WorkloadConnection!

	"Last time the secret was modified."
	lastModifiedAt: Time

	"User who last modified the secret."
	lastModifiedBy: User
}

input SecretValueInput {
	"The name of the secret value."
	name: String!

	"The secret value to set."
	value: String!
}

input CreateSecretInput {
	"The name of the secret."
	name: String!

	"The environment the secret exists in."
	environment: String!

	"The team that owns the secret."
	team: Slug!
}

input AddSecretValueInput {
	"The name of the secret."
	name: String!

	"The environment the secret exists in."
	environment: String!

	"The team that owns the secret."
	team: Slug!

	"The secret value to set."
	value: SecretValueInput!
}

input UpdateSecretValueInput {
	"The name of the secret."
	name: String!

	"The environment the secret exists in."
	environment: String!

	"The team that owns the secret."
	team: Slug!

	"The secret value to set."
	value: SecretValueInput!
}

input RemoveSecretValueInput {
	"The name of the secret."
	secretName: String!

	"The environment the secret exists in."
	environment: String!

	"The team that owns the secret."
	team: Slug!

	"The secret value to remove."
	valueName: String!
}

input DeleteSecretInput {
	"The name of the secret."
	name: String!

	"The environment the secret exists in."
	environment: String!

	"The team that owns the secret."
	team: Slug!
}

type CreateSecretPayload {
	"The created secret."
	secret: Secret
}

input SecretOrder {
	"The field to order items by."
	field: SecretOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

enum SecretOrderField {
	"Order secrets by name."
	NAME

	"Order secrets by the name of the environment."
	ENVIRONMENT

	"Order secrets by the last time it was modified."
	LAST_MODIFIED_AT
}

type AddSecretValuePayload {
	"The updated secret."
	secret: Secret
}

type UpdateSecretValuePayload {
	"The updated secret."
	secret: Secret
}

type RemoveSecretValuePayload {
	"The updated secret."
	secret: Secret
}

type DeleteSecretPayload {
	"The deleted secret."
	secretDeleted: Boolean
}

type SecretConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Secret!]!

	"List of edges."
	edges: [SecretEdge!]!
}

type SecretEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The Secret."
	node: Secret!
}

type SecretValue {
	"The name of the secret value."
	name: String!

	"The secret value itself."
	value: String!
}

extend enum ActivityLogEntryResourceType {
	"All activity log entries related to secrets will use this resource type."
	SECRET
}

type SecretCreatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type SecretValueAddedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the entry."
	data: SecretValueAddedActivityLogEntryData!
}

type SecretValueAddedActivityLogEntryData {
	"The name of the added value."
	valueName: String!
}

type SecretValueUpdatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the entry."
	data: SecretValueUpdatedActivityLogEntryData!
}

type SecretValueUpdatedActivityLogEntryData {
	"The name of the updated value."
	valueName: String!
}

type SecretValueRemovedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the entry."
	data: SecretValueRemovedActivityLogEntryData!
}

type SecretValueRemovedActivityLogEntryData {
	"The name of the removed value."
	valueName: String!
}

type SecretDeletedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}
`, BuiltIn: false},
	{Name: "../schema/serviceaccounts.graphqls", Input: `extend type Query {
	"""
	Get a list of service accounts.
	"""
	serviceAccounts(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor
	): ServiceAccountConnection!

	"""
	Returns a service account by its ID.
	"""
	serviceAccount(
		"""
		ID of the service account.
		"""
		id: ID!
	): ServiceAccount!
}

extend type Mutation {
	"""
	Create a service account.
	"""
	createServiceAccount(input: CreateServiceAccountInput!): CreateServiceAccountPayload!

	"""
	Update a service account.
	"""
	updateServiceAccount(input: UpdateServiceAccountInput!): UpdateServiceAccountPayload!

	"""
	Delete a service account.
	"""
	deleteServiceAccount(input: DeleteServiceAccountInput!): DeleteServiceAccountPayload!

	"""
	Assign a role to a service account.
	"""
	assignRoleToServiceAccount(
		input: AssignRoleToServiceAccountInput!
	): AssignRoleToServiceAccountPayload!

	"""
	Revoke a role from a service account.
	"""
	revokeRoleFromServiceAccount(
		input: RevokeRoleFromServiceAccountInput!
	): RevokeRoleFromServiceAccountPayload!

	"""
	Create a service account token.

	The secret is automatically generated, and is returned as a part of the payload for this mutation. The secret can
	not be retrieved at a later stage.

	A service account can have multiple active tokens at the same time.
	"""
	createServiceAccountToken(
		input: CreateServiceAccountTokenInput!
	): CreateServiceAccountTokenPayload!

	"""
	Update a service account token.

	Note that the secret itself can not be updated, only the metadata.
	"""
	updateServiceAccountToken(
		input: UpdateServiceAccountTokenInput!
	): UpdateServiceAccountTokenPayload!

	"""
	Delete a service account token.
	"""
	deleteServiceAccountToken(
		input: DeleteServiceAccountTokenInput!
	): DeleteServiceAccountTokenPayload!
}

input CreateServiceAccountInput {
	"""
	The name of the service account.
	"""
	name: String!

	"""
	A description of the service account.
	"""
	description: String!

	"""
	The team slug that the service account belongs to.
	"""
	teamSlug: Slug
}

input UpdateServiceAccountInput {
	"""
	The ID of the service account to update.
	"""
	serviceAccountID: ID!

	"""
	The new description of the service account.

	If not specified, the description will remain unchanged.
	"""
	description: String
}

input DeleteServiceAccountInput {
	"""
	The ID of the service account to delete.
	"""
	serviceAccountID: ID!
}

input AssignRoleToServiceAccountInput {
	"""
	The ID of the service account to assign the role to.
	"""
	serviceAccountID: ID!

	"""
	The name of the role to assign.
	"""
	roleName: String!
}

input RevokeRoleFromServiceAccountInput {
	"""
	The ID of the service account to revoke the role from.
	"""
	serviceAccountID: ID!

	"""
	The name of the role to revoke.
	"""
	roleName: String!
}

input CreateServiceAccountTokenInput {
	"""
	The ID of the service account to create the token for.
	"""
	serviceAccountID: ID!

	"""
	The name of the service account token.
	"""
	name: String!

	"""
	The description of the service account token.
	"""
	description: String!

	"""
	Optional expiry date of the token.

	If not specified, the token will never expire.
	"""
	expiresAt: Date
}

input UpdateServiceAccountTokenInput {
	"""
	The ID of the service account token to update.
	"""
	serviceAccountTokenID: ID!

	"""
	The new name of the service account token.

	If not specified, the name will remain unchanged.
	"""
	name: String

	"""
	The new description of the service account token.

	If not specified, the description will remain unchanged.
	"""
	description: String
}

input DeleteServiceAccountTokenInput {
	"""
	The ID of the service account token to delete.
	"""
	serviceAccountTokenID: ID!
}

"""
The service account type represents machine-users of the Nais API.

These types of users can be used to automate certain parts of the API, for instance team creation and managing team members.

Service accounts are created using the ` + "`" + `createServiceAccount` + "`" + ` mutation, and authenticate using tokens generated by the ` + "`" + `createServiceAccountToken` + "`" + ` mutation.
"""
type ServiceAccount implements Node {
	"""
	The globally unique ID of the service account.
	"""
	id: ID!

	"""
	The name of the service account.
	"""
	name: String!

	"""
	The description of the service account.
	"""
	description: String!

	"""
	Creation time of the service account.
	"""
	createdAt: Time!

	"""
	When the service account was last updated.
	"""
	updatedAt: Time!

	"""
	When the service account was last used for authentication.
	"""
	lastUsedAt: Time

	"""
	The team that the service account belongs to.
	"""
	team: Team

	"""
	The roles that are assigned to the service account.
	"""
	roles(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor
	): RoleConnection!

	"""
	The service account tokens.
	"""
	tokens(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor
	): ServiceAccountTokenConnection!
}

type CreateServiceAccountPayload {
	"""
	The created service account.
	"""
	serviceAccount: ServiceAccount
}

type UpdateServiceAccountPayload {
	"""
	The updated service account.
	"""
	serviceAccount: ServiceAccount
}

type DeleteServiceAccountPayload {
	"""
	Whether or not the service account was deleted.
	"""
	serviceAccountDeleted: Boolean
}

type AssignRoleToServiceAccountPayload {
	"""
	The service account that had a role assigned.
	"""
	serviceAccount: ServiceAccount
}

type RevokeRoleFromServiceAccountPayload {
	"""
	The service account that had a role revoked.
	"""
	serviceAccount: ServiceAccount
}

type CreateServiceAccountTokenPayload {
	"""
	The service account that the token belongs to.
	"""
	serviceAccount: ServiceAccount

	"""
	The created service account token.
	"""
	serviceAccountToken: ServiceAccountToken

	"""
	The secret of the service account token.

	This value is only returned once, and can not be retrieved at a later stage. If the secret is lost, a new token must be created.

	Once obtained, the secret can be used to authenticate as the service account using the HTTP ` + "`" + `Authorization` + "`" + ` request header:

	` + "`" + `` + "`" + `` + "`" + `
	Authorization: Bearer <secret>
	` + "`" + `` + "`" + `` + "`" + `
	"""
	secret: String
}

type UpdateServiceAccountTokenPayload {
	"""
	The service account that the token belongs to.
	"""
	serviceAccount: ServiceAccount

	"""
	The updated service account token.
	"""
	serviceAccountToken: ServiceAccountToken
}

type DeleteServiceAccountTokenPayload {
	"""
	The service account that the token belonged to.
	"""
	serviceAccount: ServiceAccount

	"""
	Whether or not the service account token was deleted.
	"""
	serviceAccountTokenDeleted: Boolean
}

type ServiceAccountToken implements Node {
	"""
	The globally unique ID of the service account token.
	"""
	id: ID!

	"""
	The name of the service account token.
	"""
	name: String!

	"""
	The description of the service account token.
	"""
	description: String!

	"""
	When the service account token was created.
	"""
	createdAt: Time!

	"""
	When the service account token was last updated.
	"""
	updatedAt: Time!

	"""
	When the service account token was last used for authentication.
	"""
	lastUsedAt: Time

	"""
	Expiry date of the token. If this value is empty the token never expires.
	"""
	expiresAt: Date
}

type ServiceAccountConnection {
	"""
	A list of service accounts.
	"""
	nodes: [ServiceAccount!]!

	"""
	A list of edges.
	"""
	edges: [ServiceAccountEdge!]!

	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
}

type ServiceAccountEdge {
	"""
	The service account.
	"""
	node: ServiceAccount!

	"""
	A cursor for use in pagination.
	"""
	cursor: Cursor!
}

type ServiceAccountTokenConnection {
	"""
	A list of service accounts tokens.
	"""
	nodes: [ServiceAccountToken!]!

	"""
	A list of edges.
	"""
	edges: [ServiceAccountTokenEdge!]!

	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
}

type ServiceAccountTokenEdge {
	"""
	The service account token.
	"""
	node: ServiceAccountToken!

	"""
	A cursor for use in pagination.
	"""
	cursor: Cursor!
}

extend enum ActivityLogEntryResourceType {
	SERVICE_ACCOUNT
}

type ServiceAccountCreatedActivityLogEntry implements ActivityLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
	"""
	actor: String!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the entry.
	"""
	message: String!

	"""
	Type of the resource that was affected by the action.
	"""
	resourceType: ActivityLogEntryResourceType!

	"""
	Name of the resource that was affected by the action.
	"""
	resourceName: String!

	"""
	The team slug that the entry belongs to.
	"""
	teamSlug: Slug

	"""
	The environment name that the entry belongs to.
	"""
	environmentName: String
}

type ServiceAccountUpdatedActivityLogEntry implements ActivityLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
	"""
	actor: String!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the entry.
	"""
	message: String!

	"""
	Type of the resource that was affected by the action.
	"""
	resourceType: ActivityLogEntryResourceType!

	"""
	Name of the resource that was affected by the action.
	"""
	resourceName: String!

	"""
	The team slug that the entry belongs to.
	"""
	teamSlug: Slug

	"""
	The environment name that the entry belongs to.
	"""
	environmentName: String

	"""
	Data associated with the entry.
	"""
	data: ServiceAccountUpdatedActivityLogEntryData!
}

type ServiceAccountUpdatedActivityLogEntryData {
	"""
	Fields that were updated.
	"""
	updatedFields: [ServiceAccountUpdatedActivityLogEntryDataUpdatedField!]!
}

type ServiceAccountUpdatedActivityLogEntryDataUpdatedField {
	"""
	The name of the field.
	"""
	field: String!

	"""
	The old value of the field.
	"""
	oldValue: String

	"""
	The new value of the field.
	"""
	newValue: String
}

type ServiceAccountDeletedActivityLogEntry implements ActivityLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
	"""
	actor: String!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the entry.
	"""
	message: String!

	"""
	Type of the resource that was affected by the action.
	"""
	resourceType: ActivityLogEntryResourceType!

	"""
	Name of the resource that was affected by the action.
	"""
	resourceName: String!

	"""
	The team slug that the entry belongs to.
	"""
	teamSlug: Slug

	"""
	The environment name that the entry belongs to.
	"""
	environmentName: String
}

type RoleAssignedToServiceAccountActivityLogEntry implements ActivityLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
	"""
	actor: String!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the entry.
	"""
	message: String!

	"""
	Type of the resource that was affected by the action.
	"""
	resourceType: ActivityLogEntryResourceType!

	"""
	Name of the resource that was affected by the action.
	"""
	resourceName: String!

	"""
	The team slug that the entry belongs to.
	"""
	teamSlug: Slug

	"""
	The environment name that the entry belongs to.
	"""
	environmentName: String

	"""
	Data associated with the entry.
	"""
	data: RoleAssignedToServiceAccountActivityLogEntryData!
}

type RoleAssignedToServiceAccountActivityLogEntryData {
	"""
	The added role.
	"""
	roleName: String!
}

type RoleRevokedFromServiceAccountActivityLogEntry implements ActivityLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
	"""
	actor: String!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the entry.
	"""
	message: String!

	"""
	Type of the resource that was affected by the action.
	"""
	resourceType: ActivityLogEntryResourceType!

	"""
	Name of the resource that was affected by the action.
	"""
	resourceName: String!

	"""
	The team slug that the entry belongs to.
	"""
	teamSlug: Slug

	"""
	The environment name that the entry belongs to.
	"""
	environmentName: String

	"""
	Data associated with the entry.
	"""
	data: RoleRevokedFromServiceAccountActivityLogEntryData!
}

type RoleRevokedFromServiceAccountActivityLogEntryData {
	"""
	The removed role.
	"""
	roleName: String!
}

type ServiceAccountTokenCreatedActivityLogEntry implements ActivityLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
	"""
	actor: String!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the entry.
	"""
	message: String!

	"""
	Type of the resource that was affected by the action.
	"""
	resourceType: ActivityLogEntryResourceType!

	"""
	Name of the resource that was affected by the action.
	"""
	resourceName: String!

	"""
	The team slug that the entry belongs to.
	"""
	teamSlug: Slug

	"""
	The environment name that the entry belongs to.
	"""
	environmentName: String

	"""
	Data associated with the entry.
	"""
	data: ServiceAccountTokenCreatedActivityLogEntryData!
}

type ServiceAccountTokenCreatedActivityLogEntryData {
	"""
	The name of the service account token.
	"""
	tokenName: String!
}

type ServiceAccountTokenUpdatedActivityLogEntry implements ActivityLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
	"""
	actor: String!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the entry.
	"""
	message: String!

	"""
	Type of the resource that was affected by the action.
	"""
	resourceType: ActivityLogEntryResourceType!

	"""
	Name of the resource that was affected by the action.
	"""
	resourceName: String!

	"""
	The team slug that the entry belongs to.
	"""
	teamSlug: Slug

	"""
	The environment name that the entry belongs to.
	"""
	environmentName: String

	"""
	Data associated with the entry.
	"""
	data: ServiceAccountTokenUpdatedActivityLogEntryData!
}

type ServiceAccountTokenUpdatedActivityLogEntryData {
	"""
	Fields that were updated.
	"""
	updatedFields: [ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField!]!
}

type ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField {
	"""
	The name of the field.
	"""
	field: String!

	"""
	The old value of the field.
	"""
	oldValue: String

	"""
	The new value of the field.
	"""
	newValue: String
}

type ServiceAccountTokenDeletedActivityLogEntry implements ActivityLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
	"""
	actor: String!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the entry.
	"""
	message: String!

	"""
	Type of the resource that was affected by the action.
	"""
	resourceType: ActivityLogEntryResourceType!

	"""
	Name of the resource that was affected by the action.
	"""
	resourceName: String!

	"""
	The team slug that the entry belongs to.
	"""
	teamSlug: Slug

	"""
	The environment name that the entry belongs to.
	"""
	environmentName: String

	"""
	Data associated with the entry.
	"""
	data: ServiceAccountTokenDeletedActivityLogEntryData!
}

type ServiceAccountTokenDeletedActivityLogEntryData {
	"""
	The name of the service account token.
	"""
	tokenName: String!
}
`, BuiltIn: false},
	{Name: "../schema/sqlinstance.graphqls", Input: `extend type Team {
	"SQL instances owned by the team."
	sqlInstances(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: SqlInstanceOrder
	): SqlInstanceConnection!
}

extend type TeamServiceUtilization {
	sqlInstances: TeamServiceUtilizationSqlInstances!
}

type TeamServiceUtilizationSqlInstances {
	cpu: TeamServiceUtilizationSqlInstancesCPU!
	memory: TeamServiceUtilizationSqlInstancesMemory!
	disk: TeamServiceUtilizationSqlInstancesDisk!
}

type TeamServiceUtilizationSqlInstancesCPU {
	used: Float!
	requested: Float!
	utilization: Float!
}

type TeamServiceUtilizationSqlInstancesMemory {
	used: Int!
	requested: Int!
	utilization: Float!
}

type TeamServiceUtilizationSqlInstancesDisk {
	used: Int!
	requested: Int!
	utilization: Float!
}

extend type TeamEnvironment {
	"SQL instance in the team environment."
	sqlInstance(name: String!): SqlInstance!
}

extend interface Workload {
	"SQL instances referenced by the workload. This does not currently support pagination, but will return all available SQL instances."
	sqlInstances(
		"Ordering options for items returned from the connection."
		orderBy: SqlInstanceOrder
	): SqlInstanceConnection!
}

extend type Application {
	"SQL instances referenced by the application. This does not currently support pagination, but will return all available SQL instances."
	sqlInstances(
		"Ordering options for items returned from the connection."
		orderBy: SqlInstanceOrder
	): SqlInstanceConnection!
}

extend type Job {
	"SQL instances referenced by the job. This does not currently support pagination, but will return all available SQL instances."
	sqlInstances(
		"Ordering options for items returned from the connection."
		orderBy: SqlInstanceOrder
	): SqlInstanceConnection!
}

extend type TeamInventoryCounts {
	sqlInstances: TeamInventoryCountSqlInstances!
}

type TeamInventoryCountSqlInstances {
	"Total number of SQL instances."
	total: Int!
}

type SqlDatabase implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")
	teamEnvironment: TeamEnvironment!
	charset: String
	collation: String
	deletionPolicy: String
	healthy: Boolean!
}

type SqlInstance implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")
	teamEnvironment: TeamEnvironment!
	workload: Workload
	cascadingDelete: Boolean!
	connectionName: String
	diskAutoresize: Boolean
	diskAutoresizeLimit: Int
	highAvailability: Boolean!
	healthy: Boolean!
	maintenanceVersion: String
	maintenanceWindow: SqlInstanceMaintenanceWindow
	backupConfiguration: SqlInstanceBackupConfiguration
	projectID: String!
	tier: String!
	version: String
	status: SqlInstanceStatus!
	database: SqlDatabase
	flags(first: Int, after: Cursor, last: Int, before: Cursor): SqlInstanceFlagConnection!
	users(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		orderBy: SqlInstanceUserOrder
	): SqlInstanceUserConnection!
	metrics: SqlInstanceMetrics!
	state: SqlInstanceState!
}

type SqlInstanceBackupConfiguration {
	enabled: Boolean
	startTime: String
	retainedBackups: Int
	pointInTimeRecovery: Boolean
	transactionLogRetentionDays: Int
}

type SqlInstanceFlag {
	name: String!
	value: String!
}

type SqlInstanceMaintenanceWindow {
	day: Int!
	hour: Int!
}

type SqlInstanceStatus {
	publicIpAddress: String
	privateIpAddress: String
}

type SqlInstanceUser {
	name: String!
	authentication: String!
}

type SqlInstanceConnection {
	pageInfo: PageInfo!
	nodes: [SqlInstance!]!
	edges: [SqlInstanceEdge!]!
}

type SqlInstanceFlagConnection {
	pageInfo: PageInfo!
	nodes: [SqlInstanceFlag!]!
	edges: [SqlInstanceFlagEdge!]!
}

type SqlInstanceUserConnection {
	pageInfo: PageInfo!
	nodes: [SqlInstanceUser!]!
	edges: [SqlInstanceUserEdge!]!
}

type SqlInstanceEdge {
	cursor: Cursor!
	node: SqlInstance!
}

type SqlInstanceFlagEdge {
	cursor: Cursor!
	node: SqlInstanceFlag!
}

type SqlInstanceUserEdge {
	cursor: Cursor!
	node: SqlInstanceUser!
}

input SqlInstanceOrder {
	field: SqlInstanceOrderField!
	direction: OrderDirection!
}

input SqlInstanceUserOrder {
	field: SqlInstanceUserOrderField!
	direction: OrderDirection!
}

enum SqlInstanceOrderField {
	NAME
	VERSION
	ENVIRONMENT
	STATUS
	COST
	CPU_UTILIZATION
	MEMORY_UTILIZATION
	DISK_UTILIZATION
}

enum SqlInstanceUserOrderField {
	NAME
	AUTHENTICATION
}

extend union SearchNode = SqlInstance

extend enum SearchType {
	SQL_INSTANCE
}

type SqlInstanceMetrics {
	cpu: SqlInstanceCpu!
	memory: SqlInstanceMemory!
	disk: SqlInstanceDisk!
}

type SqlInstanceCpu {
	cores: Float!
	utilization: Float!
}

type SqlInstanceMemory {
	quotaBytes: Int!
	utilization: Float!
}

type SqlInstanceDisk {
	quotaBytes: Int!
	utilization: Float!
}

enum SqlInstanceState {
	UNSPECIFIED
	RUNNABLE
	SUSPENDED
	PENDING_DELETE
	PENDING_CREATE
	MAINTENANCE
	FAILED
}
`, BuiltIn: false},
	{Name: "../schema/status.graphqls", Input: `extend interface Workload {
	"Status of the workload"
	status: WorkloadStatus!
}

extend type Application {
	"Status of the application"
	status: WorkloadStatus!
}

extend type Job {
	"Status of the job"
	status: WorkloadStatus!
}

type WorkloadStatus {
	"State of the workload"
	state: WorkloadState!
	"Errors related to the workload"
	errors: [WorkloadStatusError!]!
}

"Error describing usage of a deprecated registry"
type WorkloadStatusDeprecatedRegistry implements WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
	"Image registry"
	registry: String!
	"Image repository"
	repository: String!
	"Image name"
	name: String!
	"Image tag"
	tag: String!
}

"Error describing usage of a deprecated ingress"
type WorkloadStatusDeprecatedIngress implements WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
	"Deprecated ingress"
	ingress: String!
}

"A workload does not have any active instances, but is requested to have some"
type WorkloadStatusNoRunningInstances implements WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
}

"Error describing that a workload has new instances that are failing"
type WorkloadStatusNewInstancesFailing implements WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
	"Names of the failing instances"
	failingInstances: [String!]!
}

"The last deployed YAML is invalid"
type WorkloadStatusInvalidNaisYaml implements WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
	"Error message"
	detail: String!
}

"Error describing that the workload is failing to synchronize"
type WorkloadStatusSynchronizationFailing implements WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
	"Error message"
	detail: String!
}

"An inbound network policies are not met"
type WorkloadStatusInboundNetwork implements WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
	"Network policy"
	policy: NetworkPolicyRule!
}

"An outbound network policies are not met"
type WorkloadStatusOutboundNetwork implements WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
	"Network policy"
	policy: NetworkPolicyRule!
}

"Error describing that the workload is failing to run"
type WorkloadStatusFailedRun implements WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
	"Error message"
	detail: String!
	"Name of the run"
	name: String!
}

"Error describing that the workload is missing SBOM"
type WorkloadStatusMissingSBOM implements WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
}

"Error describing that the workload is missing SBOM"
type WorkloadStatusVulnerable implements WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
	"Vulnerabilities"
	summary: ImageVulnerabilitySummary!
}

"An error for a workload"
interface WorkloadStatusError {
	"Error level"
	level: WorkloadStatusErrorLevel!
}

"Workload status error level"
enum WorkloadStatusErrorLevel {
	"TODO are errors that should be fixed when possible"
	TODO
	"WARNING are errors that should be fixed, but are not critical"
	WARNING
	"ERROR are errors that must be fixed"
	ERROR
}

"State of the workload"
enum WorkloadState {
	"Everything is nais"
	NAIS
	"Something is not nais"
	NOT_NAIS
	"Something is failing"
	FAILING
	"Unknown state"
	UNKNOWN
}

extend enum ApplicationOrderField {
	"Order applications by status."
	STATUS
}

extend enum JobOrderField {
	"Order jobs by status."
	STATUS
}
`, BuiltIn: false},
	{Name: "../schema/teams.graphqls", Input: `extend type Query {
	"Get a list of teams."
	teams(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: TeamOrder
	): TeamConnection!

	"Get a team by its slug."
	team(slug: Slug!): Team!
}

extend type Mutation {
	"""
	Create a new Nais team

	The user creating the team will be granted team ownership, unless the user is a service account, in which case the
	team will not get an initial owner. To add one or more owners to the team, refer to the ` + "`" + `addTeamOwners` + "`" + ` mutation.

	Creation of a team will also create external resources for the team, which will be managed by the Nais API
	reconcilers. This will be done asynchronously.

	Refer to the [official Nais documentation](https://docs.nais.io/explanations/team/) for more information regarding
	Nais teams.
	"""
	createTeam(input: CreateTeamInput!): CreateTeamPayload!

	"""
	Update an existing Nais team

	This mutation can be used to update the team purpose and the main Slack channel. It is not possible to update the
	team slug.
	"""
	updateTeam(input: UpdateTeamInput!): UpdateTeamPayload!

	"""
	Update an environment for a team
	"""
	updateTeamEnvironment(input: UpdateTeamEnvironmentInput!): UpdateTeamEnvironmentPayload!

	"""
	Request a key that can be used to trigger a team deletion process

	Deleting a team is a two step process. First an owner of the team (or an admin) must request a team deletion key,
	and then a second owner of the team (or an admin) must confirm the deletion using the confirmTeamDeletion mutation.

	The returned delete key is valid for an hour, and can only be used once.

	Note: Service accounts are not allowed to request team delete keys.
	"""
	requestTeamDeletion(input: RequestTeamDeletionInput!): RequestTeamDeletionPayload!

	"""
	Confirm a team deletion

	This will start the actual team deletion process, which will be done in an asynchronous manner. All external
	entities controlled by Nais will also be deleted.

	WARNING: There is no going back after starting this process.

	Note: Service accounts are not allowed to confirm a team deletion.
	"""
	confirmTeamDeletion(input: ConfirmTeamDeletionInput!): ConfirmTeamDeletionPayload!

	"""
	Add a team member

	If the user is already a member or an owner of the team, the mutation will result in an error.
	"""
	addTeamMember(input: AddTeamMemberInput!): AddTeamMemberPayload!

	"""
	Remove a team member

	If the user is not already a member or an owner of the team, the mutation will result in an error.
	"""
	removeTeamMember(input: RemoveTeamMemberInput!): RemoveTeamMemberPayload!

	"""
	Assign a role to a team member

	The user must already be a member of the team for this mutation to succeed.
	"""
	setTeamMemberRole(input: SetTeamMemberRoleInput!): SetTeamMemberRolePayload!
}

"""
The team type represents a team on the [Nais platform](https://nais.io/).

Learn more about what Nais teams are and what they can be used for in the [official Nais documentation](https://docs.nais.io/explanations/team/).

External resources (e.g. entraIDGroupID, gitHubTeamSlug) are managed by [Nais API reconcilers](https://github.com/nais/api-reconcilers).
"""
type Team implements Node {
	"The globally unique ID of the team."
	id: ID!

	"Unique slug of the team."
	slug: Slug!

	"Main Slack channel for the team."
	slackChannel: String!

	"Purpose of the team."
	purpose: String!

	"External resources for the team."
	externalResources: TeamExternalResources!

	"Get a specific member of the team."
	member(email: String!): TeamMember!

	"Team members."
	members(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: TeamMemberOrder
	): TeamMemberConnection!

	"Timestamp of the last successful synchronization of the team."
	lastSuccessfulSync: Time

	"Whether or not the team is currently being deleted."
	deletionInProgress: Boolean!

	"Whether or not the viewer is an owner of the team."
	viewerIsOwner: Boolean!

	"Whether or not the viewer is a member of the team."
	viewerIsMember: Boolean!

	"Environments for the team."
	environments: [TeamEnvironment!]!

	"Get a specific environment for the team."
	environment(name: String!): TeamEnvironment!

	"Get a delete key for the team."
	deleteKey(key: String!): TeamDeleteKey!

	"Overall inventory of resources for the team."
	inventoryCounts: TeamInventoryCounts!
}

type TeamEnvironment implements Node {
	"The globally unique ID of the team environment."
	id: ID!

	"Name of the team environment."
	name: String! @deprecated(reason: "Use the ` + "`" + `environment` + "`" + ` field to get the environment name.")

	"The GCP project ID for the team environment."
	gcpProjectID: String

	"The Slack alerts channel for the team environment."
	slackAlertsChannel: String!

	"The connected team."
	team: Team!
}

type TeamMember {
	"Team instance."
	team: Team!

	"User instance."
	user: User!

	"The role that the user has in the team."
	role: TeamMemberRole!
}

type CreateTeamPayload {
	"The newly created team."
	team: Team
}

type UpdateTeamPayload {
	"The updated team."
	team: Team
}

type UpdateTeamEnvironmentPayload {
	"The updated team environment."
	environment: TeamEnvironment @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")

	"The updated team environment."
	teamEnvironment: TeamEnvironment
}

type RequestTeamDeletionPayload {
	"The delete key for the team. This can be used to confirm the deletion of the team."
	key: TeamDeleteKey
}

type ConfirmTeamDeletionPayload {
	"Whether or not the asynchronous deletion process was started."
	deletionStarted: Boolean
}

type AddTeamMemberPayload {
	"The added team member."
	member: TeamMember
}

type RemoveTeamMemberPayload {
	"The user that was removed from the team."
	user: User

	"The team that the member was removed from."
	team: Team
}

type SetTeamMemberRolePayload {
	"The updated team member."
	member: TeamMember
}

type TeamDeleteKey {
	"The unique key used to confirm the deletion of a team."
	key: String!

	"The creation timestamp of the key."
	createdAt: Time!

	"Expiration timestamp of the key."
	expires: Time!

	"The user who created the key."
	createdBy: User!

	"The team the delete key is for."
	team: Team!
}

type TeamConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [Team!]!

	"List of edges."
	edges: [TeamEdge!]!
}

type TeamMemberConnection {
	"Pagination information."
	pageInfo: PageInfo!

	"List of nodes."
	nodes: [TeamMember!]!

	"List of edges."
	edges: [TeamMemberEdge!]!
}

type TeamEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The team."
	node: Team!
}

type TeamMemberEdge {
	"Cursor for this edge that can be used for pagination."
	cursor: Cursor!

	"The team member."
	node: TeamMember!
}

type TeamInventoryCounts

input CreateTeamInput {
	"""
	Unique team slug.

	After creation, this value can not be changed. Also, after a potential deletion of the team, the slug can not be
	reused, so please choose wisely.
	"""
	slug: Slug!

	"""
	The purpose / description of the team.

	What is the team for? What is the team working on? This value is meant for human consumption, and should be enough
	to give a newcomer an idea of what the team is about.
	"""
	purpose: String!

	"""
	The main Slack channel for the team.

	Where does the team communicate? This value is used to link to the team's main Slack channel.
	"""
	slackChannel: String!
}

input UpdateTeamInput {
	"Slug of the team to update."
	slug: Slug!

	"""
	An optional new purpose / description of the team.

	When omitted the existing value will not be updated.
	"""
	purpose: String

	"""
	An optional new Slack channel for the team.

	When omitted the existing value will not be updated.
	"""
	slackChannel: String
}

input UpdateTeamEnvironmentInput {
	"Slug of the team to update."
	slug: Slug!

	"Name of the environment to update."
	environmentName: String!

	"Slack alerts channel for the environment. Set to an empty string to remove the existing value."
	slackAlertsChannel: String
}

"Ordering options when fetching teams."
input TeamOrder {
	"The field to order items by."
	field: TeamOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

"Ordering options for team members."
input TeamMemberOrder {
	"The field to order items by."
	field: TeamMemberOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

input RequestTeamDeletionInput {
	"Slug of the team to request a team deletion key for."
	slug: Slug!
}

input ConfirmTeamDeletionInput {
	"Slug of the team to confirm deletion for."
	slug: Slug!

	"Deletion key, acquired using the requestTeamDeletion mutation."
	key: String!
}

input AddTeamMemberInput {
	"Slug of the team that should receive a new member."
	teamSlug: Slug!

	"The email address of the user to add to the team."
	userEmail: String!

	"The role that the user will have in the team."
	role: TeamMemberRole!
}

input RemoveTeamMemberInput {
	"Slug of the team that the member should be removed from."
	teamSlug: Slug!

	"The email address of the user to remove from the team."
	userEmail: String!
}

input SetTeamMemberRoleInput {
	"The slug of the team."
	teamSlug: Slug!

	"The email address of the user."
	userEmail: String!

	"The role to assign."
	role: TeamMemberRole!
}

"Possible fields to order teams by."
enum TeamOrderField {
	"The unique slug of the team."
	TEAM_SLUG
}

"Possible fields to order team members by."
enum TeamMemberOrderField {
	"The name of user."
	NAME

	"The email address of the user."
	EMAIL

	"The role the user has in the team."
	ROLE
}

"Team member roles."
enum TeamMemberRole {
	"Regular member, read only access."
	MEMBER

	"Team owner, full access to the team."
	OWNER
}

extend enum ActivityLogEntryResourceType {
	"All activity log entries related to teams will use this resource type."
	TEAM
}

type TeamCreatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type TeamUpdatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the update."
	data: TeamUpdatedActivityLogEntryData!
}

type TeamUpdatedActivityLogEntryData {
	"Fields that were updated."
	updatedFields: [TeamUpdatedActivityLogEntryDataUpdatedField!]!
}

type TeamUpdatedActivityLogEntryDataUpdatedField {
	"The name of the field."
	field: String!

	"The old value of the field."
	oldValue: String

	"The new value of the field."
	newValue: String
}

type TeamCreateDeleteKeyActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type TeamConfirmDeleteKeyActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type TeamMemberAddedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the action."
	data: TeamMemberAddedActivityLogEntryData!
}

type TeamMemberAddedActivityLogEntryData {
	"The role that the user was added with."
	role: TeamMemberRole!

	"The ID of the user that was added."
	userID: ID!

	"The email address of the user that was added."
	userEmail: String!
}

type TeamMemberRemovedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the action."
	data: TeamMemberRemovedActivityLogEntryData!
}

type TeamMemberRemovedActivityLogEntryData {
	"The ID of the user that was removed."
	userID: ID!

	"The email address of the user that was removed."
	userEmail: String!
}

type TeamMemberSetRoleActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the action."
	data: TeamMemberSetRoleActivityLogEntryData!
}

type TeamMemberSetRoleActivityLogEntryData {
	"The role that the user was assigned."
	role: TeamMemberRole!

	"The ID of the user that was added."
	userID: ID!

	"The email address of the user that was added."
	userEmail: String!
}

type TeamEnvironmentUpdatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the action."
	data: TeamEnvironmentUpdatedActivityLogEntryData!
}

type TeamEnvironmentUpdatedActivityLogEntryData {
	"Fields that were updated."
	updatedFields: [TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField!]!
}

type TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField {
	"The name of the field."
	field: String!

	"The old value of the field."
	oldValue: String

	"The new value of the field."
	newValue: String
}

type TeamExternalResources {
	"The Entra ID (f.k.a. Azure AD) group for the team."
	entraIDGroup: TeamEntraIDGroup

	"The teams GitHub team."
	gitHubTeam: TeamGitHubTeam

	"The Google group for the team."
	googleGroup: TeamGoogleGroup

	"Google Artifact Registry."
	googleArtifactRegistry: TeamGoogleArtifactRegistry

	"CDN bucket."
	cdn: TeamCDN
}

type TeamCDN {
	"The CDN bucket for the team."
	bucket: String!
}

type TeamEntraIDGroup {
	"The ID of the Entra ID (f.k.a. Azure AD) group for the team."
	groupID: String!
}

type TeamGitHubTeam {
	"The slug of the GitHub team."
	slug: String!
}

type TeamGoogleGroup {
	"The email address of the Google Workspace group for the team."
	email: String!
}

type TeamGoogleArtifactRegistry {
	"The Google Artifact Registry for the team."
	repository: String!
}
`, BuiltIn: false},
	{Name: "../schema/unleash.graphqls", Input: `extend type Mutation {
	"""
	Create a new Unleash instance.

	This mutation will create a new Unleash instance for the given team. The team
	will be set as owner of the Unleash instance and will be able to manage it.
	"""
	createUnleashForTeam(input: CreateUnleashForTeamInput!): CreateUnleashForTeamPayload!

	"""
	Add team to the list of teams that can access the Unleash instance.
	"""
	allowTeamAccessToUnleash(input: AllowTeamAccessToUnleashInput!): AllowTeamAccessToUnleashPayload!

	"""
	Remove team from the list of teams that can access the Unleash instance.
	"""
	revokeTeamAccessToUnleash(
		input: RevokeTeamAccessToUnleashInput!
	): RevokeTeamAccessToUnleashPayload!
}

input CreateUnleashForTeamInput {
	teamSlug: Slug!
}

type CreateUnleashForTeamPayload {
	unleash: UnleashInstance
}

input AllowTeamAccessToUnleashInput {
	teamSlug: Slug!
	allowedTeamSlug: Slug!
}

type AllowTeamAccessToUnleashPayload {
	unleash: UnleashInstance
}

input RevokeTeamAccessToUnleashInput {
	teamSlug: Slug!
	revokedTeamSlug: Slug!
}

type RevokeTeamAccessToUnleashPayload {
	unleash: UnleashInstance
}

extend type Team {
	unleash: UnleashInstance
}

type UnleashInstance implements Node {
	id: ID!
	name: String!
	version: String!
	allowedTeams(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): TeamConnection!
	webIngress: String!
	apiIngress: String!
	metrics: UnleashInstanceMetrics!
	ready: Boolean!
}

type UnleashInstanceMetrics {
	toggles: Int!
	apiTokens: Int!
	cpuUtilization: Float!
	cpuRequests: Float!
	memoryUtilization: Float!
	memoryRequests: Float!
}

extend enum ActivityLogEntryResourceType {
	"All activity log entries related to unleash will use this resource type."
	UNLEASH
}

type UnleashInstanceCreatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type UnleashInstanceUpdatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"Data associated with the update."
	data: UnleashInstanceUpdatedActivityLogEntryData!
}

type UnleashInstanceUpdatedActivityLogEntryData {
	"Revoked team slug."
	revokedTeamSlug: Slug

	"Allowed team slug."
	allowedTeamSlug: Slug
}
`, BuiltIn: false},
	{Name: "../schema/users.graphqls", Input: `extend type Query {
	"""
	Get a list of users.
	"""
	users(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor

		"""
		Ordering options for items returned from the connection.
		"""
		orderBy: UserOrder
	): UserConnection!

	"""
	Get a user by an identifier.
	"""
	user(email: String): User!

	"""
	The currently authenticated user.
	"""
	me: AuthenticatedUser!
}

"""
The user type represents a user of the Nais platform and the Nais GraphQL API.
"""
type User implements Node {
	"""
	The globally unique ID of the user.
	"""
	id: ID!

	"""
	The email address of the user.
	"""
	email: String!

	"""
	The full name of the user.
	"""
	name: String!

	"""
	The external ID of the user. This value is managed by the Nais API user synchronization.
	"""
	externalID: String!

	"""
	List of teams the user is connected to.
	"""
	teams(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor

		"""
		Ordering options for items returned from the connection.
		"""
		orderBy: UserTeamOrder
	): TeamMemberConnection!

	"""
	True if the user is global admin.
	"""
	isAdmin: Boolean!
}

"""
User connection.
"""
type UserConnection {
	"""
	Pagination information.
	"""
	pageInfo: PageInfo!

	"""
	List of nodes.
	"""
	nodes: [User!]!

	"""
	List of edges.
	"""
	edges: [UserEdge!]!
}

"""
User edge.
"""
type UserEdge {
	"""
	Cursor for this edge that can be used for pagination.
	"""
	cursor: Cursor!

	"""
	The user.
	"""
	node: User!
}

"""
Ordering options when fetching users.
"""
input UserOrder {
	"""
	The field to order items by.
	"""
	field: UserOrderField!

	"""
	The direction to order items by.
	"""
	direction: OrderDirection!
}

"""
Ordering options when fetching the teams a user is connected to.
"""
input UserTeamOrder {
	"""
	The field to order items by.
	"""
	field: UserTeamOrderField!

	"""
	The direction to order items by.
	"""
	direction: OrderDirection!
}

"""
Possible fields to order users by.
"""
enum UserOrderField {
	"""
	The name of the user.
	"""
	NAME

	"""
	The email address of the user.
	"""
	EMAIL
}

"""
Possible fields to order user teams by.
"""
enum UserTeamOrderField {
	"""
	The unique slug of the team.
	"""
	TEAM_SLUG
}

"""
Authenticated user type.
"""
union AuthenticatedUser = User | ServiceAccount
`, BuiltIn: false},
	{Name: "../schema/usersync.graphqls", Input: `extend type Query {
	"""
	Log entries from the user sync process.
	"""
	userSyncLog(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor
	): UserSyncLogEntryConnection!
}

"""
Interface for user sync log entries.
"""
interface UserSyncLogEntry implements Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the log entry.
	"""
	message: String!

	"""
	The ID of the affected user.
	"""
	userID: ID!

	"""
	The name of the affected user.
	"""
	userName: String!

	"""
	The email address of the affected user.
	"""
	userEmail: String!
}

"""
User created log entry.
"""
type UserCreatedUserSyncLogEntry implements UserSyncLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the log entry.
	"""
	message: String!

	"""
	The ID of the created user.
	"""
	userID: ID!

	"""
	The name of the created user.
	"""
	userName: String!

	"""
	The email address of the created user.
	"""
	userEmail: String!
}

"""
User updated log entry.
"""
type UserUpdatedUserSyncLogEntry implements UserSyncLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the log entry.
	"""
	message: String!

	"""
	The ID of the updated user.
	"""
	userID: ID!

	"""
	The name of the updated user.
	"""
	userName: String!

	"""
	The email address of the updated user.
	"""
	userEmail: String!

	"""
	The old name of the user.
	"""
	oldUserName: String!

	"""
	The old email address of the user.
	"""
	oldUserEmail: String!
}

"""
User deleted log entry.
"""
type UserDeletedUserSyncLogEntry implements UserSyncLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the log entry.
	"""
	message: String!

	"""
	The ID of the deleted user.
	"""
	userID: ID!

	"""
	The name of the deleted user.
	"""
	userName: String!

	"""
	The email address of the deleted user.
	"""
	userEmail: String!
}

"""
Assigned role to user log entry.
"""
type RoleAssignedUserSyncLogEntry implements UserSyncLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the log entry.
	"""
	message: String!

	"""
	The ID of the user that was assigned a role.
	"""
	userID: ID!

	"""
	The name of the user that was assigned a role.
	"""
	userName: String!

	"""
	The email address of the user that was assigned a role.
	"""
	userEmail: String!

	"""
	The name of the assigned role.
	"""
	roleName: String!
}

"""
Revoked role from user log entry.
"""
type RoleRevokedUserSyncLogEntry implements UserSyncLogEntry & Node {
	"""
	ID of the entry.
	"""
	id: ID!

	"""
	Creation time of the entry.
	"""
	createdAt: Time!

	"""
	Message that summarizes the log entry.
	"""
	message: String!

	"""
	The ID of the user that got a role revoked.
	"""
	userID: ID!

	"""
	The name of the user that got a role revoked.
	"""
	userName: String!

	"""
	The email address of the user that got a role revoked.
	"""
	userEmail: String!

	"""
	The name of the revoked role.
	"""
	roleName: String!
}

"""
User sync log entry connection.
"""
type UserSyncLogEntryConnection {
	"""
	Pagination information.
	"""
	pageInfo: PageInfo!

	"""
	List of nodes.
	"""
	nodes: [UserSyncLogEntry!]!

	"""
	List of edges.
	"""
	edges: [UserSyncLogEntryEdge!]!
}

"""
User sync log edge.
"""
type UserSyncLogEntryEdge {
	"""
	Cursor for this edge that can be used for pagination.
	"""
	cursor: Cursor!

	"""
	The log entry.
	"""
	node: UserSyncLogEntry!
}
`, BuiltIn: false},
	{Name: "../schema/utilization.graphqls", Input: `extend type Application {
	utilization: WorkloadUtilization!
}

extend type Team {
	workloadUtilization(resourceType: UtilizationResourceType!): [WorkloadUtilizationData]!
	serviceUtilization: TeamServiceUtilization!
}

extend type Query {
	teamsUtilization(resourceType: UtilizationResourceType!): [TeamUtilizationData!]!
}

type TeamServiceUtilization

type WorkloadUtilizationData {
	"The workload."
	workload: Workload!

	"The requested amount of resources"
	requested: Float!

	"The current resource usage."
	used: Float!
}

type WorkloadUtilization {
	"Get the current usage for the requested resource type."
	current(resourceType: UtilizationResourceType!): Float!

	"Gets the requested amount of resources for the requested resource type."
	requested(resourceType: UtilizationResourceType!): Float!

	"Gets the limit of the resources for the requested resource type."
	limit(resourceType: UtilizationResourceType!): Float

	"Usage between start and end with step size for given resource type."
	series(input: WorkloadUtilizationSeriesInput!): [UtilizationSample!]!
}

input WorkloadUtilizationSeriesInput {
	"Fetch resource usage from this timestamp."
	start: Time!

	"Fetch resource usage until this timestamp."
	end: Time!

	"Resource type."
	resourceType: UtilizationResourceType!
}

"Resource type."
enum UtilizationResourceType {
	CPU
	MEMORY
}

"Resource utilization type."
type UtilizationSample {
	"Timestamp of the value."
	timestamp: Time!

	"Value of the used resource at the given timestamp."
	value: Float!

	"The instance for the utilization data."
	instance: String!
}

type TeamUtilizationData {
	"The team."
	team: Team!

	"The requested amount of resources"
	requested: Float!

	"The current resource usage."
	used: Float!

	"The environment for the utilization data."
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")

	"The environment for the utilization data."
	teamEnvironment: TeamEnvironment!
}
`, BuiltIn: false},
	{Name: "../schema/valkey.graphqls", Input: `extend type Team {
	"Valkey instances owned by the team."
	valkeyInstances(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: ValkeyInstanceOrder
	): ValkeyInstanceConnection!
}

extend type TeamEnvironment {
	"Valkey instance in the team environment."
	valkeyInstance(name: String!): ValkeyInstance!
}

extend interface Workload {
	"Valkey instances referenced by the workload. This does not currently support pagination, but will return all available Valkey instances."
	valkeyInstances(
		"Ordering options for items returned from the connection."
		orderBy: ValkeyInstanceOrder
	): ValkeyInstanceConnection!
}

extend type Application {
	"Valkey instances referenced by the application. This does not currently support pagination, but will return all available Valkey instances."
	valkeyInstances(
		"Ordering options for items returned from the connection."
		orderBy: ValkeyInstanceOrder
	): ValkeyInstanceConnection!
}

extend type Job {
	"Valkey instances referenced by the job. This does not currently support pagination, but will return all available Valkey instances."
	valkeyInstances(
		"Ordering options for items returned from the connection."
		orderBy: ValkeyInstanceOrder
	): ValkeyInstanceConnection!
}

extend type TeamInventoryCounts {
	valkeyInstances: TeamInventoryCountValkeyInstances!
}

type TeamInventoryCountValkeyInstances {
	"Total number of Valkey instances."
	total: Int!
}

type ValkeyInstance implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")
	teamEnvironment: TeamEnvironment!
	access(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		orderBy: ValkeyInstanceAccessOrder
	): ValkeyInstanceAccessConnection!
	workload: Workload
	status: ValkeyInstanceStatus!
}

type ValkeyInstanceAccess {
	workload: Workload!
	access: String!
}

type ValkeyInstanceStatus {
	state: String!
}

type ValkeyInstanceAccessConnection {
	pageInfo: PageInfo!
	nodes: [ValkeyInstanceAccess!]!
	edges: [ValkeyInstanceAccessEdge!]!
}

type ValkeyInstanceConnection {
	pageInfo: PageInfo!
	nodes: [ValkeyInstance!]!
	edges: [ValkeyInstanceEdge!]!
}

type ValkeyInstanceAccessEdge {
	cursor: Cursor!
	node: ValkeyInstanceAccess!
}

type ValkeyInstanceEdge {
	cursor: Cursor!
	node: ValkeyInstance!
}

input ValkeyInstanceAccessOrder {
	field: ValkeyInstanceAccessOrderField!
	direction: OrderDirection!
}

input ValkeyInstanceOrder {
	field: ValkeyInstanceOrderField!
	direction: OrderDirection!
}

enum ValkeyInstanceAccessOrderField {
	ACCESS
	WORKLOAD
}

enum ValkeyInstanceOrderField {
	NAME
	ENVIRONMENT
}

extend union SearchNode = ValkeyInstance

extend enum SearchType {
	VALKEY_INSTANCE
}
`, BuiltIn: false},
	{Name: "../schema/vulnerability.graphqls", Input: `extend type Mutation {
	"""
	Updates a vulnerability
	This mutation is currently unstable and may change in the future.
	"""
	updateImageVulnerability(input: UpdateImageVulnerabilityInput!): UpdateImageVulnerabilityPayload!
}

extend type ContainerImage {
	"Whether the image has a software bill of materials (SBOM) attached to it."
	hasSBOM: Boolean!

	"Get the vulnerabilities of the image."
	vulnerabilities(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: ImageVulnerabilityOrder
	): ImageVulnerabilityConnection!

	"Get the summary of the vulnerabilities of the image."
	vulnerabilitySummary: ImageVulnerabilitySummary

	"Workloads using this container image."
	workloadReferences(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): ContainerImageWorkloadReferenceConnection!
}

extend type Team {
	vulnerabilitySummary(filter: TeamVulnerabilitySummaryFilter): TeamVulnerabilitySummary!
}

extend enum ActivityLogEntryResourceType {
	"All activity log entries related to vulnerabilities will use this resource type."
	VULNERABILITY
}

"""
Input for filtering team workloads.
"""
input TeamVulnerabilitySummaryFilter {
	"""
	Only return workloads from the given named environments.
	"""
	environments: [String!]
}

type ImageVulnerabilitySummary {
	"Total number of vulnerabilities."
	total: Int!

	"Risk score of the image."
	riskScore: Int!

	"Number of vulnerabilities with severity LOW."
	low: Int!

	"Number of vulnerabilities with severity MEDIUM."
	medium: Int!

	"Number of vulnerabilities with severity HIGH."
	high: Int!

	"Number of vulnerabilities with severity CRITICAL."
	critical: Int!

	"Number of vulnerabilities with severity UNASSIGNED."
	unassigned: Int!
}

type ImageVulnerabilityConnection {
	"Information to aid in pagination."
	pageInfo: PageInfo!

	"List of edges."
	edges: [ImageVulnerabilityEdge!]!

	"List of nodes."
	nodes: [ImageVulnerability!]!
}

type ContainerImageWorkloadReferenceConnection {
	"Information to aid in pagination."
	pageInfo: PageInfo!

	"List of edges."
	edges: [ContainerImageWorkloadReferenceEdge!]!

	"List of nodes."
	nodes: [ContainerImageWorkloadReference!]!
}

type ImageVulnerabilityEdge {
	"A cursor for use in pagination."
	cursor: Cursor!

	"The image vulnerability."
	node: ImageVulnerability!
}

type ContainerImageWorkloadReferenceEdge {
	"A cursor for use in pagination."
	cursor: Cursor!

	"The workload reference."
	node: ContainerImageWorkloadReference!
}

type ContainerImageWorkloadReference {
	"The workload using the container image."
	workload: Workload!
}

type ImageVulnerability implements Node {
	"The globally unique ID of the image vulnerability node."
	id: ID!

	"The unique identifier of the vulnerability. E.g. CVE-****-****."
	identifier: String!

	"Severity of the vulnerability."
	severity: ImageVulnerabilitySeverity!

	"Description of the vulnerability."
	description: String!

	"Package name of the vulnerability."
	package: String!

	"State of the vulnerability."
	state: ImageVulnerabilityState!

	"Analysis trail of the vulnerability."
	analysisTrail: ImageVulnerabilityAnalysisTrail!
}

enum ImageVulnerabilitySeverity {
	LOW
	MEDIUM
	HIGH
	CRITICAL
	UNASSIGNED
}

enum ImageVulnerabilityState {
	TRIAGE
	RESOLVED
	FALSE_POSITIVE
	NOT_AFFECTED
}

"Ordering options when fetching teams."
input ImageVulnerabilityOrder {
	"The field to order items by."
	field: ImageVulnerabilityOrderField!

	"The direction to order items by."
	direction: OrderDirection!
}

enum ImageVulnerabilityOrderField {
	IDENTIFIER
	SEVERITY
	PACKAGE
	STATE
	SUPPRESSED
}

type TeamVulnerabilitySummary {
	"Risk score of the team."
	riskScore: Int!
	"Number of vulnerabilities with severity CRITICAL."
	critical: Int!
	"Number of vulnerabilities with severity HIGH."
	high: Int!
	"Number of vulnerabilities with severity MEDIUM."
	medium: Int!
	"Number of vulnerabilities with severity LOW."
	low: Int!
	"Number of vulnerabilities with severity UNASSIGNED."
	unassigned: Int!
	"Number of workloads with a software bill of materials (SBOM) attached."
	bomCount: Int!
	"Coverage of the team."
	coverage: Float!
	"Ranking of the team based on vulnerability severity."
	ranking: TeamVulnerabilityRanking!
	"Trend of vulnerability status for the team."
	riskScoreTrend: TeamVulnerabilityRiskScoreTrend!
	"Aggregated status of the vulnerabilities for the team."
	status: [TeamVulnerabilityStatus!]!
}

type TeamVulnerabilityStatus {
	state: TeamVulnerabilityState!
	title: String!
	description: String!
}

enum TeamVulnerabilityState {
	OK
	TOO_MANY_VULNERABLE_WORKLOADS
	COVERAGE_TOO_LOW
	VULNERABLE
	MISSING_SBOM
}

enum TeamVulnerabilityRanking {
	"Top third most vulnerable teams."
	MOST_VULNERABLE
	"Middle third most vulnerable teams."
	MIDDLE
	"Bottom third most vulnerable teams."
	LEAST_VULNERABLE
	"Unknown ranking."
	UNKNOWN
}

enum TeamVulnerabilityRiskScoreTrend {
	"Risk score is increasing."
	UP
	"Risk score is decreasing."
	DOWN
	"Risk score is not changing."
	FLAT
}

extend enum WorkloadOrderField {
	"Order by risk score"
	VULNERABILITY_RISK_SCORE
	"Order apps by vulnerability severity critical"
	VULNERABILITY_SEVERITY_CRITICAL
	"Order apps by vulnerability severity high"
	VULNERABILITY_SEVERITY_HIGH
	"Order apps by vulnerability severity medium"
	VULNERABILITY_SEVERITY_MEDIUM
	"Order apps by vulnerability severity low"
	VULNERABILITY_SEVERITY_LOW
	"Order apps by vulnerability severity unassigned"
	VULNERABILITY_SEVERITY_UNASSIGNED
}

input UpdateImageVulnerabilityInput {
	"The id of the vulnerability to suppress."
	vulnerabilityID: ID!
	"The analysis state of the vulnerability."
	analysisState: ImageVulnerabilityAnalysisState!
	"The a comment for suppressing the vulnerability."
	comment: String!
	"Should the vulnerability be suppressed."
	suppress: Boolean!
}

type UpdateImageVulnerabilityPayload {
	"The vulnerability updated."
	vulnerability: ImageVulnerability
}

enum ImageVulnerabilityAnalysisState {
	"Vulnerability is triaged."
	IN_TRIAGE
	"Vulnerability is resolved."
	RESOLVED
	"Vulnerability is marked as false positive."
	FALSE_POSITIVE
	"Vulnerability is marked as not affected."
	NOT_AFFECTED
}

type ImageVulnerabilityAnalysisTrail {
	state: ImageVulnerabilityAnalysisState!
	comments(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor
	): ImageVulnerabilityAnalysisCommentConnection!
	suppressed: Boolean!
}

type ImageVulnerabilityAnalysisComment {
	"The comment provided."
	comment: String!
	"Was the vulnerability suppressed."
	suppressed: Boolean!
	"State of the vulnerability."
	state: ImageVulnerabilityAnalysisState!
	"Timestamp of the comment."
	timestamp: Time!
	"User who commented."
	onBehalfOf: String!
}

type ImageVulnerabilityAnalysisCommentConnection {
	pageInfo: PageInfo!
	edges: [ImageVulnerabilityAnalysisCommentEdge!]!
	nodes: [ImageVulnerabilityAnalysisComment!]!
}

type ImageVulnerabilityAnalysisCommentEdge {
	cursor: Cursor!
	node: ImageVulnerabilityAnalysisComment!
}

type VulnerabilityUpdatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}
`, BuiltIn: false},
	{Name: "../schema/workloads.graphqls", Input: `extend type Team {
	"""
	Nais workloads owned by the team.
	"""
	workloads(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor

		"""
		Ordering options for items returned from the connection.
		"""
		orderBy: WorkloadOrder

		"""
		Filter the returned objects
		"""
		filter: TeamWorkloadsFilter
	): WorkloadConnection!
}

extend type Environment {
	"""
	Nais workloads in the environment.
	"""
	workloads(
		"""
		Get the first n items in the connection. This can be used in combination with the after parameter.
		"""
		first: Int

		"""
		Get items after this cursor.
		"""
		after: Cursor

		"""
		Get the last n items in the connection. This can be used in combination with the before parameter.
		"""
		last: Int

		"""
		Get items before this cursor.
		"""
		before: Cursor

		"""
		Ordering options for items returned from the connection.
		"""
		orderBy: EnvironmentWorkloadOrder
	): WorkloadConnection!
}

extend type TeamEnvironment {
	"""
	Workload in the team environment.
	"""
	workload(
		"""
		The name of the workload to get.
		"""
		name: String!
	): Workload!
}

"""
Interface for workloads.
"""
interface Workload implements Node {
	"""
	The globally unique ID of the workload.
	"""
	id: ID!

	"""
	The name of the workload.
	"""
	name: String!

	"""
	The team that owns the workload.
	"""
	team: Team!

	"""
	The environment the workload is deployed in.
	"""
	environment: TeamEnvironment! @deprecated(reason: "Use the ` + "`" + `teamEnvironment` + "`" + ` field instead.")

	"""
	The team environment for the workload.
	"""
	teamEnvironment: TeamEnvironment!

	"""
	The container image of the workload.
	"""
	image: ContainerImage!

	"""
	The resources allocated to the workload.
	"""
	resources: WorkloadResources!

	"""
	The workload manifest.
	"""
	manifest: WorkloadManifest!

	"""
	If set, when the workload was marked for deletion.
	"""
	deletionStartedAt: Time
}

"""
Interface for workload manifests.
"""
interface WorkloadManifest {
	"""
	The manifest content, serialized as a YAML document.
	"""
	content: String!
}

"""
Container image.
"""
type ContainerImage implements Node {
	"""
	The globally unique ID of the container image node.
	"""
	id: ID!

	"""
	Name of the container image.
	"""
	name: String!

	"""
	Tag of the container image.
	"""
	tag: String!
}

"""
Interface for resources allocated to workloads.
"""
interface WorkloadResources {
	"""
	Instances using resources above this threshold will be killed.
	"""
	limits: WorkloadResourceQuantity!

	"""
	Resources requested by the workload.
	"""
	requests: WorkloadResourceQuantity!
}

"""
Resource quantities for a workload.
"""
type WorkloadResourceQuantity {
	"""
	The number of CPU cores.
	"""
	cpu: Float!

	"""
	The amount of memory in bytes.
	"""
	memory: Int!
}

"""
Interface for authentication and authorization integrations.

Read more about this topic in the [Nais documentation](https://docs.nais.io/auth/).
"""
interface AuthIntegration {
	"""
	The name of the integration.
	"""
	name: String!
}

"""
Entra ID (f.k.a. Azure AD) authentication.

Read more: https://docs.nais.io/auth/entra-id/
"""
type EntraIDAuthIntegration implements AuthIntegration {
	"""
	The name of the integration.
	"""
	name: String!
}

"""
ID-porten authentication.

Read more: https://docs.nais.io/auth/idporten/
"""
type IDPortenAuthIntegration implements AuthIntegration {
	"""
	The name of the integration.
	"""
	name: String!
}

"""
Maskinporten authentication.

Read more: https://docs.nais.io/auth/maskinporten/
"""
type MaskinportenAuthIntegration implements AuthIntegration {
	"""
	The name of the integration.
	"""
	name: String!
}

"""
TokenX authentication.

Read more: https://docs.nais.io/auth/tokenx/
"""
type TokenXAuthIntegration implements AuthIntegration {
	"""
	The name of the integration.
	"""
	name: String!
}

"""
Workload connection.
"""
type WorkloadConnection {
	"""
	Pagination information.
	"""
	pageInfo: PageInfo!

	"""
	List of nodes.
	"""
	nodes: [Workload!]!

	"""
	List of edges.
	"""
	edges: [WorkloadEdge!]!
}

"""
Workload edge.
"""
type WorkloadEdge {
	"""
	Cursor for this edge that can be used for pagination.
	"""
	cursor: Cursor!

	"""
	The Workload.
	"""
	node: Workload!
}

"""
Ordering options when fetching workloads.
"""
input WorkloadOrder {
	"""
	The field to order items by.
	"""
	field: WorkloadOrderField!

	"""
	The direction to order items by.
	"""
	direction: OrderDirection!
}

"""
Fields to order workloads by.
"""
enum WorkloadOrderField {
	"""
	Order by name.
	"""
	NAME

	"""
	Order by status.
	"""
	STATUS

	"""
	Order by the name of the environment the workload is deployed in.
	"""
	ENVIRONMENT

	"""
	Order by the deployment time.
	"""
	DEPLOYMENT_TIME
}

"""
Ordering options when fetching workloads in an environment.
"""
input EnvironmentWorkloadOrder {
	"""
	The field to order items by.
	"""
	field: EnvironmentWorkloadOrderField!

	"""
	The direction to order items by.
	"""
	direction: OrderDirection!
}

"""
Fields to order workloads in an environment by.
"""
enum EnvironmentWorkloadOrderField {
	"""
	Order by name.
	"""
	NAME

	"""
	Order by team slug.
	"""
	TEAM_SLUG

	"""
	Order by status.
	"""
	STATUS

	"""
	Order by the deployment time.
	"""
	DEPLOYMENT_TIME
}

"""
Input for filtering team workloads.
"""
input TeamWorkloadsFilter {
	"""
	Only return workloads from the given named environments.
	"""
	environments: [String!]
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Application_bigQueryDatasets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Application_bigQueryDatasets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Application_bigQueryDatasets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*bigquery.BigQueryDatasetOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *bigquery.BigQueryDatasetOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBigQueryDatasetOrder2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetOrder(ctx, tmp)
	}

	var zeroVal *bigquery.BigQueryDatasetOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Application_buckets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Application_buckets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Application_buckets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*bucket.BucketOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *bucket.BucketOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBucketOrder2githubcomnaisapiinternalpersistencebucketBucketOrder(ctx, tmp)
	}

	var zeroVal *bucket.BucketOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Application_deployments_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Application_deployments_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Application_deployments_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Application_deployments_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Application_deployments_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Application_deployments_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Application_deployments_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Application_deployments_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Application_deployments_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Application_instances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Application_instances_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Application_instances_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Application_instances_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Application_instances_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Application_instances_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Application_instances_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Application_instances_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Application_instances_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Application_kafkaTopicAcls_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Application_kafkaTopicAcls_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Application_kafkaTopicAcls_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*kafkatopic.KafkaTopicACLOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *kafkatopic.KafkaTopicACLOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOKafkaTopicAclOrder2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACLOrder(ctx, tmp)
	}

	var zeroVal *kafkatopic.KafkaTopicACLOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Application_redisInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Application_redisInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Application_redisInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*redis.RedisInstanceOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *redis.RedisInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalORedisInstanceOrder2githubcomnaisapiinternalpersistenceredisRedisInstanceOrder(ctx, tmp)
	}

	var zeroVal *redis.RedisInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Application_secrets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Application_secrets_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Application_secrets_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Application_secrets_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Application_secrets_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Application_secrets_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Application_secrets_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Application_secrets_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Application_secrets_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Application_sqlInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Application_sqlInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Application_sqlInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*sqlinstance.SQLInstanceOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *sqlinstance.SQLInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOSqlInstanceOrder2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceOrder(ctx, tmp)
	}

	var zeroVal *sqlinstance.SQLInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Application_valkeyInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Application_valkeyInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Application_valkeyInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*valkey.ValkeyInstanceOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *valkey.ValkeyInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOValkeyInstanceOrder2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceOrder(ctx, tmp)
	}

	var zeroVal *valkey.ValkeyInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_BigQueryDataset_access_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_BigQueryDataset_access_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_BigQueryDataset_access_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_BigQueryDataset_access_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_BigQueryDataset_access_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_BigQueryDataset_access_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_BigQueryDataset_access_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_BigQueryDataset_access_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_BigQueryDataset_access_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_BigQueryDataset_access_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_BigQueryDataset_access_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*bigquery.BigQueryDatasetAccessOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *bigquery.BigQueryDatasetAccessOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBigQueryDatasetAccessOrder2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetAccessOrder(ctx, tmp)
	}

	var zeroVal *bigquery.BigQueryDatasetAccessOrder
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_vulnerabilities_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_ContainerImage_vulnerabilities_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_ContainerImage_vulnerabilities_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_ContainerImage_vulnerabilities_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_ContainerImage_vulnerabilities_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_ContainerImage_vulnerabilities_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_ContainerImage_vulnerabilities_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_vulnerabilities_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_vulnerabilities_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_vulnerabilities_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_vulnerabilities_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*vulnerability.ImageVulnerabilityOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *vulnerability.ImageVulnerabilityOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOImageVulnerabilityOrder2githubcomnaisapiinternalvulnerabilityImageVulnerabilityOrder(ctx, tmp)
	}

	var zeroVal *vulnerability.ImageVulnerabilityOrder
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_workloadReferences_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_ContainerImage_workloadReferences_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_ContainerImage_workloadReferences_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_ContainerImage_workloadReferences_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_ContainerImage_workloadReferences_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_ContainerImage_workloadReferences_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_workloadReferences_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_workloadReferences_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ContainerImage_workloadReferences_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Deployment_resources_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Deployment_resources_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Deployment_resources_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Deployment_resources_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Deployment_resources_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Deployment_resources_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Deployment_resources_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Deployment_resources_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Deployment_resources_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Deployment_statuses_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Deployment_statuses_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Deployment_statuses_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Deployment_statuses_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Deployment_statuses_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Deployment_statuses_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Deployment_statuses_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Deployment_statuses_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Deployment_statuses_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Environment_workloads_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Environment_workloads_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Environment_workloads_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Environment_workloads_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Environment_workloads_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Environment_workloads_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Environment_workloads_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Environment_workloads_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Environment_workloads_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Environment_workloads_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Environment_workloads_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*workload.EnvironmentWorkloadOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *workload.EnvironmentWorkloadOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOEnvironmentWorkloadOrder2githubcomnaisapiinternalworkloadEnvironmentWorkloadOrder(ctx, tmp)
	}

	var zeroVal *workload.EnvironmentWorkloadOrder
	return zeroVal, nil
}

func (ec *executionContext) field_ImageVulnerabilityAnalysisTrail_comments_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_ImageVulnerabilityAnalysisTrail_comments_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_ImageVulnerabilityAnalysisTrail_comments_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_ImageVulnerabilityAnalysisTrail_comments_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_ImageVulnerabilityAnalysisTrail_comments_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_ImageVulnerabilityAnalysisTrail_comments_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ImageVulnerabilityAnalysisTrail_comments_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ImageVulnerabilityAnalysisTrail_comments_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ImageVulnerabilityAnalysisTrail_comments_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_JobRun_instances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_JobRun_instances_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_JobRun_instances_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_JobRun_instances_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_JobRun_instances_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_JobRun_instances_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_JobRun_instances_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_JobRun_instances_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_JobRun_instances_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Job_bigQueryDatasets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Job_bigQueryDatasets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Job_bigQueryDatasets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*bigquery.BigQueryDatasetOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *bigquery.BigQueryDatasetOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBigQueryDatasetOrder2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetOrder(ctx, tmp)
	}

	var zeroVal *bigquery.BigQueryDatasetOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Job_buckets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Job_buckets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Job_buckets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*bucket.BucketOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *bucket.BucketOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBucketOrder2githubcomnaisapiinternalpersistencebucketBucketOrder(ctx, tmp)
	}

	var zeroVal *bucket.BucketOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Job_deployments_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Job_deployments_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Job_deployments_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Job_deployments_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Job_deployments_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Job_deployments_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Job_deployments_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Job_deployments_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Job_deployments_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Job_kafkaTopicAcls_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Job_kafkaTopicAcls_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Job_kafkaTopicAcls_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*kafkatopic.KafkaTopicACLOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *kafkatopic.KafkaTopicACLOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOKafkaTopicAclOrder2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACLOrder(ctx, tmp)
	}

	var zeroVal *kafkatopic.KafkaTopicACLOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Job_redisInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Job_redisInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Job_redisInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*redis.RedisInstanceOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *redis.RedisInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalORedisInstanceOrder2githubcomnaisapiinternalpersistenceredisRedisInstanceOrder(ctx, tmp)
	}

	var zeroVal *redis.RedisInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Job_runs_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Job_runs_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Job_runs_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Job_runs_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Job_runs_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Job_runs_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Job_runs_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Job_runs_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Job_runs_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Job_secrets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Job_secrets_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Job_secrets_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Job_secrets_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Job_secrets_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Job_secrets_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Job_secrets_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Job_secrets_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Job_secrets_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Job_sqlInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Job_sqlInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Job_sqlInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*sqlinstance.SQLInstanceOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *sqlinstance.SQLInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOSqlInstanceOrder2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceOrder(ctx, tmp)
	}

	var zeroVal *sqlinstance.SQLInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Job_valkeyInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Job_valkeyInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Job_valkeyInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*valkey.ValkeyInstanceOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *valkey.ValkeyInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOValkeyInstanceOrder2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceOrder(ctx, tmp)
	}

	var zeroVal *valkey.ValkeyInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_KafkaTopic_acl_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_KafkaTopic_acl_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_KafkaTopic_acl_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_KafkaTopic_acl_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_KafkaTopic_acl_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg4
	arg5, err := ec.field_KafkaTopic_acl_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg5
	return args, nil
}
func (ec *executionContext) field_KafkaTopic_acl_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (*kafkatopic.KafkaTopicACLFilter, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal *kafkatopic.KafkaTopicACLFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalOKafkaTopicAclFilter2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACLFilter(ctx, tmp)
	}

	var zeroVal *kafkatopic.KafkaTopicACLFilter
	return zeroVal, nil
}

func (ec *executionContext) field_KafkaTopic_acl_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*kafkatopic.KafkaTopicACLOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *kafkatopic.KafkaTopicACLOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOKafkaTopicAclOrder2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACLOrder(ctx, tmp)
	}

	var zeroVal *kafkatopic.KafkaTopicACLOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addRepositoryToTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addRepositoryToTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addRepositoryToTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (repository.AddRepositoryToTeamInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal repository.AddRepositoryToTeamInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAddRepositoryToTeamInput2githubcomnaisapiinternalgithubrepositoryAddRepositoryToTeamInput(ctx, tmp)
	}

	var zeroVal repository.AddRepositoryToTeamInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addSecretValue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addSecretValue_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addSecretValue_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (secret.AddSecretValueInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal secret.AddSecretValueInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAddSecretValueInput2githubcomnaisapiinternalworkloadsecretAddSecretValueInput(ctx, tmp)
	}

	var zeroVal secret.AddSecretValueInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addTeamMember_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addTeamMember_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addTeamMember_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (team.AddTeamMemberInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal team.AddTeamMemberInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAddTeamMemberInput2githubcomnaisapiinternalteamAddTeamMemberInput(ctx, tmp)
	}

	var zeroVal team.AddTeamMemberInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_allowTeamAccessToUnleash_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_allowTeamAccessToUnleash_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_allowTeamAccessToUnleash_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (unleash.AllowTeamAccessToUnleashInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal unleash.AllowTeamAccessToUnleashInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAllowTeamAccessToUnleashInput2githubcomnaisapiinternalunleashAllowTeamAccessToUnleashInput(ctx, tmp)
	}

	var zeroVal unleash.AllowTeamAccessToUnleashInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_assignRoleToServiceAccount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_assignRoleToServiceAccount_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_assignRoleToServiceAccount_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (serviceaccount.AssignRoleToServiceAccountInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal serviceaccount.AssignRoleToServiceAccountInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAssignRoleToServiceAccountInput2githubcomnaisapiinternalserviceaccountAssignRoleToServiceAccountInput(ctx, tmp)
	}

	var zeroVal serviceaccount.AssignRoleToServiceAccountInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_changeDeploymentKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_changeDeploymentKey_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_changeDeploymentKey_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (deployment.ChangeDeploymentKeyInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal deployment.ChangeDeploymentKeyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNChangeDeploymentKeyInput2githubcomnaisapiinternaldeploymentChangeDeploymentKeyInput(ctx, tmp)
	}

	var zeroVal deployment.ChangeDeploymentKeyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_configureReconciler_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_configureReconciler_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_configureReconciler_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (reconciler.ConfigureReconcilerInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal reconciler.ConfigureReconcilerInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNConfigureReconcilerInput2githubcomnaisapiinternalreconcilerConfigureReconcilerInput(ctx, tmp)
	}

	var zeroVal reconciler.ConfigureReconcilerInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_confirmTeamDeletion_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_confirmTeamDeletion_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_confirmTeamDeletion_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (team.ConfirmTeamDeletionInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal team.ConfirmTeamDeletionInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNConfirmTeamDeletionInput2githubcomnaisapiinternalteamConfirmTeamDeletionInput(ctx, tmp)
	}

	var zeroVal team.ConfirmTeamDeletionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createSecret_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createSecret_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createSecret_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (secret.CreateSecretInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal secret.CreateSecretInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCreateSecretInput2githubcomnaisapiinternalworkloadsecretCreateSecretInput(ctx, tmp)
	}

	var zeroVal secret.CreateSecretInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createServiceAccountToken_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createServiceAccountToken_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createServiceAccountToken_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (serviceaccount.CreateServiceAccountTokenInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal serviceaccount.CreateServiceAccountTokenInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCreateServiceAccountTokenInput2githubcomnaisapiinternalserviceaccountCreateServiceAccountTokenInput(ctx, tmp)
	}

	var zeroVal serviceaccount.CreateServiceAccountTokenInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createServiceAccount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createServiceAccount_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createServiceAccount_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (serviceaccount.CreateServiceAccountInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal serviceaccount.CreateServiceAccountInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCreateServiceAccountInput2githubcomnaisapiinternalserviceaccountCreateServiceAccountInput(ctx, tmp)
	}

	var zeroVal serviceaccount.CreateServiceAccountInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (team.CreateTeamInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal team.CreateTeamInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCreateTeamInput2githubcomnaisapiinternalteamCreateTeamInput(ctx, tmp)
	}

	var zeroVal team.CreateTeamInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createUnleashForTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createUnleashForTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createUnleashForTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (unleash.CreateUnleashForTeamInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal unleash.CreateUnleashForTeamInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCreateUnleashForTeamInput2githubcomnaisapiinternalunleashCreateUnleashForTeamInput(ctx, tmp)
	}

	var zeroVal unleash.CreateUnleashForTeamInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteApplication_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteApplication_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteApplication_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (application.DeleteApplicationInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal application.DeleteApplicationInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNDeleteApplicationInput2githubcomnaisapiinternalworkloadapplicationDeleteApplicationInput(ctx, tmp)
	}

	var zeroVal application.DeleteApplicationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteJob_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteJob_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteJob_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (job.DeleteJobInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal job.DeleteJobInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNDeleteJobInput2githubcomnaisapiinternalworkloadjobDeleteJobInput(ctx, tmp)
	}

	var zeroVal job.DeleteJobInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteSecret_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteSecret_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteSecret_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (secret.DeleteSecretInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal secret.DeleteSecretInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNDeleteSecretInput2githubcomnaisapiinternalworkloadsecretDeleteSecretInput(ctx, tmp)
	}

	var zeroVal secret.DeleteSecretInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteServiceAccountToken_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteServiceAccountToken_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteServiceAccountToken_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (serviceaccount.DeleteServiceAccountTokenInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal serviceaccount.DeleteServiceAccountTokenInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNDeleteServiceAccountTokenInput2githubcomnaisapiinternalserviceaccountDeleteServiceAccountTokenInput(ctx, tmp)
	}

	var zeroVal serviceaccount.DeleteServiceAccountTokenInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteServiceAccount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteServiceAccount_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteServiceAccount_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (serviceaccount.DeleteServiceAccountInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal serviceaccount.DeleteServiceAccountInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNDeleteServiceAccountInput2githubcomnaisapiinternalserviceaccountDeleteServiceAccountInput(ctx, tmp)
	}

	var zeroVal serviceaccount.DeleteServiceAccountInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_disableReconciler_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_disableReconciler_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_disableReconciler_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (reconciler.DisableReconcilerInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal reconciler.DisableReconcilerInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNDisableReconcilerInput2githubcomnaisapiinternalreconcilerDisableReconcilerInput(ctx, tmp)
	}

	var zeroVal reconciler.DisableReconcilerInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_enableReconciler_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_enableReconciler_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_enableReconciler_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (reconciler.EnableReconcilerInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal reconciler.EnableReconcilerInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNEnableReconcilerInput2githubcomnaisapiinternalreconcilerEnableReconcilerInput(ctx, tmp)
	}

	var zeroVal reconciler.EnableReconcilerInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeRepositoryFromTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeRepositoryFromTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeRepositoryFromTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (repository.RemoveRepositoryFromTeamInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal repository.RemoveRepositoryFromTeamInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRemoveRepositoryFromTeamInput2githubcomnaisapiinternalgithubrepositoryRemoveRepositoryFromTeamInput(ctx, tmp)
	}

	var zeroVal repository.RemoveRepositoryFromTeamInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeSecretValue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeSecretValue_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeSecretValue_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (secret.RemoveSecretValueInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal secret.RemoveSecretValueInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRemoveSecretValueInput2githubcomnaisapiinternalworkloadsecretRemoveSecretValueInput(ctx, tmp)
	}

	var zeroVal secret.RemoveSecretValueInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeTeamMember_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeTeamMember_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeTeamMember_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (team.RemoveTeamMemberInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal team.RemoveTeamMemberInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRemoveTeamMemberInput2githubcomnaisapiinternalteamRemoveTeamMemberInput(ctx, tmp)
	}

	var zeroVal team.RemoveTeamMemberInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_requestTeamDeletion_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_requestTeamDeletion_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_requestTeamDeletion_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (team.RequestTeamDeletionInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal team.RequestTeamDeletionInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRequestTeamDeletionInput2githubcomnaisapiinternalteamRequestTeamDeletionInput(ctx, tmp)
	}

	var zeroVal team.RequestTeamDeletionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_restartApplication_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_restartApplication_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_restartApplication_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (application.RestartApplicationInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal application.RestartApplicationInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRestartApplicationInput2githubcomnaisapiinternalworkloadapplicationRestartApplicationInput(ctx, tmp)
	}

	var zeroVal application.RestartApplicationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_revokeRoleFromServiceAccount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_revokeRoleFromServiceAccount_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_revokeRoleFromServiceAccount_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (serviceaccount.RevokeRoleFromServiceAccountInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal serviceaccount.RevokeRoleFromServiceAccountInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRevokeRoleFromServiceAccountInput2githubcomnaisapiinternalserviceaccountRevokeRoleFromServiceAccountInput(ctx, tmp)
	}

	var zeroVal serviceaccount.RevokeRoleFromServiceAccountInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_revokeTeamAccessToUnleash_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_revokeTeamAccessToUnleash_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_revokeTeamAccessToUnleash_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (unleash.RevokeTeamAccessToUnleashInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal unleash.RevokeTeamAccessToUnleashInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRevokeTeamAccessToUnleashInput2githubcomnaisapiinternalunleashRevokeTeamAccessToUnleashInput(ctx, tmp)
	}

	var zeroVal unleash.RevokeTeamAccessToUnleashInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setTeamMemberRole_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setTeamMemberRole_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_setTeamMemberRole_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (team.SetTeamMemberRoleInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal team.SetTeamMemberRoleInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSetTeamMemberRoleInput2githubcomnaisapiinternalteamSetTeamMemberRoleInput(ctx, tmp)
	}

	var zeroVal team.SetTeamMemberRoleInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_triggerJob_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_triggerJob_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_triggerJob_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (job.TriggerJobInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal job.TriggerJobInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNTriggerJobInput2githubcomnaisapiinternalworkloadjobTriggerJobInput(ctx, tmp)
	}

	var zeroVal job.TriggerJobInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateImageVulnerability_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateImageVulnerability_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateImageVulnerability_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (vulnerability.UpdateImageVulnerabilityInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal vulnerability.UpdateImageVulnerabilityInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateImageVulnerabilityInput2githubcomnaisapiinternalvulnerabilityUpdateImageVulnerabilityInput(ctx, tmp)
	}

	var zeroVal vulnerability.UpdateImageVulnerabilityInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateSecretValue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateSecretValue_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateSecretValue_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (secret.UpdateSecretValueInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal secret.UpdateSecretValueInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateSecretValueInput2githubcomnaisapiinternalworkloadsecretUpdateSecretValueInput(ctx, tmp)
	}

	var zeroVal secret.UpdateSecretValueInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateServiceAccountToken_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateServiceAccountToken_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateServiceAccountToken_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (serviceaccount.UpdateServiceAccountTokenInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal serviceaccount.UpdateServiceAccountTokenInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateServiceAccountTokenInput2githubcomnaisapiinternalserviceaccountUpdateServiceAccountTokenInput(ctx, tmp)
	}

	var zeroVal serviceaccount.UpdateServiceAccountTokenInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateServiceAccount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateServiceAccount_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateServiceAccount_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (serviceaccount.UpdateServiceAccountInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal serviceaccount.UpdateServiceAccountInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateServiceAccountInput2githubcomnaisapiinternalserviceaccountUpdateServiceAccountInput(ctx, tmp)
	}

	var zeroVal serviceaccount.UpdateServiceAccountInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTeamEnvironment_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateTeamEnvironment_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateTeamEnvironment_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (team.UpdateTeamEnvironmentInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal team.UpdateTeamEnvironmentInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateTeamEnvironmentInput2githubcomnaisapiinternalteamUpdateTeamEnvironmentInput(ctx, tmp)
	}

	var zeroVal team.UpdateTeamEnvironmentInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (team.UpdateTeamInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal team.UpdateTeamInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateTeamInput2githubcomnaisapiinternalteamUpdateTeamInput(ctx, tmp)
	}

	var zeroVal team.UpdateTeamInput
	return zeroVal, nil
}

func (ec *executionContext) field_OpenSearch_access_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_OpenSearch_access_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_OpenSearch_access_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_OpenSearch_access_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_OpenSearch_access_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_OpenSearch_access_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_OpenSearch_access_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_OpenSearch_access_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_OpenSearch_access_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_OpenSearch_access_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_OpenSearch_access_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*opensearch.OpenSearchAccessOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *opensearch.OpenSearchAccessOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOOpenSearchAccessOrder2githubcomnaisapiinternalpersistenceopensearchOpenSearchAccessOrder(ctx, tmp)
	}

	var zeroVal *opensearch.OpenSearchAccessOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_environment_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_environment_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_environment_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_environments_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_environments_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_environments_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*environment.EnvironmentOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *environment.EnvironmentOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOEnvironmentOrder2githubcomnaisapiinternalenvironmentEnvironmentOrder(ctx, tmp)
	}

	var zeroVal *environment.EnvironmentOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_node_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_node_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (ident.Ident, error) {
	if _, ok := rawArgs["id"]; !ok {
		var zeroVal ident.Ident
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, tmp)
	}

	var zeroVal ident.Ident
	return zeroVal, nil
}

func (ec *executionContext) field_Query_reconcilers_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_reconcilers_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Query_reconcilers_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Query_reconcilers_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Query_reconcilers_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_reconcilers_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_reconcilers_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_reconcilers_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_reconcilers_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_roles_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_roles_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Query_roles_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Query_roles_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Query_roles_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_roles_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_roles_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_roles_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_roles_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_search_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_search_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Query_search_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Query_search_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Query_search_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Query_search_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg4
	return args, nil
}
func (ec *executionContext) field_Query_search_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_search_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_search_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_search_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_search_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (search.SearchFilter, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal search.SearchFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNSearchFilter2githubcomnaisapiinternalsearchSearchFilter(ctx, tmp)
	}

	var zeroVal search.SearchFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_serviceAccount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_serviceAccount_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_serviceAccount_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (ident.Ident, error) {
	if _, ok := rawArgs["id"]; !ok {
		var zeroVal ident.Ident
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, tmp)
	}

	var zeroVal ident.Ident
	return zeroVal, nil
}

func (ec *executionContext) field_Query_serviceAccounts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_serviceAccounts_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Query_serviceAccounts_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Query_serviceAccounts_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Query_serviceAccounts_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_serviceAccounts_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_serviceAccounts_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_serviceAccounts_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_serviceAccounts_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_team_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_team_argsSlug(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["slug"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_team_argsSlug(
	ctx context.Context,
	rawArgs map[string]any,
) (slug.Slug, error) {
	if _, ok := rawArgs["slug"]; !ok {
		var zeroVal slug.Slug
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
	if tmp, ok := rawArgs["slug"]; ok {
		return ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, tmp)
	}

	var zeroVal slug.Slug
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teamsUtilization_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_teamsUtilization_argsResourceType(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["resourceType"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_teamsUtilization_argsResourceType(
	ctx context.Context,
	rawArgs map[string]any,
) (utilization.UtilizationResourceType, error) {
	if _, ok := rawArgs["resourceType"]; !ok {
		var zeroVal utilization.UtilizationResourceType
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
	if tmp, ok := rawArgs["resourceType"]; ok {
		return ec.unmarshalNUtilizationResourceType2githubcomnaisapiinternalutilizationUtilizationResourceType(ctx, tmp)
	}

	var zeroVal utilization.UtilizationResourceType
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teams_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_teams_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Query_teams_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Query_teams_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Query_teams_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Query_teams_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Query_teams_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teams_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teams_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teams_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teams_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*team.TeamOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *team.TeamOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOTeamOrder2githubcomnaisapiinternalteamTeamOrder(ctx, tmp)
	}

	var zeroVal *team.TeamOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Query_userSyncLog_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_userSyncLog_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Query_userSyncLog_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Query_userSyncLog_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Query_userSyncLog_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_userSyncLog_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_userSyncLog_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_userSyncLog_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_userSyncLog_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_user_argsEmail(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["email"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_user_argsEmail(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["email"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
	if tmp, ok := rawArgs["email"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_users_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Query_users_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Query_users_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Query_users_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Query_users_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Query_users_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_users_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_users_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_users_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Query_users_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*user.UserOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *user.UserOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOUserOrder2githubcomnaisapiinternaluserUserOrder(ctx, tmp)
	}

	var zeroVal *user.UserOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Reconciler_activityLog_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Reconciler_activityLog_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Reconciler_activityLog_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Reconciler_activityLog_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Reconciler_activityLog_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Reconciler_activityLog_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Reconciler_activityLog_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Reconciler_activityLog_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Reconciler_activityLog_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Reconciler_errors_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Reconciler_errors_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Reconciler_errors_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Reconciler_errors_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Reconciler_errors_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Reconciler_errors_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Reconciler_errors_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Reconciler_errors_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Reconciler_errors_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_RedisInstance_access_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_RedisInstance_access_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_RedisInstance_access_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_RedisInstance_access_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_RedisInstance_access_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_RedisInstance_access_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_RedisInstance_access_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_RedisInstance_access_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_RedisInstance_access_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_RedisInstance_access_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_RedisInstance_access_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*redis.RedisInstanceAccessOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *redis.RedisInstanceAccessOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalORedisInstanceAccessOrder2githubcomnaisapiinternalpersistenceredisRedisInstanceAccessOrder(ctx, tmp)
	}

	var zeroVal *redis.RedisInstanceAccessOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_applications_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Secret_applications_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Secret_applications_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Secret_applications_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Secret_applications_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Secret_applications_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_applications_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_applications_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_applications_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_jobs_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Secret_jobs_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Secret_jobs_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Secret_jobs_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Secret_jobs_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Secret_jobs_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_jobs_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_jobs_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_jobs_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_workloads_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Secret_workloads_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Secret_workloads_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Secret_workloads_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Secret_workloads_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Secret_workloads_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_workloads_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_workloads_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Secret_workloads_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ServiceAccount_roles_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_ServiceAccount_roles_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_ServiceAccount_roles_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_ServiceAccount_roles_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_ServiceAccount_roles_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_ServiceAccount_roles_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ServiceAccount_roles_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ServiceAccount_roles_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ServiceAccount_roles_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ServiceAccount_tokens_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_ServiceAccount_tokens_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_ServiceAccount_tokens_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_ServiceAccount_tokens_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_ServiceAccount_tokens_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_ServiceAccount_tokens_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ServiceAccount_tokens_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ServiceAccount_tokens_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ServiceAccount_tokens_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_flags_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_SqlInstance_flags_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_SqlInstance_flags_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_SqlInstance_flags_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_SqlInstance_flags_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_SqlInstance_flags_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_flags_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_flags_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_flags_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_users_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_SqlInstance_users_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_SqlInstance_users_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_SqlInstance_users_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_SqlInstance_users_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_SqlInstance_users_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_SqlInstance_users_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_users_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_users_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_users_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_SqlInstance_users_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*sqlinstance.SQLInstanceUserOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *sqlinstance.SQLInstanceUserOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOSqlInstanceUserOrder2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceUserOrder(ctx, tmp)
	}

	var zeroVal *sqlinstance.SQLInstanceUserOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Subscription_workloadLog_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Subscription_workloadLog_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	return args, nil
}
func (ec *executionContext) field_Subscription_workloadLog_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (podlog.WorkloadLogSubscriptionFilter, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal podlog.WorkloadLogSubscriptionFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNWorkloadLogSubscriptionFilter2githubcomnaisapiinternalworkloadpodlogWorkloadLogSubscriptionFilter(ctx, tmp)
	}

	var zeroVal podlog.WorkloadLogSubscriptionFilter
	return zeroVal, nil
}

func (ec *executionContext) field_TeamCost_daily_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamCost_daily_argsFrom(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["from"] = arg0
	arg1, err := ec.field_TeamCost_daily_argsTo(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["to"] = arg1
	arg2, err := ec.field_TeamCost_daily_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg2
	return args, nil
}
func (ec *executionContext) field_TeamCost_daily_argsFrom(
	ctx context.Context,
	rawArgs map[string]any,
) (scalar.Date, error) {
	if _, ok := rawArgs["from"]; !ok {
		var zeroVal scalar.Date
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
	if tmp, ok := rawArgs["from"]; ok {
		return ec.unmarshalNDate2githubcomnaisapiinternalgraphscalarDate(ctx, tmp)
	}

	var zeroVal scalar.Date
	return zeroVal, nil
}

func (ec *executionContext) field_TeamCost_daily_argsTo(
	ctx context.Context,
	rawArgs map[string]any,
) (scalar.Date, error) {
	if _, ok := rawArgs["to"]; !ok {
		var zeroVal scalar.Date
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
	if tmp, ok := rawArgs["to"]; ok {
		return ec.unmarshalNDate2githubcomnaisapiinternalgraphscalarDate(ctx, tmp)
	}

	var zeroVal scalar.Date
	return zeroVal, nil
}

func (ec *executionContext) field_TeamCost_daily_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (*cost.TeamCostDailyFilter, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal *cost.TeamCostDailyFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalOTeamCostDailyFilter2githubcomnaisapiinternalcostTeamCostDailyFilter(ctx, tmp)
	}

	var zeroVal *cost.TeamCostDailyFilter
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironmentCost_daily_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironmentCost_daily_argsFrom(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["from"] = arg0
	arg1, err := ec.field_TeamEnvironmentCost_daily_argsTo(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["to"] = arg1
	return args, nil
}
func (ec *executionContext) field_TeamEnvironmentCost_daily_argsFrom(
	ctx context.Context,
	rawArgs map[string]any,
) (scalar.Date, error) {
	if _, ok := rawArgs["from"]; !ok {
		var zeroVal scalar.Date
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
	if tmp, ok := rawArgs["from"]; ok {
		return ec.unmarshalNDate2githubcomnaisapiinternalgraphscalarDate(ctx, tmp)
	}

	var zeroVal scalar.Date
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironmentCost_daily_argsTo(
	ctx context.Context,
	rawArgs map[string]any,
) (scalar.Date, error) {
	if _, ok := rawArgs["to"]; !ok {
		var zeroVal scalar.Date
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
	if tmp, ok := rawArgs["to"]; ok {
		return ec.unmarshalNDate2githubcomnaisapiinternalgraphscalarDate(ctx, tmp)
	}

	var zeroVal scalar.Date
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_application_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironment_application_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_application_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_bigQueryDataset_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironment_bigQueryDataset_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_bigQueryDataset_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_bucket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironment_bucket_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_bucket_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_job_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironment_job_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_job_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_kafkaTopic_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironment_kafkaTopic_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_kafkaTopic_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_openSearchInstance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironment_openSearchInstance_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_openSearchInstance_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_redisInstance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironment_redisInstance_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_redisInstance_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_secret_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironment_secret_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_secret_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_sqlInstance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironment_sqlInstance_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_sqlInstance_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_valkeyInstance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironment_valkeyInstance_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_valkeyInstance_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_TeamEnvironment_workload_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_TeamEnvironment_workload_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_TeamEnvironment_workload_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Team_activityLog_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_activityLog_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_activityLog_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_activityLog_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_activityLog_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Team_activityLog_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_activityLog_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_activityLog_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_activityLog_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_applications_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_applications_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_applications_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_applications_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_applications_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_applications_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	arg5, err := ec.field_Team_applications_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg5
	return args, nil
}
func (ec *executionContext) field_Team_applications_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_applications_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_applications_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_applications_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_applications_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*application.ApplicationOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *application.ApplicationOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOApplicationOrder2githubcomnaisapiinternalworkloadapplicationApplicationOrder(ctx, tmp)
	}

	var zeroVal *application.ApplicationOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_applications_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (*application.TeamApplicationsFilter, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal *application.TeamApplicationsFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalOTeamApplicationsFilter2githubcomnaisapiinternalworkloadapplicationTeamApplicationsFilter(ctx, tmp)
	}

	var zeroVal *application.TeamApplicationsFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Team_bigQueryDatasets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_bigQueryDatasets_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_bigQueryDatasets_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_bigQueryDatasets_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_bigQueryDatasets_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_bigQueryDatasets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_bigQueryDatasets_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_bigQueryDatasets_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_bigQueryDatasets_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_bigQueryDatasets_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_bigQueryDatasets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*bigquery.BigQueryDatasetOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *bigquery.BigQueryDatasetOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBigQueryDatasetOrder2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetOrder(ctx, tmp)
	}

	var zeroVal *bigquery.BigQueryDatasetOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_buckets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_buckets_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_buckets_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_buckets_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_buckets_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_buckets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_buckets_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_buckets_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_buckets_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_buckets_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_buckets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*bucket.BucketOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *bucket.BucketOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOBucketOrder2githubcomnaisapiinternalpersistencebucketBucketOrder(ctx, tmp)
	}

	var zeroVal *bucket.BucketOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_deleteKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_deleteKey_argsKey(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["key"] = arg0
	return args, nil
}
func (ec *executionContext) field_Team_deleteKey_argsKey(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["key"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
	if tmp, ok := rawArgs["key"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Team_deployments_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_deployments_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_deployments_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_deployments_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_deployments_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_Team_deployments_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_deployments_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_deployments_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_deployments_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_environment_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_environment_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Team_environment_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Team_jobs_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_jobs_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_jobs_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_jobs_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_jobs_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_jobs_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	arg5, err := ec.field_Team_jobs_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg5
	return args, nil
}
func (ec *executionContext) field_Team_jobs_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_jobs_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_jobs_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_jobs_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_jobs_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*job.JobOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *job.JobOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOJobOrder2githubcomnaisapiinternalworkloadjobJobOrder(ctx, tmp)
	}

	var zeroVal *job.JobOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_jobs_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (*job.TeamJobsFilter, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal *job.TeamJobsFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalOTeamJobsFilter2githubcomnaisapiinternalworkloadjobTeamJobsFilter(ctx, tmp)
	}

	var zeroVal *job.TeamJobsFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Team_kafkaTopics_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_kafkaTopics_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_kafkaTopics_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_kafkaTopics_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_kafkaTopics_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_kafkaTopics_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_kafkaTopics_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_kafkaTopics_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_kafkaTopics_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_kafkaTopics_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_kafkaTopics_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*kafkatopic.KafkaTopicOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *kafkatopic.KafkaTopicOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOKafkaTopicOrder2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicOrder(ctx, tmp)
	}

	var zeroVal *kafkatopic.KafkaTopicOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_member_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_member_argsEmail(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["email"] = arg0
	return args, nil
}
func (ec *executionContext) field_Team_member_argsEmail(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["email"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
	if tmp, ok := rawArgs["email"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Team_members_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_members_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_members_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_members_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_members_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_members_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_members_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_members_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_members_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_members_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_members_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*team.TeamMemberOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *team.TeamMemberOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOTeamMemberOrder2githubcomnaisapiinternalteamTeamMemberOrder(ctx, tmp)
	}

	var zeroVal *team.TeamMemberOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_openSearchInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_openSearchInstances_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_openSearchInstances_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_openSearchInstances_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_openSearchInstances_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_openSearchInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_openSearchInstances_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_openSearchInstances_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_openSearchInstances_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_openSearchInstances_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_openSearchInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*opensearch.OpenSearchOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *opensearch.OpenSearchOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOOpenSearchOrder2githubcomnaisapiinternalpersistenceopensearchOpenSearchOrder(ctx, tmp)
	}

	var zeroVal *opensearch.OpenSearchOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_redisInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_redisInstances_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_redisInstances_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_redisInstances_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_redisInstances_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_redisInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_redisInstances_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_redisInstances_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_redisInstances_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_redisInstances_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_redisInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*redis.RedisInstanceOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *redis.RedisInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalORedisInstanceOrder2githubcomnaisapiinternalpersistenceredisRedisInstanceOrder(ctx, tmp)
	}

	var zeroVal *redis.RedisInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_repositories_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_repositories_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_repositories_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_repositories_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_repositories_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_repositories_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	arg5, err := ec.field_Team_repositories_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg5
	return args, nil
}
func (ec *executionContext) field_Team_repositories_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_repositories_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_repositories_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_repositories_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_repositories_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*repository.RepositoryOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *repository.RepositoryOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalORepositoryOrder2githubcomnaisapiinternalgithubrepositoryRepositoryOrder(ctx, tmp)
	}

	var zeroVal *repository.RepositoryOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_repositories_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (*repository.TeamRepositoryFilter, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal *repository.TeamRepositoryFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalOTeamRepositoryFilter2githubcomnaisapiinternalgithubrepositoryTeamRepositoryFilter(ctx, tmp)
	}

	var zeroVal *repository.TeamRepositoryFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Team_secrets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_secrets_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_secrets_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_secrets_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_secrets_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_secrets_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	arg5, err := ec.field_Team_secrets_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg5
	return args, nil
}
func (ec *executionContext) field_Team_secrets_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_secrets_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_secrets_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_secrets_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_secrets_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*secret.SecretOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *secret.SecretOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOSecretOrder2githubcomnaisapiinternalworkloadsecretSecretOrder(ctx, tmp)
	}

	var zeroVal *secret.SecretOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_secrets_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (*secret.SecretFilter, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal *secret.SecretFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalOSecretFilter2githubcomnaisapiinternalworkloadsecretSecretFilter(ctx, tmp)
	}

	var zeroVal *secret.SecretFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Team_sqlInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_sqlInstances_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_sqlInstances_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_sqlInstances_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_sqlInstances_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_sqlInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_sqlInstances_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_sqlInstances_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_sqlInstances_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_sqlInstances_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_sqlInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*sqlinstance.SQLInstanceOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *sqlinstance.SQLInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOSqlInstanceOrder2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceOrder(ctx, tmp)
	}

	var zeroVal *sqlinstance.SQLInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_valkeyInstances_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_valkeyInstances_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_valkeyInstances_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_valkeyInstances_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_valkeyInstances_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_valkeyInstances_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_Team_valkeyInstances_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_valkeyInstances_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_valkeyInstances_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_valkeyInstances_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_valkeyInstances_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*valkey.ValkeyInstanceOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *valkey.ValkeyInstanceOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOValkeyInstanceOrder2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceOrder(ctx, tmp)
	}

	var zeroVal *valkey.ValkeyInstanceOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_vulnerabilitySummary_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_vulnerabilitySummary_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	return args, nil
}
func (ec *executionContext) field_Team_vulnerabilitySummary_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (*vulnerability.TeamVulnerabilitySummaryFilter, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal *vulnerability.TeamVulnerabilitySummaryFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalOTeamVulnerabilitySummaryFilter2githubcomnaisapiinternalvulnerabilityTeamVulnerabilitySummaryFilter(ctx, tmp)
	}

	var zeroVal *vulnerability.TeamVulnerabilitySummaryFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloadUtilization_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_workloadUtilization_argsResourceType(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["resourceType"] = arg0
	return args, nil
}
func (ec *executionContext) field_Team_workloadUtilization_argsResourceType(
	ctx context.Context,
	rawArgs map[string]any,
) (utilization.UtilizationResourceType, error) {
	if _, ok := rawArgs["resourceType"]; !ok {
		var zeroVal utilization.UtilizationResourceType
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
	if tmp, ok := rawArgs["resourceType"]; ok {
		return ec.unmarshalNUtilizationResourceType2githubcomnaisapiinternalutilizationUtilizationResourceType(ctx, tmp)
	}

	var zeroVal utilization.UtilizationResourceType
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloads_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Team_workloads_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_Team_workloads_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_Team_workloads_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_Team_workloads_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_Team_workloads_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	arg5, err := ec.field_Team_workloads_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg5
	return args, nil
}
func (ec *executionContext) field_Team_workloads_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloads_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloads_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloads_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloads_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*workload.WorkloadOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *workload.WorkloadOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOWorkloadOrder2githubcomnaisapiinternalworkloadWorkloadOrder(ctx, tmp)
	}

	var zeroVal *workload.WorkloadOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Team_workloads_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (*workload.TeamWorkloadsFilter, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal *workload.TeamWorkloadsFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalOTeamWorkloadsFilter2githubcomnaisapiinternalworkloadTeamWorkloadsFilter(ctx, tmp)
	}

	var zeroVal *workload.TeamWorkloadsFilter
	return zeroVal, nil
}

func (ec *executionContext) field_UnleashInstance_allowedTeams_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_UnleashInstance_allowedTeams_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_UnleashInstance_allowedTeams_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_UnleashInstance_allowedTeams_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_UnleashInstance_allowedTeams_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	return args, nil
}
func (ec *executionContext) field_UnleashInstance_allowedTeams_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_UnleashInstance_allowedTeams_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_UnleashInstance_allowedTeams_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_UnleashInstance_allowedTeams_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_User_teams_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_User_teams_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_User_teams_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_User_teams_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_User_teams_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_User_teams_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_User_teams_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_User_teams_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_User_teams_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_User_teams_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_User_teams_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*team.UserTeamOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *team.UserTeamOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOUserTeamOrder2githubcomnaisapiinternalteamUserTeamOrder(ctx, tmp)
	}

	var zeroVal *team.UserTeamOrder
	return zeroVal, nil
}

func (ec *executionContext) field_ValkeyInstance_access_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_ValkeyInstance_access_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg0
	arg1, err := ec.field_ValkeyInstance_access_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := ec.field_ValkeyInstance_access_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg2
	arg3, err := ec.field_ValkeyInstance_access_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg3
	arg4, err := ec.field_ValkeyInstance_access_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	return args, nil
}
func (ec *executionContext) field_ValkeyInstance_access_argsFirst(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["first"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ValkeyInstance_access_argsAfter(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["after"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ValkeyInstance_access_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_ValkeyInstance_access_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*pagination.Cursor, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *pagination.Cursor
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, tmp)
	}

	var zeroVal *pagination.Cursor
	return zeroVal, nil
}

func (ec *executionContext) field_ValkeyInstance_access_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*valkey.ValkeyInstanceAccessOrder, error) {
	if _, ok := rawArgs["orderBy"]; !ok {
		var zeroVal *valkey.ValkeyInstanceAccessOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOValkeyInstanceAccessOrder2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceAccessOrder(ctx, tmp)
	}

	var zeroVal *valkey.ValkeyInstanceAccessOrder
	return zeroVal, nil
}

func (ec *executionContext) field_WorkloadCost_daily_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_WorkloadCost_daily_argsFrom(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["from"] = arg0
	arg1, err := ec.field_WorkloadCost_daily_argsTo(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["to"] = arg1
	return args, nil
}
func (ec *executionContext) field_WorkloadCost_daily_argsFrom(
	ctx context.Context,
	rawArgs map[string]any,
) (scalar.Date, error) {
	if _, ok := rawArgs["from"]; !ok {
		var zeroVal scalar.Date
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
	if tmp, ok := rawArgs["from"]; ok {
		return ec.unmarshalNDate2githubcomnaisapiinternalgraphscalarDate(ctx, tmp)
	}

	var zeroVal scalar.Date
	return zeroVal, nil
}

func (ec *executionContext) field_WorkloadCost_daily_argsTo(
	ctx context.Context,
	rawArgs map[string]any,
) (scalar.Date, error) {
	if _, ok := rawArgs["to"]; !ok {
		var zeroVal scalar.Date
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
	if tmp, ok := rawArgs["to"]; ok {
		return ec.unmarshalNDate2githubcomnaisapiinternalgraphscalarDate(ctx, tmp)
	}

	var zeroVal scalar.Date
	return zeroVal, nil
}

func (ec *executionContext) field_WorkloadUtilization_current_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_WorkloadUtilization_current_argsResourceType(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["resourceType"] = arg0
	return args, nil
}
func (ec *executionContext) field_WorkloadUtilization_current_argsResourceType(
	ctx context.Context,
	rawArgs map[string]any,
) (utilization.UtilizationResourceType, error) {
	if _, ok := rawArgs["resourceType"]; !ok {
		var zeroVal utilization.UtilizationResourceType
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
	if tmp, ok := rawArgs["resourceType"]; ok {
		return ec.unmarshalNUtilizationResourceType2githubcomnaisapiinternalutilizationUtilizationResourceType(ctx, tmp)
	}

	var zeroVal utilization.UtilizationResourceType
	return zeroVal, nil
}

func (ec *executionContext) field_WorkloadUtilization_limit_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_WorkloadUtilization_limit_argsResourceType(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["resourceType"] = arg0
	return args, nil
}
func (ec *executionContext) field_WorkloadUtilization_limit_argsResourceType(
	ctx context.Context,
	rawArgs map[string]any,
) (utilization.UtilizationResourceType, error) {
	if _, ok := rawArgs["resourceType"]; !ok {
		var zeroVal utilization.UtilizationResourceType
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
	if tmp, ok := rawArgs["resourceType"]; ok {
		return ec.unmarshalNUtilizationResourceType2githubcomnaisapiinternalutilizationUtilizationResourceType(ctx, tmp)
	}

	var zeroVal utilization.UtilizationResourceType
	return zeroVal, nil
}

func (ec *executionContext) field_WorkloadUtilization_requested_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_WorkloadUtilization_requested_argsResourceType(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["resourceType"] = arg0
	return args, nil
}
func (ec *executionContext) field_WorkloadUtilization_requested_argsResourceType(
	ctx context.Context,
	rawArgs map[string]any,
) (utilization.UtilizationResourceType, error) {
	if _, ok := rawArgs["resourceType"]; !ok {
		var zeroVal utilization.UtilizationResourceType
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
	if tmp, ok := rawArgs["resourceType"]; ok {
		return ec.unmarshalNUtilizationResourceType2githubcomnaisapiinternalutilizationUtilizationResourceType(ctx, tmp)
	}

	var zeroVal utilization.UtilizationResourceType
	return zeroVal, nil
}

func (ec *executionContext) field_WorkloadUtilization_series_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_WorkloadUtilization_series_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_WorkloadUtilization_series_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (utilization.WorkloadUtilizationSeriesInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal utilization.WorkloadUtilizationSeriesInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNWorkloadUtilizationSeriesInput2githubcomnaisapiinternalutilizationWorkloadUtilizationSeriesInput(ctx, tmp)
	}

	var zeroVal utilization.WorkloadUtilizationSeriesInput
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ActivityLogEntryConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[activitylog.ActivityLogEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActivityLogEntryConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActivityLogEntryConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActivityLogEntryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActivityLogEntryConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[activitylog.ActivityLogEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActivityLogEntryConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]activitylog.ActivityLogEntry)
	fc.Result = res
	return ec.marshalNActivityLogEntry2githubcomnaisapiinternalactivitylogActivityLogEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActivityLogEntryConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActivityLogEntryConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActivityLogEntryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[activitylog.ActivityLogEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActivityLogEntryConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[activitylog.ActivityLogEntry])
	fc.Result = res
	return ec.marshalNActivityLogEntryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActivityLogEntryConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActivityLogEntryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ActivityLogEntryEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ActivityLogEntryEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ActivityLogEntryEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActivityLogEntryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[activitylog.ActivityLogEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActivityLogEntryEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActivityLogEntryEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActivityLogEntryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActivityLogEntryEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[activitylog.ActivityLogEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActivityLogEntryEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntry)
	fc.Result = res
	return ec.marshalNActivityLogEntry2githubcomnaisapiinternalactivitylogActivityLogEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActivityLogEntryEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActivityLogEntryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddRepositoryToTeamPayload_repository(ctx context.Context, field graphql.CollectedField, obj *repository.AddRepositoryToTeamPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddRepositoryToTeamPayload_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*repository.Repository)
	fc.Result = res
	return ec.marshalORepository2githubcomnaisapiinternalgithubrepositoryRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddRepositoryToTeamPayload_repository(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddRepositoryToTeamPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "team":
				return ec.fieldContext_Repository_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddSecretValuePayload_secret(ctx context.Context, field graphql.CollectedField, obj *secret.AddSecretValuePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddSecretValuePayload_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*secret.Secret)
	fc.Result = res
	return ec.marshalOSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddSecretValuePayload_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddSecretValuePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Secret_id(ctx, field)
			case "name":
				return ec.fieldContext_Secret_name(ctx, field)
			case "environment":
				return ec.fieldContext_Secret_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Secret_teamEnvironment(ctx, field)
			case "team":
				return ec.fieldContext_Secret_team(ctx, field)
			case "values":
				return ec.fieldContext_Secret_values(ctx, field)
			case "applications":
				return ec.fieldContext_Secret_applications(ctx, field)
			case "jobs":
				return ec.fieldContext_Secret_jobs(ctx, field)
			case "workloads":
				return ec.fieldContext_Secret_workloads(ctx, field)
			case "lastModifiedAt":
				return ec.fieldContext_Secret_lastModifiedAt(ctx, field)
			case "lastModifiedBy":
				return ec.fieldContext_Secret_lastModifiedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Secret", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddTeamMemberPayload_member(ctx context.Context, field graphql.CollectedField, obj *team.AddTeamMemberPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddTeamMemberPayload_member(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Member, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamMember)
	fc.Result = res
	return ec.marshalOTeamMember2githubcomnaisapiinternalteamTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddTeamMemberPayload_member(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddTeamMemberPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamMember_team(ctx, field)
			case "user":
				return ec.fieldContext_TeamMember_user(ctx, field)
			case "role":
				return ec.fieldContext_TeamMember_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AllowTeamAccessToUnleashPayload_unleash(ctx context.Context, field graphql.CollectedField, obj *unleash.AllowTeamAccessToUnleashPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AllowTeamAccessToUnleashPayload_unleash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unleash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*unleash.UnleashInstance)
	fc.Result = res
	return ec.marshalOUnleashInstance2githubcomnaisapiinternalunleashUnleashInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AllowTeamAccessToUnleashPayload_unleash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AllowTeamAccessToUnleashPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UnleashInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_UnleashInstance_name(ctx, field)
			case "version":
				return ec.fieldContext_UnleashInstance_version(ctx, field)
			case "allowedTeams":
				return ec.fieldContext_UnleashInstance_allowedTeams(ctx, field)
			case "webIngress":
				return ec.fieldContext_UnleashInstance_webIngress(ctx, field)
			case "apiIngress":
				return ec.fieldContext_UnleashInstance_apiIngress(ctx, field)
			case "metrics":
				return ec.fieldContext_UnleashInstance_metrics(ctx, field)
			case "ready":
				return ec.fieldContext_UnleashInstance_ready(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UnleashInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_id(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_name(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_team(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_environment(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_image(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.ContainerImage)
	fc.Result = res
	return ec.marshalNContainerImage2githubcomnaisapiinternalworkloadContainerImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerImage_id(ctx, field)
			case "name":
				return ec.fieldContext_ContainerImage_name(ctx, field)
			case "tag":
				return ec.fieldContext_ContainerImage_tag(ctx, field)
			case "hasSBOM":
				return ec.fieldContext_ContainerImage_hasSBOM(ctx, field)
			case "vulnerabilities":
				return ec.fieldContext_ContainerImage_vulnerabilities(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_ContainerImage_vulnerabilitySummary(ctx, field)
			case "workloadReferences":
				return ec.fieldContext_ContainerImage_workloadReferences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_resources(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.ApplicationResources)
	fc.Result = res
	return ec.marshalNApplicationResources2githubcomnaisapiinternalworkloadapplicationApplicationResources(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_resources(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "limits":
				return ec.fieldContext_ApplicationResources_limits(ctx, field)
			case "requests":
				return ec.fieldContext_ApplicationResources_requests(ctx, field)
			case "scaling":
				return ec.fieldContext_ApplicationResources_scaling(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_ingresses(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_ingresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ingresses(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*application.Ingress)
	fc.Result = res
	return ec.marshalNIngress2githubcomnaisapiinternalworkloadapplicationIngress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_ingresses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_Ingress_url(ctx, field)
			case "type":
				return ec.fieldContext_Ingress_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Ingress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_authIntegrations(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_authIntegrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().AuthIntegrations(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]workload.ApplicationAuthIntegrations)
	fc.Result = res
	return ec.marshalNApplicationAuthIntegrations2githubcomnaisapiinternalworkloadApplicationAuthIntegrations(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_authIntegrations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ApplicationAuthIntegrations does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_manifest(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_manifest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Manifest(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.ApplicationManifest)
	fc.Result = res
	return ec.marshalNApplicationManifest2githubcomnaisapiinternalworkloadapplicationApplicationManifest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_manifest(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "content":
				return ec.fieldContext_ApplicationManifest_content(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationManifest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_instances(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_instances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Instances(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*application.ApplicationInstance])
	fc.Result = res
	return ec.marshalNApplicationInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_instances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ApplicationInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ApplicationInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ApplicationInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_instances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_deletionStartedAt(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_deletionStartedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionStartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_deletionStartedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_bigQueryDatasets(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_bigQueryDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().BigQueryDatasets(rctx, obj, fc.Args["orderBy"].(*bigquery.BigQueryDatasetOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bigquery.BigQueryDataset])
	fc.Result = res
	return ec.marshalNBigQueryDatasetConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_bigQueryDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BigQueryDatasetConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BigQueryDatasetConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BigQueryDatasetConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_bigQueryDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_buckets(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_buckets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Buckets(rctx, obj, fc.Args["orderBy"].(*bucket.BucketOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bucket.Bucket])
	fc.Result = res
	return ec.marshalNBucketConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_buckets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BucketConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BucketConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BucketConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_buckets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_cost(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.WorkloadCost)
	fc.Result = res
	return ec.marshalNWorkloadCost2githubcomnaisapiinternalcostWorkloadCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "daily":
				return ec.fieldContext_WorkloadCost_daily(ctx, field)
			case "monthly":
				return ec.fieldContext_WorkloadCost_monthly(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_deployments(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_deployments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Deployments(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*deployment.Deployment])
	fc.Result = res
	return ec.marshalNDeploymentConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_deployments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_DeploymentConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_DeploymentConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_DeploymentConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_deployments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_kafkaTopicAcls(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().KafkaTopicAcls(rctx, obj, fc.Args["orderBy"].(*kafkatopic.KafkaTopicACLOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*kafkatopic.KafkaTopicACL])
	fc.Result = res
	return ec.marshalNKafkaTopicAclConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_kafkaTopicAcls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_KafkaTopicAclConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_KafkaTopicAclConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_KafkaTopicAclConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAclConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_kafkaTopicAcls_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_logDestinations(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_logDestinations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().LogDestinations(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]logging.LogDestination)
	fc.Result = res
	return ec.marshalNLogDestination2githubcomnaisapiinternalworkloadloggingLogDestination(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_logDestinations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_networkPolicy(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_networkPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().NetworkPolicy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*netpol.NetworkPolicy)
	fc.Result = res
	return ec.marshalNNetworkPolicy2githubcomnaisapiinternalworkloadnetpolNetworkPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_networkPolicy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "inbound":
				return ec.fieldContext_NetworkPolicy_inbound(ctx, field)
			case "outbound":
				return ec.fieldContext_NetworkPolicy_outbound(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_openSearch(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_openSearch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().OpenSearch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearch)
	fc.Result = res
	return ec.marshalOOpenSearch2githubcomnaisapiinternalpersistenceopensearchOpenSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_openSearch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_OpenSearch_teamEnvironment(ctx, field)
			case "status":
				return ec.fieldContext_OpenSearch_status(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_redisInstances(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_redisInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().RedisInstances(rctx, obj, fc.Args["orderBy"].(*redis.RedisInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*redis.RedisInstance])
	fc.Result = res
	return ec.marshalNRedisInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_redisInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_RedisInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_RedisInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RedisInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_redisInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_secrets(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_secrets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Secrets(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*secret.Secret])
	fc.Result = res
	return ec.marshalNSecretConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_secrets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SecretConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SecretConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SecretConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_secrets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_sqlInstances(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_sqlInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().SQLInstances(rctx, obj, fc.Args["orderBy"].(*sqlinstance.SQLInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*sqlinstance.SQLInstance])
	fc.Result = res
	return ec.marshalNSqlInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_sqlInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SqlInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SqlInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SqlInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_sqlInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_status(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*status.WorkloadStatus)
	fc.Result = res
	return ec.marshalNWorkloadStatus2githubcomnaisapiinternalstatusWorkloadStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_WorkloadStatus_state(ctx, field)
			case "errors":
				return ec.fieldContext_WorkloadStatus_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_utilization(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_utilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Utilization(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*utilization.WorkloadUtilization)
	fc.Result = res
	return ec.marshalNWorkloadUtilization2githubcomnaisapiinternalutilizationWorkloadUtilization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_utilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_WorkloadUtilization_current(ctx, field)
			case "requested":
				return ec.fieldContext_WorkloadUtilization_requested(ctx, field)
			case "limit":
				return ec.fieldContext_WorkloadUtilization_limit(ctx, field)
			case "series":
				return ec.fieldContext_WorkloadUtilization_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadUtilization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_valkeyInstances(ctx context.Context, field graphql.CollectedField, obj *application.Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_valkeyInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().ValkeyInstances(rctx, obj, fc.Args["orderBy"].(*valkey.ValkeyInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*valkey.ValkeyInstance])
	fc.Result = res
	return ec.marshalNValkeyInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_valkeyInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ValkeyInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ValkeyInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ValkeyInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_valkeyInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.Application]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.Application]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*application.Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomnaisapiinternalworkloadapplicationApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Application_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "instances":
				return ec.fieldContext_Application_instances(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Application_deletionStartedAt(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Application_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Application_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Application_redisInstances(ctx, field)
			case "secrets":
				return ec.fieldContext_Application_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Application_valkeyInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.Application]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*application.Application])
	fc.Result = res
	return ec.marshalNApplicationEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ApplicationEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ApplicationEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationDeletedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationDeletedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationDeletedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationDeletedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationDeletedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationDeletedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationDeletedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationDeletedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationDeletedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*application.Application]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*application.Application]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomnaisapiinternalworkloadapplicationApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Application_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "instances":
				return ec.fieldContext_Application_instances(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Application_deletionStartedAt(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Application_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Application_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Application_redisInstances(ctx, field)
			case "secrets":
				return ec.fieldContext_Application_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Application_valkeyInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_id(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstance_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstance_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_name(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstance_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstance_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_image(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstance_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.ContainerImage)
	fc.Result = res
	return ec.marshalNContainerImage2githubcomnaisapiinternalworkloadContainerImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstance_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerImage_id(ctx, field)
			case "name":
				return ec.fieldContext_ContainerImage_name(ctx, field)
			case "tag":
				return ec.fieldContext_ContainerImage_tag(ctx, field)
			case "hasSBOM":
				return ec.fieldContext_ContainerImage_hasSBOM(ctx, field)
			case "vulnerabilities":
				return ec.fieldContext_ContainerImage_vulnerabilities(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_ContainerImage_vulnerabilitySummary(ctx, field)
			case "workloadReferences":
				return ec.fieldContext_ContainerImage_workloadReferences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_restarts(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstance_restarts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Restarts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstance_restarts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_created(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstance_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Created, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstance_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstance_status(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstance_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.ApplicationInstanceStatus)
	fc.Result = res
	return ec.marshalNApplicationInstanceStatus2githubcomnaisapiinternalworkloadapplicationApplicationInstanceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstance_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_ApplicationInstanceStatus_state(ctx, field)
			case "message":
				return ec.fieldContext_ApplicationInstanceStatus_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationInstanceStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.ApplicationInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstanceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstanceConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.ApplicationInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstanceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*application.ApplicationInstance)
	fc.Result = res
	return ec.marshalNApplicationInstance2githubcomnaisapiinternalworkloadapplicationApplicationInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstanceConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationInstance_name(ctx, field)
			case "image":
				return ec.fieldContext_ApplicationInstance_image(ctx, field)
			case "restarts":
				return ec.fieldContext_ApplicationInstance_restarts(ctx, field)
			case "created":
				return ec.fieldContext_ApplicationInstance_created(ctx, field)
			case "status":
				return ec.fieldContext_ApplicationInstance_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*application.ApplicationInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstanceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*application.ApplicationInstance])
	fc.Result = res
	return ec.marshalNApplicationInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstanceConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ApplicationInstanceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ApplicationInstanceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationInstanceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*application.ApplicationInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstanceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstanceEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*application.ApplicationInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstanceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.ApplicationInstance)
	fc.Result = res
	return ec.marshalNApplicationInstance2githubcomnaisapiinternalworkloadapplicationApplicationInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstanceEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationInstance_name(ctx, field)
			case "image":
				return ec.fieldContext_ApplicationInstance_image(ctx, field)
			case "restarts":
				return ec.fieldContext_ApplicationInstance_restarts(ctx, field)
			case "created":
				return ec.fieldContext_ApplicationInstance_created(ctx, field)
			case "status":
				return ec.fieldContext_ApplicationInstance_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceStatus_state(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstanceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstanceStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(application.ApplicationInstanceState)
	fc.Result = res
	return ec.marshalNApplicationInstanceState2githubcomnaisapiinternalworkloadapplicationApplicationInstanceState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstanceStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ApplicationInstanceState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationInstanceStatus_message(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationInstanceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationInstanceStatus_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationInstanceStatus_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationInstanceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationManifest_content(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationManifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationManifest_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationManifest_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationManifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationResources_limits(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationResources_limits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.WorkloadResourceQuantity)
	fc.Result = res
	return ec.marshalNWorkloadResourceQuantity2githubcomnaisapiinternalworkloadWorkloadResourceQuantity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationResources_limits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadResourceQuantity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationResources_requests(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationResources_requests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.WorkloadResourceQuantity)
	fc.Result = res
	return ec.marshalNWorkloadResourceQuantity2githubcomnaisapiinternalworkloadWorkloadResourceQuantity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationResources_requests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadResourceQuantity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationResources_scaling(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationResources_scaling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scaling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.ApplicationScaling)
	fc.Result = res
	return ec.marshalNApplicationScaling2githubcomnaisapiinternalworkloadapplicationApplicationScaling(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationResources_scaling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "minInstances":
				return ec.fieldContext_ApplicationScaling_minInstances(ctx, field)
			case "maxInstances":
				return ec.fieldContext_ApplicationScaling_maxInstances(ctx, field)
			case "strategies":
				return ec.fieldContext_ApplicationScaling_strategies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationScaling", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationRestartedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationRestartedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationRestartedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationRestartedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationRestartedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationRestartedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationRestartedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationRestartedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationRestartedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationRestartedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationRestartedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaling_minInstances(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaling) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationScaling_minInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinInstances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationScaling_minInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaling",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaling_maxInstances(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaling) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationScaling_maxInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxInstances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationScaling_maxInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaling",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationScaling_strategies(ctx context.Context, field graphql.CollectedField, obj *application.ApplicationScaling) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationScaling_strategies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Strategies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]application.ScalingStrategy)
	fc.Result = res
	return ec.marshalNScalingStrategy2githubcomnaisapiinternalworkloadapplicationScalingStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationScaling_strategies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationScaling",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScalingStrategy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssignRoleToServiceAccountPayload_serviceAccount(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.AssignRoleToServiceAccountPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssignRoleToServiceAccountPayload_serviceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccount)
	fc.Result = res
	return ec.marshalOServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssignRoleToServiceAccountPayload_serviceAccount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssignRoleToServiceAccountPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccount_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccount_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccount_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccount_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccount_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccount_lastUsedAt(ctx, field)
			case "team":
				return ec.fieldContext_ServiceAccount_team(ctx, field)
			case "roles":
				return ec.fieldContext_ServiceAccount_roles(ctx, field)
			case "tokens":
				return ec.fieldContext_ServiceAccount_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_id(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_name(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_team(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BigQueryDataset().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_environment(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BigQueryDataset().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BigQueryDataset().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_cascadingDelete(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_cascadingDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CascadingDelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_cascadingDelete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_description(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_access(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BigQueryDataset().Access(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*bigquery.BigQueryDatasetAccessOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bigquery.BigQueryDatasetAccess])
	fc.Result = res
	return ec.marshalNBigQueryDatasetAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_access(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BigQueryDatasetAccessConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BigQueryDatasetAccessConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BigQueryDatasetAccessConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetAccessConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_BigQueryDataset_access_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_status(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bigquery.BigQueryDatasetStatus)
	fc.Result = res
	return ec.marshalNBigQueryDatasetStatus2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "creationTime":
				return ec.fieldContext_BigQueryDatasetStatus_creationTime(ctx, field)
			case "lastModifiedTime":
				return ec.fieldContext_BigQueryDatasetStatus_lastModifiedTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_workload(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BigQueryDataset().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDataset_cost(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDataset_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BigQueryDataset().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.BigQueryDatasetCost)
	fc.Result = res
	return ec.marshalNBigQueryDatasetCost2githubcomnaisapiinternalcostBigQueryDatasetCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDataset_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_BigQueryDatasetCost_sum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccess_role(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDatasetAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccess_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccess_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccess_email(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDatasetAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccess_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccess_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccessConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDatasetAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccessConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccessConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccessConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDatasetAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccessConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*bigquery.BigQueryDatasetAccess)
	fc.Result = res
	return ec.marshalNBigQueryDatasetAccess2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccessConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccessConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "role":
				return ec.fieldContext_BigQueryDatasetAccess_role(ctx, field)
			case "email":
				return ec.fieldContext_BigQueryDatasetAccess_email(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccessConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDatasetAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccessConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*bigquery.BigQueryDatasetAccess])
	fc.Result = res
	return ec.marshalNBigQueryDatasetAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccessConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_BigQueryDatasetAccessEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_BigQueryDatasetAccessEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetAccessEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccessEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bigquery.BigQueryDatasetAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccessEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccessEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetAccessEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bigquery.BigQueryDatasetAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetAccessEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bigquery.BigQueryDatasetAccess)
	fc.Result = res
	return ec.marshalNBigQueryDatasetAccess2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetAccessEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "role":
				return ec.fieldContext_BigQueryDatasetAccess_role(ctx, field)
			case "email":
				return ec.fieldContext_BigQueryDatasetAccess_email(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDataset]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDataset]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*bigquery.BigQueryDataset)
	fc.Result = res
	return ec.marshalNBigQueryDataset2githubcomnaisapiinternalpersistencebigqueryBigQueryDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BigQueryDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_BigQueryDataset_name(ctx, field)
			case "team":
				return ec.fieldContext_BigQueryDataset_team(ctx, field)
			case "environment":
				return ec.fieldContext_BigQueryDataset_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_BigQueryDataset_teamEnvironment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_BigQueryDataset_cascadingDelete(ctx, field)
			case "description":
				return ec.fieldContext_BigQueryDataset_description(ctx, field)
			case "access":
				return ec.fieldContext_BigQueryDataset_access(ctx, field)
			case "status":
				return ec.fieldContext_BigQueryDataset_status(ctx, field)
			case "workload":
				return ec.fieldContext_BigQueryDataset_workload(ctx, field)
			case "cost":
				return ec.fieldContext_BigQueryDataset_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDataset", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bigquery.BigQueryDataset]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*bigquery.BigQueryDataset])
	fc.Result = res
	return ec.marshalNBigQueryDatasetEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_BigQueryDatasetEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_BigQueryDatasetEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetCost_sum(ctx context.Context, field graphql.CollectedField, obj *cost.BigQueryDatasetCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetCost_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetCost_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetCost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bigquery.BigQueryDataset]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bigquery.BigQueryDataset]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bigquery.BigQueryDataset)
	fc.Result = res
	return ec.marshalNBigQueryDataset2githubcomnaisapiinternalpersistencebigqueryBigQueryDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BigQueryDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_BigQueryDataset_name(ctx, field)
			case "team":
				return ec.fieldContext_BigQueryDataset_team(ctx, field)
			case "environment":
				return ec.fieldContext_BigQueryDataset_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_BigQueryDataset_teamEnvironment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_BigQueryDataset_cascadingDelete(ctx, field)
			case "description":
				return ec.fieldContext_BigQueryDataset_description(ctx, field)
			case "access":
				return ec.fieldContext_BigQueryDataset_access(ctx, field)
			case "status":
				return ec.fieldContext_BigQueryDataset_status(ctx, field)
			case "workload":
				return ec.fieldContext_BigQueryDataset_workload(ctx, field)
			case "cost":
				return ec.fieldContext_BigQueryDataset_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDataset", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetStatus_creationTime(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDatasetStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetStatus_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetStatus_creationTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BigQueryDatasetStatus_lastModifiedTime(ctx context.Context, field graphql.CollectedField, obj *bigquery.BigQueryDatasetStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BigQueryDatasetStatus_lastModifiedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastModifiedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BigQueryDatasetStatus_lastModifiedTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BigQueryDatasetStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_id(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_name(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_team(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bucket().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_environment(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bucket().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bucket().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_cascadingDelete(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_cascadingDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CascadingDelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_cascadingDelete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_publicAccessPrevention(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_publicAccessPrevention(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicAccessPrevention, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_publicAccessPrevention(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_uniformBucketLevelAccess(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_uniformBucketLevelAccess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UniformBucketLevelAccess, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_uniformBucketLevelAccess(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_workload(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bucket().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bucket_status(ctx context.Context, field graphql.CollectedField, obj *bucket.Bucket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bucket_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bucket.BucketStatus)
	fc.Result = res
	return ec.marshalNBucketStatus2githubcomnaisapiinternalpersistencebucketBucketStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bucket_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bucket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_BucketStatus_state(ctx, field)
			case "errors":
				return ec.fieldContext_BucketStatus_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bucket.Bucket]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bucket.Bucket]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*bucket.Bucket)
	fc.Result = res
	return ec.marshalNBucket2githubcomnaisapiinternalpersistencebucketBucket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bucket_id(ctx, field)
			case "name":
				return ec.fieldContext_Bucket_name(ctx, field)
			case "team":
				return ec.fieldContext_Bucket_team(ctx, field)
			case "environment":
				return ec.fieldContext_Bucket_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Bucket_teamEnvironment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_Bucket_cascadingDelete(ctx, field)
			case "publicAccessPrevention":
				return ec.fieldContext_Bucket_publicAccessPrevention(ctx, field)
			case "uniformBucketLevelAccess":
				return ec.fieldContext_Bucket_uniformBucketLevelAccess(ctx, field)
			case "workload":
				return ec.fieldContext_Bucket_workload(ctx, field)
			case "status":
				return ec.fieldContext_Bucket_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bucket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*bucket.Bucket]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*bucket.Bucket])
	fc.Result = res
	return ec.marshalNBucketEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_BucketEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_BucketEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bucket.Bucket]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*bucket.Bucket]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bucket.Bucket)
	fc.Result = res
	return ec.marshalNBucket2githubcomnaisapiinternalpersistencebucketBucket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bucket_id(ctx, field)
			case "name":
				return ec.fieldContext_Bucket_name(ctx, field)
			case "team":
				return ec.fieldContext_Bucket_team(ctx, field)
			case "environment":
				return ec.fieldContext_Bucket_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Bucket_teamEnvironment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_Bucket_cascadingDelete(ctx, field)
			case "publicAccessPrevention":
				return ec.fieldContext_Bucket_publicAccessPrevention(ctx, field)
			case "uniformBucketLevelAccess":
				return ec.fieldContext_Bucket_uniformBucketLevelAccess(ctx, field)
			case "workload":
				return ec.fieldContext_Bucket_workload(ctx, field)
			case "status":
				return ec.fieldContext_Bucket_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bucket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketError_message(ctx context.Context, field graphql.CollectedField, obj *bucket.BucketError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketError_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketError_details(ctx context.Context, field graphql.CollectedField, obj *bucket.BucketError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketError_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketError_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketStatus_state(ctx context.Context, field graphql.CollectedField, obj *bucket.BucketStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bucket.BucketState)
	fc.Result = res
	return ec.marshalNBucketState2githubcomnaisapiinternalpersistencebucketBucketState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BucketState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketStatus_errors(ctx context.Context, field graphql.CollectedField, obj *bucket.BucketStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BucketStatus_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*bucket.BucketError)
	fc.Result = res
	return ec.marshalNBucketError2githubcomnaisapiinternalpersistencebucketBucketError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BucketStatus_errors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_BucketError_message(ctx, field)
			case "details":
				return ec.fieldContext_BucketError_details(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CPUScalingStrategy_threshold(ctx context.Context, field graphql.CollectedField, obj *application.CPUScalingStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CPUScalingStrategy_threshold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Threshold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CPUScalingStrategy_threshold(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CPUScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeDeploymentKeyPayload_deploymentKey(ctx context.Context, field graphql.CollectedField, obj *deployment.ChangeDeploymentKeyPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeDeploymentKeyPayload_deploymentKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeploymentKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*deployment.DeploymentKey)
	fc.Result = res
	return ec.marshalODeploymentKey2githubcomnaisapiinternaldeploymentDeploymentKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeDeploymentKeyPayload_deploymentKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeDeploymentKeyPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeploymentKey_id(ctx, field)
			case "key":
				return ec.fieldContext_DeploymentKey_key(ctx, field)
			case "created":
				return ec.fieldContext_DeploymentKey_created(ctx, field)
			case "expires":
				return ec.fieldContext_DeploymentKey_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfirmTeamDeletionPayload_deletionStarted(ctx context.Context, field graphql.CollectedField, obj *team.ConfirmTeamDeletionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfirmTeamDeletionPayload_deletionStarted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionStarted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfirmTeamDeletionPayload_deletionStarted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfirmTeamDeletionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_id(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_name(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_tag(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_tag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_hasSBOM(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_hasSBOM(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerImage().HasSbom(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_hasSBOM(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_vulnerabilities(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_vulnerabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerImage().Vulnerabilities(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*vulnerability.ImageVulnerabilityOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*vulnerability.ImageVulnerability])
	fc.Result = res
	return ec.marshalNImageVulnerabilityConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_vulnerabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ImageVulnerabilityConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_ImageVulnerabilityConnection_edges(ctx, field)
			case "nodes":
				return ec.fieldContext_ImageVulnerabilityConnection_nodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilityConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ContainerImage_vulnerabilities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_vulnerabilitySummary(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_vulnerabilitySummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerImage().VulnerabilitySummary(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*vulnerability.ImageVulnerabilitySummary)
	fc.Result = res
	return ec.marshalOImageVulnerabilitySummary2githubcomnaisapiinternalvulnerabilityImageVulnerabilitySummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_vulnerabilitySummary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_ImageVulnerabilitySummary_total(ctx, field)
			case "riskScore":
				return ec.fieldContext_ImageVulnerabilitySummary_riskScore(ctx, field)
			case "low":
				return ec.fieldContext_ImageVulnerabilitySummary_low(ctx, field)
			case "medium":
				return ec.fieldContext_ImageVulnerabilitySummary_medium(ctx, field)
			case "high":
				return ec.fieldContext_ImageVulnerabilitySummary_high(ctx, field)
			case "critical":
				return ec.fieldContext_ImageVulnerabilitySummary_critical(ctx, field)
			case "unassigned":
				return ec.fieldContext_ImageVulnerabilitySummary_unassigned(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilitySummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImage_workloadReferences(ctx context.Context, field graphql.CollectedField, obj *workload.ContainerImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImage_workloadReferences(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerImage().WorkloadReferences(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*vulnerability.ContainerImageWorkloadReference])
	fc.Result = res
	return ec.marshalNContainerImageWorkloadReferenceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImage_workloadReferences(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImage",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ContainerImageWorkloadReferenceConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_ContainerImageWorkloadReferenceConnection_edges(ctx, field)
			case "nodes":
				return ec.fieldContext_ContainerImageWorkloadReferenceConnection_nodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImageWorkloadReferenceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ContainerImage_workloadReferences_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReference_workload(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ContainerImageWorkloadReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReference_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerImageWorkloadReference().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReference_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReference",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReferenceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReferenceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReferenceConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReferenceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReferenceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReferenceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*vulnerability.ContainerImageWorkloadReference])
	fc.Result = res
	return ec.marshalNContainerImageWorkloadReferenceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReferenceConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReferenceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ContainerImageWorkloadReferenceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ContainerImageWorkloadReferenceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImageWorkloadReferenceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReferenceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReferenceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*vulnerability.ContainerImageWorkloadReference)
	fc.Result = res
	return ec.marshalNContainerImageWorkloadReference2githubcomnaisapiinternalvulnerabilityContainerImageWorkloadReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReferenceConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReferenceConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_ContainerImageWorkloadReference_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImageWorkloadReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReferenceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*vulnerability.ContainerImageWorkloadReference]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReferenceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReferenceEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReferenceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerImageWorkloadReferenceEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*vulnerability.ContainerImageWorkloadReference]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerImageWorkloadReferenceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*vulnerability.ContainerImageWorkloadReference)
	fc.Result = res
	return ec.marshalNContainerImageWorkloadReference2githubcomnaisapiinternalvulnerabilityContainerImageWorkloadReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerImageWorkloadReferenceEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerImageWorkloadReferenceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_ContainerImageWorkloadReference_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImageWorkloadReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateSecretPayload_secret(ctx context.Context, field graphql.CollectedField, obj *secret.CreateSecretPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateSecretPayload_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*secret.Secret)
	fc.Result = res
	return ec.marshalOSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateSecretPayload_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateSecretPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Secret_id(ctx, field)
			case "name":
				return ec.fieldContext_Secret_name(ctx, field)
			case "environment":
				return ec.fieldContext_Secret_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Secret_teamEnvironment(ctx, field)
			case "team":
				return ec.fieldContext_Secret_team(ctx, field)
			case "values":
				return ec.fieldContext_Secret_values(ctx, field)
			case "applications":
				return ec.fieldContext_Secret_applications(ctx, field)
			case "jobs":
				return ec.fieldContext_Secret_jobs(ctx, field)
			case "workloads":
				return ec.fieldContext_Secret_workloads(ctx, field)
			case "lastModifiedAt":
				return ec.fieldContext_Secret_lastModifiedAt(ctx, field)
			case "lastModifiedBy":
				return ec.fieldContext_Secret_lastModifiedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Secret", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateServiceAccountPayload_serviceAccount(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.CreateServiceAccountPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateServiceAccountPayload_serviceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccount)
	fc.Result = res
	return ec.marshalOServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateServiceAccountPayload_serviceAccount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateServiceAccountPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccount_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccount_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccount_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccount_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccount_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccount_lastUsedAt(ctx, field)
			case "team":
				return ec.fieldContext_ServiceAccount_team(ctx, field)
			case "roles":
				return ec.fieldContext_ServiceAccount_roles(ctx, field)
			case "tokens":
				return ec.fieldContext_ServiceAccount_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateServiceAccountTokenPayload_serviceAccount(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.CreateServiceAccountTokenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateServiceAccountTokenPayload_serviceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccount)
	fc.Result = res
	return ec.marshalOServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateServiceAccountTokenPayload_serviceAccount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateServiceAccountTokenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccount_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccount_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccount_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccount_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccount_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccount_lastUsedAt(ctx, field)
			case "team":
				return ec.fieldContext_ServiceAccount_team(ctx, field)
			case "roles":
				return ec.fieldContext_ServiceAccount_roles(ctx, field)
			case "tokens":
				return ec.fieldContext_ServiceAccount_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateServiceAccountTokenPayload_serviceAccountToken(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.CreateServiceAccountTokenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateServiceAccountTokenPayload_serviceAccountToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccountToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccountToken)
	fc.Result = res
	return ec.marshalOServiceAccountToken2githubcomnaisapiinternalserviceaccountServiceAccountToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateServiceAccountTokenPayload_serviceAccountToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateServiceAccountTokenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccountToken_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccountToken_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccountToken_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccountToken_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccountToken_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccountToken_lastUsedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_ServiceAccountToken_expiresAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountToken", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateServiceAccountTokenPayload_secret(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.CreateServiceAccountTokenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateServiceAccountTokenPayload_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateServiceAccountTokenPayload_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateServiceAccountTokenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTeamPayload_team(ctx context.Context, field graphql.CollectedField, obj *team.CreateTeamPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTeamPayload_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Team, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTeamPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTeamPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateUnleashForTeamPayload_unleash(ctx context.Context, field graphql.CollectedField, obj *unleash.CreateUnleashForTeamPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateUnleashForTeamPayload_unleash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unleash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*unleash.UnleashInstance)
	fc.Result = res
	return ec.marshalOUnleashInstance2githubcomnaisapiinternalunleashUnleashInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateUnleashForTeamPayload_unleash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateUnleashForTeamPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UnleashInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_UnleashInstance_name(ctx, field)
			case "version":
				return ec.fieldContext_UnleashInstance_version(ctx, field)
			case "allowedTeams":
				return ec.fieldContext_UnleashInstance_allowedTeams(ctx, field)
			case "webIngress":
				return ec.fieldContext_UnleashInstance_webIngress(ctx, field)
			case "apiIngress":
				return ec.fieldContext_UnleashInstance_apiIngress(ctx, field)
			case "metrics":
				return ec.fieldContext_UnleashInstance_metrics(ctx, field)
			case "ready":
				return ec.fieldContext_UnleashInstance_ready(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UnleashInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteApplicationPayload_team(ctx context.Context, field graphql.CollectedField, obj *application.DeleteApplicationPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteApplicationPayload_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DeleteApplicationPayload().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteApplicationPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteApplicationPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteApplicationPayload_success(ctx context.Context, field graphql.CollectedField, obj *application.DeleteApplicationPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteApplicationPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteApplicationPayload_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteApplicationPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteJobPayload_team(ctx context.Context, field graphql.CollectedField, obj *job.DeleteJobPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteJobPayload_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DeleteJobPayload().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteJobPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteJobPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteJobPayload_success(ctx context.Context, field graphql.CollectedField, obj *job.DeleteJobPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteJobPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteJobPayload_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteJobPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteSecretPayload_secretDeleted(ctx context.Context, field graphql.CollectedField, obj *secret.DeleteSecretPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteSecretPayload_secretDeleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretDeleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteSecretPayload_secretDeleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteSecretPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteServiceAccountPayload_serviceAccountDeleted(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.DeleteServiceAccountPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteServiceAccountPayload_serviceAccountDeleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccountDeleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteServiceAccountPayload_serviceAccountDeleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteServiceAccountPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteServiceAccountTokenPayload_serviceAccount(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.DeleteServiceAccountTokenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteServiceAccountTokenPayload_serviceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccount)
	fc.Result = res
	return ec.marshalOServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteServiceAccountTokenPayload_serviceAccount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteServiceAccountTokenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccount_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccount_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccount_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccount_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccount_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccount_lastUsedAt(ctx, field)
			case "team":
				return ec.fieldContext_ServiceAccount_team(ctx, field)
			case "roles":
				return ec.fieldContext_ServiceAccount_roles(ctx, field)
			case "tokens":
				return ec.fieldContext_ServiceAccount_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteServiceAccountTokenPayload_serviceAccountTokenDeleted(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.DeleteServiceAccountTokenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteServiceAccountTokenPayload_serviceAccountTokenDeleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccountTokenDeleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteServiceAccountTokenPayload_serviceAccountTokenDeleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteServiceAccountTokenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Deployment_id(ctx context.Context, field graphql.CollectedField, obj *deployment.Deployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Deployment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Deployment_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Deployment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Deployment_createdAt(ctx context.Context, field graphql.CollectedField, obj *deployment.Deployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Deployment_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Deployment_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Deployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Deployment_teamSlug(ctx context.Context, field graphql.CollectedField, obj *deployment.Deployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Deployment_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Deployment_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Deployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Deployment_environmentName(ctx context.Context, field graphql.CollectedField, obj *deployment.Deployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Deployment_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Deployment_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Deployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Deployment_repository(ctx context.Context, field graphql.CollectedField, obj *deployment.Deployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Deployment_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Deployment_repository(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Deployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Deployment_deployerUsername(ctx context.Context, field graphql.CollectedField, obj *deployment.Deployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Deployment_deployerUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeployerUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Deployment_deployerUsername(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Deployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Deployment_commitSha(ctx context.Context, field graphql.CollectedField, obj *deployment.Deployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Deployment_commitSha(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitSha, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Deployment_commitSha(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Deployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Deployment_triggerUrl(ctx context.Context, field graphql.CollectedField, obj *deployment.Deployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Deployment_triggerUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggerUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Deployment_triggerUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Deployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Deployment_resources(ctx context.Context, field graphql.CollectedField, obj *deployment.Deployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Deployment_resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Deployment().Resources(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*deployment.DeploymentResource])
	fc.Result = res
	return ec.marshalNDeploymentResourceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Deployment_resources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Deployment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_DeploymentResourceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_DeploymentResourceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_DeploymentResourceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentResourceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Deployment_resources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Deployment_statuses(ctx context.Context, field graphql.CollectedField, obj *deployment.Deployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Deployment_statuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Deployment().Statuses(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*deployment.DeploymentStatus])
	fc.Result = res
	return ec.marshalNDeploymentStatusConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Deployment_statuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Deployment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_DeploymentStatusConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_DeploymentStatusConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_DeploymentStatusConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentStatusConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Deployment_statuses_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*deployment.Deployment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*deployment.Deployment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*deployment.Deployment)
	fc.Result = res
	return ec.marshalNDeployment2githubcomnaisapiinternaldeploymentDeployment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Deployment_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Deployment_createdAt(ctx, field)
			case "teamSlug":
				return ec.fieldContext_Deployment_teamSlug(ctx, field)
			case "environmentName":
				return ec.fieldContext_Deployment_environmentName(ctx, field)
			case "repository":
				return ec.fieldContext_Deployment_repository(ctx, field)
			case "deployerUsername":
				return ec.fieldContext_Deployment_deployerUsername(ctx, field)
			case "commitSha":
				return ec.fieldContext_Deployment_commitSha(ctx, field)
			case "triggerUrl":
				return ec.fieldContext_Deployment_triggerUrl(ctx, field)
			case "resources":
				return ec.fieldContext_Deployment_resources(ctx, field)
			case "statuses":
				return ec.fieldContext_Deployment_statuses(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Deployment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*deployment.Deployment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*deployment.Deployment])
	fc.Result = res
	return ec.marshalNDeploymentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_DeploymentEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_DeploymentEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*deployment.Deployment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*deployment.Deployment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*deployment.Deployment)
	fc.Result = res
	return ec.marshalNDeployment2githubcomnaisapiinternaldeploymentDeployment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Deployment_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Deployment_createdAt(ctx, field)
			case "teamSlug":
				return ec.fieldContext_Deployment_teamSlug(ctx, field)
			case "environmentName":
				return ec.fieldContext_Deployment_environmentName(ctx, field)
			case "repository":
				return ec.fieldContext_Deployment_repository(ctx, field)
			case "deployerUsername":
				return ec.fieldContext_Deployment_deployerUsername(ctx, field)
			case "commitSha":
				return ec.fieldContext_Deployment_commitSha(ctx, field)
			case "triggerUrl":
				return ec.fieldContext_Deployment_triggerUrl(ctx, field)
			case "resources":
				return ec.fieldContext_Deployment_resources(ctx, field)
			case "statuses":
				return ec.fieldContext_Deployment_statuses(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Deployment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentKey_id(ctx context.Context, field graphql.CollectedField, obj *deployment.DeploymentKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentKey_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentKey_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentKey_key(ctx context.Context, field graphql.CollectedField, obj *deployment.DeploymentKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentKey_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentKey_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentKey_created(ctx context.Context, field graphql.CollectedField, obj *deployment.DeploymentKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentKey_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Created, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentKey_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentKey_expires(ctx context.Context, field graphql.CollectedField, obj *deployment.DeploymentKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentKey_expires(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expires, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentKey_expires(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentResource_id(ctx context.Context, field graphql.CollectedField, obj *deployment.DeploymentResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentResource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentResource_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentResource",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentResource_kind(ctx context.Context, field graphql.CollectedField, obj *deployment.DeploymentResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentResource_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentResource_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentResource_name(ctx context.Context, field graphql.CollectedField, obj *deployment.DeploymentResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentResource_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentResource_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentResourceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*deployment.DeploymentResource]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentResourceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentResourceConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentResourceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*deployment.DeploymentResource]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentResourceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*deployment.DeploymentResource)
	fc.Result = res
	return ec.marshalNDeploymentResource2githubcomnaisapiinternaldeploymentDeploymentResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentResourceConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentResourceConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeploymentResource_id(ctx, field)
			case "kind":
				return ec.fieldContext_DeploymentResource_kind(ctx, field)
			case "name":
				return ec.fieldContext_DeploymentResource_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentResource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentResourceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*deployment.DeploymentResource]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentResourceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*deployment.DeploymentResource])
	fc.Result = res
	return ec.marshalNDeploymentResourceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentResourceConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_DeploymentResourceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_DeploymentResourceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentResourceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentResourceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*deployment.DeploymentResource]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentResourceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentResourceEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentResourceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentResourceEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*deployment.DeploymentResource]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentResourceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*deployment.DeploymentResource)
	fc.Result = res
	return ec.marshalNDeploymentResource2githubcomnaisapiinternaldeploymentDeploymentResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentResourceEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentResourceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeploymentResource_id(ctx, field)
			case "kind":
				return ec.fieldContext_DeploymentResource_kind(ctx, field)
			case "name":
				return ec.fieldContext_DeploymentResource_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentResource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentStatus_id(ctx context.Context, field graphql.CollectedField, obj *deployment.DeploymentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentStatus_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentStatus_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentStatus_createdAt(ctx context.Context, field graphql.CollectedField, obj *deployment.DeploymentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentStatus_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentStatus_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentStatus_state(ctx context.Context, field graphql.CollectedField, obj *deployment.DeploymentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(deployment.DeploymentStatusState)
	fc.Result = res
	return ec.marshalNDeploymentStatusState2githubcomnaisapiinternaldeploymentDeploymentStatusState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeploymentStatusState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentStatus_message(ctx context.Context, field graphql.CollectedField, obj *deployment.DeploymentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentStatus_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentStatus_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentStatusConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*deployment.DeploymentStatus]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentStatusConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentStatusConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentStatusConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentStatusConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*deployment.DeploymentStatus]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentStatusConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*deployment.DeploymentStatus)
	fc.Result = res
	return ec.marshalNDeploymentStatus2githubcomnaisapiinternaldeploymentDeploymentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentStatusConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentStatusConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeploymentStatus_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_DeploymentStatus_createdAt(ctx, field)
			case "state":
				return ec.fieldContext_DeploymentStatus_state(ctx, field)
			case "message":
				return ec.fieldContext_DeploymentStatus_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentStatusConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*deployment.DeploymentStatus]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentStatusConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*deployment.DeploymentStatus])
	fc.Result = res
	return ec.marshalNDeploymentStatusEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentStatusConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentStatusConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_DeploymentStatusEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_DeploymentStatusEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentStatusEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentStatusEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*deployment.DeploymentStatus]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentStatusEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentStatusEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentStatusEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentStatusEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*deployment.DeploymentStatus]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentStatusEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*deployment.DeploymentStatus)
	fc.Result = res
	return ec.marshalNDeploymentStatus2githubcomnaisapiinternaldeploymentDeploymentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentStatusEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentStatusEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeploymentStatus_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_DeploymentStatus_createdAt(ctx, field)
			case "state":
				return ec.fieldContext_DeploymentStatus_state(ctx, field)
			case "message":
				return ec.fieldContext_DeploymentStatus_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntraIDAuthIntegration_name(ctx context.Context, field graphql.CollectedField, obj *workload.EntraIDAuthIntegration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntraIDAuthIntegration_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntraIDAuthIntegration_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntraIDAuthIntegration",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_id(ctx context.Context, field graphql.CollectedField, obj *environment.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_name(ctx context.Context, field graphql.CollectedField, obj *environment.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_workloads(ctx context.Context, field graphql.CollectedField, obj *environment.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_workloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Environment().Workloads(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*workload.EnvironmentWorkloadOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[workload.Workload])
	fc.Result = res
	return ec.marshalNWorkloadConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_workloads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_WorkloadConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_WorkloadConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_WorkloadConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Environment_workloads_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EnvironmentConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*environment.Environment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnvironmentConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnvironmentConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvironmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvironmentConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*environment.Environment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnvironmentConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*environment.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomnaisapiinternalenvironmentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnvironmentConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvironmentConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "workloads":
				return ec.fieldContext_Environment_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvironmentConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*environment.Environment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnvironmentConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*environment.Environment])
	fc.Result = res
	return ec.marshalNEnvironmentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnvironmentConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvironmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_EnvironmentEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_EnvironmentEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EnvironmentEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvironmentEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*environment.Environment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnvironmentEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnvironmentEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvironmentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvironmentEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*environment.Environment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnvironmentEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*environment.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomnaisapiinternalenvironmentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnvironmentEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvironmentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "workloads":
				return ec.fieldContext_Environment_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalNetworkPolicyHost_target(ctx context.Context, field graphql.CollectedField, obj *netpol.ExternalNetworkPolicyHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalNetworkPolicyHost_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalNetworkPolicyHost_target(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalNetworkPolicyHost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalNetworkPolicyHost_ports(ctx context.Context, field graphql.CollectedField, obj *netpol.ExternalNetworkPolicyHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalNetworkPolicyHost_ports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalNetworkPolicyHost_ports(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalNetworkPolicyHost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalNetworkPolicyIpv4_target(ctx context.Context, field graphql.CollectedField, obj *netpol.ExternalNetworkPolicyIpv4) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalNetworkPolicyIpv4_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalNetworkPolicyIpv4_target(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalNetworkPolicyIpv4",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalNetworkPolicyIpv4_ports(ctx context.Context, field graphql.CollectedField, obj *netpol.ExternalNetworkPolicyIpv4) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalNetworkPolicyIpv4_ports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalNetworkPolicyIpv4_ports(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalNetworkPolicyIpv4",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureKafka_id(ctx context.Context, field graphql.CollectedField, obj *feature.FeatureKafka) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureKafka_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureKafka_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureKafka",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureKafka_enabled(ctx context.Context, field graphql.CollectedField, obj *feature.FeatureKafka) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureKafka_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureKafka_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureKafka",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureOpenSearch_id(ctx context.Context, field graphql.CollectedField, obj *feature.FeatureOpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureOpenSearch_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureOpenSearch_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureOpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureOpenSearch_enabled(ctx context.Context, field graphql.CollectedField, obj *feature.FeatureOpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureOpenSearch_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureOpenSearch_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureOpenSearch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureRedis_id(ctx context.Context, field graphql.CollectedField, obj *feature.FeatureRedis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureRedis_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureRedis_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureRedis",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureRedis_enabled(ctx context.Context, field graphql.CollectedField, obj *feature.FeatureRedis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureRedis_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureRedis_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureRedis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureUnleash_id(ctx context.Context, field graphql.CollectedField, obj *feature.FeatureUnleash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureUnleash_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureUnleash_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureUnleash",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureUnleash_enabled(ctx context.Context, field graphql.CollectedField, obj *feature.FeatureUnleash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureUnleash_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureUnleash_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureUnleash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureValkey_id(ctx context.Context, field graphql.CollectedField, obj *feature.FeatureValkey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureValkey_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureValkey_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureValkey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureValkey_enabled(ctx context.Context, field graphql.CollectedField, obj *feature.FeatureValkey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureValkey_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureValkey_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureValkey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Features_id(ctx context.Context, field graphql.CollectedField, obj *feature.Features) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Features_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Features_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Features",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Features_unleash(ctx context.Context, field graphql.CollectedField, obj *feature.Features) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Features_unleash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unleash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(feature.FeatureUnleash)
	fc.Result = res
	return ec.marshalNFeatureUnleash2githubcomnaisapiinternalfeatureFeatureUnleash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Features_unleash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Features",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeatureUnleash_id(ctx, field)
			case "enabled":
				return ec.fieldContext_FeatureUnleash_enabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureUnleash", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Features_redis(ctx context.Context, field graphql.CollectedField, obj *feature.Features) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Features_redis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Redis, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(feature.FeatureRedis)
	fc.Result = res
	return ec.marshalNFeatureRedis2githubcomnaisapiinternalfeatureFeatureRedis(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Features_redis(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Features",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeatureRedis_id(ctx, field)
			case "enabled":
				return ec.fieldContext_FeatureRedis_enabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureRedis", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Features_valkey(ctx context.Context, field graphql.CollectedField, obj *feature.Features) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Features_valkey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Valkey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(feature.FeatureValkey)
	fc.Result = res
	return ec.marshalNFeatureValkey2githubcomnaisapiinternalfeatureFeatureValkey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Features_valkey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Features",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeatureValkey_id(ctx, field)
			case "enabled":
				return ec.fieldContext_FeatureValkey_enabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureValkey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Features_kafka(ctx context.Context, field graphql.CollectedField, obj *feature.Features) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Features_kafka(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kafka, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(feature.FeatureKafka)
	fc.Result = res
	return ec.marshalNFeatureKafka2githubcomnaisapiinternalfeatureFeatureKafka(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Features_kafka(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Features",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeatureKafka_id(ctx, field)
			case "enabled":
				return ec.fieldContext_FeatureKafka_enabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureKafka", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Features_openSearch(ctx context.Context, field graphql.CollectedField, obj *feature.Features) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Features_openSearch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OpenSearch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(feature.FeatureOpenSearch)
	fc.Result = res
	return ec.marshalNFeatureOpenSearch2githubcomnaisapiinternalfeatureFeatureOpenSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Features_openSearch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Features",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeatureOpenSearch_id(ctx, field)
			case "enabled":
				return ec.fieldContext_FeatureOpenSearch_enabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureOpenSearch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IDPortenAuthIntegration_name(ctx context.Context, field graphql.CollectedField, obj *workload.IDPortenAuthIntegration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IDPortenAuthIntegration_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IDPortenAuthIntegration_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IDPortenAuthIntegration",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_id(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_identifier(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_identifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Identifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_identifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_severity(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(vulnerability.ImageVulnerabilitySeverity)
	fc.Result = res
	return ec.marshalNImageVulnerabilitySeverity2githubcomnaisapiinternalvulnerabilityImageVulnerabilitySeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageVulnerabilitySeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_description(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_package(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_package(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_package(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_state(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(vulnerability.ImageVulnerabilityState)
	fc.Result = res
	return ec.marshalNImageVulnerabilityState2githubcomnaisapiinternalvulnerabilityImageVulnerabilityState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageVulnerabilityState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerability_analysisTrail(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerability) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerability_analysisTrail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ImageVulnerability().AnalysisTrail(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*vulnerability.ImageVulnerabilityAnalysisTrail)
	fc.Result = res
	return ec.marshalNImageVulnerabilityAnalysisTrail2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisTrail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerability_analysisTrail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerability",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_ImageVulnerabilityAnalysisTrail_state(ctx, field)
			case "comments":
				return ec.fieldContext_ImageVulnerabilityAnalysisTrail_comments(ctx, field)
			case "suppressed":
				return ec.fieldContext_ImageVulnerabilityAnalysisTrail_suppressed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilityAnalysisTrail", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisComment_comment(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilityAnalysisComment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisComment_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisComment_comment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisComment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisComment_suppressed(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilityAnalysisComment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisComment_suppressed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suppressed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisComment_suppressed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisComment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisComment_state(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilityAnalysisComment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisComment_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(vulnerability.ImageVulnerabilityAnalysisState)
	fc.Result = res
	return ec.marshalNImageVulnerabilityAnalysisState2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisComment_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisComment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageVulnerabilityAnalysisState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisComment_timestamp(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilityAnalysisComment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisComment_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisComment_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisComment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisComment_onBehalfOf(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilityAnalysisComment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisComment_onBehalfOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnBehalfOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisComment_onBehalfOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisComment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisCommentConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisCommentConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisCommentConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisCommentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisCommentConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisCommentConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*vulnerability.ImageVulnerabilityAnalysisComment])
	fc.Result = res
	return ec.marshalNImageVulnerabilityAnalysisCommentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisCommentConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisCommentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ImageVulnerabilityAnalysisCommentEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ImageVulnerabilityAnalysisCommentEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilityAnalysisCommentEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisCommentConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisCommentConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*vulnerability.ImageVulnerabilityAnalysisComment)
	fc.Result = res
	return ec.marshalNImageVulnerabilityAnalysisComment2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisComment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisCommentConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisCommentConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "comment":
				return ec.fieldContext_ImageVulnerabilityAnalysisComment_comment(ctx, field)
			case "suppressed":
				return ec.fieldContext_ImageVulnerabilityAnalysisComment_suppressed(ctx, field)
			case "state":
				return ec.fieldContext_ImageVulnerabilityAnalysisComment_state(ctx, field)
			case "timestamp":
				return ec.fieldContext_ImageVulnerabilityAnalysisComment_timestamp(ctx, field)
			case "onBehalfOf":
				return ec.fieldContext_ImageVulnerabilityAnalysisComment_onBehalfOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilityAnalysisComment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisCommentEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*vulnerability.ImageVulnerabilityAnalysisComment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisCommentEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisCommentEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisCommentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisCommentEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*vulnerability.ImageVulnerabilityAnalysisComment]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisCommentEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*vulnerability.ImageVulnerabilityAnalysisComment)
	fc.Result = res
	return ec.marshalNImageVulnerabilityAnalysisComment2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisComment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisCommentEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisCommentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "comment":
				return ec.fieldContext_ImageVulnerabilityAnalysisComment_comment(ctx, field)
			case "suppressed":
				return ec.fieldContext_ImageVulnerabilityAnalysisComment_suppressed(ctx, field)
			case "state":
				return ec.fieldContext_ImageVulnerabilityAnalysisComment_state(ctx, field)
			case "timestamp":
				return ec.fieldContext_ImageVulnerabilityAnalysisComment_timestamp(ctx, field)
			case "onBehalfOf":
				return ec.fieldContext_ImageVulnerabilityAnalysisComment_onBehalfOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilityAnalysisComment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisTrail_state(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilityAnalysisTrail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisTrail_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(vulnerability.ImageVulnerabilityAnalysisState)
	fc.Result = res
	return ec.marshalNImageVulnerabilityAnalysisState2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisTrail_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisTrail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageVulnerabilityAnalysisState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisTrail_comments(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilityAnalysisTrail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisTrail_comments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ImageVulnerabilityAnalysisTrail().Comments(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment])
	fc.Result = res
	return ec.marshalNImageVulnerabilityAnalysisCommentConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisTrail_comments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisTrail",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ImageVulnerabilityAnalysisCommentConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_ImageVulnerabilityAnalysisCommentConnection_edges(ctx, field)
			case "nodes":
				return ec.fieldContext_ImageVulnerabilityAnalysisCommentConnection_nodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilityAnalysisCommentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ImageVulnerabilityAnalysisTrail_comments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityAnalysisTrail_suppressed(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilityAnalysisTrail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityAnalysisTrail_suppressed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suppressed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityAnalysisTrail_suppressed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityAnalysisTrail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ImageVulnerability]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ImageVulnerability]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*vulnerability.ImageVulnerability])
	fc.Result = res
	return ec.marshalNImageVulnerabilityEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ImageVulnerabilityEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ImageVulnerabilityEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilityEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*vulnerability.ImageVulnerability]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*vulnerability.ImageVulnerability)
	fc.Result = res
	return ec.marshalNImageVulnerability2githubcomnaisapiinternalvulnerabilityImageVulnerability(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ImageVulnerability_id(ctx, field)
			case "identifier":
				return ec.fieldContext_ImageVulnerability_identifier(ctx, field)
			case "severity":
				return ec.fieldContext_ImageVulnerability_severity(ctx, field)
			case "description":
				return ec.fieldContext_ImageVulnerability_description(ctx, field)
			case "package":
				return ec.fieldContext_ImageVulnerability_package(ctx, field)
			case "state":
				return ec.fieldContext_ImageVulnerability_state(ctx, field)
			case "analysisTrail":
				return ec.fieldContext_ImageVulnerability_analysisTrail(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerability", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*vulnerability.ImageVulnerability]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilityEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*vulnerability.ImageVulnerability]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilityEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*vulnerability.ImageVulnerability)
	fc.Result = res
	return ec.marshalNImageVulnerability2githubcomnaisapiinternalvulnerabilityImageVulnerability(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilityEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilityEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ImageVulnerability_id(ctx, field)
			case "identifier":
				return ec.fieldContext_ImageVulnerability_identifier(ctx, field)
			case "severity":
				return ec.fieldContext_ImageVulnerability_severity(ctx, field)
			case "description":
				return ec.fieldContext_ImageVulnerability_description(ctx, field)
			case "package":
				return ec.fieldContext_ImageVulnerability_package(ctx, field)
			case "state":
				return ec.fieldContext_ImageVulnerability_state(ctx, field)
			case "analysisTrail":
				return ec.fieldContext_ImageVulnerability_analysisTrail(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerability", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_total(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_riskScore(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_riskScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RiskScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_riskScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_low(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_low(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Low, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_low(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_medium(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_medium(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Medium, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_medium(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_high(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_high(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.High, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_high(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_critical(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_critical(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Critical, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_critical(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageVulnerabilitySummary_unassigned(ctx context.Context, field graphql.CollectedField, obj *vulnerability.ImageVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageVulnerabilitySummary_unassigned(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unassigned, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageVulnerabilitySummary_unassigned(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InboundNetworkPolicy_rules(ctx context.Context, field graphql.CollectedField, obj *netpol.InboundNetworkPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InboundNetworkPolicy_rules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*netpol.NetworkPolicyRule)
	fc.Result = res
	return ec.marshalNNetworkPolicyRule2githubcomnaisapiinternalworkloadnetpolNetworkPolicyRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InboundNetworkPolicy_rules(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InboundNetworkPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "targetWorkloadName":
				return ec.fieldContext_NetworkPolicyRule_targetWorkloadName(ctx, field)
			case "targetWorkload":
				return ec.fieldContext_NetworkPolicyRule_targetWorkload(ctx, field)
			case "targetTeamSlug":
				return ec.fieldContext_NetworkPolicyRule_targetTeamSlug(ctx, field)
			case "targetTeam":
				return ec.fieldContext_NetworkPolicyRule_targetTeam(ctx, field)
			case "mutual":
				return ec.fieldContext_NetworkPolicyRule_mutual(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkPolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ingress_url(ctx context.Context, field graphql.CollectedField, obj *application.Ingress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ingress_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ingress_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ingress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ingress_type(ctx context.Context, field graphql.CollectedField, obj *application.Ingress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ingress_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Ingress().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(application.IngressType)
	fc.Result = res
	return ec.marshalNIngressType2githubcomnaisapiinternalworkloadapplicationIngressType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ingress_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ingress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IngressType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_id(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_name(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_team(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_environment(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_image(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.ContainerImage)
	fc.Result = res
	return ec.marshalNContainerImage2githubcomnaisapiinternalworkloadContainerImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerImage_id(ctx, field)
			case "name":
				return ec.fieldContext_ContainerImage_name(ctx, field)
			case "tag":
				return ec.fieldContext_ContainerImage_tag(ctx, field)
			case "hasSBOM":
				return ec.fieldContext_ContainerImage_hasSBOM(ctx, field)
			case "vulnerabilities":
				return ec.fieldContext_ContainerImage_vulnerabilities(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_ContainerImage_vulnerabilitySummary(ctx, field)
			case "workloadReferences":
				return ec.fieldContext_ContainerImage_workloadReferences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_resources(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.JobResources)
	fc.Result = res
	return ec.marshalNJobResources2githubcomnaisapiinternalworkloadjobJobResources(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_resources(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "limits":
				return ec.fieldContext_JobResources_limits(ctx, field)
			case "requests":
				return ec.fieldContext_JobResources_requests(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_authIntegrations(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_authIntegrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().AuthIntegrations(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]workload.JobAuthIntegrations)
	fc.Result = res
	return ec.marshalNJobAuthIntegrations2githubcomnaisapiinternalworkloadJobAuthIntegrations(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_authIntegrations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobAuthIntegrations does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_schedule(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_schedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schedule(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*job.JobSchedule)
	fc.Result = res
	return ec.marshalOJobSchedule2githubcomnaisapiinternalworkloadjobJobSchedule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_schedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "expression":
				return ec.fieldContext_JobSchedule_expression(ctx, field)
			case "timeZone":
				return ec.fieldContext_JobSchedule_timeZone(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobSchedule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_runs(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_runs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Runs(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*job.JobRun])
	fc.Result = res
	return ec.marshalNJobRunConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_runs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_JobRunConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_JobRunConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_JobRunConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRunConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_runs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_manifest(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_manifest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Manifest(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.JobManifest)
	fc.Result = res
	return ec.marshalNJobManifest2githubcomnaisapiinternalworkloadjobJobManifest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_manifest(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "content":
				return ec.fieldContext_JobManifest_content(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobManifest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_deletionStartedAt(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_deletionStartedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionStartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_deletionStartedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_bigQueryDatasets(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_bigQueryDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().BigQueryDatasets(rctx, obj, fc.Args["orderBy"].(*bigquery.BigQueryDatasetOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bigquery.BigQueryDataset])
	fc.Result = res
	return ec.marshalNBigQueryDatasetConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_bigQueryDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BigQueryDatasetConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BigQueryDatasetConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BigQueryDatasetConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_bigQueryDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_buckets(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_buckets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Buckets(rctx, obj, fc.Args["orderBy"].(*bucket.BucketOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bucket.Bucket])
	fc.Result = res
	return ec.marshalNBucketConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_buckets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BucketConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BucketConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BucketConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_buckets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_cost(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.WorkloadCost)
	fc.Result = res
	return ec.marshalNWorkloadCost2githubcomnaisapiinternalcostWorkloadCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "daily":
				return ec.fieldContext_WorkloadCost_daily(ctx, field)
			case "monthly":
				return ec.fieldContext_WorkloadCost_monthly(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_deployments(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_deployments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Deployments(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*deployment.Deployment])
	fc.Result = res
	return ec.marshalNDeploymentConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_deployments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_DeploymentConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_DeploymentConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_DeploymentConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_deployments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_kafkaTopicAcls(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_kafkaTopicAcls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().KafkaTopicAcls(rctx, obj, fc.Args["orderBy"].(*kafkatopic.KafkaTopicACLOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*kafkatopic.KafkaTopicACL])
	fc.Result = res
	return ec.marshalNKafkaTopicAclConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_kafkaTopicAcls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_KafkaTopicAclConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_KafkaTopicAclConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_KafkaTopicAclConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAclConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_kafkaTopicAcls_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_logDestinations(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_logDestinations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().LogDestinations(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]logging.LogDestination)
	fc.Result = res
	return ec.marshalNLogDestination2githubcomnaisapiinternalworkloadloggingLogDestination(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_logDestinations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_networkPolicy(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_networkPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().NetworkPolicy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*netpol.NetworkPolicy)
	fc.Result = res
	return ec.marshalNNetworkPolicy2githubcomnaisapiinternalworkloadnetpolNetworkPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_networkPolicy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "inbound":
				return ec.fieldContext_NetworkPolicy_inbound(ctx, field)
			case "outbound":
				return ec.fieldContext_NetworkPolicy_outbound(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_openSearch(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_openSearch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().OpenSearch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearch)
	fc.Result = res
	return ec.marshalOOpenSearch2githubcomnaisapiinternalpersistenceopensearchOpenSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_openSearch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_OpenSearch_teamEnvironment(ctx, field)
			case "status":
				return ec.fieldContext_OpenSearch_status(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_redisInstances(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_redisInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().RedisInstances(rctx, obj, fc.Args["orderBy"].(*redis.RedisInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*redis.RedisInstance])
	fc.Result = res
	return ec.marshalNRedisInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_redisInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_RedisInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_RedisInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RedisInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_redisInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_secrets(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_secrets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Secrets(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*secret.Secret])
	fc.Result = res
	return ec.marshalNSecretConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_secrets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SecretConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SecretConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SecretConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_secrets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_sqlInstances(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_sqlInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().SQLInstances(rctx, obj, fc.Args["orderBy"].(*sqlinstance.SQLInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*sqlinstance.SQLInstance])
	fc.Result = res
	return ec.marshalNSqlInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_sqlInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SqlInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SqlInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SqlInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_sqlInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_status(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*status.WorkloadStatus)
	fc.Result = res
	return ec.marshalNWorkloadStatus2githubcomnaisapiinternalstatusWorkloadStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_WorkloadStatus_state(ctx, field)
			case "errors":
				return ec.fieldContext_WorkloadStatus_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_valkeyInstances(ctx context.Context, field graphql.CollectedField, obj *job.Job) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Job_valkeyInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Job().ValkeyInstances(rctx, obj, fc.Args["orderBy"].(*valkey.ValkeyInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*valkey.ValkeyInstance])
	fc.Result = res
	return ec.marshalNValkeyInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Job_valkeyInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ValkeyInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ValkeyInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ValkeyInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_valkeyInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _JobConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.Job]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.Job]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*job.Job)
	fc.Result = res
	return ec.marshalNJob2githubcomnaisapiinternalworkloadjobJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "name":
				return ec.fieldContext_Job_name(ctx, field)
			case "team":
				return ec.fieldContext_Job_team(ctx, field)
			case "environment":
				return ec.fieldContext_Job_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Job_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Job_image(ctx, field)
			case "resources":
				return ec.fieldContext_Job_resources(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Job_authIntegrations(ctx, field)
			case "schedule":
				return ec.fieldContext_Job_schedule(ctx, field)
			case "runs":
				return ec.fieldContext_Job_runs(ctx, field)
			case "manifest":
				return ec.fieldContext_Job_manifest(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Job_deletionStartedAt(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Job_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Job_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Job_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Job_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Job_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Job_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Job_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Job_openSearch(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Job_redisInstances(ctx, field)
			case "secrets":
				return ec.fieldContext_Job_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Job_sqlInstances(ctx, field)
			case "status":
				return ec.fieldContext_Job_status(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Job_valkeyInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.Job]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*job.Job])
	fc.Result = res
	return ec.marshalNJobEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_JobEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_JobEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobDeletedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *job.JobDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobDeletedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobDeletedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobDeletedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *job.JobDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobDeletedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobDeletedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobDeletedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *job.JobDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobDeletedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobDeletedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobDeletedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *job.JobDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobDeletedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobDeletedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobDeletedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *job.JobDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobDeletedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobDeletedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobDeletedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *job.JobDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobDeletedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobDeletedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobDeletedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *job.JobDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobDeletedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobDeletedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobDeletedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *job.JobDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobDeletedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobDeletedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*job.Job]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*job.Job]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.Job)
	fc.Result = res
	return ec.marshalNJob2githubcomnaisapiinternalworkloadjobJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "name":
				return ec.fieldContext_Job_name(ctx, field)
			case "team":
				return ec.fieldContext_Job_team(ctx, field)
			case "environment":
				return ec.fieldContext_Job_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Job_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Job_image(ctx, field)
			case "resources":
				return ec.fieldContext_Job_resources(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Job_authIntegrations(ctx, field)
			case "schedule":
				return ec.fieldContext_Job_schedule(ctx, field)
			case "runs":
				return ec.fieldContext_Job_runs(ctx, field)
			case "manifest":
				return ec.fieldContext_Job_manifest(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Job_deletionStartedAt(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Job_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Job_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Job_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Job_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Job_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Job_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Job_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Job_openSearch(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Job_redisInstances(ctx, field)
			case "secrets":
				return ec.fieldContext_Job_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Job_sqlInstances(ctx, field)
			case "status":
				return ec.fieldContext_Job_status(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Job_valkeyInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobManifest_content(ctx context.Context, field graphql.CollectedField, obj *job.JobManifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobManifest_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobManifest_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobManifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobResources_limits(ctx context.Context, field graphql.CollectedField, obj *job.JobResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobResources_limits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.WorkloadResourceQuantity)
	fc.Result = res
	return ec.marshalNWorkloadResourceQuantity2githubcomnaisapiinternalworkloadWorkloadResourceQuantity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobResources_limits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadResourceQuantity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobResources_requests(ctx context.Context, field graphql.CollectedField, obj *job.JobResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobResources_requests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.WorkloadResourceQuantity)
	fc.Result = res
	return ec.marshalNWorkloadResourceQuantity2githubcomnaisapiinternalworkloadWorkloadResourceQuantity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobResources_requests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadResourceQuantity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_id(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_name(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_startTime(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_completionTime(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_completionTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletionTime(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_completionTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_status(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.JobRunStatus)
	fc.Result = res
	return ec.marshalNJobRunStatus2githubcomnaisapiinternalworkloadjobJobRunStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_JobRunStatus_state(ctx, field)
			case "message":
				return ec.fieldContext_JobRunStatus_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRunStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_image(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*workload.ContainerImage)
	fc.Result = res
	return ec.marshalNContainerImage2githubcomnaisapiinternalworkloadContainerImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerImage_id(ctx, field)
			case "name":
				return ec.fieldContext_ContainerImage_name(ctx, field)
			case "tag":
				return ec.fieldContext_ContainerImage_tag(ctx, field)
			case "hasSBOM":
				return ec.fieldContext_ContainerImage_hasSBOM(ctx, field)
			case "vulnerabilities":
				return ec.fieldContext_ContainerImage_vulnerabilities(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_ContainerImage_vulnerabilitySummary(ctx, field)
			case "workloadReferences":
				return ec.fieldContext_ContainerImage_workloadReferences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_duration(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.JobRun().Duration(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_instances(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_instances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.JobRun().Instances(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*job.JobRunInstance])
	fc.Result = res
	return ec.marshalNJobRunInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_instances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_JobRunInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_JobRunInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_JobRunInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRunInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_JobRun_instances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _JobRun_trigger(ctx context.Context, field graphql.CollectedField, obj *job.JobRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRun_trigger(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Trigger, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.JobRunTrigger)
	fc.Result = res
	return ec.marshalNJobRunTrigger2githubcomnaisapiinternalworkloadjobJobRunTrigger(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRun_trigger(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_JobRunTrigger_type(ctx, field)
			case "actor":
				return ec.fieldContext_JobRunTrigger_actor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRunTrigger", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.JobRun]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.JobRun]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*job.JobRun)
	fc.Result = res
	return ec.marshalNJobRun2githubcomnaisapiinternalworkloadjobJobRun(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JobRun_id(ctx, field)
			case "name":
				return ec.fieldContext_JobRun_name(ctx, field)
			case "startTime":
				return ec.fieldContext_JobRun_startTime(ctx, field)
			case "completionTime":
				return ec.fieldContext_JobRun_completionTime(ctx, field)
			case "status":
				return ec.fieldContext_JobRun_status(ctx, field)
			case "image":
				return ec.fieldContext_JobRun_image(ctx, field)
			case "duration":
				return ec.fieldContext_JobRun_duration(ctx, field)
			case "instances":
				return ec.fieldContext_JobRun_instances(ctx, field)
			case "trigger":
				return ec.fieldContext_JobRun_trigger(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRun", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.JobRun]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*job.JobRun])
	fc.Result = res
	return ec.marshalNJobRunEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_JobRunEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_JobRunEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRunEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*job.JobRun]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*job.JobRun]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.JobRun)
	fc.Result = res
	return ec.marshalNJobRun2githubcomnaisapiinternalworkloadjobJobRun(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JobRun_id(ctx, field)
			case "name":
				return ec.fieldContext_JobRun_name(ctx, field)
			case "startTime":
				return ec.fieldContext_JobRun_startTime(ctx, field)
			case "completionTime":
				return ec.fieldContext_JobRun_completionTime(ctx, field)
			case "status":
				return ec.fieldContext_JobRun_status(ctx, field)
			case "image":
				return ec.fieldContext_JobRun_image(ctx, field)
			case "duration":
				return ec.fieldContext_JobRun_duration(ctx, field)
			case "instances":
				return ec.fieldContext_JobRun_instances(ctx, field)
			case "trigger":
				return ec.fieldContext_JobRun_trigger(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRun", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunInstance_id(ctx context.Context, field graphql.CollectedField, obj *job.JobRunInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunInstance_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunInstance_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunInstance_name(ctx context.Context, field graphql.CollectedField, obj *job.JobRunInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunInstance_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunInstance_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunInstanceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.JobRunInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunInstanceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunInstanceConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunInstanceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.JobRunInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunInstanceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*job.JobRunInstance)
	fc.Result = res
	return ec.marshalNJobRunInstance2githubcomnaisapiinternalworkloadjobJobRunInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunInstanceConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunInstanceConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JobRunInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_JobRunInstance_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRunInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunInstanceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*job.JobRunInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunInstanceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*job.JobRunInstance])
	fc.Result = res
	return ec.marshalNJobRunInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunInstanceConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_JobRunInstanceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_JobRunInstanceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRunInstanceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunInstanceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*job.JobRunInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunInstanceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunInstanceEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunInstanceEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*job.JobRunInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunInstanceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.JobRunInstance)
	fc.Result = res
	return ec.marshalNJobRunInstance2githubcomnaisapiinternalworkloadjobJobRunInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunInstanceEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JobRunInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_JobRunInstance_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRunInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunStatus_state(ctx context.Context, field graphql.CollectedField, obj *job.JobRunStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(job.JobRunState)
	fc.Result = res
	return ec.marshalNJobRunState2githubcomnaisapiinternalworkloadjobJobRunState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobRunState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunStatus_message(ctx context.Context, field graphql.CollectedField, obj *job.JobRunStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunStatus_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunStatus_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunTrigger_type(ctx context.Context, field graphql.CollectedField, obj *job.JobRunTrigger) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunTrigger_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(job.JobRunTriggerType)
	fc.Result = res
	return ec.marshalNJobRunTriggerType2githubcomnaisapiinternalworkloadjobJobRunTriggerType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunTrigger_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunTrigger",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobRunTriggerType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRunTrigger_actor(ctx context.Context, field graphql.CollectedField, obj *job.JobRunTrigger) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRunTrigger_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRunTrigger_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRunTrigger",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobSchedule_expression(ctx context.Context, field graphql.CollectedField, obj *job.JobSchedule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobSchedule_expression(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobSchedule_expression(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobSchedule_timeZone(ctx context.Context, field graphql.CollectedField, obj *job.JobSchedule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobSchedule_timeZone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeZone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobSchedule_timeZone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobTriggeredActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *job.JobTriggeredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobTriggeredActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobTriggeredActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobTriggeredActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobTriggeredActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *job.JobTriggeredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobTriggeredActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobTriggeredActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobTriggeredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobTriggeredActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *job.JobTriggeredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobTriggeredActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobTriggeredActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobTriggeredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobTriggeredActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *job.JobTriggeredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobTriggeredActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobTriggeredActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobTriggeredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobTriggeredActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *job.JobTriggeredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobTriggeredActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobTriggeredActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobTriggeredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobTriggeredActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *job.JobTriggeredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobTriggeredActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobTriggeredActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobTriggeredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobTriggeredActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *job.JobTriggeredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobTriggeredActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobTriggeredActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobTriggeredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobTriggeredActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *job.JobTriggeredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobTriggeredActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobTriggeredActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobTriggeredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaLagScalingStrategy_threshold(ctx context.Context, field graphql.CollectedField, obj *application.KafkaLagScalingStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaLagScalingStrategy_threshold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Threshold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaLagScalingStrategy_threshold(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaLagScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaLagScalingStrategy_consumerGroup(ctx context.Context, field graphql.CollectedField, obj *application.KafkaLagScalingStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaLagScalingStrategy_consumerGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConsumerGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaLagScalingStrategy_consumerGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaLagScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaLagScalingStrategy_topicName(ctx context.Context, field graphql.CollectedField, obj *application.KafkaLagScalingStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaLagScalingStrategy_topicName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaLagScalingStrategy_topicName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaLagScalingStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_id(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_name(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_team(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopic().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_environment(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopic().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopic().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_acl(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_acl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopic().ACL(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["filter"].(*kafkatopic.KafkaTopicACLFilter), fc.Args["orderBy"].(*kafkatopic.KafkaTopicACLOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*kafkatopic.KafkaTopicACL])
	fc.Result = res
	return ec.marshalNKafkaTopicAclConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_acl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_KafkaTopicAclConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_KafkaTopicAclConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_KafkaTopicAclConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAclConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KafkaTopic_acl_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_configuration(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.KafkaTopicConfiguration)
	fc.Result = res
	return ec.marshalOKafkaTopicConfiguration2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_configuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cleanupPolicy":
				return ec.fieldContext_KafkaTopicConfiguration_cleanupPolicy(ctx, field)
			case "maxMessageBytes":
				return ec.fieldContext_KafkaTopicConfiguration_maxMessageBytes(ctx, field)
			case "minimumInSyncReplicas":
				return ec.fieldContext_KafkaTopicConfiguration_minimumInSyncReplicas(ctx, field)
			case "partitions":
				return ec.fieldContext_KafkaTopicConfiguration_partitions(ctx, field)
			case "replication":
				return ec.fieldContext_KafkaTopicConfiguration_replication(ctx, field)
			case "retentionBytes":
				return ec.fieldContext_KafkaTopicConfiguration_retentionBytes(ctx, field)
			case "retentionHours":
				return ec.fieldContext_KafkaTopicConfiguration_retentionHours(ctx, field)
			case "segmentHours":
				return ec.fieldContext_KafkaTopicConfiguration_segmentHours(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicConfiguration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopic_pool(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopic_pool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopic_pool(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_access(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_access(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_workloadName(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_workloadName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkloadName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_workloadName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_teamName(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_teamName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_teamName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_team(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopicAcl().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_workload(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopicAcl().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAcl_topic(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAcl_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KafkaTopicAcl().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.KafkaTopic)
	fc.Result = res
	return ec.marshalNKafkaTopic2githubcomnaisapiinternalpersistencekafkatopicKafkaTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAcl_topic(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAcl",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KafkaTopic_id(ctx, field)
			case "name":
				return ec.fieldContext_KafkaTopic_name(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopic_team(ctx, field)
			case "environment":
				return ec.fieldContext_KafkaTopic_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_KafkaTopic_teamEnvironment(ctx, field)
			case "acl":
				return ec.fieldContext_KafkaTopic_acl(ctx, field)
			case "configuration":
				return ec.fieldContext_KafkaTopic_configuration(ctx, field)
			case "pool":
				return ec.fieldContext_KafkaTopic_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAclConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopicACL]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAclConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAclConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAclConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAclConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopicACL]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAclConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*kafkatopic.KafkaTopicACL)
	fc.Result = res
	return ec.marshalNKafkaTopicAcl2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAclConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAclConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "access":
				return ec.fieldContext_KafkaTopicAcl_access(ctx, field)
			case "workloadName":
				return ec.fieldContext_KafkaTopicAcl_workloadName(ctx, field)
			case "teamName":
				return ec.fieldContext_KafkaTopicAcl_teamName(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopicAcl_team(ctx, field)
			case "workload":
				return ec.fieldContext_KafkaTopicAcl_workload(ctx, field)
			case "topic":
				return ec.fieldContext_KafkaTopicAcl_topic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAcl", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAclConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopicACL]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAclConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*kafkatopic.KafkaTopicACL])
	fc.Result = res
	return ec.marshalNKafkaTopicAclEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAclConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAclConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_KafkaTopicAclEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_KafkaTopicAclEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAclEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAclEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*kafkatopic.KafkaTopicACL]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAclEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAclEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAclEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicAclEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*kafkatopic.KafkaTopicACL]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicAclEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.KafkaTopicACL)
	fc.Result = res
	return ec.marshalNKafkaTopicAcl2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicAclEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicAclEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "access":
				return ec.fieldContext_KafkaTopicAcl_access(ctx, field)
			case "workloadName":
				return ec.fieldContext_KafkaTopicAcl_workloadName(ctx, field)
			case "teamName":
				return ec.fieldContext_KafkaTopicAcl_teamName(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopicAcl_team(ctx, field)
			case "workload":
				return ec.fieldContext_KafkaTopicAcl_workload(ctx, field)
			case "topic":
				return ec.fieldContext_KafkaTopicAcl_topic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicAcl", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_cleanupPolicy(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_cleanupPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CleanupPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_cleanupPolicy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_maxMessageBytes(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_maxMessageBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxMessageBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_maxMessageBytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_minimumInSyncReplicas(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_minimumInSyncReplicas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinimumInSyncReplicas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_minimumInSyncReplicas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_partitions(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_partitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Partitions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_partitions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_replication(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_replication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Replication, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_replication(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_retentionBytes(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_retentionBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RetentionBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_retentionBytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_retentionHours(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_retentionHours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RetentionHours, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_retentionHours(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConfiguration_segmentHours(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.KafkaTopicConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConfiguration_segmentHours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SegmentHours, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConfiguration_segmentHours(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopic]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopic]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*kafkatopic.KafkaTopic)
	fc.Result = res
	return ec.marshalNKafkaTopic2githubcomnaisapiinternalpersistencekafkatopicKafkaTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KafkaTopic_id(ctx, field)
			case "name":
				return ec.fieldContext_KafkaTopic_name(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopic_team(ctx, field)
			case "environment":
				return ec.fieldContext_KafkaTopic_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_KafkaTopic_teamEnvironment(ctx, field)
			case "acl":
				return ec.fieldContext_KafkaTopic_acl(ctx, field)
			case "configuration":
				return ec.fieldContext_KafkaTopic_configuration(ctx, field)
			case "pool":
				return ec.fieldContext_KafkaTopic_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*kafkatopic.KafkaTopic]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*kafkatopic.KafkaTopic])
	fc.Result = res
	return ec.marshalNKafkaTopicEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_KafkaTopicEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_KafkaTopicEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*kafkatopic.KafkaTopic]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KafkaTopicEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*kafkatopic.KafkaTopic]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KafkaTopicEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.KafkaTopic)
	fc.Result = res
	return ec.marshalNKafkaTopic2githubcomnaisapiinternalpersistencekafkatopicKafkaTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KafkaTopicEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KafkaTopicEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KafkaTopic_id(ctx, field)
			case "name":
				return ec.fieldContext_KafkaTopic_name(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopic_team(ctx, field)
			case "environment":
				return ec.fieldContext_KafkaTopic_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_KafkaTopic_teamEnvironment(ctx, field)
			case "acl":
				return ec.fieldContext_KafkaTopic_acl(ctx, field)
			case "configuration":
				return ec.fieldContext_KafkaTopic_configuration(ctx, field)
			case "pool":
				return ec.fieldContext_KafkaTopic_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogDestinationLoki_id(ctx context.Context, field graphql.CollectedField, obj *logging.LogDestinationLoki) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogDestinationLoki_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogDestinationLoki_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogDestinationLoki",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogDestinationLoki_grafanaURL(ctx context.Context, field graphql.CollectedField, obj *logging.LogDestinationLoki) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogDestinationLoki_grafanaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GrafanaURL(ctx), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogDestinationLoki_grafanaURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogDestinationLoki",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogDestinationSecureLogs_id(ctx context.Context, field graphql.CollectedField, obj *logging.LogDestinationSecureLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogDestinationSecureLogs_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogDestinationSecureLogs_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogDestinationSecureLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MaskinportenAuthIntegration_name(ctx context.Context, field graphql.CollectedField, obj *workload.MaskinportenAuthIntegration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MaskinportenAuthIntegration_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MaskinportenAuthIntegration_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MaskinportenAuthIntegration",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteApplication(rctx, fc.Args["input"].(application.DeleteApplicationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.DeleteApplicationPayload)
	fc.Result = res
	return ec.marshalNDeleteApplicationPayload2githubcomnaisapiinternalworkloadapplicationDeleteApplicationPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_DeleteApplicationPayload_team(ctx, field)
			case "success":
				return ec.fieldContext_DeleteApplicationPayload_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteApplicationPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestartApplication(rctx, fc.Args["input"].(application.RestartApplicationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.RestartApplicationPayload)
	fc.Result = res
	return ec.marshalNRestartApplicationPayload2githubcomnaisapiinternalworkloadapplicationRestartApplicationPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "application":
				return ec.fieldContext_RestartApplicationPayload_application(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RestartApplicationPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_changeDeploymentKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_changeDeploymentKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ChangeDeploymentKey(rctx, fc.Args["input"].(deployment.ChangeDeploymentKeyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*deployment.ChangeDeploymentKeyPayload)
	fc.Result = res
	return ec.marshalNChangeDeploymentKeyPayload2githubcomnaisapiinternaldeploymentChangeDeploymentKeyPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_changeDeploymentKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deploymentKey":
				return ec.fieldContext_ChangeDeploymentKeyPayload_deploymentKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeDeploymentKeyPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_changeDeploymentKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteJob(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteJob(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteJob(rctx, fc.Args["input"].(job.DeleteJobInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.DeleteJobPayload)
	fc.Result = res
	return ec.marshalNDeleteJobPayload2githubcomnaisapiinternalworkloadjobDeleteJobPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteJob(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_DeleteJobPayload_team(ctx, field)
			case "success":
				return ec.fieldContext_DeleteJobPayload_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteJobPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteJob_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_triggerJob(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_triggerJob(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TriggerJob(rctx, fc.Args["input"].(job.TriggerJobInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.TriggerJobPayload)
	fc.Result = res
	return ec.marshalNTriggerJobPayload2githubcomnaisapiinternalworkloadjobTriggerJobPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_triggerJob(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "job":
				return ec.fieldContext_TriggerJobPayload_job(ctx, field)
			case "jobRun":
				return ec.fieldContext_TriggerJobPayload_jobRun(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TriggerJobPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_triggerJob_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_enableReconciler(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_enableReconciler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EnableReconciler(rctx, fc.Args["input"].(reconciler.EnableReconcilerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*reconciler.Reconciler)
	fc.Result = res
	return ec.marshalNReconciler2githubcomnaisapiinternalreconcilerReconciler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_enableReconciler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Reconciler_id(ctx, field)
			case "name":
				return ec.fieldContext_Reconciler_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Reconciler_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Reconciler_description(ctx, field)
			case "enabled":
				return ec.fieldContext_Reconciler_enabled(ctx, field)
			case "config":
				return ec.fieldContext_Reconciler_config(ctx, field)
			case "configured":
				return ec.fieldContext_Reconciler_configured(ctx, field)
			case "errors":
				return ec.fieldContext_Reconciler_errors(ctx, field)
			case "activityLog":
				return ec.fieldContext_Reconciler_activityLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Reconciler", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_enableReconciler_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_disableReconciler(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_disableReconciler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DisableReconciler(rctx, fc.Args["input"].(reconciler.DisableReconcilerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*reconciler.Reconciler)
	fc.Result = res
	return ec.marshalNReconciler2githubcomnaisapiinternalreconcilerReconciler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_disableReconciler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Reconciler_id(ctx, field)
			case "name":
				return ec.fieldContext_Reconciler_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Reconciler_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Reconciler_description(ctx, field)
			case "enabled":
				return ec.fieldContext_Reconciler_enabled(ctx, field)
			case "config":
				return ec.fieldContext_Reconciler_config(ctx, field)
			case "configured":
				return ec.fieldContext_Reconciler_configured(ctx, field)
			case "errors":
				return ec.fieldContext_Reconciler_errors(ctx, field)
			case "activityLog":
				return ec.fieldContext_Reconciler_activityLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Reconciler", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_disableReconciler_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_configureReconciler(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_configureReconciler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfigureReconciler(rctx, fc.Args["input"].(reconciler.ConfigureReconcilerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*reconciler.Reconciler)
	fc.Result = res
	return ec.marshalNReconciler2githubcomnaisapiinternalreconcilerReconciler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_configureReconciler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Reconciler_id(ctx, field)
			case "name":
				return ec.fieldContext_Reconciler_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Reconciler_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Reconciler_description(ctx, field)
			case "enabled":
				return ec.fieldContext_Reconciler_enabled(ctx, field)
			case "config":
				return ec.fieldContext_Reconciler_config(ctx, field)
			case "configured":
				return ec.fieldContext_Reconciler_configured(ctx, field)
			case "errors":
				return ec.fieldContext_Reconciler_errors(ctx, field)
			case "activityLog":
				return ec.fieldContext_Reconciler_activityLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Reconciler", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_configureReconciler_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addRepositoryToTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addRepositoryToTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddRepositoryToTeam(rctx, fc.Args["input"].(repository.AddRepositoryToTeamInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*repository.AddRepositoryToTeamPayload)
	fc.Result = res
	return ec.marshalNAddRepositoryToTeamPayload2githubcomnaisapiinternalgithubrepositoryAddRepositoryToTeamPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addRepositoryToTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "repository":
				return ec.fieldContext_AddRepositoryToTeamPayload_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AddRepositoryToTeamPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addRepositoryToTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeRepositoryFromTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeRepositoryFromTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveRepositoryFromTeam(rctx, fc.Args["input"].(repository.RemoveRepositoryFromTeamInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*repository.RemoveRepositoryFromTeamPayload)
	fc.Result = res
	return ec.marshalNRemoveRepositoryFromTeamPayload2githubcomnaisapiinternalgithubrepositoryRemoveRepositoryFromTeamPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeRepositoryFromTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_RemoveRepositoryFromTeamPayload_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RemoveRepositoryFromTeamPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeRepositoryFromTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSecret(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateSecret(rctx, fc.Args["input"].(secret.CreateSecretInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*secret.CreateSecretPayload)
	fc.Result = res
	return ec.marshalNCreateSecretPayload2githubcomnaisapiinternalworkloadsecretCreateSecretPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "secret":
				return ec.fieldContext_CreateSecretPayload_secret(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateSecretPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSecret_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addSecretValue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addSecretValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddSecretValue(rctx, fc.Args["input"].(secret.AddSecretValueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*secret.AddSecretValuePayload)
	fc.Result = res
	return ec.marshalNAddSecretValuePayload2githubcomnaisapiinternalworkloadsecretAddSecretValuePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addSecretValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "secret":
				return ec.fieldContext_AddSecretValuePayload_secret(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AddSecretValuePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addSecretValue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSecretValue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSecretValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateSecretValue(rctx, fc.Args["input"].(secret.UpdateSecretValueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*secret.UpdateSecretValuePayload)
	fc.Result = res
	return ec.marshalNUpdateSecretValuePayload2githubcomnaisapiinternalworkloadsecretUpdateSecretValuePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSecretValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "secret":
				return ec.fieldContext_UpdateSecretValuePayload_secret(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateSecretValuePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSecretValue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeSecretValue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeSecretValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveSecretValue(rctx, fc.Args["input"].(secret.RemoveSecretValueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*secret.RemoveSecretValuePayload)
	fc.Result = res
	return ec.marshalNRemoveSecretValuePayload2githubcomnaisapiinternalworkloadsecretRemoveSecretValuePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeSecretValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "secret":
				return ec.fieldContext_RemoveSecretValuePayload_secret(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RemoveSecretValuePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeSecretValue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSecret(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteSecret(rctx, fc.Args["input"].(secret.DeleteSecretInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*secret.DeleteSecretPayload)
	fc.Result = res
	return ec.marshalNDeleteSecretPayload2githubcomnaisapiinternalworkloadsecretDeleteSecretPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "secretDeleted":
				return ec.fieldContext_DeleteSecretPayload_secretDeleted(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteSecretPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSecret_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createServiceAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createServiceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateServiceAccount(rctx, fc.Args["input"].(serviceaccount.CreateServiceAccountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.CreateServiceAccountPayload)
	fc.Result = res
	return ec.marshalNCreateServiceAccountPayload2githubcomnaisapiinternalserviceaccountCreateServiceAccountPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createServiceAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "serviceAccount":
				return ec.fieldContext_CreateServiceAccountPayload_serviceAccount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateServiceAccountPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createServiceAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateServiceAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateServiceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateServiceAccount(rctx, fc.Args["input"].(serviceaccount.UpdateServiceAccountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.UpdateServiceAccountPayload)
	fc.Result = res
	return ec.marshalNUpdateServiceAccountPayload2githubcomnaisapiinternalserviceaccountUpdateServiceAccountPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateServiceAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "serviceAccount":
				return ec.fieldContext_UpdateServiceAccountPayload_serviceAccount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateServiceAccountPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateServiceAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteServiceAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteServiceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteServiceAccount(rctx, fc.Args["input"].(serviceaccount.DeleteServiceAccountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.DeleteServiceAccountPayload)
	fc.Result = res
	return ec.marshalNDeleteServiceAccountPayload2githubcomnaisapiinternalserviceaccountDeleteServiceAccountPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteServiceAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "serviceAccountDeleted":
				return ec.fieldContext_DeleteServiceAccountPayload_serviceAccountDeleted(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteServiceAccountPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteServiceAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_assignRoleToServiceAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_assignRoleToServiceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AssignRoleToServiceAccount(rctx, fc.Args["input"].(serviceaccount.AssignRoleToServiceAccountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.AssignRoleToServiceAccountPayload)
	fc.Result = res
	return ec.marshalNAssignRoleToServiceAccountPayload2githubcomnaisapiinternalserviceaccountAssignRoleToServiceAccountPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_assignRoleToServiceAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "serviceAccount":
				return ec.fieldContext_AssignRoleToServiceAccountPayload_serviceAccount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AssignRoleToServiceAccountPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_assignRoleToServiceAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_revokeRoleFromServiceAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_revokeRoleFromServiceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RevokeRoleFromServiceAccount(rctx, fc.Args["input"].(serviceaccount.RevokeRoleFromServiceAccountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.RevokeRoleFromServiceAccountPayload)
	fc.Result = res
	return ec.marshalNRevokeRoleFromServiceAccountPayload2githubcomnaisapiinternalserviceaccountRevokeRoleFromServiceAccountPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_revokeRoleFromServiceAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "serviceAccount":
				return ec.fieldContext_RevokeRoleFromServiceAccountPayload_serviceAccount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RevokeRoleFromServiceAccountPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_revokeRoleFromServiceAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createServiceAccountToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createServiceAccountToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateServiceAccountToken(rctx, fc.Args["input"].(serviceaccount.CreateServiceAccountTokenInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.CreateServiceAccountTokenPayload)
	fc.Result = res
	return ec.marshalNCreateServiceAccountTokenPayload2githubcomnaisapiinternalserviceaccountCreateServiceAccountTokenPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createServiceAccountToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "serviceAccount":
				return ec.fieldContext_CreateServiceAccountTokenPayload_serviceAccount(ctx, field)
			case "serviceAccountToken":
				return ec.fieldContext_CreateServiceAccountTokenPayload_serviceAccountToken(ctx, field)
			case "secret":
				return ec.fieldContext_CreateServiceAccountTokenPayload_secret(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateServiceAccountTokenPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createServiceAccountToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateServiceAccountToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateServiceAccountToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateServiceAccountToken(rctx, fc.Args["input"].(serviceaccount.UpdateServiceAccountTokenInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.UpdateServiceAccountTokenPayload)
	fc.Result = res
	return ec.marshalNUpdateServiceAccountTokenPayload2githubcomnaisapiinternalserviceaccountUpdateServiceAccountTokenPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateServiceAccountToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "serviceAccount":
				return ec.fieldContext_UpdateServiceAccountTokenPayload_serviceAccount(ctx, field)
			case "serviceAccountToken":
				return ec.fieldContext_UpdateServiceAccountTokenPayload_serviceAccountToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateServiceAccountTokenPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateServiceAccountToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteServiceAccountToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteServiceAccountToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteServiceAccountToken(rctx, fc.Args["input"].(serviceaccount.DeleteServiceAccountTokenInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.DeleteServiceAccountTokenPayload)
	fc.Result = res
	return ec.marshalNDeleteServiceAccountTokenPayload2githubcomnaisapiinternalserviceaccountDeleteServiceAccountTokenPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteServiceAccountToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "serviceAccount":
				return ec.fieldContext_DeleteServiceAccountTokenPayload_serviceAccount(ctx, field)
			case "serviceAccountTokenDeleted":
				return ec.fieldContext_DeleteServiceAccountTokenPayload_serviceAccountTokenDeleted(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteServiceAccountTokenPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteServiceAccountToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTeam(rctx, fc.Args["input"].(team.CreateTeamInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.CreateTeamPayload)
	fc.Result = res
	return ec.marshalNCreateTeamPayload2githubcomnaisapiinternalteamCreateTeamPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_CreateTeamPayload_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateTeamPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTeam(rctx, fc.Args["input"].(team.UpdateTeamInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.UpdateTeamPayload)
	fc.Result = res
	return ec.marshalNUpdateTeamPayload2githubcomnaisapiinternalteamUpdateTeamPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_UpdateTeamPayload_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTeamPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTeamEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTeamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTeamEnvironment(rctx, fc.Args["input"].(team.UpdateTeamEnvironmentInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.UpdateTeamEnvironmentPayload)
	fc.Result = res
	return ec.marshalNUpdateTeamEnvironmentPayload2githubcomnaisapiinternalteamUpdateTeamEnvironmentPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTeamEnvironment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "environment":
				return ec.fieldContext_UpdateTeamEnvironmentPayload_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_UpdateTeamEnvironmentPayload_teamEnvironment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTeamEnvironmentPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTeamEnvironment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestTeamDeletion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestTeamDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RequestTeamDeletion(rctx, fc.Args["input"].(team.RequestTeamDeletionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.RequestTeamDeletionPayload)
	fc.Result = res
	return ec.marshalNRequestTeamDeletionPayload2githubcomnaisapiinternalteamRequestTeamDeletionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestTeamDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_RequestTeamDeletionPayload_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RequestTeamDeletionPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestTeamDeletion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_confirmTeamDeletion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_confirmTeamDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmTeamDeletion(rctx, fc.Args["input"].(team.ConfirmTeamDeletionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.ConfirmTeamDeletionPayload)
	fc.Result = res
	return ec.marshalNConfirmTeamDeletionPayload2githubcomnaisapiinternalteamConfirmTeamDeletionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_confirmTeamDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletionStarted":
				return ec.fieldContext_ConfirmTeamDeletionPayload_deletionStarted(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfirmTeamDeletionPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_confirmTeamDeletion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addTeamMember(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addTeamMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddTeamMember(rctx, fc.Args["input"].(team.AddTeamMemberInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.AddTeamMemberPayload)
	fc.Result = res
	return ec.marshalNAddTeamMemberPayload2githubcomnaisapiinternalteamAddTeamMemberPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addTeamMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "member":
				return ec.fieldContext_AddTeamMemberPayload_member(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AddTeamMemberPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addTeamMember_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeTeamMember(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeTeamMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveTeamMember(rctx, fc.Args["input"].(team.RemoveTeamMemberInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.RemoveTeamMemberPayload)
	fc.Result = res
	return ec.marshalNRemoveTeamMemberPayload2githubcomnaisapiinternalteamRemoveTeamMemberPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeTeamMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_RemoveTeamMemberPayload_user(ctx, field)
			case "team":
				return ec.fieldContext_RemoveTeamMemberPayload_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RemoveTeamMemberPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeTeamMember_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setTeamMemberRole(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setTeamMemberRole(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetTeamMemberRole(rctx, fc.Args["input"].(team.SetTeamMemberRoleInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.SetTeamMemberRolePayload)
	fc.Result = res
	return ec.marshalNSetTeamMemberRolePayload2githubcomnaisapiinternalteamSetTeamMemberRolePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setTeamMemberRole(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "member":
				return ec.fieldContext_SetTeamMemberRolePayload_member(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetTeamMemberRolePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setTeamMemberRole_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUnleashForTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUnleashForTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUnleashForTeam(rctx, fc.Args["input"].(unleash.CreateUnleashForTeamInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*unleash.CreateUnleashForTeamPayload)
	fc.Result = res
	return ec.marshalNCreateUnleashForTeamPayload2githubcomnaisapiinternalunleashCreateUnleashForTeamPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUnleashForTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "unleash":
				return ec.fieldContext_CreateUnleashForTeamPayload_unleash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateUnleashForTeamPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUnleashForTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_allowTeamAccessToUnleash(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_allowTeamAccessToUnleash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AllowTeamAccessToUnleash(rctx, fc.Args["input"].(unleash.AllowTeamAccessToUnleashInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*unleash.AllowTeamAccessToUnleashPayload)
	fc.Result = res
	return ec.marshalNAllowTeamAccessToUnleashPayload2githubcomnaisapiinternalunleashAllowTeamAccessToUnleashPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_allowTeamAccessToUnleash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "unleash":
				return ec.fieldContext_AllowTeamAccessToUnleashPayload_unleash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AllowTeamAccessToUnleashPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_allowTeamAccessToUnleash_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_revokeTeamAccessToUnleash(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_revokeTeamAccessToUnleash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RevokeTeamAccessToUnleash(rctx, fc.Args["input"].(unleash.RevokeTeamAccessToUnleashInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*unleash.RevokeTeamAccessToUnleashPayload)
	fc.Result = res
	return ec.marshalNRevokeTeamAccessToUnleashPayload2githubcomnaisapiinternalunleashRevokeTeamAccessToUnleashPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_revokeTeamAccessToUnleash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "unleash":
				return ec.fieldContext_RevokeTeamAccessToUnleashPayload_unleash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RevokeTeamAccessToUnleashPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_revokeTeamAccessToUnleash_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateImageVulnerability(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateImageVulnerability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateImageVulnerability(rctx, fc.Args["input"].(vulnerability.UpdateImageVulnerabilityInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*vulnerability.UpdateImageVulnerabilityPayload)
	fc.Result = res
	return ec.marshalNUpdateImageVulnerabilityPayload2githubcomnaisapiinternalvulnerabilityUpdateImageVulnerabilityPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateImageVulnerability(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "vulnerability":
				return ec.fieldContext_UpdateImageVulnerabilityPayload_vulnerability(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateImageVulnerabilityPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateImageVulnerability_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicy_inbound(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicy_inbound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inbound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*netpol.InboundNetworkPolicy)
	fc.Result = res
	return ec.marshalNInboundNetworkPolicy2githubcomnaisapiinternalworkloadnetpolInboundNetworkPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicy_inbound(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rules":
				return ec.fieldContext_InboundNetworkPolicy_rules(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InboundNetworkPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicy_outbound(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicy_outbound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Outbound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*netpol.OutboundNetworkPolicy)
	fc.Result = res
	return ec.marshalNOutboundNetworkPolicy2githubcomnaisapiinternalworkloadnetpolOutboundNetworkPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicy_outbound(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rules":
				return ec.fieldContext_OutboundNetworkPolicy_rules(ctx, field)
			case "external":
				return ec.fieldContext_OutboundNetworkPolicy_external(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OutboundNetworkPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicyRule_targetWorkloadName(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicyRule_targetWorkloadName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetWorkloadName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicyRule_targetWorkloadName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicyRule_targetWorkload(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicyRule_targetWorkload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.NetworkPolicyRule().TargetWorkload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicyRule_targetWorkload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicyRule",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicyRule_targetTeamSlug(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicyRule_targetTeamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetTeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicyRule_targetTeamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicyRule_targetTeam(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicyRule_targetTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.NetworkPolicyRule().TargetTeam(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicyRule_targetTeam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicyRule",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkPolicyRule_mutual(ctx context.Context, field graphql.CollectedField, obj *netpol.NetworkPolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkPolicyRule_mutual(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.NetworkPolicyRule().Mutual(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkPolicyRule_mutual(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkPolicyRule",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_id(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_name(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_team(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearch().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_environment(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearch().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearch().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_status(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearchStatus)
	fc.Result = res
	return ec.marshalNOpenSearchStatus2githubcomnaisapiinternalpersistenceopensearchOpenSearchStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_OpenSearchStatus_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_workload(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearch().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_access(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearch().Access(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*opensearch.OpenSearchAccessOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*opensearch.OpenSearchAccess])
	fc.Result = res
	return ec.marshalNOpenSearchAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_access(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_OpenSearchAccessConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_OpenSearchAccessConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_OpenSearchAccessConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchAccessConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_OpenSearch_access_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearch_cost(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearch_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearch().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.OpenSearchCost)
	fc.Result = res
	return ec.marshalNOpenSearchCost2githubcomnaisapiinternalcostOpenSearchCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearch_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_OpenSearchCost_sum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccess_workload(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearchAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccess_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OpenSearchAccess().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccess_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccess",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccess_access(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearchAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccess_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccess_access(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccessConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearchAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccessConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccessConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccessConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearchAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccessConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*opensearch.OpenSearchAccess)
	fc.Result = res
	return ec.marshalNOpenSearchAccess2githubcomnaisapiinternalpersistenceopensearchOpenSearchAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccessConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccessConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_OpenSearchAccess_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearchAccess_access(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccessConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearchAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccessConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*opensearch.OpenSearchAccess])
	fc.Result = res
	return ec.marshalNOpenSearchAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccessConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_OpenSearchAccessEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_OpenSearchAccessEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchAccessEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccessEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*opensearch.OpenSearchAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccessEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccessEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchAccessEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*opensearch.OpenSearchAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchAccessEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearchAccess)
	fc.Result = res
	return ec.marshalNOpenSearchAccess2githubcomnaisapiinternalpersistenceopensearchOpenSearchAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchAccessEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_OpenSearchAccess_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearchAccess_access(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearch]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearch]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*opensearch.OpenSearch)
	fc.Result = res
	return ec.marshalNOpenSearch2githubcomnaisapiinternalpersistenceopensearchOpenSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_OpenSearch_teamEnvironment(ctx, field)
			case "status":
				return ec.fieldContext_OpenSearch_status(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*opensearch.OpenSearch]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*opensearch.OpenSearch])
	fc.Result = res
	return ec.marshalNOpenSearchEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_OpenSearchEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_OpenSearchEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchCost_sum(ctx context.Context, field graphql.CollectedField, obj *cost.OpenSearchCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchCost_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchCost_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchCost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*opensearch.OpenSearch]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*opensearch.OpenSearch]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearch)
	fc.Result = res
	return ec.marshalNOpenSearch2githubcomnaisapiinternalpersistenceopensearchOpenSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_OpenSearch_teamEnvironment(ctx, field)
			case "status":
				return ec.fieldContext_OpenSearch_status(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSearchStatus_state(ctx context.Context, field graphql.CollectedField, obj *opensearch.OpenSearchStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSearchStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSearchStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSearchStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OutboundNetworkPolicy_rules(ctx context.Context, field graphql.CollectedField, obj *netpol.OutboundNetworkPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OutboundNetworkPolicy_rules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*netpol.NetworkPolicyRule)
	fc.Result = res
	return ec.marshalNNetworkPolicyRule2githubcomnaisapiinternalworkloadnetpolNetworkPolicyRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OutboundNetworkPolicy_rules(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OutboundNetworkPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "targetWorkloadName":
				return ec.fieldContext_NetworkPolicyRule_targetWorkloadName(ctx, field)
			case "targetWorkload":
				return ec.fieldContext_NetworkPolicyRule_targetWorkload(ctx, field)
			case "targetTeamSlug":
				return ec.fieldContext_NetworkPolicyRule_targetTeamSlug(ctx, field)
			case "targetTeam":
				return ec.fieldContext_NetworkPolicyRule_targetTeam(ctx, field)
			case "mutual":
				return ec.fieldContext_NetworkPolicyRule_mutual(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkPolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OutboundNetworkPolicy_external(ctx context.Context, field graphql.CollectedField, obj *netpol.OutboundNetworkPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OutboundNetworkPolicy_external(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.External, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]netpol.ExternalNetworkPolicyTarget)
	fc.Result = res
	return ec.marshalNExternalNetworkPolicyTarget2githubcomnaisapiinternalworkloadnetpolExternalNetworkPolicyTarget(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OutboundNetworkPolicy_external(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OutboundNetworkPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*pagination.Cursor)
	fc.Result = res
	return ec.marshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*pagination.Cursor)
	fc.Result = res
	return ec.marshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_totalCount(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_pageStart(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_pageStart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageStart(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_pageStart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_pageEnd(ctx context.Context, field graphql.CollectedField, obj *pagination.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_pageEnd(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageEnd(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_pageEnd(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(ident.Ident))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Node)
	fc.Result = res
	return ec.marshalONode2githubcomnaisapiinternalgraphmodelNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_roles(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Roles(rctx, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*authz.Role])
	fc.Result = res
	return ec.marshalNRoleConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_roles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_RoleConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RoleConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RoleConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoleConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_roles_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_environments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Environments(rctx, fc.Args["orderBy"].(*environment.EnvironmentOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*environment.Environment])
	fc.Result = res
	return ec.marshalNEnvironmentConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_environments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_EnvironmentConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_EnvironmentConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_EnvironmentConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EnvironmentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_environments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_environment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Environment(rctx, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*environment.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomnaisapiinternalenvironmentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "workloads":
				return ec.fieldContext_Environment_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_environment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_features(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_features(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Features(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*feature.Features)
	fc.Result = res
	return ec.marshalNFeatures2githubcomnaisapiinternalfeatureFeatures(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_features(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Features_id(ctx, field)
			case "unleash":
				return ec.fieldContext_Features_unleash(ctx, field)
			case "redis":
				return ec.fieldContext_Features_redis(ctx, field)
			case "valkey":
				return ec.fieldContext_Features_valkey(ctx, field)
			case "kafka":
				return ec.fieldContext_Features_kafka(ctx, field)
			case "openSearch":
				return ec.fieldContext_Features_openSearch(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Features", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_reconcilers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_reconcilers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Reconcilers(rctx, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*reconciler.Reconciler])
	fc.Result = res
	return ec.marshalNReconcilerConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_reconcilers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ReconcilerConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ReconcilerConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ReconcilerConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconcilerConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_reconcilers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_search(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_search(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Search(rctx, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["filter"].(search.SearchFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[search.SearchNode])
	fc.Result = res
	return ec.marshalNSearchNodeConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_search(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SearchNodeConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SearchNodeConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SearchNodeConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchNodeConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_search_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_serviceAccounts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_serviceAccounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceAccounts(rctx, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*serviceaccount.ServiceAccount])
	fc.Result = res
	return ec.marshalNServiceAccountConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_serviceAccounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_ServiceAccountConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ServiceAccountConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ServiceAccountConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_serviceAccounts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_serviceAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_serviceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceAccount(rctx, fc.Args["id"].(ident.Ident))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccount)
	fc.Result = res
	return ec.marshalNServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_serviceAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccount_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccount_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccount_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccount_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccount_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccount_lastUsedAt(ctx, field)
			case "team":
				return ec.fieldContext_ServiceAccount_team(ctx, field)
			case "roles":
				return ec.fieldContext_ServiceAccount_roles(ctx, field)
			case "tokens":
				return ec.fieldContext_ServiceAccount_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_serviceAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_teams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_teams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Teams(rctx, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*team.TeamOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*team.Team])
	fc.Result = res
	return ec.marshalNTeamConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_teams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_TeamConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_TeamConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_TeamConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_teams_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_team(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Team(rctx, fc.Args["slug"].(slug.Slug))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_team(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_team_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*user.UserOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*user.User])
	fc.Result = res
	return ec.marshalNUserConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_UserConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_UserConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_UserConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_users_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, fc.Args["email"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalNUser2githubcomnaisapiinternaluserUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Me(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(authz.AuthenticatedUser)
	fc.Result = res
	return ec.marshalNAuthenticatedUser2githubcomnaisapiinternalauthauthzAuthenticatedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuthenticatedUser does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_userSyncLog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userSyncLog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserSyncLog(rctx, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[usersync.UserSyncLogEntry])
	fc.Result = res
	return ec.marshalNUserSyncLogEntryConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userSyncLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_UserSyncLogEntryConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_UserSyncLogEntryConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_UserSyncLogEntryConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSyncLogEntryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userSyncLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_teamsUtilization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_teamsUtilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TeamsUtilization(rctx, fc.Args["resourceType"].(utilization.UtilizationResourceType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*utilization.TeamUtilizationData)
	fc.Result = res
	return ec.marshalNTeamUtilizationData2githubcomnaisapiinternalutilizationTeamUtilizationData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_teamsUtilization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamUtilizationData_team(ctx, field)
			case "requested":
				return ec.fieldContext_TeamUtilizationData_requested(ctx, field)
			case "used":
				return ec.fieldContext_TeamUtilizationData_used(ctx, field)
			case "environment":
				return ec.fieldContext_TeamUtilizationData_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_TeamUtilizationData_teamEnvironment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamUtilizationData", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_teamsUtilization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_id(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_name(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_displayName(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_description(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_enabled(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_config(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Reconciler().Config(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*reconciler.ReconcilerConfig)
	fc.Result = res
	return ec.marshalNReconcilerConfig2githubcomnaisapiinternalreconcilerReconcilerConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_config(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ReconcilerConfig_key(ctx, field)
			case "displayName":
				return ec.fieldContext_ReconcilerConfig_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ReconcilerConfig_description(ctx, field)
			case "configured":
				return ec.fieldContext_ReconcilerConfig_configured(ctx, field)
			case "secret":
				return ec.fieldContext_ReconcilerConfig_secret(ctx, field)
			case "value":
				return ec.fieldContext_ReconcilerConfig_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconcilerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_configured(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_configured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Reconciler().Configured(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_configured(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_errors(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Reconciler().Errors(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*reconciler.ReconcilerError])
	fc.Result = res
	return ec.marshalNReconcilerErrorConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ReconcilerErrorConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ReconcilerErrorConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ReconcilerErrorConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconcilerErrorConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Reconciler_errors_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Reconciler_activityLog(ctx context.Context, field graphql.CollectedField, obj *reconciler.Reconciler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Reconciler_activityLog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Reconciler().ActivityLog(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[activitylog.ActivityLogEntry])
	fc.Result = res
	return ec.marshalNActivityLogEntryConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Reconciler_activityLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Reconciler",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ActivityLogEntryConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ActivityLogEntryConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ActivityLogEntryConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ActivityLogEntryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Reconciler_activityLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_key(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_displayName(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_description(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_configured(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_configured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configured, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_configured(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_secret(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfig_value(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfig_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfig_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfiguredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfiguredActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfiguredActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfiguredActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfiguredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfiguredActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfiguredActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfiguredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfiguredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfiguredActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfiguredActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfiguredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfiguredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfiguredActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfiguredActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfiguredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfiguredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfiguredActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfiguredActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfiguredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfiguredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfiguredActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfiguredActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfiguredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfiguredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfiguredActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfiguredActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfiguredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfiguredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfiguredActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfiguredActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfiguredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfiguredActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfiguredActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*reconciler.ReconcilerConfiguredActivityLogEntryData)
	fc.Result = res
	return ec.marshalNReconcilerConfiguredActivityLogEntryData2githubcomnaisapiinternalreconcilerReconcilerConfiguredActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfiguredActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfiguredActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updatedKeys":
				return ec.fieldContext_ReconcilerConfiguredActivityLogEntryData_updatedKeys(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconcilerConfiguredActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntryData_updatedKeys(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerConfiguredActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConfiguredActivityLogEntryData_updatedKeys(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedKeys, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConfiguredActivityLogEntryData_updatedKeys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConfiguredActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*reconciler.Reconciler]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*reconciler.Reconciler]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*reconciler.Reconciler)
	fc.Result = res
	return ec.marshalNReconciler2githubcomnaisapiinternalreconcilerReconciler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Reconciler_id(ctx, field)
			case "name":
				return ec.fieldContext_Reconciler_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Reconciler_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Reconciler_description(ctx, field)
			case "enabled":
				return ec.fieldContext_Reconciler_enabled(ctx, field)
			case "config":
				return ec.fieldContext_Reconciler_config(ctx, field)
			case "configured":
				return ec.fieldContext_Reconciler_configured(ctx, field)
			case "errors":
				return ec.fieldContext_Reconciler_errors(ctx, field)
			case "activityLog":
				return ec.fieldContext_Reconciler_activityLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Reconciler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*reconciler.Reconciler]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*reconciler.Reconciler])
	fc.Result = res
	return ec.marshalNReconcilerEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ReconcilerEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ReconcilerEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconcilerEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerDisabledActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerDisabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerDisabledActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerDisabledActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerDisabledActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerDisabledActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerDisabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerDisabledActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerDisabledActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerDisabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerDisabledActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerDisabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerDisabledActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerDisabledActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerDisabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerDisabledActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerDisabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerDisabledActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerDisabledActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerDisabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerDisabledActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerDisabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerDisabledActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerDisabledActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerDisabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerDisabledActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerDisabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerDisabledActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerDisabledActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerDisabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerDisabledActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerDisabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerDisabledActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerDisabledActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerDisabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerDisabledActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerDisabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerDisabledActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerDisabledActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerDisabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*reconciler.Reconciler]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*reconciler.Reconciler]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*reconciler.Reconciler)
	fc.Result = res
	return ec.marshalNReconciler2githubcomnaisapiinternalreconcilerReconciler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Reconciler_id(ctx, field)
			case "name":
				return ec.fieldContext_Reconciler_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Reconciler_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Reconciler_description(ctx, field)
			case "enabled":
				return ec.fieldContext_Reconciler_enabled(ctx, field)
			case "config":
				return ec.fieldContext_Reconciler_config(ctx, field)
			case "configured":
				return ec.fieldContext_Reconciler_configured(ctx, field)
			case "errors":
				return ec.fieldContext_Reconciler_errors(ctx, field)
			case "activityLog":
				return ec.fieldContext_Reconciler_activityLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Reconciler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEnabledActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerEnabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEnabledActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEnabledActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEnabledActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEnabledActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerEnabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEnabledActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEnabledActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEnabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEnabledActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerEnabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEnabledActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEnabledActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEnabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEnabledActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerEnabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEnabledActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEnabledActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEnabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEnabledActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerEnabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEnabledActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEnabledActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEnabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEnabledActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerEnabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEnabledActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEnabledActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEnabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEnabledActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerEnabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEnabledActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEnabledActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEnabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerEnabledActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerEnabledActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerEnabledActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerEnabledActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerEnabledActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerError_id(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerError_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerError_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerError",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerError_correlationID(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerError_correlationID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CorrelationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerError_correlationID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerError_createdAt(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerError_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerError_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerError_message(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerError_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerError_team(ctx context.Context, field graphql.CollectedField, obj *reconciler.ReconcilerError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerError_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ReconcilerError().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerError_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerError",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerErrorConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*reconciler.ReconcilerError]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerErrorConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerErrorConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerErrorConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerErrorConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*reconciler.ReconcilerError]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerErrorConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*reconciler.ReconcilerError)
	fc.Result = res
	return ec.marshalNReconcilerError2githubcomnaisapiinternalreconcilerReconcilerError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerErrorConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerErrorConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ReconcilerError_id(ctx, field)
			case "correlationID":
				return ec.fieldContext_ReconcilerError_correlationID(ctx, field)
			case "createdAt":
				return ec.fieldContext_ReconcilerError_createdAt(ctx, field)
			case "message":
				return ec.fieldContext_ReconcilerError_message(ctx, field)
			case "team":
				return ec.fieldContext_ReconcilerError_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconcilerError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerErrorConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*reconciler.ReconcilerError]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerErrorConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*reconciler.ReconcilerError])
	fc.Result = res
	return ec.marshalNReconcilerErrorEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerErrorConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerErrorConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ReconcilerErrorEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ReconcilerErrorEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconcilerErrorEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerErrorEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*reconciler.ReconcilerError]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerErrorEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerErrorEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerErrorEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconcilerErrorEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*reconciler.ReconcilerError]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconcilerErrorEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*reconciler.ReconcilerError)
	fc.Result = res
	return ec.marshalNReconcilerError2githubcomnaisapiinternalreconcilerReconcilerError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconcilerErrorEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconcilerErrorEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ReconcilerError_id(ctx, field)
			case "correlationID":
				return ec.fieldContext_ReconcilerError_correlationID(ctx, field)
			case "createdAt":
				return ec.fieldContext_ReconcilerError_createdAt(ctx, field)
			case "message":
				return ec.fieldContext_ReconcilerError_message(ctx, field)
			case "team":
				return ec.fieldContext_ReconcilerError_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconcilerError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_id(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_name(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_team(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstance().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_environment(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstance().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstance().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_access(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstance().Access(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*redis.RedisInstanceAccessOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*redis.RedisInstanceAccess])
	fc.Result = res
	return ec.marshalNRedisInstanceAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_access(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_RedisInstanceAccessConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_RedisInstanceAccessConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RedisInstanceAccessConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceAccessConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RedisInstance_access_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_workload(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstance().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_status(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*redis.RedisInstanceStatus)
	fc.Result = res
	return ec.marshalNRedisInstanceStatus2githubcomnaisapiinternalpersistenceredisRedisInstanceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_RedisInstanceStatus_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstance_cost(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstance_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstance().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.RedisInstanceCost)
	fc.Result = res
	return ec.marshalNRedisInstanceCost2githubcomnaisapiinternalcostRedisInstanceCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstance_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_RedisInstanceCost_sum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccess_workload(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstanceAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccess_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RedisInstanceAccess().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccess_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccess",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccess_access(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstanceAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccess_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccess_access(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccessConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccessConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccessConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccessConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccessConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*redis.RedisInstanceAccess)
	fc.Result = res
	return ec.marshalNRedisInstanceAccess2githubcomnaisapiinternalpersistenceredisRedisInstanceAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccessConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccessConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_RedisInstanceAccess_workload(ctx, field)
			case "access":
				return ec.fieldContext_RedisInstanceAccess_access(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccessConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccessConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*redis.RedisInstanceAccess])
	fc.Result = res
	return ec.marshalNRedisInstanceAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccessConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_RedisInstanceAccessEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_RedisInstanceAccessEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceAccessEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccessEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*redis.RedisInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccessEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccessEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceAccessEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*redis.RedisInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceAccessEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*redis.RedisInstanceAccess)
	fc.Result = res
	return ec.marshalNRedisInstanceAccess2githubcomnaisapiinternalpersistenceredisRedisInstanceAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceAccessEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_RedisInstanceAccess_workload(ctx, field)
			case "access":
				return ec.fieldContext_RedisInstanceAccess_access(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*redis.RedisInstance)
	fc.Result = res
	return ec.marshalNRedisInstance2githubcomnaisapiinternalpersistenceredisRedisInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RedisInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_RedisInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_RedisInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_RedisInstance_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_RedisInstance_teamEnvironment(ctx, field)
			case "access":
				return ec.fieldContext_RedisInstance_access(ctx, field)
			case "workload":
				return ec.fieldContext_RedisInstance_workload(ctx, field)
			case "status":
				return ec.fieldContext_RedisInstance_status(ctx, field)
			case "cost":
				return ec.fieldContext_RedisInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*redis.RedisInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*redis.RedisInstance])
	fc.Result = res
	return ec.marshalNRedisInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_RedisInstanceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_RedisInstanceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceCost_sum(ctx context.Context, field graphql.CollectedField, obj *cost.RedisInstanceCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceCost_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceCost_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceCost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*redis.RedisInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*redis.RedisInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*redis.RedisInstance)
	fc.Result = res
	return ec.marshalNRedisInstance2githubcomnaisapiinternalpersistenceredisRedisInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RedisInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_RedisInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_RedisInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_RedisInstance_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_RedisInstance_teamEnvironment(ctx, field)
			case "access":
				return ec.fieldContext_RedisInstance_access(ctx, field)
			case "workload":
				return ec.fieldContext_RedisInstance_workload(ctx, field)
			case "status":
				return ec.fieldContext_RedisInstance_status(ctx, field)
			case "cost":
				return ec.fieldContext_RedisInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RedisInstanceStatus_state(ctx context.Context, field graphql.CollectedField, obj *redis.RedisInstanceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RedisInstanceStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RedisInstanceStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RedisInstanceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveRepositoryFromTeamPayload_success(ctx context.Context, field graphql.CollectedField, obj *repository.RemoveRepositoryFromTeamPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveRepositoryFromTeamPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveRepositoryFromTeamPayload_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveRepositoryFromTeamPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveSecretValuePayload_secret(ctx context.Context, field graphql.CollectedField, obj *secret.RemoveSecretValuePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveSecretValuePayload_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*secret.Secret)
	fc.Result = res
	return ec.marshalOSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveSecretValuePayload_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveSecretValuePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Secret_id(ctx, field)
			case "name":
				return ec.fieldContext_Secret_name(ctx, field)
			case "environment":
				return ec.fieldContext_Secret_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Secret_teamEnvironment(ctx, field)
			case "team":
				return ec.fieldContext_Secret_team(ctx, field)
			case "values":
				return ec.fieldContext_Secret_values(ctx, field)
			case "applications":
				return ec.fieldContext_Secret_applications(ctx, field)
			case "jobs":
				return ec.fieldContext_Secret_jobs(ctx, field)
			case "workloads":
				return ec.fieldContext_Secret_workloads(ctx, field)
			case "lastModifiedAt":
				return ec.fieldContext_Secret_lastModifiedAt(ctx, field)
			case "lastModifiedBy":
				return ec.fieldContext_Secret_lastModifiedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Secret", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveTeamMemberPayload_user(ctx context.Context, field graphql.CollectedField, obj *team.RemoveTeamMemberPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveTeamMemberPayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RemoveTeamMemberPayload().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalOUser2githubcomnaisapiinternaluserUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveTeamMemberPayload_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveTeamMemberPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveTeamMemberPayload_team(ctx context.Context, field graphql.CollectedField, obj *team.RemoveTeamMemberPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveTeamMemberPayload_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RemoveTeamMemberPayload().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveTeamMemberPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveTeamMemberPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_id(ctx context.Context, field graphql.CollectedField, obj *repository.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_name(ctx context.Context, field graphql.CollectedField, obj *repository.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_team(ctx context.Context, field graphql.CollectedField, obj *repository.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryAddedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryAddedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryAddedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryAddedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryAddedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryAddedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryAddedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryAddedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryAddedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryAddedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryAddedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryAddedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryAddedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryAddedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryAddedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryAddedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryAddedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryAddedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryAddedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryAddedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryAddedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryAddedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryAddedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryAddedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryAddedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*repository.Repository]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*repository.Repository]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*repository.Repository)
	fc.Result = res
	return ec.marshalNRepository2githubcomnaisapiinternalgithubrepositoryRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "team":
				return ec.fieldContext_Repository_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*repository.Repository]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*repository.Repository])
	fc.Result = res
	return ec.marshalNRepositoryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_RepositoryEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_RepositoryEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*repository.Repository]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*repository.Repository]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*repository.Repository)
	fc.Result = res
	return ec.marshalNRepository2githubcomnaisapiinternalgithubrepositoryRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "team":
				return ec.fieldContext_Repository_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryRemovedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryRemovedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryRemovedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryRemovedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryRemovedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryRemovedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryRemovedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryRemovedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryRemovedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryRemovedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryRemovedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryRemovedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryRemovedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryRemovedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryRemovedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryRemovedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryRemovedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryRemovedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryRemovedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryRemovedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryRemovedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryRemovedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *repository.RepositoryRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryRemovedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryRemovedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RequestTeamDeletionPayload_key(ctx context.Context, field graphql.CollectedField, obj *team.RequestTeamDeletionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RequestTeamDeletionPayload_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamDeleteKey)
	fc.Result = res
	return ec.marshalOTeamDeleteKey2githubcomnaisapiinternalteamTeamDeleteKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RequestTeamDeletionPayload_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RequestTeamDeletionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_TeamDeleteKey_key(ctx, field)
			case "createdAt":
				return ec.fieldContext_TeamDeleteKey_createdAt(ctx, field)
			case "expires":
				return ec.fieldContext_TeamDeleteKey_expires(ctx, field)
			case "createdBy":
				return ec.fieldContext_TeamDeleteKey_createdBy(ctx, field)
			case "team":
				return ec.fieldContext_TeamDeleteKey_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamDeleteKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RestartApplicationPayload_application(ctx context.Context, field graphql.CollectedField, obj *application.RestartApplicationPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RestartApplicationPayload_application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RestartApplicationPayload().Application(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*application.Application)
	fc.Result = res
	return ec.marshalOApplication2githubcomnaisapiinternalworkloadapplicationApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RestartApplicationPayload_application(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RestartApplicationPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Application_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "instances":
				return ec.fieldContext_Application_instances(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Application_deletionStartedAt(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Application_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Application_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Application_redisInstances(ctx, field)
			case "secrets":
				return ec.fieldContext_Application_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Application_valkeyInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RevokeRoleFromServiceAccountPayload_serviceAccount(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RevokeRoleFromServiceAccountPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RevokeRoleFromServiceAccountPayload_serviceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccount)
	fc.Result = res
	return ec.marshalOServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RevokeRoleFromServiceAccountPayload_serviceAccount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RevokeRoleFromServiceAccountPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccount_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccount_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccount_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccount_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccount_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccount_lastUsedAt(ctx, field)
			case "team":
				return ec.fieldContext_ServiceAccount_team(ctx, field)
			case "roles":
				return ec.fieldContext_ServiceAccount_roles(ctx, field)
			case "tokens":
				return ec.fieldContext_ServiceAccount_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RevokeTeamAccessToUnleashPayload_unleash(ctx context.Context, field graphql.CollectedField, obj *unleash.RevokeTeamAccessToUnleashPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RevokeTeamAccessToUnleashPayload_unleash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unleash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*unleash.UnleashInstance)
	fc.Result = res
	return ec.marshalOUnleashInstance2githubcomnaisapiinternalunleashUnleashInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RevokeTeamAccessToUnleashPayload_unleash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RevokeTeamAccessToUnleashPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UnleashInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_UnleashInstance_name(ctx, field)
			case "version":
				return ec.fieldContext_UnleashInstance_version(ctx, field)
			case "allowedTeams":
				return ec.fieldContext_UnleashInstance_allowedTeams(ctx, field)
			case "webIngress":
				return ec.fieldContext_UnleashInstance_webIngress(ctx, field)
			case "apiIngress":
				return ec.fieldContext_UnleashInstance_apiIngress(ctx, field)
			case "metrics":
				return ec.fieldContext_UnleashInstance_metrics(ctx, field)
			case "ready":
				return ec.fieldContext_UnleashInstance_ready(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UnleashInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Role_id(ctx context.Context, field graphql.CollectedField, obj *authz.Role) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Role_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Role_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Role",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Role_name(ctx context.Context, field graphql.CollectedField, obj *authz.Role) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Role_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Role_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Role",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Role_description(ctx context.Context, field graphql.CollectedField, obj *authz.Role) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Role_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Role_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Role",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedToServiceAccountActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedToServiceAccountActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedToServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedToServiceAccountActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedToServiceAccountActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedToServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedToServiceAccountActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedToServiceAccountActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedToServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedToServiceAccountActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedToServiceAccountActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedToServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedToServiceAccountActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedToServiceAccountActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedToServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedToServiceAccountActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedToServiceAccountActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedToServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedToServiceAccountActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalOSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedToServiceAccountActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedToServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedToServiceAccountActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedToServiceAccountActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedToServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedToServiceAccountActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.RoleAssignedToServiceAccountActivityLogEntryData)
	fc.Result = res
	return ec.marshalNRoleAssignedToServiceAccountActivityLogEntryData2githubcomnaisapiinternalserviceaccountRoleAssignedToServiceAccountActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedToServiceAccountActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedToServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "roleName":
				return ec.fieldContext_RoleAssignedToServiceAccountActivityLogEntryData_roleName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoleAssignedToServiceAccountActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntryData_roleName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedToServiceAccountActivityLogEntryData_roleName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoleName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedToServiceAccountActivityLogEntryData_roleName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedToServiceAccountActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedUserSyncLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleAssignedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedUserSyncLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedUserSyncLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedUserSyncLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedUserSyncLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleAssignedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedUserSyncLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedUserSyncLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedUserSyncLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleAssignedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedUserSyncLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedUserSyncLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedUserSyncLogEntry_userID(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleAssignedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedUserSyncLogEntry_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedUserSyncLogEntry_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedUserSyncLogEntry_userName(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleAssignedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedUserSyncLogEntry_userName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedUserSyncLogEntry_userName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedUserSyncLogEntry_userEmail(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleAssignedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedUserSyncLogEntry_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedUserSyncLogEntry_userEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleAssignedUserSyncLogEntry_roleName(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleAssignedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleAssignedUserSyncLogEntry_roleName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoleName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleAssignedUserSyncLogEntry_roleName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleAssignedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*authz.Role]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*authz.Role)
	fc.Result = res
	return ec.marshalNRole2githubcomnaisapiinternalauthauthzRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Role_id(ctx, field)
			case "name":
				return ec.fieldContext_Role_name(ctx, field)
			case "description":
				return ec.fieldContext_Role_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Role", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*authz.Role]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*authz.Role])
	fc.Result = res
	return ec.marshalNRoleEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_RoleEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_RoleEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoleEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*authz.Role]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*authz.Role]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*authz.Role)
	fc.Result = res
	return ec.marshalNRole2githubcomnaisapiinternalauthauthzRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Role_id(ctx, field)
			case "name":
				return ec.fieldContext_Role_name(ctx, field)
			case "description":
				return ec.fieldContext_Role_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Role", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*authz.Role]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedFromServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedFromServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedFromServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedFromServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedFromServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedFromServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalOSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedFromServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedFromServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.RoleRevokedFromServiceAccountActivityLogEntryData)
	fc.Result = res
	return ec.marshalNRoleRevokedFromServiceAccountActivityLogEntryData2githubcomnaisapiinternalserviceaccountRoleRevokedFromServiceAccountActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedFromServiceAccountActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedFromServiceAccountActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "roleName":
				return ec.fieldContext_RoleRevokedFromServiceAccountActivityLogEntryData_roleName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoleRevokedFromServiceAccountActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntryData_roleName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedFromServiceAccountActivityLogEntryData_roleName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoleName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedFromServiceAccountActivityLogEntryData_roleName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedFromServiceAccountActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedUserSyncLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleRevokedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedUserSyncLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedUserSyncLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedUserSyncLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedUserSyncLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleRevokedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedUserSyncLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedUserSyncLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedUserSyncLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleRevokedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedUserSyncLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedUserSyncLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedUserSyncLogEntry_userID(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleRevokedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedUserSyncLogEntry_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedUserSyncLogEntry_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedUserSyncLogEntry_userName(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleRevokedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedUserSyncLogEntry_userName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedUserSyncLogEntry_userName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedUserSyncLogEntry_userEmail(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleRevokedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedUserSyncLogEntry_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedUserSyncLogEntry_userEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoleRevokedUserSyncLogEntry_roleName(ctx context.Context, field graphql.CollectedField, obj *usersync.RoleRevokedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoleRevokedUserSyncLogEntry_roleName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoleName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoleRevokedUserSyncLogEntry_roleName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoleRevokedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchNodeConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[search.SearchNode]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchNodeConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchNodeConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchNodeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchNodeConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[search.SearchNode]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchNodeConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]search.SearchNode)
	fc.Result = res
	return ec.marshalNSearchNode2githubcomnaisapiinternalsearchSearchNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchNodeConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchNodeConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchNode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchNodeConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[search.SearchNode]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchNodeConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[search.SearchNode])
	fc.Result = res
	return ec.marshalNSearchNodeEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchNodeConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchNodeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_SearchNodeEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_SearchNodeEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchNodeEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchNodeEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[search.SearchNode]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchNodeEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchNodeEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchNodeEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchNodeEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[search.SearchNode]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchNodeEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(search.SearchNode)
	fc.Result = res
	return ec.marshalNSearchNode2githubcomnaisapiinternalsearchSearchNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchNodeEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchNodeEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchNode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_id(ctx context.Context, field graphql.CollectedField, obj *secret.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_name(ctx context.Context, field graphql.CollectedField, obj *secret.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_environment(ctx context.Context, field graphql.CollectedField, obj *secret.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Secret().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *secret.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Secret().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_team(ctx context.Context, field graphql.CollectedField, obj *secret.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Secret().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_values(ctx context.Context, field graphql.CollectedField, obj *secret.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Secret().Values(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*secret.SecretValue)
	fc.Result = res
	return ec.marshalNSecretValue2githubcomnaisapiinternalworkloadsecretSecretValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_values(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SecretValue_name(ctx, field)
			case "value":
				return ec.fieldContext_SecretValue_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_applications(ctx context.Context, field graphql.CollectedField, obj *secret.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_applications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Secret().Applications(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*application.Application])
	fc.Result = res
	return ec.marshalNApplicationConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_applications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ApplicationConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ApplicationConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ApplicationConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Secret_applications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Secret_jobs(ctx context.Context, field graphql.CollectedField, obj *secret.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_jobs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Secret().Jobs(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*job.Job])
	fc.Result = res
	return ec.marshalNJobConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_jobs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_JobConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_JobConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_JobConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Secret_jobs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Secret_workloads(ctx context.Context, field graphql.CollectedField, obj *secret.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_workloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Secret().Workloads(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[workload.Workload])
	fc.Result = res
	return ec.marshalNWorkloadConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_workloads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_WorkloadConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_WorkloadConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_WorkloadConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Secret_workloads_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Secret_lastModifiedAt(ctx context.Context, field graphql.CollectedField, obj *secret.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_lastModifiedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastModifiedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_lastModifiedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Secret_lastModifiedBy(ctx context.Context, field graphql.CollectedField, obj *secret.Secret) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Secret_lastModifiedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Secret().LastModifiedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalOUser2githubcomnaisapiinternaluserUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Secret_lastModifiedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Secret",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*secret.Secret]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*secret.Secret]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*secret.Secret)
	fc.Result = res
	return ec.marshalNSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Secret_id(ctx, field)
			case "name":
				return ec.fieldContext_Secret_name(ctx, field)
			case "environment":
				return ec.fieldContext_Secret_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Secret_teamEnvironment(ctx, field)
			case "team":
				return ec.fieldContext_Secret_team(ctx, field)
			case "values":
				return ec.fieldContext_Secret_values(ctx, field)
			case "applications":
				return ec.fieldContext_Secret_applications(ctx, field)
			case "jobs":
				return ec.fieldContext_Secret_jobs(ctx, field)
			case "workloads":
				return ec.fieldContext_Secret_workloads(ctx, field)
			case "lastModifiedAt":
				return ec.fieldContext_Secret_lastModifiedAt(ctx, field)
			case "lastModifiedBy":
				return ec.fieldContext_Secret_lastModifiedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Secret", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*secret.Secret]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*secret.Secret])
	fc.Result = res
	return ec.marshalNSecretEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_SecretEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_SecretEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretCreatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *secret.SecretCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretCreatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretCreatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretCreatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *secret.SecretCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretCreatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretCreatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretCreatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *secret.SecretCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretCreatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretCreatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretCreatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *secret.SecretCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretCreatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretCreatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretCreatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *secret.SecretCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretCreatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretCreatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretCreatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretCreatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretCreatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretCreatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *secret.SecretCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretCreatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretCreatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretCreatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretCreatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretCreatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretDeletedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *secret.SecretDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretDeletedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretDeletedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretDeletedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *secret.SecretDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretDeletedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretDeletedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretDeletedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *secret.SecretDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretDeletedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretDeletedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretDeletedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *secret.SecretDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretDeletedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretDeletedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretDeletedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *secret.SecretDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretDeletedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretDeletedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretDeletedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretDeletedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretDeletedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretDeletedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *secret.SecretDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretDeletedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretDeletedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretDeletedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretDeletedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretDeletedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*secret.Secret]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*secret.Secret]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*secret.Secret)
	fc.Result = res
	return ec.marshalNSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Secret_id(ctx, field)
			case "name":
				return ec.fieldContext_Secret_name(ctx, field)
			case "environment":
				return ec.fieldContext_Secret_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Secret_teamEnvironment(ctx, field)
			case "team":
				return ec.fieldContext_Secret_team(ctx, field)
			case "values":
				return ec.fieldContext_Secret_values(ctx, field)
			case "applications":
				return ec.fieldContext_Secret_applications(ctx, field)
			case "jobs":
				return ec.fieldContext_Secret_jobs(ctx, field)
			case "workloads":
				return ec.fieldContext_Secret_workloads(ctx, field)
			case "lastModifiedAt":
				return ec.fieldContext_Secret_lastModifiedAt(ctx, field)
			case "lastModifiedBy":
				return ec.fieldContext_Secret_lastModifiedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Secret", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValue_name(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValue_value(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValue_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValue_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueAddedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueAddedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueAddedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueAddedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueAddedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueAddedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueAddedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueAddedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueAddedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueAddedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueAddedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueAddedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueAddedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueAddedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueAddedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueAddedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueAddedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueAddedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueAddedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueAddedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueAddedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueAddedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueAddedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueAddedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueAddedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueAddedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueAddedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*secret.SecretValueAddedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNSecretValueAddedActivityLogEntryData2githubcomnaisapiinternalworkloadsecretSecretValueAddedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueAddedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "valueName":
				return ec.fieldContext_SecretValueAddedActivityLogEntryData_valueName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretValueAddedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueAddedActivityLogEntryData_valueName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueAddedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueAddedActivityLogEntryData_valueName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValueName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueAddedActivityLogEntryData_valueName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueAddedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueRemovedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueRemovedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueRemovedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueRemovedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueRemovedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueRemovedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueRemovedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueRemovedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueRemovedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueRemovedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueRemovedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueRemovedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueRemovedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueRemovedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueRemovedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueRemovedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueRemovedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueRemovedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueRemovedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueRemovedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueRemovedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueRemovedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueRemovedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueRemovedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueRemovedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueRemovedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*secret.SecretValueRemovedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNSecretValueRemovedActivityLogEntryData2githubcomnaisapiinternalworkloadsecretSecretValueRemovedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueRemovedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "valueName":
				return ec.fieldContext_SecretValueRemovedActivityLogEntryData_valueName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretValueRemovedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueRemovedActivityLogEntryData_valueName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueRemovedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueRemovedActivityLogEntryData_valueName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValueName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueRemovedActivityLogEntryData_valueName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueRemovedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueUpdatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueUpdatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueUpdatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueUpdatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueUpdatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueUpdatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueUpdatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueUpdatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueUpdatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueUpdatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueUpdatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueUpdatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueUpdatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueUpdatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueUpdatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueUpdatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueUpdatedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*secret.SecretValueUpdatedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNSecretValueUpdatedActivityLogEntryData2githubcomnaisapiinternalworkloadsecretSecretValueUpdatedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueUpdatedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "valueName":
				return ec.fieldContext_SecretValueUpdatedActivityLogEntryData_valueName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretValueUpdatedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntryData_valueName(ctx context.Context, field graphql.CollectedField, obj *secret.SecretValueUpdatedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SecretValueUpdatedActivityLogEntryData_valueName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValueName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SecretValueUpdatedActivityLogEntryData_valueName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretValueUpdatedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccount_id(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccount_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccount_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccount_name(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccount_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccount_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccount_description(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccount_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccount_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccount_createdAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccount_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccount_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccount_updatedAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccount_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccount_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccount_lastUsedAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccount_lastUsedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceAccount().LastUsedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccount_lastUsedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccount_team(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccount_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceAccount().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccount_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccount_roles(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccount_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceAccount().Roles(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*authz.Role])
	fc.Result = res
	return ec.marshalNRoleConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccount_roles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_RoleConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RoleConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RoleConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoleConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ServiceAccount_roles_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccount_tokens(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccount_tokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceAccount().Tokens(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*serviceaccount.ServiceAccountToken])
	fc.Result = res
	return ec.marshalNServiceAccountTokenConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccount_tokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_ServiceAccountTokenConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ServiceAccountTokenConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ServiceAccountTokenConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountTokenConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ServiceAccount_tokens_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*serviceaccount.ServiceAccount]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*serviceaccount.ServiceAccount)
	fc.Result = res
	return ec.marshalNServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccount_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccount_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccount_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccount_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccount_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccount_lastUsedAt(ctx, field)
			case "team":
				return ec.fieldContext_ServiceAccount_team(ctx, field)
			case "roles":
				return ec.fieldContext_ServiceAccount_roles(ctx, field)
			case "tokens":
				return ec.fieldContext_ServiceAccount_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*serviceaccount.ServiceAccount]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*serviceaccount.ServiceAccount])
	fc.Result = res
	return ec.marshalNServiceAccountEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ServiceAccountEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ServiceAccountEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*serviceaccount.ServiceAccount]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountCreatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountCreatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountCreatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountCreatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountCreatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountCreatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountCreatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountCreatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountCreatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountCreatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountCreatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountCreatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountCreatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountCreatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountCreatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountCreatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountCreatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountCreatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountCreatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountCreatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalOSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountCreatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountCreatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountCreatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountCreatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountDeletedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountDeletedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountDeletedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountDeletedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountDeletedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountDeletedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountDeletedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountDeletedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountDeletedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountDeletedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountDeletedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountDeletedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountDeletedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountDeletedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountDeletedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountDeletedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountDeletedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountDeletedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountDeletedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountDeletedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalOSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountDeletedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountDeletedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountDeletedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountDeletedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*serviceaccount.ServiceAccount]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccount)
	fc.Result = res
	return ec.marshalNServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccount_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccount_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccount_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccount_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccount_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccount_lastUsedAt(ctx, field)
			case "team":
				return ec.fieldContext_ServiceAccount_team(ctx, field)
			case "roles":
				return ec.fieldContext_ServiceAccount_roles(ctx, field)
			case "tokens":
				return ec.fieldContext_ServiceAccount_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*serviceaccount.ServiceAccount]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountToken_id(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountToken_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountToken_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountToken",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountToken_name(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountToken_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountToken_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountToken_description(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountToken_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountToken_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountToken_createdAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountToken_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountToken_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountToken_updatedAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountToken_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountToken_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountToken_lastUsedAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountToken_lastUsedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUsedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountToken_lastUsedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountToken_expiresAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountToken_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*scalar.Date)
	fc.Result = res
	return ec.marshalODate2githubcomnaisapiinternalgraphscalarDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountToken_expiresAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*serviceaccount.ServiceAccountToken]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*serviceaccount.ServiceAccountToken)
	fc.Result = res
	return ec.marshalNServiceAccountToken2githubcomnaisapiinternalserviceaccountServiceAccountToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccountToken_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccountToken_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccountToken_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccountToken_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccountToken_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccountToken_lastUsedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_ServiceAccountToken_expiresAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountToken", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*serviceaccount.ServiceAccountToken]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*serviceaccount.ServiceAccountToken])
	fc.Result = res
	return ec.marshalNServiceAccountTokenEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ServiceAccountTokenEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ServiceAccountTokenEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountTokenEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*serviceaccount.ServiceAccountToken]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenCreatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenCreatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenCreatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenCreatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenCreatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenCreatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenCreatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenCreatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenCreatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenCreatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenCreatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenCreatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenCreatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalOSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenCreatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenCreatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenCreatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenCreatedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccountTokenCreatedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNServiceAccountTokenCreatedActivityLogEntryData2githubcomnaisapiinternalserviceaccountServiceAccountTokenCreatedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenCreatedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tokenName":
				return ec.fieldContext_ServiceAccountTokenCreatedActivityLogEntryData_tokenName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountTokenCreatedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntryData_tokenName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenCreatedActivityLogEntryData_tokenName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenCreatedActivityLogEntryData_tokenName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenCreatedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenDeletedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenDeletedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenDeletedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenDeletedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenDeletedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenDeletedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenDeletedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenDeletedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenDeletedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenDeletedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenDeletedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenDeletedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenDeletedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalOSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenDeletedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenDeletedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenDeletedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenDeletedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccountTokenDeletedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNServiceAccountTokenDeletedActivityLogEntryData2githubcomnaisapiinternalserviceaccountServiceAccountTokenDeletedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenDeletedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenDeletedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tokenName":
				return ec.fieldContext_ServiceAccountTokenDeletedActivityLogEntryData_tokenName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountTokenDeletedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntryData_tokenName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenDeletedActivityLogEntryData_tokenName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenDeletedActivityLogEntryData_tokenName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenDeletedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*serviceaccount.ServiceAccountToken]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccountToken)
	fc.Result = res
	return ec.marshalNServiceAccountToken2githubcomnaisapiinternalserviceaccountServiceAccountToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccountToken_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccountToken_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccountToken_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccountToken_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccountToken_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccountToken_lastUsedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_ServiceAccountToken_expiresAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountToken", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*serviceaccount.ServiceAccountToken]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalOSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccountTokenUpdatedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNServiceAccountTokenUpdatedActivityLogEntryData2githubcomnaisapiinternalserviceaccountServiceAccountTokenUpdatedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updatedFields":
				return ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntryData_updatedFields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountTokenUpdatedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntryData_updatedFields(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntryData_updatedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*serviceaccount.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField)
	fc.Result = res
	return ec.marshalNServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalserviceaccountServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntryData_updatedFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "field":
				return ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_field(ctx, field)
			case "oldValue":
				return ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field)
			case "newValue":
				return ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_field(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_field(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_oldValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_newValue(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_newValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalOSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccountUpdatedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNServiceAccountUpdatedActivityLogEntryData2githubcomnaisapiinternalserviceaccountServiceAccountUpdatedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updatedFields":
				return ec.fieldContext_ServiceAccountUpdatedActivityLogEntryData_updatedFields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountUpdatedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntryData_updatedFields(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntryData_updatedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*serviceaccount.ServiceAccountUpdatedActivityLogEntryDataUpdatedField)
	fc.Result = res
	return ec.marshalNServiceAccountUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalserviceaccountServiceAccountUpdatedActivityLogEntryDataUpdatedField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntryData_updatedFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "field":
				return ec.fieldContext_ServiceAccountUpdatedActivityLogEntryDataUpdatedField_field(ctx, field)
			case "oldValue":
				return ec.fieldContext_ServiceAccountUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field)
			case "newValue":
				return ec.fieldContext_ServiceAccountUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountUpdatedActivityLogEntryDataUpdatedField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntryDataUpdatedField_field(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntryDataUpdatedField_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntryDataUpdatedField_field(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntryDataUpdatedField_oldValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntryDataUpdatedField_newValue(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceAccountUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceAccountUpdatedActivityLogEntryDataUpdatedField_newValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceAccountUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceCostSample_service(ctx context.Context, field graphql.CollectedField, obj *cost.ServiceCostSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceCostSample_service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Service, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceCostSample_service(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceCostSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceCostSample_cost(ctx context.Context, field graphql.CollectedField, obj *cost.ServiceCostSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceCostSample_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceCostSample_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceCostSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceCostSeries_date(ctx context.Context, field graphql.CollectedField, obj *cost.ServiceCostSeries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceCostSeries_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(scalar.Date)
	fc.Result = res
	return ec.marshalNDate2githubcomnaisapiinternalgraphscalarDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceCostSeries_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceCostSeries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceCostSeries_sum(ctx context.Context, field graphql.CollectedField, obj *cost.ServiceCostSeries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceCostSeries_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceCostSeries_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceCostSeries",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceCostSeries_services(ctx context.Context, field graphql.CollectedField, obj *cost.ServiceCostSeries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceCostSeries_services(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Services, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*cost.ServiceCostSample)
	fc.Result = res
	return ec.marshalNServiceCostSample2githubcomnaisapiinternalcostServiceCostSample(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceCostSeries_services(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceCostSeries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "service":
				return ec.fieldContext_ServiceCostSample_service(ctx, field)
			case "cost":
				return ec.fieldContext_ServiceCostSample_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceCostSample", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetTeamMemberRolePayload_member(ctx context.Context, field graphql.CollectedField, obj *team.SetTeamMemberRolePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetTeamMemberRolePayload_member(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Member, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamMember)
	fc.Result = res
	return ec.marshalOTeamMember2githubcomnaisapiinternalteamTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetTeamMemberRolePayload_member(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetTeamMemberRolePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamMember_team(ctx, field)
			case "user":
				return ec.fieldContext_TeamMember_user(ctx, field)
			case "role":
				return ec.fieldContext_TeamMember_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_id(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_name(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_team(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlDatabase().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_environment(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlDatabase().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlDatabase().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_charset(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_charset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Charset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_charset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_collation(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_collation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Collation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_collation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_deletionPolicy(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_deletionPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_deletionPolicy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlDatabase_healthy(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLDatabase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlDatabase_healthy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Healthy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlDatabase_healthy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlDatabase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_id(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_name(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_team(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_environment(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_workload(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_cascadingDelete(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_cascadingDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CascadingDelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_cascadingDelete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_connectionName(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_connectionName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_connectionName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_diskAutoresize(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_diskAutoresize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiskAutoresize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_diskAutoresize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_diskAutoresizeLimit(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_diskAutoresizeLimit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiskAutoresizeLimit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_diskAutoresizeLimit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_highAvailability(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_highAvailability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HighAvailability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_highAvailability(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_healthy(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_healthy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Healthy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_healthy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_maintenanceVersion(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_maintenanceVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaintenanceVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_maintenanceVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_maintenanceWindow(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_maintenanceWindow(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaintenanceWindow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceMaintenanceWindow)
	fc.Result = res
	return ec.marshalOSqlInstanceMaintenanceWindow2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceMaintenanceWindow(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_maintenanceWindow(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "day":
				return ec.fieldContext_SqlInstanceMaintenanceWindow_day(ctx, field)
			case "hour":
				return ec.fieldContext_SqlInstanceMaintenanceWindow_hour(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceMaintenanceWindow", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_backupConfiguration(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_backupConfiguration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackupConfiguration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceBackupConfiguration)
	fc.Result = res
	return ec.marshalOSqlInstanceBackupConfiguration2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceBackupConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_backupConfiguration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_SqlInstanceBackupConfiguration_enabled(ctx, field)
			case "startTime":
				return ec.fieldContext_SqlInstanceBackupConfiguration_startTime(ctx, field)
			case "retainedBackups":
				return ec.fieldContext_SqlInstanceBackupConfiguration_retainedBackups(ctx, field)
			case "pointInTimeRecovery":
				return ec.fieldContext_SqlInstanceBackupConfiguration_pointInTimeRecovery(ctx, field)
			case "transactionLogRetentionDays":
				return ec.fieldContext_SqlInstanceBackupConfiguration_transactionLogRetentionDays(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceBackupConfiguration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_projectID(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_projectID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_projectID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_tier(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_tier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_tier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_version(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_status(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceStatus)
	fc.Result = res
	return ec.marshalNSqlInstanceStatus2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "publicIpAddress":
				return ec.fieldContext_SqlInstanceStatus_publicIpAddress(ctx, field)
			case "privateIpAddress":
				return ec.fieldContext_SqlInstanceStatus_privateIpAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_database(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_database(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Database(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLDatabase)
	fc.Result = res
	return ec.marshalOSqlDatabase2githubcomnaisapiinternalpersistencesqlinstanceSQLDatabase(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_database(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SqlDatabase_id(ctx, field)
			case "name":
				return ec.fieldContext_SqlDatabase_name(ctx, field)
			case "team":
				return ec.fieldContext_SqlDatabase_team(ctx, field)
			case "environment":
				return ec.fieldContext_SqlDatabase_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_SqlDatabase_teamEnvironment(ctx, field)
			case "charset":
				return ec.fieldContext_SqlDatabase_charset(ctx, field)
			case "collation":
				return ec.fieldContext_SqlDatabase_collation(ctx, field)
			case "deletionPolicy":
				return ec.fieldContext_SqlDatabase_deletionPolicy(ctx, field)
			case "healthy":
				return ec.fieldContext_SqlDatabase_healthy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlDatabase", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_flags(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_flags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Flags(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*sqlinstance.SQLInstanceFlag])
	fc.Result = res
	return ec.marshalNSqlInstanceFlagConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_flags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SqlInstanceFlagConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SqlInstanceFlagConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SqlInstanceFlagConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceFlagConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SqlInstance_flags_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_users(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Users(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*sqlinstance.SQLInstanceUserOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*sqlinstance.SQLInstanceUser])
	fc.Result = res
	return ec.marshalNSqlInstanceUserConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SqlInstanceUserConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SqlInstanceUserConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SqlInstanceUserConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceUserConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SqlInstance_users_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_metrics(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_metrics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Metrics(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceMetrics)
	fc.Result = res
	return ec.marshalNSqlInstanceMetrics2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_metrics(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_SqlInstanceMetrics_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_SqlInstanceMetrics_memory(ctx, field)
			case "disk":
				return ec.fieldContext_SqlInstanceMetrics_disk(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_state(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().State(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(sqlinstance.SQLInstanceState)
	fc.Result = res
	return ec.marshalNSqlInstanceState2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SqlInstanceState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstance_cost(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstance_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstance().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.SQLInstanceCost)
	fc.Result = res
	return ec.marshalNSqlInstanceCost2githubcomnaisapiinternalcostSQLInstanceCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstance_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_SqlInstanceCost_sum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceBackupConfiguration_enabled(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceBackupConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceBackupConfiguration_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceBackupConfiguration_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceBackupConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceBackupConfiguration_startTime(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceBackupConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceBackupConfiguration_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceBackupConfiguration_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceBackupConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceBackupConfiguration_retainedBackups(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceBackupConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceBackupConfiguration_retainedBackups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RetainedBackups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceBackupConfiguration_retainedBackups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceBackupConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceBackupConfiguration_pointInTimeRecovery(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceBackupConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceBackupConfiguration_pointInTimeRecovery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PointInTimeRecovery, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceBackupConfiguration_pointInTimeRecovery(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceBackupConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceBackupConfiguration_transactionLogRetentionDays(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceBackupConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceBackupConfiguration_transactionLogRetentionDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionLogRetentionDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceBackupConfiguration_transactionLogRetentionDays(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceBackupConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*sqlinstance.SQLInstance)
	fc.Result = res
	return ec.marshalNSqlInstance2githubcomnaisapiinternalpersistencesqlinstanceSQLInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SqlInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_SqlInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_SqlInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_SqlInstance_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_SqlInstance_teamEnvironment(ctx, field)
			case "workload":
				return ec.fieldContext_SqlInstance_workload(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_SqlInstance_cascadingDelete(ctx, field)
			case "connectionName":
				return ec.fieldContext_SqlInstance_connectionName(ctx, field)
			case "diskAutoresize":
				return ec.fieldContext_SqlInstance_diskAutoresize(ctx, field)
			case "diskAutoresizeLimit":
				return ec.fieldContext_SqlInstance_diskAutoresizeLimit(ctx, field)
			case "highAvailability":
				return ec.fieldContext_SqlInstance_highAvailability(ctx, field)
			case "healthy":
				return ec.fieldContext_SqlInstance_healthy(ctx, field)
			case "maintenanceVersion":
				return ec.fieldContext_SqlInstance_maintenanceVersion(ctx, field)
			case "maintenanceWindow":
				return ec.fieldContext_SqlInstance_maintenanceWindow(ctx, field)
			case "backupConfiguration":
				return ec.fieldContext_SqlInstance_backupConfiguration(ctx, field)
			case "projectID":
				return ec.fieldContext_SqlInstance_projectID(ctx, field)
			case "tier":
				return ec.fieldContext_SqlInstance_tier(ctx, field)
			case "version":
				return ec.fieldContext_SqlInstance_version(ctx, field)
			case "status":
				return ec.fieldContext_SqlInstance_status(ctx, field)
			case "database":
				return ec.fieldContext_SqlInstance_database(ctx, field)
			case "flags":
				return ec.fieldContext_SqlInstance_flags(ctx, field)
			case "users":
				return ec.fieldContext_SqlInstance_users(ctx, field)
			case "metrics":
				return ec.fieldContext_SqlInstance_metrics(ctx, field)
			case "state":
				return ec.fieldContext_SqlInstance_state(ctx, field)
			case "cost":
				return ec.fieldContext_SqlInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*sqlinstance.SQLInstance])
	fc.Result = res
	return ec.marshalNSqlInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_SqlInstanceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_SqlInstanceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceCost_sum(ctx context.Context, field graphql.CollectedField, obj *cost.SQLInstanceCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceCost_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceCost_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceCost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceCpu_cores(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceCPU) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceCpu_cores(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cores, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceCpu_cores(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceCpu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceCpu_utilization(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceCPU) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceCpu_utilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Utilization, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceCpu_utilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceCpu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceDisk_quotaBytes(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceDisk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceDisk_quotaBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuotaBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceDisk_quotaBytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceDisk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceDisk_utilization(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceDisk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceDisk_utilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Utilization, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceDisk_utilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceDisk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstance)
	fc.Result = res
	return ec.marshalNSqlInstance2githubcomnaisapiinternalpersistencesqlinstanceSQLInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SqlInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_SqlInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_SqlInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_SqlInstance_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_SqlInstance_teamEnvironment(ctx, field)
			case "workload":
				return ec.fieldContext_SqlInstance_workload(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_SqlInstance_cascadingDelete(ctx, field)
			case "connectionName":
				return ec.fieldContext_SqlInstance_connectionName(ctx, field)
			case "diskAutoresize":
				return ec.fieldContext_SqlInstance_diskAutoresize(ctx, field)
			case "diskAutoresizeLimit":
				return ec.fieldContext_SqlInstance_diskAutoresizeLimit(ctx, field)
			case "highAvailability":
				return ec.fieldContext_SqlInstance_highAvailability(ctx, field)
			case "healthy":
				return ec.fieldContext_SqlInstance_healthy(ctx, field)
			case "maintenanceVersion":
				return ec.fieldContext_SqlInstance_maintenanceVersion(ctx, field)
			case "maintenanceWindow":
				return ec.fieldContext_SqlInstance_maintenanceWindow(ctx, field)
			case "backupConfiguration":
				return ec.fieldContext_SqlInstance_backupConfiguration(ctx, field)
			case "projectID":
				return ec.fieldContext_SqlInstance_projectID(ctx, field)
			case "tier":
				return ec.fieldContext_SqlInstance_tier(ctx, field)
			case "version":
				return ec.fieldContext_SqlInstance_version(ctx, field)
			case "status":
				return ec.fieldContext_SqlInstance_status(ctx, field)
			case "database":
				return ec.fieldContext_SqlInstance_database(ctx, field)
			case "flags":
				return ec.fieldContext_SqlInstance_flags(ctx, field)
			case "users":
				return ec.fieldContext_SqlInstance_users(ctx, field)
			case "metrics":
				return ec.fieldContext_SqlInstance_metrics(ctx, field)
			case "state":
				return ec.fieldContext_SqlInstance_state(ctx, field)
			case "cost":
				return ec.fieldContext_SqlInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlag_name(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceFlag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlag_value(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceFlag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlag_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlag_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlagConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceFlag]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlagConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlagConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlagConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlagConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceFlag]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlagConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*sqlinstance.SQLInstanceFlag)
	fc.Result = res
	return ec.marshalNSqlInstanceFlag2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceFlag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlagConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlagConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SqlInstanceFlag_name(ctx, field)
			case "value":
				return ec.fieldContext_SqlInstanceFlag_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceFlag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlagConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceFlag]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlagConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*sqlinstance.SQLInstanceFlag])
	fc.Result = res
	return ec.marshalNSqlInstanceFlagEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlagConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlagConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_SqlInstanceFlagEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_SqlInstanceFlagEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceFlagEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlagEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstanceFlag]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlagEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlagEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlagEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceFlagEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstanceFlag]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceFlagEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceFlag)
	fc.Result = res
	return ec.marshalNSqlInstanceFlag2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceFlag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceFlagEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceFlagEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SqlInstanceFlag_name(ctx, field)
			case "value":
				return ec.fieldContext_SqlInstanceFlag_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceFlag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceMaintenanceWindow_day(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceMaintenanceWindow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceMaintenanceWindow_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Day, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceMaintenanceWindow_day(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceMaintenanceWindow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceMaintenanceWindow_hour(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceMaintenanceWindow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceMaintenanceWindow_hour(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hour, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceMaintenanceWindow_hour(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceMaintenanceWindow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceMemory_quotaBytes(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceMemory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceMemory_quotaBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuotaBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceMemory_quotaBytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceMemory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceMemory_utilization(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceMemory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceMemory_utilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Utilization, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceMemory_utilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceMemory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceMetrics_cpu(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceMetrics_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstanceMetrics().CPU(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceCPU)
	fc.Result = res
	return ec.marshalNSqlInstanceCpu2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceCPU(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceMetrics_cpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cores":
				return ec.fieldContext_SqlInstanceCpu_cores(ctx, field)
			case "utilization":
				return ec.fieldContext_SqlInstanceCpu_utilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceCpu", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceMetrics_memory(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceMetrics_memory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstanceMetrics().Memory(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceMemory)
	fc.Result = res
	return ec.marshalNSqlInstanceMemory2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceMemory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceMetrics_memory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "quotaBytes":
				return ec.fieldContext_SqlInstanceMemory_quotaBytes(ctx, field)
			case "utilization":
				return ec.fieldContext_SqlInstanceMemory_utilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceMemory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceMetrics_disk(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceMetrics_disk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SqlInstanceMetrics().Disk(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceDisk)
	fc.Result = res
	return ec.marshalNSqlInstanceDisk2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceDisk(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceMetrics_disk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "quotaBytes":
				return ec.fieldContext_SqlInstanceDisk_quotaBytes(ctx, field)
			case "utilization":
				return ec.fieldContext_SqlInstanceDisk_utilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceDisk", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceStatus_publicIpAddress(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceStatus_publicIpAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicIPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceStatus_publicIpAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceStatus_privateIpAddress(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceStatus_privateIpAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateIPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceStatus_privateIpAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUser_name(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUser_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUser_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUser_authentication(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.SQLInstanceUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUser_authentication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Authentication, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUser_authentication(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUserConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceUser]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUserConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUserConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUserConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceUser]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUserConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*sqlinstance.SQLInstanceUser)
	fc.Result = res
	return ec.marshalNSqlInstanceUser2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUserConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUserConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SqlInstanceUser_name(ctx, field)
			case "authentication":
				return ec.fieldContext_SqlInstanceUser_authentication(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUserConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*sqlinstance.SQLInstanceUser]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUserConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*sqlinstance.SQLInstanceUser])
	fc.Result = res
	return ec.marshalNSqlInstanceUserEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUserConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_SqlInstanceUserEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_SqlInstanceUserEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceUserEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstanceUser]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUserEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SqlInstanceUserEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*sqlinstance.SQLInstanceUser]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SqlInstanceUserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstanceUser)
	fc.Result = res
	return ec.marshalNSqlInstanceUser2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SqlInstanceUserEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SqlInstanceUserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SqlInstanceUser_name(ctx, field)
			case "authentication":
				return ec.fieldContext_SqlInstanceUser_authentication(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_workloadLog(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_workloadLog(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().WorkloadLog(rctx, fc.Args["filter"].(podlog.WorkloadLogSubscriptionFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *podlog.WorkloadLogLine):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNWorkloadLogLine2githubcomnaisapiinternalworkloadpodlogWorkloadLogLine(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_workloadLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "time":
				return ec.fieldContext_WorkloadLogLine_time(ctx, field)
			case "message":
				return ec.fieldContext_WorkloadLogLine_message(ctx, field)
			case "instance":
				return ec.fieldContext_WorkloadLogLine_instance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadLogLine", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_workloadLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_id(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_slug(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_slug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_slug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_slackChannel(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_slackChannel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackChannel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_slackChannel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_purpose(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_purpose(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Purpose, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_purpose(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_externalResources(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_externalResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalResources(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamExternalResources)
	fc.Result = res
	return ec.marshalNTeamExternalResources2githubcomnaisapiinternalteamTeamExternalResources(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_externalResources(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "entraIDGroup":
				return ec.fieldContext_TeamExternalResources_entraIDGroup(ctx, field)
			case "gitHubTeam":
				return ec.fieldContext_TeamExternalResources_gitHubTeam(ctx, field)
			case "googleGroup":
				return ec.fieldContext_TeamExternalResources_googleGroup(ctx, field)
			case "googleArtifactRegistry":
				return ec.fieldContext_TeamExternalResources_googleArtifactRegistry(ctx, field)
			case "cdn":
				return ec.fieldContext_TeamExternalResources_cdn(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamExternalResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_member(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_member(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Member(rctx, obj, fc.Args["email"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamMember)
	fc.Result = res
	return ec.marshalNTeamMember2githubcomnaisapiinternalteamTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_member(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamMember_team(ctx, field)
			case "user":
				return ec.fieldContext_TeamMember_user(ctx, field)
			case "role":
				return ec.fieldContext_TeamMember_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_member_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_members(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_members(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Members(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*team.TeamMemberOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*team.TeamMember])
	fc.Result = res
	return ec.marshalNTeamMemberConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_members(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_TeamMemberConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_TeamMemberConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_TeamMemberConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_members_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_lastSuccessfulSync(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSuccessfulSync, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_lastSuccessfulSync(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_deletionInProgress(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_deletionInProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionInProgress(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_deletionInProgress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_viewerIsOwner(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_viewerIsOwner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().ViewerIsOwner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_viewerIsOwner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_viewerIsMember(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_viewerIsMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().ViewerIsMember(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_viewerIsMember(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_environments(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Environments(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_environments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_environment(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Environment(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_environment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_deleteKey(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_deleteKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().DeleteKey(rctx, obj, fc.Args["key"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamDeleteKey)
	fc.Result = res
	return ec.marshalNTeamDeleteKey2githubcomnaisapiinternalteamTeamDeleteKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_deleteKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_TeamDeleteKey_key(ctx, field)
			case "createdAt":
				return ec.fieldContext_TeamDeleteKey_createdAt(ctx, field)
			case "expires":
				return ec.fieldContext_TeamDeleteKey_expires(ctx, field)
			case "createdBy":
				return ec.fieldContext_TeamDeleteKey_createdBy(ctx, field)
			case "team":
				return ec.fieldContext_TeamDeleteKey_team(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamDeleteKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_deleteKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_inventoryCounts(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_inventoryCounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().InventoryCounts(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamInventoryCounts)
	fc.Result = res
	return ec.marshalNTeamInventoryCounts2githubcomnaisapiinternalteamTeamInventoryCounts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_inventoryCounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "applications":
				return ec.fieldContext_TeamInventoryCounts_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_TeamInventoryCounts_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_TeamInventoryCounts_buckets(ctx, field)
			case "jobs":
				return ec.fieldContext_TeamInventoryCounts_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_TeamInventoryCounts_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_TeamInventoryCounts_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_TeamInventoryCounts_redisInstances(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_TeamInventoryCounts_sqlInstances(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_TeamInventoryCounts_valkeyInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamInventoryCounts", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_activityLog(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_activityLog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().ActivityLog(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[activitylog.ActivityLogEntry])
	fc.Result = res
	return ec.marshalNActivityLogEntryConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_activityLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ActivityLogEntryConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ActivityLogEntryConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ActivityLogEntryConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ActivityLogEntryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_activityLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_applications(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_applications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Applications(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*application.ApplicationOrder), fc.Args["filter"].(*application.TeamApplicationsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*application.Application])
	fc.Result = res
	return ec.marshalNApplicationConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_applications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ApplicationConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ApplicationConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ApplicationConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_applications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_bigQueryDatasets(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_bigQueryDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().BigQueryDatasets(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*bigquery.BigQueryDatasetOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bigquery.BigQueryDataset])
	fc.Result = res
	return ec.marshalNBigQueryDatasetConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_bigQueryDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BigQueryDatasetConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BigQueryDatasetConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BigQueryDatasetConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDatasetConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_bigQueryDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_buckets(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_buckets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Buckets(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*bucket.BucketOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*bucket.Bucket])
	fc.Result = res
	return ec.marshalNBucketConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_buckets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_BucketConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_BucketConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_BucketConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_buckets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_cost(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.TeamCost)
	fc.Result = res
	return ec.marshalNTeamCost2githubcomnaisapiinternalcostTeamCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "daily":
				return ec.fieldContext_TeamCost_daily(ctx, field)
			case "monthlySummary":
				return ec.fieldContext_TeamCost_monthlySummary(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_deploymentKey(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_deploymentKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().DeploymentKey(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*deployment.DeploymentKey)
	fc.Result = res
	return ec.marshalODeploymentKey2githubcomnaisapiinternaldeploymentDeploymentKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_deploymentKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeploymentKey_id(ctx, field)
			case "key":
				return ec.fieldContext_DeploymentKey_key(ctx, field)
			case "created":
				return ec.fieldContext_DeploymentKey_created(ctx, field)
			case "expires":
				return ec.fieldContext_DeploymentKey_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_deployments(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_deployments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Deployments(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*deployment.Deployment])
	fc.Result = res
	return ec.marshalNDeploymentConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_deployments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_DeploymentConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_DeploymentConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_DeploymentConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_deployments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_jobs(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_jobs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Jobs(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*job.JobOrder), fc.Args["filter"].(*job.TeamJobsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*job.Job])
	fc.Result = res
	return ec.marshalNJobConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_jobs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_JobConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_JobConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_JobConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_jobs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_kafkaTopics(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_kafkaTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().KafkaTopics(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*kafkatopic.KafkaTopicOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*kafkatopic.KafkaTopic])
	fc.Result = res
	return ec.marshalNKafkaTopicConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_kafkaTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_KafkaTopicConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_KafkaTopicConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_KafkaTopicConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopicConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_kafkaTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_openSearchInstances(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_openSearchInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().OpenSearchInstances(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*opensearch.OpenSearchOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*opensearch.OpenSearch])
	fc.Result = res
	return ec.marshalNOpenSearchConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_openSearchInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_OpenSearchConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_OpenSearchConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_OpenSearchConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearchConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_openSearchInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_redisInstances(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_redisInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().RedisInstances(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*redis.RedisInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*redis.RedisInstance])
	fc.Result = res
	return ec.marshalNRedisInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_redisInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_RedisInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_RedisInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RedisInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_redisInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_repositories(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Repositories(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*repository.RepositoryOrder), fc.Args["filter"].(*repository.TeamRepositoryFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*repository.Repository])
	fc.Result = res
	return ec.marshalNRepositoryConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_RepositoryConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_RepositoryConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_RepositoryConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_repositories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_secrets(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_secrets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Secrets(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*secret.SecretOrder), fc.Args["filter"].(*secret.SecretFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*secret.Secret])
	fc.Result = res
	return ec.marshalNSecretConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_secrets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SecretConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SecretConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SecretConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_secrets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_sqlInstances(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_sqlInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().SQLInstances(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*sqlinstance.SQLInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*sqlinstance.SQLInstance])
	fc.Result = res
	return ec.marshalNSqlInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_sqlInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_SqlInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_SqlInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_SqlInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_sqlInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_unleash(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_unleash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Unleash(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*unleash.UnleashInstance)
	fc.Result = res
	return ec.marshalOUnleashInstance2githubcomnaisapiinternalunleashUnleashInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_unleash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UnleashInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_UnleashInstance_name(ctx, field)
			case "version":
				return ec.fieldContext_UnleashInstance_version(ctx, field)
			case "allowedTeams":
				return ec.fieldContext_UnleashInstance_allowedTeams(ctx, field)
			case "webIngress":
				return ec.fieldContext_UnleashInstance_webIngress(ctx, field)
			case "apiIngress":
				return ec.fieldContext_UnleashInstance_apiIngress(ctx, field)
			case "metrics":
				return ec.fieldContext_UnleashInstance_metrics(ctx, field)
			case "ready":
				return ec.fieldContext_UnleashInstance_ready(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UnleashInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_workloadUtilization(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_workloadUtilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().WorkloadUtilization(rctx, obj, fc.Args["resourceType"].(utilization.UtilizationResourceType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*utilization.WorkloadUtilizationData)
	fc.Result = res
	return ec.marshalNWorkloadUtilizationData2githubcomnaisapiinternalutilizationWorkloadUtilizationData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_workloadUtilization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_WorkloadUtilizationData_workload(ctx, field)
			case "requested":
				return ec.fieldContext_WorkloadUtilizationData_requested(ctx, field)
			case "used":
				return ec.fieldContext_WorkloadUtilizationData_used(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadUtilizationData", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_workloadUtilization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_serviceUtilization(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_serviceUtilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().ServiceUtilization(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*utilization.TeamServiceUtilization)
	fc.Result = res
	return ec.marshalNTeamServiceUtilization2githubcomnaisapiinternalutilizationTeamServiceUtilization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_serviceUtilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sqlInstances":
				return ec.fieldContext_TeamServiceUtilization_sqlInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamServiceUtilization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_valkeyInstances(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_valkeyInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().ValkeyInstances(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*valkey.ValkeyInstanceOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*valkey.ValkeyInstance])
	fc.Result = res
	return ec.marshalNValkeyInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_valkeyInstances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ValkeyInstanceConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ValkeyInstanceConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ValkeyInstanceConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstanceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_valkeyInstances_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_vulnerabilitySummary(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().VulnerabilitySummary(rctx, obj, fc.Args["filter"].(*vulnerability.TeamVulnerabilitySummaryFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*vulnerability.TeamVulnerabilitySummary)
	fc.Result = res
	return ec.marshalNTeamVulnerabilitySummary2githubcomnaisapiinternalvulnerabilityTeamVulnerabilitySummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_vulnerabilitySummary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "riskScore":
				return ec.fieldContext_TeamVulnerabilitySummary_riskScore(ctx, field)
			case "critical":
				return ec.fieldContext_TeamVulnerabilitySummary_critical(ctx, field)
			case "high":
				return ec.fieldContext_TeamVulnerabilitySummary_high(ctx, field)
			case "medium":
				return ec.fieldContext_TeamVulnerabilitySummary_medium(ctx, field)
			case "low":
				return ec.fieldContext_TeamVulnerabilitySummary_low(ctx, field)
			case "unassigned":
				return ec.fieldContext_TeamVulnerabilitySummary_unassigned(ctx, field)
			case "bomCount":
				return ec.fieldContext_TeamVulnerabilitySummary_bomCount(ctx, field)
			case "coverage":
				return ec.fieldContext_TeamVulnerabilitySummary_coverage(ctx, field)
			case "ranking":
				return ec.fieldContext_TeamVulnerabilitySummary_ranking(ctx, field)
			case "riskScoreTrend":
				return ec.fieldContext_TeamVulnerabilitySummary_riskScoreTrend(ctx, field)
			case "status":
				return ec.fieldContext_TeamVulnerabilitySummary_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamVulnerabilitySummary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_vulnerabilitySummary_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Team_workloads(ctx context.Context, field graphql.CollectedField, obj *team.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_workloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Workloads(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*workload.WorkloadOrder), fc.Args["filter"].(*workload.TeamWorkloadsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[workload.Workload])
	fc.Result = res
	return ec.marshalNWorkloadConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_workloads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_WorkloadConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_WorkloadConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_WorkloadConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Team_workloads_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamCDN_bucket(ctx context.Context, field graphql.CollectedField, obj *team.TeamCDN) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCDN_bucket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bucket, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCDN_bucket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCDN",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConfirmDeleteKeyActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamConfirmDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConfirmDeleteKeyActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConfirmDeleteKeyActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConfirmDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.Team]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.Team]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.Team]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*team.Team])
	fc.Result = res
	return ec.marshalNTeamEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_TeamEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_TeamEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCost_daily(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCost_daily(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamCost().Daily(rctx, obj, fc.Args["from"].(scalar.Date), fc.Args["to"].(scalar.Date), fc.Args["filter"].(*cost.TeamCostDailyFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.TeamCostPeriod)
	fc.Result = res
	return ec.marshalNTeamCostPeriod2githubcomnaisapiinternalcostTeamCostPeriod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCost_daily(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_TeamCostPeriod_sum(ctx, field)
			case "series":
				return ec.fieldContext_TeamCostPeriod_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamCostPeriod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamCost_daily_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamCost_monthlySummary(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCost_monthlySummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamCost().MonthlySummary(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.TeamCostMonthlySummary)
	fc.Result = res
	return ec.marshalNTeamCostMonthlySummary2githubcomnaisapiinternalcostTeamCostMonthlySummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCost_monthlySummary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_TeamCostMonthlySummary_sum(ctx, field)
			case "series":
				return ec.fieldContext_TeamCostMonthlySummary_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamCostMonthlySummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostMonthlySample_date(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostMonthlySample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostMonthlySample_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(scalar.Date)
	fc.Result = res
	return ec.marshalNDate2githubcomnaisapiinternalgraphscalarDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostMonthlySample_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostMonthlySample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostMonthlySample_cost(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostMonthlySample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostMonthlySample_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostMonthlySample_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostMonthlySample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostMonthlySummary_sum(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostMonthlySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostMonthlySummary_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostMonthlySummary_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostMonthlySummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostMonthlySummary_series(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostMonthlySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostMonthlySummary_series(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Series, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*cost.TeamCostMonthlySample)
	fc.Result = res
	return ec.marshalNTeamCostMonthlySample2githubcomnaisapiinternalcostTeamCostMonthlySample(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostMonthlySummary_series(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostMonthlySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "date":
				return ec.fieldContext_TeamCostMonthlySample_date(ctx, field)
			case "cost":
				return ec.fieldContext_TeamCostMonthlySample_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamCostMonthlySample", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostPeriod_sum(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostPeriod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostPeriod_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostPeriod_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostPeriod",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCostPeriod_series(ctx context.Context, field graphql.CollectedField, obj *cost.TeamCostPeriod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCostPeriod_series(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Series, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*cost.ServiceCostSeries)
	fc.Result = res
	return ec.marshalNServiceCostSeries2githubcomnaisapiinternalcostServiceCostSeries(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCostPeriod_series(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCostPeriod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "date":
				return ec.fieldContext_ServiceCostSeries_date(ctx, field)
			case "sum":
				return ec.fieldContext_ServiceCostSeries_sum(ctx, field)
			case "services":
				return ec.fieldContext_ServiceCostSeries_services(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceCostSeries", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreateDeleteKeyActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreateDeleteKeyActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreateDeleteKeyActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreateDeleteKeyActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreateDeleteKeyActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamCreatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamCreatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamCreatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeleteKey_key(ctx context.Context, field graphql.CollectedField, obj *team.TeamDeleteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeleteKey_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeleteKey_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeleteKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeleteKey_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamDeleteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeleteKey_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeleteKey_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeleteKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeleteKey_expires(ctx context.Context, field graphql.CollectedField, obj *team.TeamDeleteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeleteKey_expires(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expires(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeleteKey_expires(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeleteKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeleteKey_createdBy(ctx context.Context, field graphql.CollectedField, obj *team.TeamDeleteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeleteKey_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamDeleteKey().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalNUser2githubcomnaisapiinternaluserUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeleteKey_createdBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeleteKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeleteKey_team(ctx context.Context, field graphql.CollectedField, obj *team.TeamDeleteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeleteKey_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamDeleteKey().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeleteKey_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeleteKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeployKeyUpdatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *deployment.TeamDeployKeyUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeployKeyUpdatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeployKeyUpdatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeployKeyUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeployKeyUpdatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *deployment.TeamDeployKeyUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeployKeyUpdatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeployKeyUpdatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeployKeyUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeployKeyUpdatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *deployment.TeamDeployKeyUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeployKeyUpdatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeployKeyUpdatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeployKeyUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeployKeyUpdatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *deployment.TeamDeployKeyUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeployKeyUpdatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeployKeyUpdatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeployKeyUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeployKeyUpdatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *deployment.TeamDeployKeyUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeployKeyUpdatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeployKeyUpdatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeployKeyUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeployKeyUpdatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *deployment.TeamDeployKeyUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeployKeyUpdatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeployKeyUpdatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeployKeyUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeployKeyUpdatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *deployment.TeamDeployKeyUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeployKeyUpdatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeployKeyUpdatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeployKeyUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamDeployKeyUpdatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *deployment.TeamDeployKeyUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamDeployKeyUpdatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamDeployKeyUpdatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamDeployKeyUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*team.Team]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*team.Team]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEntraIDGroup_groupID(ctx context.Context, field graphql.CollectedField, obj *team.TeamEntraIDGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEntraIDGroup_groupID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEntraIDGroup_groupID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEntraIDGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_name(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_gcpProjectID(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCPProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_gcpProjectID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_slackAlertsChannel(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackAlertsChannel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_slackAlertsChannel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_team(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_application(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Application(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomnaisapiinternalworkloadapplicationApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_application(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "team":
				return ec.fieldContext_Application_team(ctx, field)
			case "environment":
				return ec.fieldContext_Application_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Application_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Application_image(ctx, field)
			case "resources":
				return ec.fieldContext_Application_resources(ctx, field)
			case "ingresses":
				return ec.fieldContext_Application_ingresses(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Application_authIntegrations(ctx, field)
			case "manifest":
				return ec.fieldContext_Application_manifest(ctx, field)
			case "instances":
				return ec.fieldContext_Application_instances(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Application_deletionStartedAt(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Application_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Application_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Application_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Application_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Application_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Application_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Application_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Application_openSearch(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Application_redisInstances(ctx, field)
			case "secrets":
				return ec.fieldContext_Application_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Application_sqlInstances(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "utilization":
				return ec.fieldContext_Application_utilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Application_valkeyInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_application_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_bigQueryDataset(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().BigQueryDataset(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bigquery.BigQueryDataset)
	fc.Result = res
	return ec.marshalNBigQueryDataset2githubcomnaisapiinternalpersistencebigqueryBigQueryDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_bigQueryDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BigQueryDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_BigQueryDataset_name(ctx, field)
			case "team":
				return ec.fieldContext_BigQueryDataset_team(ctx, field)
			case "environment":
				return ec.fieldContext_BigQueryDataset_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_BigQueryDataset_teamEnvironment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_BigQueryDataset_cascadingDelete(ctx, field)
			case "description":
				return ec.fieldContext_BigQueryDataset_description(ctx, field)
			case "access":
				return ec.fieldContext_BigQueryDataset_access(ctx, field)
			case "status":
				return ec.fieldContext_BigQueryDataset_status(ctx, field)
			case "workload":
				return ec.fieldContext_BigQueryDataset_workload(ctx, field)
			case "cost":
				return ec.fieldContext_BigQueryDataset_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BigQueryDataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_bigQueryDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_bucket(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_bucket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Bucket(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bucket.Bucket)
	fc.Result = res
	return ec.marshalNBucket2githubcomnaisapiinternalpersistencebucketBucket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_bucket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bucket_id(ctx, field)
			case "name":
				return ec.fieldContext_Bucket_name(ctx, field)
			case "team":
				return ec.fieldContext_Bucket_team(ctx, field)
			case "environment":
				return ec.fieldContext_Bucket_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Bucket_teamEnvironment(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_Bucket_cascadingDelete(ctx, field)
			case "publicAccessPrevention":
				return ec.fieldContext_Bucket_publicAccessPrevention(ctx, field)
			case "uniformBucketLevelAccess":
				return ec.fieldContext_Bucket_uniformBucketLevelAccess(ctx, field)
			case "workload":
				return ec.fieldContext_Bucket_workload(ctx, field)
			case "status":
				return ec.fieldContext_Bucket_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bucket", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_bucket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_cost(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.TeamEnvironmentCost)
	fc.Result = res
	return ec.marshalNTeamEnvironmentCost2githubcomnaisapiinternalcostTeamEnvironmentCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "daily":
				return ec.fieldContext_TeamEnvironmentCost_daily(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironmentCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_environment(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*environment.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomnaisapiinternalenvironmentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "workloads":
				return ec.fieldContext_Environment_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_job(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_job(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Job(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.Job)
	fc.Result = res
	return ec.marshalNJob2githubcomnaisapiinternalworkloadjobJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_job(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "name":
				return ec.fieldContext_Job_name(ctx, field)
			case "team":
				return ec.fieldContext_Job_team(ctx, field)
			case "environment":
				return ec.fieldContext_Job_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Job_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Job_image(ctx, field)
			case "resources":
				return ec.fieldContext_Job_resources(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Job_authIntegrations(ctx, field)
			case "schedule":
				return ec.fieldContext_Job_schedule(ctx, field)
			case "runs":
				return ec.fieldContext_Job_runs(ctx, field)
			case "manifest":
				return ec.fieldContext_Job_manifest(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Job_deletionStartedAt(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Job_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Job_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Job_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Job_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Job_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Job_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Job_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Job_openSearch(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Job_redisInstances(ctx, field)
			case "secrets":
				return ec.fieldContext_Job_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Job_sqlInstances(ctx, field)
			case "status":
				return ec.fieldContext_Job_status(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Job_valkeyInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_job_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_kafkaTopic(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().KafkaTopic(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.KafkaTopic)
	fc.Result = res
	return ec.marshalNKafkaTopic2githubcomnaisapiinternalpersistencekafkatopicKafkaTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_kafkaTopic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KafkaTopic_id(ctx, field)
			case "name":
				return ec.fieldContext_KafkaTopic_name(ctx, field)
			case "team":
				return ec.fieldContext_KafkaTopic_team(ctx, field)
			case "environment":
				return ec.fieldContext_KafkaTopic_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_KafkaTopic_teamEnvironment(ctx, field)
			case "acl":
				return ec.fieldContext_KafkaTopic_acl(ctx, field)
			case "configuration":
				return ec.fieldContext_KafkaTopic_configuration(ctx, field)
			case "pool":
				return ec.fieldContext_KafkaTopic_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KafkaTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_kafkaTopic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_openSearchInstance(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().OpenSearchInstance(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*opensearch.OpenSearch)
	fc.Result = res
	return ec.marshalNOpenSearch2githubcomnaisapiinternalpersistenceopensearchOpenSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_openSearchInstance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OpenSearch_id(ctx, field)
			case "name":
				return ec.fieldContext_OpenSearch_name(ctx, field)
			case "team":
				return ec.fieldContext_OpenSearch_team(ctx, field)
			case "environment":
				return ec.fieldContext_OpenSearch_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_OpenSearch_teamEnvironment(ctx, field)
			case "status":
				return ec.fieldContext_OpenSearch_status(ctx, field)
			case "workload":
				return ec.fieldContext_OpenSearch_workload(ctx, field)
			case "access":
				return ec.fieldContext_OpenSearch_access(ctx, field)
			case "cost":
				return ec.fieldContext_OpenSearch_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSearch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_openSearchInstance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_redisInstance(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().RedisInstance(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*redis.RedisInstance)
	fc.Result = res
	return ec.marshalNRedisInstance2githubcomnaisapiinternalpersistenceredisRedisInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_redisInstance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RedisInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_RedisInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_RedisInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_RedisInstance_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_RedisInstance_teamEnvironment(ctx, field)
			case "access":
				return ec.fieldContext_RedisInstance_access(ctx, field)
			case "workload":
				return ec.fieldContext_RedisInstance_workload(ctx, field)
			case "status":
				return ec.fieldContext_RedisInstance_status(ctx, field)
			case "cost":
				return ec.fieldContext_RedisInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RedisInstance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_redisInstance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_secret(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Secret(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*secret.Secret)
	fc.Result = res
	return ec.marshalNSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_secret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Secret_id(ctx, field)
			case "name":
				return ec.fieldContext_Secret_name(ctx, field)
			case "environment":
				return ec.fieldContext_Secret_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Secret_teamEnvironment(ctx, field)
			case "team":
				return ec.fieldContext_Secret_team(ctx, field)
			case "values":
				return ec.fieldContext_Secret_values(ctx, field)
			case "applications":
				return ec.fieldContext_Secret_applications(ctx, field)
			case "jobs":
				return ec.fieldContext_Secret_jobs(ctx, field)
			case "workloads":
				return ec.fieldContext_Secret_workloads(ctx, field)
			case "lastModifiedAt":
				return ec.fieldContext_Secret_lastModifiedAt(ctx, field)
			case "lastModifiedBy":
				return ec.fieldContext_Secret_lastModifiedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Secret", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_secret_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_sqlInstance(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().SQLInstance(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.SQLInstance)
	fc.Result = res
	return ec.marshalNSqlInstance2githubcomnaisapiinternalpersistencesqlinstanceSQLInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_sqlInstance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SqlInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_SqlInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_SqlInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_SqlInstance_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_SqlInstance_teamEnvironment(ctx, field)
			case "workload":
				return ec.fieldContext_SqlInstance_workload(ctx, field)
			case "cascadingDelete":
				return ec.fieldContext_SqlInstance_cascadingDelete(ctx, field)
			case "connectionName":
				return ec.fieldContext_SqlInstance_connectionName(ctx, field)
			case "diskAutoresize":
				return ec.fieldContext_SqlInstance_diskAutoresize(ctx, field)
			case "diskAutoresizeLimit":
				return ec.fieldContext_SqlInstance_diskAutoresizeLimit(ctx, field)
			case "highAvailability":
				return ec.fieldContext_SqlInstance_highAvailability(ctx, field)
			case "healthy":
				return ec.fieldContext_SqlInstance_healthy(ctx, field)
			case "maintenanceVersion":
				return ec.fieldContext_SqlInstance_maintenanceVersion(ctx, field)
			case "maintenanceWindow":
				return ec.fieldContext_SqlInstance_maintenanceWindow(ctx, field)
			case "backupConfiguration":
				return ec.fieldContext_SqlInstance_backupConfiguration(ctx, field)
			case "projectID":
				return ec.fieldContext_SqlInstance_projectID(ctx, field)
			case "tier":
				return ec.fieldContext_SqlInstance_tier(ctx, field)
			case "version":
				return ec.fieldContext_SqlInstance_version(ctx, field)
			case "status":
				return ec.fieldContext_SqlInstance_status(ctx, field)
			case "database":
				return ec.fieldContext_SqlInstance_database(ctx, field)
			case "flags":
				return ec.fieldContext_SqlInstance_flags(ctx, field)
			case "users":
				return ec.fieldContext_SqlInstance_users(ctx, field)
			case "metrics":
				return ec.fieldContext_SqlInstance_metrics(ctx, field)
			case "state":
				return ec.fieldContext_SqlInstance_state(ctx, field)
			case "cost":
				return ec.fieldContext_SqlInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SqlInstance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_sqlInstance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_valkeyInstance(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().ValkeyInstance(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*valkey.ValkeyInstance)
	fc.Result = res
	return ec.marshalNValkeyInstance2githubcomnaisapiinternalpersistencevalkeyValkeyInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_valkeyInstance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ValkeyInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_ValkeyInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_ValkeyInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_ValkeyInstance_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_ValkeyInstance_teamEnvironment(ctx, field)
			case "access":
				return ec.fieldContext_ValkeyInstance_access(ctx, field)
			case "workload":
				return ec.fieldContext_ValkeyInstance_workload(ctx, field)
			case "status":
				return ec.fieldContext_ValkeyInstance_status(ctx, field)
			case "cost":
				return ec.fieldContext_ValkeyInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_valkeyInstance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironment_workload(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironment_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironment().Workload(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironment_workload(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironment_workload_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentCost_daily(ctx context.Context, field graphql.CollectedField, obj *cost.TeamEnvironmentCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentCost_daily(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamEnvironmentCost().Daily(rctx, obj, fc.Args["from"].(scalar.Date), fc.Args["to"].(scalar.Date))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.TeamEnvironmentCostPeriod)
	fc.Result = res
	return ec.marshalNTeamEnvironmentCostPeriod2githubcomnaisapiinternalcostTeamEnvironmentCostPeriod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentCost_daily(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentCost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_TeamEnvironmentCostPeriod_sum(ctx, field)
			case "series":
				return ec.fieldContext_TeamEnvironmentCostPeriod_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironmentCostPeriod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TeamEnvironmentCost_daily_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentCostPeriod_sum(ctx context.Context, field graphql.CollectedField, obj *cost.TeamEnvironmentCostPeriod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentCostPeriod_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentCostPeriod_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentCostPeriod",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentCostPeriod_series(ctx context.Context, field graphql.CollectedField, obj *cost.TeamEnvironmentCostPeriod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentCostPeriod_series(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Series, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*cost.WorkloadCostSeries)
	fc.Result = res
	return ec.marshalNWorkloadCostSeries2githubcomnaisapiinternalcostWorkloadCostSeries(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentCostPeriod_series(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentCostPeriod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "date":
				return ec.fieldContext_WorkloadCostSeries_date(ctx, field)
			case "sum":
				return ec.fieldContext_WorkloadCostSeries_sum(ctx, field)
			case "workloads":
				return ec.fieldContext_WorkloadCostSeries_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadCostSeries", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironmentUpdatedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNTeamEnvironmentUpdatedActivityLogEntryData2githubcomnaisapiinternalteamTeamEnvironmentUpdatedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updatedFields":
				return ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntryData_updatedFields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironmentUpdatedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntryData_updatedFields(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntryData_updatedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*team.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField)
	fc.Result = res
	return ec.marshalNTeamEnvironmentUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalteamTeamEnvironmentUpdatedActivityLogEntryDataUpdatedField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntryData_updatedFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "field":
				return ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_field(ctx, field)
			case "oldValue":
				return ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field)
			case "newValue":
				return ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_field(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_field(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_oldValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_newValue(ctx context.Context, field graphql.CollectedField, obj *team.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_newValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamExternalResources_entraIDGroup(ctx context.Context, field graphql.CollectedField, obj *team.TeamExternalResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamExternalResources_entraIDGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntraIDGroup(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamEntraIDGroup)
	fc.Result = res
	return ec.marshalOTeamEntraIDGroup2githubcomnaisapiinternalteamTeamEntraIDGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamExternalResources_entraIDGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamExternalResources",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "groupID":
				return ec.fieldContext_TeamEntraIDGroup_groupID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEntraIDGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamExternalResources_gitHubTeam(ctx context.Context, field graphql.CollectedField, obj *team.TeamExternalResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamExternalResources_gitHubTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitHubTeam(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamGitHubTeam)
	fc.Result = res
	return ec.marshalOTeamGitHubTeam2githubcomnaisapiinternalteamTeamGitHubTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamExternalResources_gitHubTeam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamExternalResources",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "slug":
				return ec.fieldContext_TeamGitHubTeam_slug(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamGitHubTeam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamExternalResources_googleGroup(ctx context.Context, field graphql.CollectedField, obj *team.TeamExternalResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamExternalResources_googleGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoogleGroup(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamGoogleGroup)
	fc.Result = res
	return ec.marshalOTeamGoogleGroup2githubcomnaisapiinternalteamTeamGoogleGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamExternalResources_googleGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamExternalResources",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "email":
				return ec.fieldContext_TeamGoogleGroup_email(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamGoogleGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamExternalResources_googleArtifactRegistry(ctx context.Context, field graphql.CollectedField, obj *team.TeamExternalResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamExternalResources_googleArtifactRegistry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoogleArtifactRegistry(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamGoogleArtifactRegistry)
	fc.Result = res
	return ec.marshalOTeamGoogleArtifactRegistry2githubcomnaisapiinternalteamTeamGoogleArtifactRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamExternalResources_googleArtifactRegistry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamExternalResources",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "repository":
				return ec.fieldContext_TeamGoogleArtifactRegistry_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamGoogleArtifactRegistry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamExternalResources_cdn(ctx context.Context, field graphql.CollectedField, obj *team.TeamExternalResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamExternalResources_cdn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CDN(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamCDN)
	fc.Result = res
	return ec.marshalOTeamCDN2githubcomnaisapiinternalteamTeamCDN(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamExternalResources_cdn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamExternalResources",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bucket":
				return ec.fieldContext_TeamCDN_bucket(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamCDN", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamGitHubTeam_slug(ctx context.Context, field graphql.CollectedField, obj *team.TeamGitHubTeam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamGitHubTeam_slug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamGitHubTeam_slug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamGitHubTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamGoogleArtifactRegistry_repository(ctx context.Context, field graphql.CollectedField, obj *team.TeamGoogleArtifactRegistry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamGoogleArtifactRegistry_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamGoogleArtifactRegistry_repository(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamGoogleArtifactRegistry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamGoogleGroup_email(ctx context.Context, field graphql.CollectedField, obj *team.TeamGoogleGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamGoogleGroup_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamGoogleGroup_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamGoogleGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountApplications_total(ctx context.Context, field graphql.CollectedField, obj *application.TeamInventoryCountApplications) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCountApplications_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCountApplications_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountApplications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountApplications_notNais(ctx context.Context, field graphql.CollectedField, obj *application.TeamInventoryCountApplications) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCountApplications_notNais(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamInventoryCountApplications().NotNais(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCountApplications_notNais(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountApplications",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountBigQueryDatasets_total(ctx context.Context, field graphql.CollectedField, obj *bigquery.TeamInventoryCountBigQueryDatasets) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCountBigQueryDatasets_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCountBigQueryDatasets_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountBigQueryDatasets",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountBuckets_total(ctx context.Context, field graphql.CollectedField, obj *bucket.TeamInventoryCountBuckets) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCountBuckets_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCountBuckets_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountBuckets",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountJobs_total(ctx context.Context, field graphql.CollectedField, obj *job.TeamInventoryCountJobs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCountJobs_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCountJobs_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountJobs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountJobs_notNais(ctx context.Context, field graphql.CollectedField, obj *job.TeamInventoryCountJobs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCountJobs_notNais(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamInventoryCountJobs().NotNais(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCountJobs_notNais(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountJobs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountKafkaTopics_total(ctx context.Context, field graphql.CollectedField, obj *kafkatopic.TeamInventoryCountKafkaTopics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCountKafkaTopics_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCountKafkaTopics_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountKafkaTopics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountOpenSearchInstances_total(ctx context.Context, field graphql.CollectedField, obj *opensearch.TeamInventoryCountOpenSearchInstances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCountOpenSearchInstances_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCountOpenSearchInstances_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountOpenSearchInstances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountRedisInstances_total(ctx context.Context, field graphql.CollectedField, obj *redis.TeamInventoryCountRedisInstances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCountRedisInstances_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCountRedisInstances_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountRedisInstances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountSqlInstances_total(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamInventoryCountSQLInstances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCountSqlInstances_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCountSqlInstances_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountSqlInstances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCountValkeyInstances_total(ctx context.Context, field graphql.CollectedField, obj *valkey.TeamInventoryCountValkeyInstances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCountValkeyInstances_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCountValkeyInstances_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCountValkeyInstances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCounts_applications(ctx context.Context, field graphql.CollectedField, obj *team.TeamInventoryCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCounts_applications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamInventoryCounts().Applications(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*application.TeamInventoryCountApplications)
	fc.Result = res
	return ec.marshalNTeamInventoryCountApplications2githubcomnaisapiinternalworkloadapplicationTeamInventoryCountApplications(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCounts_applications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCounts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_TeamInventoryCountApplications_total(ctx, field)
			case "notNais":
				return ec.fieldContext_TeamInventoryCountApplications_notNais(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamInventoryCountApplications", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCounts_bigQueryDatasets(ctx context.Context, field graphql.CollectedField, obj *team.TeamInventoryCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCounts_bigQueryDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamInventoryCounts().BigQueryDatasets(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bigquery.TeamInventoryCountBigQueryDatasets)
	fc.Result = res
	return ec.marshalNTeamInventoryCountBigQueryDatasets2githubcomnaisapiinternalpersistencebigqueryTeamInventoryCountBigQueryDatasets(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCounts_bigQueryDatasets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCounts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_TeamInventoryCountBigQueryDatasets_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamInventoryCountBigQueryDatasets", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCounts_buckets(ctx context.Context, field graphql.CollectedField, obj *team.TeamInventoryCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCounts_buckets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamInventoryCounts().Buckets(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bucket.TeamInventoryCountBuckets)
	fc.Result = res
	return ec.marshalNTeamInventoryCountBuckets2githubcomnaisapiinternalpersistencebucketTeamInventoryCountBuckets(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCounts_buckets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCounts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_TeamInventoryCountBuckets_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamInventoryCountBuckets", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCounts_jobs(ctx context.Context, field graphql.CollectedField, obj *team.TeamInventoryCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCounts_jobs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamInventoryCounts().Jobs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*job.TeamInventoryCountJobs)
	fc.Result = res
	return ec.marshalNTeamInventoryCountJobs2githubcomnaisapiinternalworkloadjobTeamInventoryCountJobs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCounts_jobs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCounts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_TeamInventoryCountJobs_total(ctx, field)
			case "notNais":
				return ec.fieldContext_TeamInventoryCountJobs_notNais(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamInventoryCountJobs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCounts_kafkaTopics(ctx context.Context, field graphql.CollectedField, obj *team.TeamInventoryCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCounts_kafkaTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamInventoryCounts().KafkaTopics(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*kafkatopic.TeamInventoryCountKafkaTopics)
	fc.Result = res
	return ec.marshalNTeamInventoryCountKafkaTopics2githubcomnaisapiinternalpersistencekafkatopicTeamInventoryCountKafkaTopics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCounts_kafkaTopics(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCounts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_TeamInventoryCountKafkaTopics_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamInventoryCountKafkaTopics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCounts_openSearchInstances(ctx context.Context, field graphql.CollectedField, obj *team.TeamInventoryCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCounts_openSearchInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamInventoryCounts().OpenSearchInstances(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*opensearch.TeamInventoryCountOpenSearchInstances)
	fc.Result = res
	return ec.marshalNTeamInventoryCountOpenSearchInstances2githubcomnaisapiinternalpersistenceopensearchTeamInventoryCountOpenSearchInstances(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCounts_openSearchInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCounts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_TeamInventoryCountOpenSearchInstances_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamInventoryCountOpenSearchInstances", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCounts_redisInstances(ctx context.Context, field graphql.CollectedField, obj *team.TeamInventoryCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCounts_redisInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamInventoryCounts().RedisInstances(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*redis.TeamInventoryCountRedisInstances)
	fc.Result = res
	return ec.marshalNTeamInventoryCountRedisInstances2githubcomnaisapiinternalpersistenceredisTeamInventoryCountRedisInstances(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCounts_redisInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCounts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_TeamInventoryCountRedisInstances_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamInventoryCountRedisInstances", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCounts_sqlInstances(ctx context.Context, field graphql.CollectedField, obj *team.TeamInventoryCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCounts_sqlInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamInventoryCounts().SQLInstances(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.TeamInventoryCountSQLInstances)
	fc.Result = res
	return ec.marshalNTeamInventoryCountSqlInstances2githubcomnaisapiinternalpersistencesqlinstanceTeamInventoryCountSQLInstances(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCounts_sqlInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCounts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_TeamInventoryCountSqlInstances_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamInventoryCountSqlInstances", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamInventoryCounts_valkeyInstances(ctx context.Context, field graphql.CollectedField, obj *team.TeamInventoryCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamInventoryCounts_valkeyInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamInventoryCounts().ValkeyInstances(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*valkey.TeamInventoryCountValkeyInstances)
	fc.Result = res
	return ec.marshalNTeamInventoryCountValkeyInstances2githubcomnaisapiinternalpersistencevalkeyTeamInventoryCountValkeyInstances(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamInventoryCounts_valkeyInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamInventoryCounts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_TeamInventoryCountValkeyInstances_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamInventoryCountValkeyInstances", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_team(ctx context.Context, field graphql.CollectedField, obj *team.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamMember().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_user(ctx context.Context, field graphql.CollectedField, obj *team.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamMember().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalNUser2githubcomnaisapiinternaluserUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_role(ctx context.Context, field graphql.CollectedField, obj *team.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(team.TeamMemberRole)
	fc.Result = res
	return ec.marshalNTeamMemberRole2githubcomnaisapiinternalteamTeamMemberRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TeamMemberRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamMemberAddedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNTeamMemberAddedActivityLogEntryData2githubcomnaisapiinternalteamTeamMemberAddedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "role":
				return ec.fieldContext_TeamMemberAddedActivityLogEntryData_role(ctx, field)
			case "userID":
				return ec.fieldContext_TeamMemberAddedActivityLogEntryData_userID(ctx, field)
			case "userEmail":
				return ec.fieldContext_TeamMemberAddedActivityLogEntryData_userEmail(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberAddedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntryData_role(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntryData_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(team.TeamMemberRole)
	fc.Result = res
	return ec.marshalNTeamMemberRole2githubcomnaisapiinternalteamTeamMemberRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntryData_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TeamMemberRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntryData_userID(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntryData_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntryData_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntryData",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberAddedActivityLogEntryData_userEmail(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberAddedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberAddedActivityLogEntryData_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberAddedActivityLogEntryData_userEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberAddedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.TeamMember]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.TeamMember]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*team.TeamMember)
	fc.Result = res
	return ec.marshalNTeamMember2githubcomnaisapiinternalteamTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamMember_team(ctx, field)
			case "user":
				return ec.fieldContext_TeamMember_user(ctx, field)
			case "role":
				return ec.fieldContext_TeamMember_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*team.TeamMember]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*team.TeamMember])
	fc.Result = res
	return ec.marshalNTeamMemberEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_TeamMemberEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_TeamMemberEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*team.TeamMember]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*team.TeamMember]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamMember)
	fc.Result = res
	return ec.marshalNTeamMember2githubcomnaisapiinternalteamTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "team":
				return ec.fieldContext_TeamMember_team(ctx, field)
			case "user":
				return ec.fieldContext_TeamMember_user(ctx, field)
			case "role":
				return ec.fieldContext_TeamMember_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamMemberRemovedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNTeamMemberRemovedActivityLogEntryData2githubcomnaisapiinternalteamTeamMemberRemovedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userID":
				return ec.fieldContext_TeamMemberRemovedActivityLogEntryData_userID(ctx, field)
			case "userEmail":
				return ec.fieldContext_TeamMemberRemovedActivityLogEntryData_userEmail(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberRemovedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntryData_userID(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedActivityLogEntryData_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedActivityLogEntryData_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedActivityLogEntryData",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntryData_userEmail(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberRemovedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberRemovedActivityLogEntryData_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberRemovedActivityLogEntryData_userEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberRemovedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamMemberSetRoleActivityLogEntryData)
	fc.Result = res
	return ec.marshalNTeamMemberSetRoleActivityLogEntryData2githubcomnaisapiinternalteamTeamMemberSetRoleActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "role":
				return ec.fieldContext_TeamMemberSetRoleActivityLogEntryData_role(ctx, field)
			case "userID":
				return ec.fieldContext_TeamMemberSetRoleActivityLogEntryData_userID(ctx, field)
			case "userEmail":
				return ec.fieldContext_TeamMemberSetRoleActivityLogEntryData_userEmail(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberSetRoleActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntryData_role(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntryData_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(team.TeamMemberRole)
	fc.Result = res
	return ec.marshalNTeamMemberRole2githubcomnaisapiinternalteamTeamMemberRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntryData_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TeamMemberRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntryData_userID(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntryData_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntryData_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntryData",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntryData_userEmail(ctx context.Context, field graphql.CollectedField, obj *team.TeamMemberSetRoleActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMemberSetRoleActivityLogEntryData_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMemberSetRoleActivityLogEntryData_userEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMemberSetRoleActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilization_sqlInstances(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamServiceUtilization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilization_sqlInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamServiceUtilization().SQLInstances(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.TeamServiceUtilizationSQLInstances)
	fc.Result = res
	return ec.marshalNTeamServiceUtilizationSqlInstances2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstances(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilization_sqlInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilization",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_TeamServiceUtilizationSqlInstances_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_TeamServiceUtilizationSqlInstances_memory(ctx, field)
			case "disk":
				return ec.fieldContext_TeamServiceUtilizationSqlInstances_disk(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamServiceUtilizationSqlInstances", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstances_cpu(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstances_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamServiceUtilizationSqlInstances().CPU(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.TeamServiceUtilizationSQLInstancesCPU)
	fc.Result = res
	return ec.marshalNTeamServiceUtilizationSqlInstancesCPU2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstancesCPU(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstances_cpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstances",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_TeamServiceUtilizationSqlInstancesCPU_used(ctx, field)
			case "requested":
				return ec.fieldContext_TeamServiceUtilizationSqlInstancesCPU_requested(ctx, field)
			case "utilization":
				return ec.fieldContext_TeamServiceUtilizationSqlInstancesCPU_utilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamServiceUtilizationSqlInstancesCPU", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstances_memory(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstances_memory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamServiceUtilizationSqlInstances().Memory(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.TeamServiceUtilizationSQLInstancesMemory)
	fc.Result = res
	return ec.marshalNTeamServiceUtilizationSqlInstancesMemory2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstancesMemory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstances_memory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstances",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_TeamServiceUtilizationSqlInstancesMemory_used(ctx, field)
			case "requested":
				return ec.fieldContext_TeamServiceUtilizationSqlInstancesMemory_requested(ctx, field)
			case "utilization":
				return ec.fieldContext_TeamServiceUtilizationSqlInstancesMemory_utilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamServiceUtilizationSqlInstancesMemory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstances_disk(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstances_disk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamServiceUtilizationSqlInstances().Disk(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*sqlinstance.TeamServiceUtilizationSQLInstancesDisk)
	fc.Result = res
	return ec.marshalNTeamServiceUtilizationSqlInstancesDisk2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstancesDisk(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstances_disk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstances",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_TeamServiceUtilizationSqlInstancesDisk_used(ctx, field)
			case "requested":
				return ec.fieldContext_TeamServiceUtilizationSqlInstancesDisk_requested(ctx, field)
			case "utilization":
				return ec.fieldContext_TeamServiceUtilizationSqlInstancesDisk_utilization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamServiceUtilizationSqlInstancesDisk", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesCPU_used(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstancesCPU) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstancesCPU_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstancesCPU_used(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstancesCPU",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesCPU_requested(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstancesCPU) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstancesCPU_requested(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requested, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstancesCPU_requested(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstancesCPU",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesCPU_utilization(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstancesCPU) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstancesCPU_utilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Utilization, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstancesCPU_utilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstancesCPU",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesDisk_used(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstancesDisk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstancesDisk_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstancesDisk_used(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstancesDisk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesDisk_requested(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstancesDisk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstancesDisk_requested(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requested, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstancesDisk_requested(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstancesDisk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesDisk_utilization(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstancesDisk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstancesDisk_utilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Utilization, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstancesDisk_utilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstancesDisk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesMemory_used(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstancesMemory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstancesMemory_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstancesMemory_used(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstancesMemory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesMemory_requested(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstancesMemory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstancesMemory_requested(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requested, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstancesMemory_requested(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstancesMemory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesMemory_utilization(ctx context.Context, field graphql.CollectedField, obj *sqlinstance.TeamServiceUtilizationSQLInstancesMemory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamServiceUtilizationSqlInstancesMemory_utilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Utilization, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamServiceUtilizationSqlInstancesMemory_utilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamServiceUtilizationSqlInstancesMemory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamUpdatedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNTeamUpdatedActivityLogEntryData2githubcomnaisapiinternalteamTeamUpdatedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updatedFields":
				return ec.fieldContext_TeamUpdatedActivityLogEntryData_updatedFields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamUpdatedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntryData_updatedFields(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntryData_updatedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*team.TeamUpdatedActivityLogEntryDataUpdatedField)
	fc.Result = res
	return ec.marshalNTeamUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalteamTeamUpdatedActivityLogEntryDataUpdatedField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntryData_updatedFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "field":
				return ec.fieldContext_TeamUpdatedActivityLogEntryDataUpdatedField_field(ctx, field)
			case "oldValue":
				return ec.fieldContext_TeamUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field)
			case "newValue":
				return ec.fieldContext_TeamUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamUpdatedActivityLogEntryDataUpdatedField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntryDataUpdatedField_field(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntryDataUpdatedField_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntryDataUpdatedField_field(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntryDataUpdatedField_oldValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUpdatedActivityLogEntryDataUpdatedField_newValue(ctx context.Context, field graphql.CollectedField, obj *team.TeamUpdatedActivityLogEntryDataUpdatedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUpdatedActivityLogEntryDataUpdatedField_newValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUpdatedActivityLogEntryDataUpdatedField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUtilizationData_team(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUtilizationData_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamUtilizationData().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUtilizationData_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUtilizationData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUtilizationData_requested(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUtilizationData_requested(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requested, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUtilizationData_requested(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUtilizationData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUtilizationData_used(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUtilizationData_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUtilizationData_used(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUtilizationData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUtilizationData_environment(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUtilizationData_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamUtilizationData().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUtilizationData_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUtilizationData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamUtilizationData_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *utilization.TeamUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamUtilizationData_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamUtilizationData().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamUtilizationData_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamUtilizationData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilityStatus_state(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilityStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilityStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(vulnerability.TeamVulnerabilityState)
	fc.Result = res
	return ec.marshalNTeamVulnerabilityState2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilityStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilityStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TeamVulnerabilityState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilityStatus_title(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilityStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilityStatus_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilityStatus_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilityStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilityStatus_description(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilityStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilityStatus_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilityStatus_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilityStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_riskScore(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_riskScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RiskScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_riskScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_critical(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_critical(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Critical, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_critical(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_high(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_high(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.High, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_high(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_medium(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_medium(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Medium, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_medium(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_low(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_low(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Low, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_low(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_unassigned(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_unassigned(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unassigned, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_unassigned(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_bomCount(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_bomCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BomCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_bomCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_coverage(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_coverage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Coverage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_coverage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_ranking(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_ranking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamVulnerabilitySummary().Ranking(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(vulnerability.TeamVulnerabilityRanking)
	fc.Result = res
	return ec.marshalNTeamVulnerabilityRanking2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityRanking(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_ranking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TeamVulnerabilityRanking does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_riskScoreTrend(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_riskScoreTrend(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamVulnerabilitySummary().RiskScoreTrend(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(vulnerability.TeamVulnerabilityRiskScoreTrend)
	fc.Result = res
	return ec.marshalNTeamVulnerabilityRiskScoreTrend2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityRiskScoreTrend(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_riskScoreTrend(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TeamVulnerabilityRiskScoreTrend does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamVulnerabilitySummary_status(ctx context.Context, field graphql.CollectedField, obj *vulnerability.TeamVulnerabilitySummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamVulnerabilitySummary_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamVulnerabilitySummary().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*vulnerability.TeamVulnerabilityStatus)
	fc.Result = res
	return ec.marshalNTeamVulnerabilityStatus2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamVulnerabilitySummary_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamVulnerabilitySummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_TeamVulnerabilityStatus_state(ctx, field)
			case "title":
				return ec.fieldContext_TeamVulnerabilityStatus_title(ctx, field)
			case "description":
				return ec.fieldContext_TeamVulnerabilityStatus_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamVulnerabilityStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenXAuthIntegration_name(ctx context.Context, field graphql.CollectedField, obj *workload.TokenXAuthIntegration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenXAuthIntegration_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenXAuthIntegration_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenXAuthIntegration",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerJobPayload_job(ctx context.Context, field graphql.CollectedField, obj *job.TriggerJobPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerJobPayload_job(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TriggerJobPayload().Job(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*job.Job)
	fc.Result = res
	return ec.marshalOJob2githubcomnaisapiinternalworkloadjobJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerJobPayload_job(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerJobPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "name":
				return ec.fieldContext_Job_name(ctx, field)
			case "team":
				return ec.fieldContext_Job_team(ctx, field)
			case "environment":
				return ec.fieldContext_Job_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Job_teamEnvironment(ctx, field)
			case "image":
				return ec.fieldContext_Job_image(ctx, field)
			case "resources":
				return ec.fieldContext_Job_resources(ctx, field)
			case "authIntegrations":
				return ec.fieldContext_Job_authIntegrations(ctx, field)
			case "schedule":
				return ec.fieldContext_Job_schedule(ctx, field)
			case "runs":
				return ec.fieldContext_Job_runs(ctx, field)
			case "manifest":
				return ec.fieldContext_Job_manifest(ctx, field)
			case "deletionStartedAt":
				return ec.fieldContext_Job_deletionStartedAt(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Job_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Job_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Job_cost(ctx, field)
			case "deployments":
				return ec.fieldContext_Job_deployments(ctx, field)
			case "kafkaTopicAcls":
				return ec.fieldContext_Job_kafkaTopicAcls(ctx, field)
			case "logDestinations":
				return ec.fieldContext_Job_logDestinations(ctx, field)
			case "networkPolicy":
				return ec.fieldContext_Job_networkPolicy(ctx, field)
			case "openSearch":
				return ec.fieldContext_Job_openSearch(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Job_redisInstances(ctx, field)
			case "secrets":
				return ec.fieldContext_Job_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Job_sqlInstances(ctx, field)
			case "status":
				return ec.fieldContext_Job_status(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Job_valkeyInstances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerJobPayload_jobRun(ctx context.Context, field graphql.CollectedField, obj *job.TriggerJobPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerJobPayload_jobRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobRun, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*job.JobRun)
	fc.Result = res
	return ec.marshalOJobRun2githubcomnaisapiinternalworkloadjobJobRun(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerJobPayload_jobRun(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerJobPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JobRun_id(ctx, field)
			case "name":
				return ec.fieldContext_JobRun_name(ctx, field)
			case "startTime":
				return ec.fieldContext_JobRun_startTime(ctx, field)
			case "completionTime":
				return ec.fieldContext_JobRun_completionTime(ctx, field)
			case "status":
				return ec.fieldContext_JobRun_status(ctx, field)
			case "image":
				return ec.fieldContext_JobRun_image(ctx, field)
			case "duration":
				return ec.fieldContext_JobRun_duration(ctx, field)
			case "instances":
				return ec.fieldContext_JobRun_instances(ctx, field)
			case "trigger":
				return ec.fieldContext_JobRun_trigger(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRun", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstance_id(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstance_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstance_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstance_name(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstance_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstance_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstance_version(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstance_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstance_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstance_allowedTeams(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstance_allowedTeams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UnleashInstance().AllowedTeams(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*team.Team])
	fc.Result = res
	return ec.marshalNTeamConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstance_allowedTeams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_TeamConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_TeamConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_TeamConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_UnleashInstance_allowedTeams_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstance_webIngress(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstance_webIngress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WebIngress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstance_webIngress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstance_apiIngress(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstance_apiIngress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIIngress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstance_apiIngress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstance_metrics(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstance_metrics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metrics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*unleash.UnleashInstanceMetrics)
	fc.Result = res
	return ec.marshalNUnleashInstanceMetrics2githubcomnaisapiinternalunleashUnleashInstanceMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstance_metrics(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "toggles":
				return ec.fieldContext_UnleashInstanceMetrics_toggles(ctx, field)
			case "apiTokens":
				return ec.fieldContext_UnleashInstanceMetrics_apiTokens(ctx, field)
			case "cpuUtilization":
				return ec.fieldContext_UnleashInstanceMetrics_cpuUtilization(ctx, field)
			case "cpuRequests":
				return ec.fieldContext_UnleashInstanceMetrics_cpuRequests(ctx, field)
			case "memoryUtilization":
				return ec.fieldContext_UnleashInstanceMetrics_memoryUtilization(ctx, field)
			case "memoryRequests":
				return ec.fieldContext_UnleashInstanceMetrics_memoryRequests(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UnleashInstanceMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstance_ready(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstance_ready(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ready, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstance_ready(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceCreatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceCreatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceCreatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceCreatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceCreatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceCreatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceCreatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceCreatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceCreatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceCreatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceCreatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceCreatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceCreatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceCreatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceCreatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceCreatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceCreatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceCreatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceCreatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceCreatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceCreatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceCreatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceCreatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceCreatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceCreatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceCreatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceMetrics_toggles(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceMetrics_toggles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UnleashInstanceMetrics().Toggles(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceMetrics_toggles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceMetrics_apiTokens(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceMetrics_apiTokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UnleashInstanceMetrics().APITokens(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceMetrics_apiTokens(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceMetrics_cpuUtilization(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceMetrics_cpuUtilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UnleashInstanceMetrics().CPUUtilization(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceMetrics_cpuUtilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceMetrics_cpuRequests(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceMetrics_cpuRequests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPURequests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceMetrics_cpuRequests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceMetrics_memoryUtilization(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceMetrics_memoryUtilization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UnleashInstanceMetrics().MemoryUtilization(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceMetrics_memoryUtilization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceMetrics_memoryRequests(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceMetrics_memoryRequests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemoryRequests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceMetrics_memoryRequests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceUpdatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceUpdatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceUpdatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceUpdatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceUpdatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceUpdatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceUpdatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceUpdatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceUpdatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceUpdatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceUpdatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceUpdatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceUpdatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceUpdatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceUpdatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceUpdatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceUpdatedActivityLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*unleash.UnleashInstanceUpdatedActivityLogEntryData)
	fc.Result = res
	return ec.marshalNUnleashInstanceUpdatedActivityLogEntryData2githubcomnaisapiinternalunleashUnleashInstanceUpdatedActivityLogEntryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceUpdatedActivityLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "revokedTeamSlug":
				return ec.fieldContext_UnleashInstanceUpdatedActivityLogEntryData_revokedTeamSlug(ctx, field)
			case "allowedTeamSlug":
				return ec.fieldContext_UnleashInstanceUpdatedActivityLogEntryData_allowedTeamSlug(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UnleashInstanceUpdatedActivityLogEntryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntryData_revokedTeamSlug(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceUpdatedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceUpdatedActivityLogEntryData_revokedTeamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RevokedTeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalOSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceUpdatedActivityLogEntryData_revokedTeamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceUpdatedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntryData_allowedTeamSlug(ctx context.Context, field graphql.CollectedField, obj *unleash.UnleashInstanceUpdatedActivityLogEntryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnleashInstanceUpdatedActivityLogEntryData_allowedTeamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowedTeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalOSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnleashInstanceUpdatedActivityLogEntryData_allowedTeamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnleashInstanceUpdatedActivityLogEntryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateImageVulnerabilityPayload_vulnerability(ctx context.Context, field graphql.CollectedField, obj *vulnerability.UpdateImageVulnerabilityPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateImageVulnerabilityPayload_vulnerability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vulnerability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*vulnerability.ImageVulnerability)
	fc.Result = res
	return ec.marshalOImageVulnerability2githubcomnaisapiinternalvulnerabilityImageVulnerability(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateImageVulnerabilityPayload_vulnerability(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateImageVulnerabilityPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ImageVulnerability_id(ctx, field)
			case "identifier":
				return ec.fieldContext_ImageVulnerability_identifier(ctx, field)
			case "severity":
				return ec.fieldContext_ImageVulnerability_severity(ctx, field)
			case "description":
				return ec.fieldContext_ImageVulnerability_description(ctx, field)
			case "package":
				return ec.fieldContext_ImageVulnerability_package(ctx, field)
			case "state":
				return ec.fieldContext_ImageVulnerability_state(ctx, field)
			case "analysisTrail":
				return ec.fieldContext_ImageVulnerability_analysisTrail(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerability", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateSecretValuePayload_secret(ctx context.Context, field graphql.CollectedField, obj *secret.UpdateSecretValuePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateSecretValuePayload_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*secret.Secret)
	fc.Result = res
	return ec.marshalOSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateSecretValuePayload_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateSecretValuePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Secret_id(ctx, field)
			case "name":
				return ec.fieldContext_Secret_name(ctx, field)
			case "environment":
				return ec.fieldContext_Secret_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_Secret_teamEnvironment(ctx, field)
			case "team":
				return ec.fieldContext_Secret_team(ctx, field)
			case "values":
				return ec.fieldContext_Secret_values(ctx, field)
			case "applications":
				return ec.fieldContext_Secret_applications(ctx, field)
			case "jobs":
				return ec.fieldContext_Secret_jobs(ctx, field)
			case "workloads":
				return ec.fieldContext_Secret_workloads(ctx, field)
			case "lastModifiedAt":
				return ec.fieldContext_Secret_lastModifiedAt(ctx, field)
			case "lastModifiedBy":
				return ec.fieldContext_Secret_lastModifiedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Secret", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateServiceAccountPayload_serviceAccount(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.UpdateServiceAccountPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateServiceAccountPayload_serviceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccount)
	fc.Result = res
	return ec.marshalOServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateServiceAccountPayload_serviceAccount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateServiceAccountPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccount_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccount_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccount_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccount_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccount_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccount_lastUsedAt(ctx, field)
			case "team":
				return ec.fieldContext_ServiceAccount_team(ctx, field)
			case "roles":
				return ec.fieldContext_ServiceAccount_roles(ctx, field)
			case "tokens":
				return ec.fieldContext_ServiceAccount_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateServiceAccountTokenPayload_serviceAccount(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.UpdateServiceAccountTokenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateServiceAccountTokenPayload_serviceAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccount)
	fc.Result = res
	return ec.marshalOServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateServiceAccountTokenPayload_serviceAccount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateServiceAccountTokenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccount_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccount_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccount_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccount_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccount_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccount_lastUsedAt(ctx, field)
			case "team":
				return ec.fieldContext_ServiceAccount_team(ctx, field)
			case "roles":
				return ec.fieldContext_ServiceAccount_roles(ctx, field)
			case "tokens":
				return ec.fieldContext_ServiceAccount_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateServiceAccountTokenPayload_serviceAccountToken(ctx context.Context, field graphql.CollectedField, obj *serviceaccount.UpdateServiceAccountTokenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateServiceAccountTokenPayload_serviceAccountToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccountToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*serviceaccount.ServiceAccountToken)
	fc.Result = res
	return ec.marshalOServiceAccountToken2githubcomnaisapiinternalserviceaccountServiceAccountToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateServiceAccountTokenPayload_serviceAccountToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateServiceAccountTokenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServiceAccountToken_id(ctx, field)
			case "name":
				return ec.fieldContext_ServiceAccountToken_name(ctx, field)
			case "description":
				return ec.fieldContext_ServiceAccountToken_description(ctx, field)
			case "createdAt":
				return ec.fieldContext_ServiceAccountToken_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ServiceAccountToken_updatedAt(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_ServiceAccountToken_lastUsedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_ServiceAccountToken_expiresAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceAccountToken", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamEnvironmentPayload_environment(ctx context.Context, field graphql.CollectedField, obj *team.UpdateTeamEnvironmentPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamEnvironmentPayload_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UpdateTeamEnvironmentPayload().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalOTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamEnvironmentPayload_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamEnvironmentPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamEnvironmentPayload_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *team.UpdateTeamEnvironmentPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamEnvironmentPayload_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamEnvironment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalOTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamEnvironmentPayload_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamEnvironmentPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamPayload_team(ctx context.Context, field graphql.CollectedField, obj *team.UpdateTeamPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamPayload_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Team, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamPayload_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_externalID(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_externalID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_externalID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_teams(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_teams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Teams(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*team.UserTeamOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*team.TeamMember])
	fc.Result = res
	return ec.marshalNTeamMemberConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_teams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_TeamMemberConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_TeamMemberConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_TeamMemberConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMemberConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_teams_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _User_isAdmin(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_isAdmin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAdmin(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_isAdmin(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*user.User]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*user.User]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*user.User)
	fc.Result = res
	return ec.marshalNUser2githubcomnaisapiinternaluserUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*user.User]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*user.User])
	fc.Result = res
	return ec.marshalNUserEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_UserEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_UserEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserCreatedUserSyncLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *usersync.UserCreatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserCreatedUserSyncLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserCreatedUserSyncLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserCreatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserCreatedUserSyncLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *usersync.UserCreatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserCreatedUserSyncLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserCreatedUserSyncLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserCreatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserCreatedUserSyncLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *usersync.UserCreatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserCreatedUserSyncLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserCreatedUserSyncLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserCreatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserCreatedUserSyncLogEntry_userID(ctx context.Context, field graphql.CollectedField, obj *usersync.UserCreatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserCreatedUserSyncLogEntry_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserCreatedUserSyncLogEntry_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserCreatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserCreatedUserSyncLogEntry_userName(ctx context.Context, field graphql.CollectedField, obj *usersync.UserCreatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserCreatedUserSyncLogEntry_userName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserCreatedUserSyncLogEntry_userName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserCreatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserCreatedUserSyncLogEntry_userEmail(ctx context.Context, field graphql.CollectedField, obj *usersync.UserCreatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserCreatedUserSyncLogEntry_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserCreatedUserSyncLogEntry_userEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserCreatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserDeletedUserSyncLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *usersync.UserDeletedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserDeletedUserSyncLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserDeletedUserSyncLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserDeletedUserSyncLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserDeletedUserSyncLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *usersync.UserDeletedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserDeletedUserSyncLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserDeletedUserSyncLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserDeletedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserDeletedUserSyncLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *usersync.UserDeletedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserDeletedUserSyncLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserDeletedUserSyncLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserDeletedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserDeletedUserSyncLogEntry_userID(ctx context.Context, field graphql.CollectedField, obj *usersync.UserDeletedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserDeletedUserSyncLogEntry_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserDeletedUserSyncLogEntry_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserDeletedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserDeletedUserSyncLogEntry_userName(ctx context.Context, field graphql.CollectedField, obj *usersync.UserDeletedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserDeletedUserSyncLogEntry_userName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserDeletedUserSyncLogEntry_userName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserDeletedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserDeletedUserSyncLogEntry_userEmail(ctx context.Context, field graphql.CollectedField, obj *usersync.UserDeletedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserDeletedUserSyncLogEntry_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserDeletedUserSyncLogEntry_userEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserDeletedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*user.User]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*user.User]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*user.User)
	fc.Result = res
	return ec.marshalNUser2githubcomnaisapiinternaluserUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "externalID":
				return ec.fieldContext_User_externalID(ctx, field)
			case "teams":
				return ec.fieldContext_User_teams(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSyncLogEntryConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[usersync.UserSyncLogEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSyncLogEntryConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSyncLogEntryConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSyncLogEntryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSyncLogEntryConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[usersync.UserSyncLogEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSyncLogEntryConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]usersync.UserSyncLogEntry)
	fc.Result = res
	return ec.marshalNUserSyncLogEntry2githubcomnaisapiinternalusersyncUserSyncLogEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSyncLogEntryConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSyncLogEntryConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSyncLogEntryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[usersync.UserSyncLogEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSyncLogEntryConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[usersync.UserSyncLogEntry])
	fc.Result = res
	return ec.marshalNUserSyncLogEntryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSyncLogEntryConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSyncLogEntryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_UserSyncLogEntryEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_UserSyncLogEntryEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSyncLogEntryEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSyncLogEntryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[usersync.UserSyncLogEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSyncLogEntryEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSyncLogEntryEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSyncLogEntryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSyncLogEntryEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[usersync.UserSyncLogEntry]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSyncLogEntryEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(usersync.UserSyncLogEntry)
	fc.Result = res
	return ec.marshalNUserSyncLogEntry2githubcomnaisapiinternalusersyncUserSyncLogEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSyncLogEntryEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSyncLogEntryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserUpdatedUserSyncLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *usersync.UserUpdatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserUpdatedUserSyncLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserUpdatedUserSyncLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserUpdatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserUpdatedUserSyncLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *usersync.UserUpdatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserUpdatedUserSyncLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserUpdatedUserSyncLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserUpdatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserUpdatedUserSyncLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *usersync.UserUpdatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserUpdatedUserSyncLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserUpdatedUserSyncLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserUpdatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserUpdatedUserSyncLogEntry_userID(ctx context.Context, field graphql.CollectedField, obj *usersync.UserUpdatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserUpdatedUserSyncLogEntry_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserUpdatedUserSyncLogEntry_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserUpdatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserUpdatedUserSyncLogEntry_userName(ctx context.Context, field graphql.CollectedField, obj *usersync.UserUpdatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserUpdatedUserSyncLogEntry_userName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserUpdatedUserSyncLogEntry_userName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserUpdatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserUpdatedUserSyncLogEntry_userEmail(ctx context.Context, field graphql.CollectedField, obj *usersync.UserUpdatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserUpdatedUserSyncLogEntry_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserUpdatedUserSyncLogEntry_userEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserUpdatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserUpdatedUserSyncLogEntry_oldUserName(ctx context.Context, field graphql.CollectedField, obj *usersync.UserUpdatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserUpdatedUserSyncLogEntry_oldUserName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldUserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserUpdatedUserSyncLogEntry_oldUserName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserUpdatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserUpdatedUserSyncLogEntry_oldUserEmail(ctx context.Context, field graphql.CollectedField, obj *usersync.UserUpdatedUserSyncLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserUpdatedUserSyncLogEntry_oldUserEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldUserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserUpdatedUserSyncLogEntry_oldUserEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserUpdatedUserSyncLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UtilizationSample_timestamp(ctx context.Context, field graphql.CollectedField, obj *utilization.UtilizationSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UtilizationSample_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UtilizationSample_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UtilizationSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UtilizationSample_value(ctx context.Context, field graphql.CollectedField, obj *utilization.UtilizationSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UtilizationSample_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UtilizationSample_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UtilizationSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UtilizationSample_instance(ctx context.Context, field graphql.CollectedField, obj *utilization.UtilizationSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UtilizationSample_instance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Instance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UtilizationSample_instance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UtilizationSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstance_id(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstance_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstance_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstance_name(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstance_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstance_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstance_team(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstance_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ValkeyInstance().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstance_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "slug":
				return ec.fieldContext_Team_slug(ctx, field)
			case "slackChannel":
				return ec.fieldContext_Team_slackChannel(ctx, field)
			case "purpose":
				return ec.fieldContext_Team_purpose(ctx, field)
			case "externalResources":
				return ec.fieldContext_Team_externalResources(ctx, field)
			case "member":
				return ec.fieldContext_Team_member(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "lastSuccessfulSync":
				return ec.fieldContext_Team_lastSuccessfulSync(ctx, field)
			case "deletionInProgress":
				return ec.fieldContext_Team_deletionInProgress(ctx, field)
			case "viewerIsOwner":
				return ec.fieldContext_Team_viewerIsOwner(ctx, field)
			case "viewerIsMember":
				return ec.fieldContext_Team_viewerIsMember(ctx, field)
			case "environments":
				return ec.fieldContext_Team_environments(ctx, field)
			case "environment":
				return ec.fieldContext_Team_environment(ctx, field)
			case "deleteKey":
				return ec.fieldContext_Team_deleteKey(ctx, field)
			case "inventoryCounts":
				return ec.fieldContext_Team_inventoryCounts(ctx, field)
			case "activityLog":
				return ec.fieldContext_Team_activityLog(ctx, field)
			case "applications":
				return ec.fieldContext_Team_applications(ctx, field)
			case "bigQueryDatasets":
				return ec.fieldContext_Team_bigQueryDatasets(ctx, field)
			case "buckets":
				return ec.fieldContext_Team_buckets(ctx, field)
			case "cost":
				return ec.fieldContext_Team_cost(ctx, field)
			case "deploymentKey":
				return ec.fieldContext_Team_deploymentKey(ctx, field)
			case "deployments":
				return ec.fieldContext_Team_deployments(ctx, field)
			case "jobs":
				return ec.fieldContext_Team_jobs(ctx, field)
			case "kafkaTopics":
				return ec.fieldContext_Team_kafkaTopics(ctx, field)
			case "openSearchInstances":
				return ec.fieldContext_Team_openSearchInstances(ctx, field)
			case "redisInstances":
				return ec.fieldContext_Team_redisInstances(ctx, field)
			case "repositories":
				return ec.fieldContext_Team_repositories(ctx, field)
			case "secrets":
				return ec.fieldContext_Team_secrets(ctx, field)
			case "sqlInstances":
				return ec.fieldContext_Team_sqlInstances(ctx, field)
			case "unleash":
				return ec.fieldContext_Team_unleash(ctx, field)
			case "workloadUtilization":
				return ec.fieldContext_Team_workloadUtilization(ctx, field)
			case "serviceUtilization":
				return ec.fieldContext_Team_serviceUtilization(ctx, field)
			case "valkeyInstances":
				return ec.fieldContext_Team_valkeyInstances(ctx, field)
			case "vulnerabilitySummary":
				return ec.fieldContext_Team_vulnerabilitySummary(ctx, field)
			case "workloads":
				return ec.fieldContext_Team_workloads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstance_environment(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstance_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ValkeyInstance().Environment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstance_environment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstance_teamEnvironment(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstance_teamEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ValkeyInstance().TeamEnvironment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*team.TeamEnvironment)
	fc.Result = res
	return ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstance_teamEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamEnvironment_id(ctx, field)
			case "name":
				return ec.fieldContext_TeamEnvironment_name(ctx, field)
			case "gcpProjectID":
				return ec.fieldContext_TeamEnvironment_gcpProjectID(ctx, field)
			case "slackAlertsChannel":
				return ec.fieldContext_TeamEnvironment_slackAlertsChannel(ctx, field)
			case "team":
				return ec.fieldContext_TeamEnvironment_team(ctx, field)
			case "application":
				return ec.fieldContext_TeamEnvironment_application(ctx, field)
			case "bigQueryDataset":
				return ec.fieldContext_TeamEnvironment_bigQueryDataset(ctx, field)
			case "bucket":
				return ec.fieldContext_TeamEnvironment_bucket(ctx, field)
			case "cost":
				return ec.fieldContext_TeamEnvironment_cost(ctx, field)
			case "environment":
				return ec.fieldContext_TeamEnvironment_environment(ctx, field)
			case "job":
				return ec.fieldContext_TeamEnvironment_job(ctx, field)
			case "kafkaTopic":
				return ec.fieldContext_TeamEnvironment_kafkaTopic(ctx, field)
			case "openSearchInstance":
				return ec.fieldContext_TeamEnvironment_openSearchInstance(ctx, field)
			case "redisInstance":
				return ec.fieldContext_TeamEnvironment_redisInstance(ctx, field)
			case "secret":
				return ec.fieldContext_TeamEnvironment_secret(ctx, field)
			case "sqlInstance":
				return ec.fieldContext_TeamEnvironment_sqlInstance(ctx, field)
			case "valkeyInstance":
				return ec.fieldContext_TeamEnvironment_valkeyInstance(ctx, field)
			case "workload":
				return ec.fieldContext_TeamEnvironment_workload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamEnvironment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstance_access(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstance_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ValkeyInstance().Access(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*pagination.Cursor), fc.Args["last"].(*int), fc.Args["before"].(*pagination.Cursor), fc.Args["orderBy"].(*valkey.ValkeyInstanceAccessOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*pagination.Connection[*valkey.ValkeyInstanceAccess])
	fc.Result = res
	return ec.marshalNValkeyInstanceAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstance_access(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_ValkeyInstanceAccessConnection_pageInfo(ctx, field)
			case "nodes":
				return ec.fieldContext_ValkeyInstanceAccessConnection_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_ValkeyInstanceAccessConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstanceAccessConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValkeyInstance_access_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstance_workload(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstance_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ValkeyInstance().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstance_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstance_status(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstance_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*valkey.ValkeyInstanceStatus)
	fc.Result = res
	return ec.marshalNValkeyInstanceStatus2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstance_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_ValkeyInstanceStatus_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstanceStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstance_cost(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstance_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ValkeyInstance().Cost(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.ValkeyInstanceCost)
	fc.Result = res
	return ec.marshalNValkeyInstanceCost2githubcomnaisapiinternalcostValkeyInstanceCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstance_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_ValkeyInstanceCost_sum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstanceCost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceAccess_workload(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstanceAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceAccess_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ValkeyInstanceAccess().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceAccess_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceAccess",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceAccess_access(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstanceAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceAccess_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceAccess_access(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceAccessConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*valkey.ValkeyInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceAccessConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceAccessConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceAccessConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*valkey.ValkeyInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceAccessConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*valkey.ValkeyInstanceAccess)
	fc.Result = res
	return ec.marshalNValkeyInstanceAccess2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceAccessConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceAccessConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_ValkeyInstanceAccess_workload(ctx, field)
			case "access":
				return ec.fieldContext_ValkeyInstanceAccess_access(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstanceAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceAccessConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*valkey.ValkeyInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceAccessConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*valkey.ValkeyInstanceAccess])
	fc.Result = res
	return ec.marshalNValkeyInstanceAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceAccessConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceAccessConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ValkeyInstanceAccessEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ValkeyInstanceAccessEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstanceAccessEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceAccessEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*valkey.ValkeyInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceAccessEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceAccessEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceAccessEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*valkey.ValkeyInstanceAccess]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceAccessEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*valkey.ValkeyInstanceAccess)
	fc.Result = res
	return ec.marshalNValkeyInstanceAccess2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceAccessEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceAccessEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_ValkeyInstanceAccess_workload(ctx, field)
			case "access":
				return ec.fieldContext_ValkeyInstanceAccess_access(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstanceAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*valkey.ValkeyInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*valkey.ValkeyInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*valkey.ValkeyInstance)
	fc.Result = res
	return ec.marshalNValkeyInstance2githubcomnaisapiinternalpersistencevalkeyValkeyInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ValkeyInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_ValkeyInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_ValkeyInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_ValkeyInstance_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_ValkeyInstance_teamEnvironment(ctx, field)
			case "access":
				return ec.fieldContext_ValkeyInstance_access(ctx, field)
			case "workload":
				return ec.fieldContext_ValkeyInstance_workload(ctx, field)
			case "status":
				return ec.fieldContext_ValkeyInstance_status(ctx, field)
			case "cost":
				return ec.fieldContext_ValkeyInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[*valkey.ValkeyInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[*valkey.ValkeyInstance])
	fc.Result = res
	return ec.marshalNValkeyInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ValkeyInstanceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ValkeyInstanceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstanceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceCost_sum(ctx context.Context, field graphql.CollectedField, obj *cost.ValkeyInstanceCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceCost_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceCost_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceCost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*valkey.ValkeyInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[*valkey.ValkeyInstance]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*valkey.ValkeyInstance)
	fc.Result = res
	return ec.marshalNValkeyInstance2githubcomnaisapiinternalpersistencevalkeyValkeyInstance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ValkeyInstance_id(ctx, field)
			case "name":
				return ec.fieldContext_ValkeyInstance_name(ctx, field)
			case "team":
				return ec.fieldContext_ValkeyInstance_team(ctx, field)
			case "environment":
				return ec.fieldContext_ValkeyInstance_environment(ctx, field)
			case "teamEnvironment":
				return ec.fieldContext_ValkeyInstance_teamEnvironment(ctx, field)
			case "access":
				return ec.fieldContext_ValkeyInstance_access(ctx, field)
			case "workload":
				return ec.fieldContext_ValkeyInstance_workload(ctx, field)
			case "status":
				return ec.fieldContext_ValkeyInstance_status(ctx, field)
			case "cost":
				return ec.fieldContext_ValkeyInstance_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValkeyInstance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValkeyInstanceStatus_state(ctx context.Context, field graphql.CollectedField, obj *valkey.ValkeyInstanceStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValkeyInstanceStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValkeyInstanceStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValkeyInstanceStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerabilityUpdatedActivityLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *vulnerability.VulnerabilityUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VulnerabilityUpdatedActivityLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ident.Ident)
	fc.Result = res
	return ec.marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VulnerabilityUpdatedActivityLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerabilityUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerabilityUpdatedActivityLogEntry_actor(ctx context.Context, field graphql.CollectedField, obj *vulnerability.VulnerabilityUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VulnerabilityUpdatedActivityLogEntry_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VulnerabilityUpdatedActivityLogEntry_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerabilityUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerabilityUpdatedActivityLogEntry_createdAt(ctx context.Context, field graphql.CollectedField, obj *vulnerability.VulnerabilityUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VulnerabilityUpdatedActivityLogEntry_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VulnerabilityUpdatedActivityLogEntry_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerabilityUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerabilityUpdatedActivityLogEntry_message(ctx context.Context, field graphql.CollectedField, obj *vulnerability.VulnerabilityUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VulnerabilityUpdatedActivityLogEntry_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VulnerabilityUpdatedActivityLogEntry_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerabilityUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerabilityUpdatedActivityLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *vulnerability.VulnerabilityUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VulnerabilityUpdatedActivityLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(activitylog.ActivityLogEntryResourceType)
	fc.Result = res
	return ec.marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VulnerabilityUpdatedActivityLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerabilityUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActivityLogEntryResourceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerabilityUpdatedActivityLogEntry_resourceName(ctx context.Context, field graphql.CollectedField, obj *vulnerability.VulnerabilityUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VulnerabilityUpdatedActivityLogEntry_resourceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VulnerabilityUpdatedActivityLogEntry_resourceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerabilityUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerabilityUpdatedActivityLogEntry_teamSlug(ctx context.Context, field graphql.CollectedField, obj *vulnerability.VulnerabilityUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VulnerabilityUpdatedActivityLogEntry_teamSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*slug.Slug)
	fc.Result = res
	return ec.marshalNSlug2githubcomnaisapiinternalslugSlug(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VulnerabilityUpdatedActivityLogEntry_teamSlug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerabilityUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Slug does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VulnerabilityUpdatedActivityLogEntry_environmentName(ctx context.Context, field graphql.CollectedField, obj *vulnerability.VulnerabilityUpdatedActivityLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VulnerabilityUpdatedActivityLogEntry_environmentName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VulnerabilityUpdatedActivityLogEntry_environmentName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VulnerabilityUpdatedActivityLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[workload.Workload]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "totalCount":
				return ec.fieldContext_PageInfo_totalCount(ctx, field)
			case "pageStart":
				return ec.fieldContext_PageInfo_pageStart(ctx, field)
			case "pageEnd":
				return ec.fieldContext_PageInfo_pageEnd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[workload.Workload]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadConnection_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadConnection_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadConnection_edges(ctx context.Context, field graphql.CollectedField, obj *pagination.Connection[workload.Workload]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]pagination.Edge[workload.Workload])
	fc.Result = res
	return ec.marshalNWorkloadEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_WorkloadEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_WorkloadEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCost_daily(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCost_daily(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadCost().Daily(rctx, obj, fc.Args["from"].(scalar.Date), fc.Args["to"].(scalar.Date))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.WorkloadCostPeriod)
	fc.Result = res
	return ec.marshalNWorkloadCostPeriod2githubcomnaisapiinternalcostWorkloadCostPeriod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCost_daily(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_WorkloadCostPeriod_sum(ctx, field)
			case "series":
				return ec.fieldContext_WorkloadCostPeriod_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadCostPeriod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkloadCost_daily_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCost_monthly(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCost_monthly(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadCost().Monthly(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cost.WorkloadCostPeriod)
	fc.Result = res
	return ec.marshalNWorkloadCostPeriod2githubcomnaisapiinternalcostWorkloadCostPeriod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCost_monthly(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sum":
				return ec.fieldContext_WorkloadCostPeriod_sum(ctx, field)
			case "series":
				return ec.fieldContext_WorkloadCostPeriod_series(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadCostPeriod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCostPeriod_sum(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCostPeriod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCostPeriod_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCostPeriod_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCostPeriod",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCostPeriod_series(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCostPeriod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCostPeriod_series(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Series, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*cost.ServiceCostSeries)
	fc.Result = res
	return ec.marshalNServiceCostSeries2githubcomnaisapiinternalcostServiceCostSeries(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCostPeriod_series(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCostPeriod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "date":
				return ec.fieldContext_ServiceCostSeries_date(ctx, field)
			case "sum":
				return ec.fieldContext_ServiceCostSeries_sum(ctx, field)
			case "services":
				return ec.fieldContext_ServiceCostSeries_services(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceCostSeries", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCostSample_workload(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCostSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCostSample_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadCostSample().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalOWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCostSample_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCostSample",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCostSample_workloadName(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCostSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCostSample_workloadName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkloadName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCostSample_workloadName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCostSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCostSample_cost(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCostSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCostSample_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCostSample_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCostSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCostSeries_date(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCostSeries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCostSeries_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(scalar.Date)
	fc.Result = res
	return ec.marshalNDate2githubcomnaisapiinternalgraphscalarDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCostSeries_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCostSeries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCostSeries_sum(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCostSeries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCostSeries_sum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCostSeries_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCostSeries",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadCostSeries_workloads(ctx context.Context, field graphql.CollectedField, obj *cost.WorkloadCostSeries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadCostSeries_workloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workloads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*cost.WorkloadCostSample)
	fc.Result = res
	return ec.marshalNWorkloadCostSample2githubcomnaisapiinternalcostWorkloadCostSample(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadCostSeries_workloads(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadCostSeries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "workload":
				return ec.fieldContext_WorkloadCostSample_workload(ctx, field)
			case "workloadName":
				return ec.fieldContext_WorkloadCostSample_workloadName(ctx, field)
			case "cost":
				return ec.fieldContext_WorkloadCostSample_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkloadCostSample", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[workload.Workload]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pagination.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadEdge_node(ctx context.Context, field graphql.CollectedField, obj *pagination.Edge[workload.Workload]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadLogLine_time(ctx context.Context, field graphql.CollectedField, obj *podlog.WorkloadLogLine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadLogLine_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadLogLine_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadLogLine",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadLogLine_message(ctx context.Context, field graphql.CollectedField, obj *podlog.WorkloadLogLine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadLogLine_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadLogLine_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadLogLine",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadLogLine_instance(ctx context.Context, field graphql.CollectedField, obj *podlog.WorkloadLogLine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadLogLine_instance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Instance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadLogLine_instance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadLogLine",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadResourceQuantity_cpu(ctx context.Context, field graphql.CollectedField, obj *workload.WorkloadResourceQuantity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadResourceQuantity_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadResourceQuantity_cpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadResourceQuantity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadResourceQuantity_memory(ctx context.Context, field graphql.CollectedField, obj *workload.WorkloadResourceQuantity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadResourceQuantity_memory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Memory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadResourceQuantity_memory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadResourceQuantity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatus_state(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadState)
	fc.Result = res
	return ec.marshalNWorkloadState2githubcomnaisapiinternalstatusWorkloadState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatus_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatus_errors(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatus_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]status.WorkloadStatusError)
	fc.Result = res
	return ec.marshalNWorkloadStatusError2githubcomnaisapiinternalstatusWorkloadStatusError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatus_errors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusDeprecatedIngress_level(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusDeprecatedIngress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusDeprecatedIngress_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadStatusErrorLevel)
	fc.Result = res
	return ec.marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusDeprecatedIngress_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusDeprecatedIngress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadStatusErrorLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusDeprecatedIngress_ingress(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusDeprecatedIngress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusDeprecatedIngress_ingress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ingress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusDeprecatedIngress_ingress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusDeprecatedIngress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusDeprecatedRegistry_level(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusDeprecatedRegistry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusDeprecatedRegistry_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadStatusErrorLevel)
	fc.Result = res
	return ec.marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusDeprecatedRegistry_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusDeprecatedRegistry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadStatusErrorLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusDeprecatedRegistry_registry(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusDeprecatedRegistry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusDeprecatedRegistry_registry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Registry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusDeprecatedRegistry_registry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusDeprecatedRegistry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusDeprecatedRegistry_repository(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusDeprecatedRegistry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusDeprecatedRegistry_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusDeprecatedRegistry_repository(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusDeprecatedRegistry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusDeprecatedRegistry_name(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusDeprecatedRegistry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusDeprecatedRegistry_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusDeprecatedRegistry_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusDeprecatedRegistry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusDeprecatedRegistry_tag(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusDeprecatedRegistry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusDeprecatedRegistry_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusDeprecatedRegistry_tag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusDeprecatedRegistry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusFailedRun_level(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusFailedRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusFailedRun_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadStatusErrorLevel)
	fc.Result = res
	return ec.marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusFailedRun_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusFailedRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadStatusErrorLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusFailedRun_detail(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusFailedRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusFailedRun_detail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Detail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusFailedRun_detail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusFailedRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusFailedRun_name(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusFailedRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusFailedRun_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusFailedRun_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusFailedRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusInboundNetwork_level(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusInboundNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusInboundNetwork_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadStatusErrorLevel)
	fc.Result = res
	return ec.marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusInboundNetwork_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusInboundNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadStatusErrorLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusInboundNetwork_policy(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusInboundNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusInboundNetwork_policy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Policy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*netpol.NetworkPolicyRule)
	fc.Result = res
	return ec.marshalNNetworkPolicyRule2githubcomnaisapiinternalworkloadnetpolNetworkPolicyRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusInboundNetwork_policy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusInboundNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "targetWorkloadName":
				return ec.fieldContext_NetworkPolicyRule_targetWorkloadName(ctx, field)
			case "targetWorkload":
				return ec.fieldContext_NetworkPolicyRule_targetWorkload(ctx, field)
			case "targetTeamSlug":
				return ec.fieldContext_NetworkPolicyRule_targetTeamSlug(ctx, field)
			case "targetTeam":
				return ec.fieldContext_NetworkPolicyRule_targetTeam(ctx, field)
			case "mutual":
				return ec.fieldContext_NetworkPolicyRule_mutual(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkPolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusInvalidNaisYaml_level(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusInvalidNaisYaml) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusInvalidNaisYaml_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadStatusErrorLevel)
	fc.Result = res
	return ec.marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusInvalidNaisYaml_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusInvalidNaisYaml",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadStatusErrorLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusInvalidNaisYaml_detail(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusInvalidNaisYaml) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusInvalidNaisYaml_detail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Detail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusInvalidNaisYaml_detail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusInvalidNaisYaml",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusMissingSBOM_level(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusMissingSBOM) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusMissingSBOM_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadStatusErrorLevel)
	fc.Result = res
	return ec.marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusMissingSBOM_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusMissingSBOM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadStatusErrorLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusNewInstancesFailing_level(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusNewInstancesFailing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusNewInstancesFailing_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadStatusErrorLevel)
	fc.Result = res
	return ec.marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusNewInstancesFailing_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusNewInstancesFailing",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadStatusErrorLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusNewInstancesFailing_failingInstances(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusNewInstancesFailing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusNewInstancesFailing_failingInstances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailingInstances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusNewInstancesFailing_failingInstances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusNewInstancesFailing",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusNoRunningInstances_level(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusNoRunningInstances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusNoRunningInstances_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadStatusErrorLevel)
	fc.Result = res
	return ec.marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusNoRunningInstances_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusNoRunningInstances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadStatusErrorLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusOutboundNetwork_level(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusOutboundNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusOutboundNetwork_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadStatusErrorLevel)
	fc.Result = res
	return ec.marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusOutboundNetwork_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusOutboundNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadStatusErrorLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusOutboundNetwork_policy(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusOutboundNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusOutboundNetwork_policy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Policy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*netpol.NetworkPolicyRule)
	fc.Result = res
	return ec.marshalNNetworkPolicyRule2githubcomnaisapiinternalworkloadnetpolNetworkPolicyRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusOutboundNetwork_policy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusOutboundNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "targetWorkloadName":
				return ec.fieldContext_NetworkPolicyRule_targetWorkloadName(ctx, field)
			case "targetWorkload":
				return ec.fieldContext_NetworkPolicyRule_targetWorkload(ctx, field)
			case "targetTeamSlug":
				return ec.fieldContext_NetworkPolicyRule_targetTeamSlug(ctx, field)
			case "targetTeam":
				return ec.fieldContext_NetworkPolicyRule_targetTeam(ctx, field)
			case "mutual":
				return ec.fieldContext_NetworkPolicyRule_mutual(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkPolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusSynchronizationFailing_level(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusSynchronizationFailing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusSynchronizationFailing_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadStatusErrorLevel)
	fc.Result = res
	return ec.marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusSynchronizationFailing_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusSynchronizationFailing",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadStatusErrorLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusSynchronizationFailing_detail(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusSynchronizationFailing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusSynchronizationFailing_detail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Detail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusSynchronizationFailing_detail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusSynchronizationFailing",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusVulnerable_level(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusVulnerable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusVulnerable_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(status.WorkloadStatusErrorLevel)
	fc.Result = res
	return ec.marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusVulnerable_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusVulnerable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorkloadStatusErrorLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadStatusVulnerable_summary(ctx context.Context, field graphql.CollectedField, obj *status.WorkloadStatusVulnerable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadStatusVulnerable_summary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Summary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*vulnerability.ImageVulnerabilitySummary)
	fc.Result = res
	return ec.marshalNImageVulnerabilitySummary2githubcomnaisapiinternalvulnerabilityImageVulnerabilitySummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadStatusVulnerable_summary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadStatusVulnerable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_ImageVulnerabilitySummary_total(ctx, field)
			case "riskScore":
				return ec.fieldContext_ImageVulnerabilitySummary_riskScore(ctx, field)
			case "low":
				return ec.fieldContext_ImageVulnerabilitySummary_low(ctx, field)
			case "medium":
				return ec.fieldContext_ImageVulnerabilitySummary_medium(ctx, field)
			case "high":
				return ec.fieldContext_ImageVulnerabilitySummary_high(ctx, field)
			case "critical":
				return ec.fieldContext_ImageVulnerabilitySummary_critical(ctx, field)
			case "unassigned":
				return ec.fieldContext_ImageVulnerabilitySummary_unassigned(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageVulnerabilitySummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilization_current(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilization_current(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadUtilization().Current(rctx, obj, fc.Args["resourceType"].(utilization.UtilizationResourceType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilization_current(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilization",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkloadUtilization_current_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilization_requested(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilization_requested(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadUtilization().Requested(rctx, obj, fc.Args["resourceType"].(utilization.UtilizationResourceType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilization_requested(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilization",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkloadUtilization_requested_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilization_limit(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilization_limit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadUtilization().Limit(rctx, obj, fc.Args["resourceType"].(utilization.UtilizationResourceType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilization_limit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilization",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkloadUtilization_limit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilization_series(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilization_series(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadUtilization().Series(rctx, obj, fc.Args["input"].(utilization.WorkloadUtilizationSeriesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*utilization.UtilizationSample)
	fc.Result = res
	return ec.marshalNUtilizationSample2githubcomnaisapiinternalutilizationUtilizationSample(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilization_series(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilization",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "timestamp":
				return ec.fieldContext_UtilizationSample_timestamp(ctx, field)
			case "value":
				return ec.fieldContext_UtilizationSample_value(ctx, field)
			case "instance":
				return ec.fieldContext_UtilizationSample_instance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UtilizationSample", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkloadUtilization_series_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilizationData_workload(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilizationData_workload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkloadUtilizationData().Workload(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(workload.Workload)
	fc.Result = res
	return ec.marshalNWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilizationData_workload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilizationData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilizationData_requested(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilizationData_requested(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requested, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilizationData_requested(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilizationData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkloadUtilizationData_used(ctx context.Context, field graphql.CollectedField, obj *utilization.WorkloadUtilizationData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkloadUtilizationData_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkloadUtilizationData_used(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkloadUtilizationData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddRepositoryToTeamInput(ctx context.Context, obj any) (repository.AddRepositoryToTeamInput, error) {
	var it repository.AddRepositoryToTeamInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "repositoryName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "repositoryName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repositoryName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepositoryName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddSecretValueInput(ctx context.Context, obj any) (secret.AddSecretValueInput, error) {
	var it secret.AddSecretValueInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "environment", "team", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "environment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environment = data
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Team = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNSecretValueInput2githubcomnaisapiinternalworkloadsecretSecretValueInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddTeamMemberInput(ctx context.Context, obj any) (team.AddTeamMemberInput, error) {
	var it team.AddTeamMemberInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "userEmail", "role"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "userEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userEmail"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserEmail = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalNTeamMemberRole2githubcomnaisapiinternalteamTeamMemberRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAllowTeamAccessToUnleashInput(ctx context.Context, obj any) (unleash.AllowTeamAccessToUnleashInput, error) {
	var it unleash.AllowTeamAccessToUnleashInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "allowedTeamSlug"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "allowedTeamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedTeamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowedTeamSlug = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationOrder(ctx context.Context, obj any) (application.ApplicationOrder, error) {
	var it application.ApplicationOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNApplicationOrderField2githubcomnaisapiinternalworkloadapplicationApplicationOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAssignRoleToServiceAccountInput(ctx context.Context, obj any) (serviceaccount.AssignRoleToServiceAccountInput, error) {
	var it serviceaccount.AssignRoleToServiceAccountInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"serviceAccountID", "roleName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "serviceAccountID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceAccountID"))
			data, err := ec.unmarshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceAccountID = data
		case "roleName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoleName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBigQueryDatasetAccessOrder(ctx context.Context, obj any) (bigquery.BigQueryDatasetAccessOrder, error) {
	var it bigquery.BigQueryDatasetAccessOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNBigQueryDatasetAccessOrderField2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetAccessOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBigQueryDatasetOrder(ctx context.Context, obj any) (bigquery.BigQueryDatasetOrder, error) {
	var it bigquery.BigQueryDatasetOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNBigQueryDatasetOrderField2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBucketOrder(ctx context.Context, obj any) (bucket.BucketOrder, error) {
	var it bucket.BucketOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNBucketOrderField2githubcomnaisapiinternalpersistencebucketBucketOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChangeDeploymentKeyInput(ctx context.Context, obj any) (deployment.ChangeDeploymentKeyInput, error) {
	var it deployment.ChangeDeploymentKeyInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputConfigureReconcilerInput(ctx context.Context, obj any) (reconciler.ConfigureReconcilerInput, error) {
	var it reconciler.ConfigureReconcilerInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "config"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "config":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("config"))
			data, err := ec.unmarshalNReconcilerConfigInput2githubcomnaisapiinternalreconcilerReconcilerConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Config = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputConfirmTeamDeletionInput(ctx context.Context, obj any) (team.ConfirmTeamDeletionInput, error) {
	var it team.ConfirmTeamDeletionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"slug", "key"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "slug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slug = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateSecretInput(ctx context.Context, obj any) (secret.CreateSecretInput, error) {
	var it secret.CreateSecretInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "environment", "team"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "environment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environment = data
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Team = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateServiceAccountInput(ctx context.Context, obj any) (serviceaccount.CreateServiceAccountInput, error) {
	var it serviceaccount.CreateServiceAccountInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "teamSlug"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalOSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateServiceAccountTokenInput(ctx context.Context, obj any) (serviceaccount.CreateServiceAccountTokenInput, error) {
	var it serviceaccount.CreateServiceAccountTokenInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"serviceAccountID", "name", "description", "expiresAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "serviceAccountID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceAccountID"))
			data, err := ec.unmarshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceAccountID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalODate2githubcomnaisapiinternalgraphscalarDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTeamInput(ctx context.Context, obj any) (team.CreateTeamInput, error) {
	var it team.CreateTeamInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"slug", "purpose", "slackChannel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "slug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slug = data
		case "purpose":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("purpose"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Purpose = data
		case "slackChannel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackChannel"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackChannel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUnleashForTeamInput(ctx context.Context, obj any) (unleash.CreateUnleashForTeamInput, error) {
	var it unleash.CreateUnleashForTeamInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteApplicationInput(ctx context.Context, obj any) (application.DeleteApplicationInput, error) {
	var it application.DeleteApplicationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "teamSlug", "environmentName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "environmentName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environmentName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnvironmentName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteJobInput(ctx context.Context, obj any) (job.DeleteJobInput, error) {
	var it job.DeleteJobInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "teamSlug", "environmentName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "environmentName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environmentName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnvironmentName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteSecretInput(ctx context.Context, obj any) (secret.DeleteSecretInput, error) {
	var it secret.DeleteSecretInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "environment", "team"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "environment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environment = data
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Team = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteServiceAccountInput(ctx context.Context, obj any) (serviceaccount.DeleteServiceAccountInput, error) {
	var it serviceaccount.DeleteServiceAccountInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"serviceAccountID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "serviceAccountID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceAccountID"))
			data, err := ec.unmarshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceAccountID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteServiceAccountTokenInput(ctx context.Context, obj any) (serviceaccount.DeleteServiceAccountTokenInput, error) {
	var it serviceaccount.DeleteServiceAccountTokenInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"serviceAccountTokenID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "serviceAccountTokenID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceAccountTokenID"))
			data, err := ec.unmarshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceAccountTokenID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDisableReconcilerInput(ctx context.Context, obj any) (reconciler.DisableReconcilerInput, error) {
	var it reconciler.DisableReconcilerInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEnableReconcilerInput(ctx context.Context, obj any) (reconciler.EnableReconcilerInput, error) {
	var it reconciler.EnableReconcilerInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEnvironmentOrder(ctx context.Context, obj any) (environment.EnvironmentOrder, error) {
	var it environment.EnvironmentOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNEnvironmentOrderField2githubcomnaisapiinternalenvironmentEnvironmentOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEnvironmentWorkloadOrder(ctx context.Context, obj any) (workload.EnvironmentWorkloadOrder, error) {
	var it workload.EnvironmentWorkloadOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNEnvironmentWorkloadOrderField2githubcomnaisapiinternalworkloadEnvironmentWorkloadOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageVulnerabilityOrder(ctx context.Context, obj any) (vulnerability.ImageVulnerabilityOrder, error) {
	var it vulnerability.ImageVulnerabilityOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNImageVulnerabilityOrderField2githubcomnaisapiinternalvulnerabilityImageVulnerabilityOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJobOrder(ctx context.Context, obj any) (job.JobOrder, error) {
	var it job.JobOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNJobOrderField2githubcomnaisapiinternalworkloadjobJobOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKafkaTopicAclFilter(ctx context.Context, obj any) (kafkatopic.KafkaTopicACLFilter, error) {
	var it kafkatopic.KafkaTopicACLFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"team", "workload", "validWorkloads"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			data, err := ec.unmarshalOSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Team = data
		case "workload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workload"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Workload = data
		case "validWorkloads":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validWorkloads"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValidWorkloads = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKafkaTopicAclOrder(ctx context.Context, obj any) (kafkatopic.KafkaTopicACLOrder, error) {
	var it kafkatopic.KafkaTopicACLOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNKafkaTopicAclOrderField2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACLOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKafkaTopicOrder(ctx context.Context, obj any) (kafkatopic.KafkaTopicOrder, error) {
	var it kafkatopic.KafkaTopicOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNKafkaTopicOrderField2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOpenSearchAccessOrder(ctx context.Context, obj any) (opensearch.OpenSearchAccessOrder, error) {
	var it opensearch.OpenSearchAccessOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNOpenSearchAccessOrderField2githubcomnaisapiinternalpersistenceopensearchOpenSearchAccessOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOpenSearchOrder(ctx context.Context, obj any) (opensearch.OpenSearchOrder, error) {
	var it opensearch.OpenSearchOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNOpenSearchOrderField2githubcomnaisapiinternalpersistenceopensearchOpenSearchOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputReconcilerConfigInput(ctx context.Context, obj any) (reconciler.ReconcilerConfigInput, error) {
	var it reconciler.ReconcilerConfigInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRedisInstanceAccessOrder(ctx context.Context, obj any) (redis.RedisInstanceAccessOrder, error) {
	var it redis.RedisInstanceAccessOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNRedisInstanceAccessOrderField2githubcomnaisapiinternalpersistenceredisRedisInstanceAccessOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRedisInstanceOrder(ctx context.Context, obj any) (redis.RedisInstanceOrder, error) {
	var it redis.RedisInstanceOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNRedisInstanceOrderField2githubcomnaisapiinternalpersistenceredisRedisInstanceOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveRepositoryFromTeamInput(ctx context.Context, obj any) (repository.RemoveRepositoryFromTeamInput, error) {
	var it repository.RemoveRepositoryFromTeamInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "repositoryName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "repositoryName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repositoryName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepositoryName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveSecretValueInput(ctx context.Context, obj any) (secret.RemoveSecretValueInput, error) {
	var it secret.RemoveSecretValueInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"secretName", "environment", "team", "valueName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "secretName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretName = data
		case "environment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environment = data
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Team = data
		case "valueName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveTeamMemberInput(ctx context.Context, obj any) (team.RemoveTeamMemberInput, error) {
	var it team.RemoveTeamMemberInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "userEmail"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "userEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userEmail"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserEmail = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepositoryOrder(ctx context.Context, obj any) (repository.RepositoryOrder, error) {
	var it repository.RepositoryOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNRepositoryOrderField2githubcomnaisapiinternalgithubrepositoryRepositoryOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRequestTeamDeletionInput(ctx context.Context, obj any) (team.RequestTeamDeletionInput, error) {
	var it team.RequestTeamDeletionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"slug"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "slug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slug = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRestartApplicationInput(ctx context.Context, obj any) (application.RestartApplicationInput, error) {
	var it application.RestartApplicationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "teamSlug", "environmentName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "environmentName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environmentName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnvironmentName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRevokeRoleFromServiceAccountInput(ctx context.Context, obj any) (serviceaccount.RevokeRoleFromServiceAccountInput, error) {
	var it serviceaccount.RevokeRoleFromServiceAccountInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"serviceAccountID", "roleName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "serviceAccountID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceAccountID"))
			data, err := ec.unmarshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceAccountID = data
		case "roleName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoleName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRevokeTeamAccessToUnleashInput(ctx context.Context, obj any) (unleash.RevokeTeamAccessToUnleashInput, error) {
	var it unleash.RevokeTeamAccessToUnleashInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "revokedTeamSlug"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "revokedTeamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revokedTeamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.RevokedTeamSlug = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchFilter(ctx context.Context, obj any) (search.SearchFilter, error) {
	var it search.SearchFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"query", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "query":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Query = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOSearchType2githubcomnaisapiinternalsearchSearchType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSecretFilter(ctx context.Context, obj any) (secret.SecretFilter, error) {
	var it secret.SecretFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"inUse"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "inUse":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inUse"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.InUse = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSecretOrder(ctx context.Context, obj any) (secret.SecretOrder, error) {
	var it secret.SecretOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNSecretOrderField2githubcomnaisapiinternalworkloadsecretSecretOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSecretValueInput(ctx context.Context, obj any) (secret.SecretValueInput, error) {
	var it secret.SecretValueInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetTeamMemberRoleInput(ctx context.Context, obj any) (team.SetTeamMemberRoleInput, error) {
	var it team.SetTeamMemberRoleInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"teamSlug", "userEmail", "role"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "userEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userEmail"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserEmail = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalNTeamMemberRole2githubcomnaisapiinternalteamTeamMemberRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSqlInstanceOrder(ctx context.Context, obj any) (sqlinstance.SQLInstanceOrder, error) {
	var it sqlinstance.SQLInstanceOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNSqlInstanceOrderField2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSqlInstanceUserOrder(ctx context.Context, obj any) (sqlinstance.SQLInstanceUserOrder, error) {
	var it sqlinstance.SQLInstanceUserOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNSqlInstanceUserOrderField2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceUserOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamApplicationsFilter(ctx context.Context, obj any) (application.TeamApplicationsFilter, error) {
	var it application.TeamApplicationsFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "environments"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "environments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environments"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environments = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamCostDailyFilter(ctx context.Context, obj any) (cost.TeamCostDailyFilter, error) {
	var it cost.TeamCostDailyFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"services"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "services":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("services"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Services = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamJobsFilter(ctx context.Context, obj any) (job.TeamJobsFilter, error) {
	var it job.TeamJobsFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "environments"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "environments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environments"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environments = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamMemberOrder(ctx context.Context, obj any) (team.TeamMemberOrder, error) {
	var it team.TeamMemberOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNTeamMemberOrderField2githubcomnaisapiinternalteamTeamMemberOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamOrder(ctx context.Context, obj any) (team.TeamOrder, error) {
	var it team.TeamOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNTeamOrderField2githubcomnaisapiinternalteamTeamOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamRepositoryFilter(ctx context.Context, obj any) (repository.TeamRepositoryFilter, error) {
	var it repository.TeamRepositoryFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamVulnerabilitySummaryFilter(ctx context.Context, obj any) (vulnerability.TeamVulnerabilitySummaryFilter, error) {
	var it vulnerability.TeamVulnerabilitySummaryFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"environments"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "environments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environments"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environments = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamWorkloadsFilter(ctx context.Context, obj any) (workload.TeamWorkloadsFilter, error) {
	var it workload.TeamWorkloadsFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"environments"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "environments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environments"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environments = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTriggerJobInput(ctx context.Context, obj any) (job.TriggerJobInput, error) {
	var it job.TriggerJobInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "teamSlug", "environmentName", "runName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "teamSlug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teamSlug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.TeamSlug = data
		case "environmentName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environmentName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnvironmentName = data
		case "runName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RunName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateImageVulnerabilityInput(ctx context.Context, obj any) (vulnerability.UpdateImageVulnerabilityInput, error) {
	var it vulnerability.UpdateImageVulnerabilityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"vulnerabilityID", "analysisState", "comment", "suppress"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "vulnerabilityID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vulnerabilityID"))
			data, err := ec.unmarshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, v)
			if err != nil {
				return it, err
			}
			it.VulnerabilityID = data
		case "analysisState":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("analysisState"))
			data, err := ec.unmarshalNImageVulnerabilityAnalysisState2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisState(ctx, v)
			if err != nil {
				return it, err
			}
			it.AnalysisState = data
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comment = data
		case "suppress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suppress"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Suppress = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSecretValueInput(ctx context.Context, obj any) (secret.UpdateSecretValueInput, error) {
	var it secret.UpdateSecretValueInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "environment", "team", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "environment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environment = data
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Team = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNSecretValueInput2githubcomnaisapiinternalworkloadsecretSecretValueInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateServiceAccountInput(ctx context.Context, obj any) (serviceaccount.UpdateServiceAccountInput, error) {
	var it serviceaccount.UpdateServiceAccountInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"serviceAccountID", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "serviceAccountID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceAccountID"))
			data, err := ec.unmarshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceAccountID = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateServiceAccountTokenInput(ctx context.Context, obj any) (serviceaccount.UpdateServiceAccountTokenInput, error) {
	var it serviceaccount.UpdateServiceAccountTokenInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"serviceAccountTokenID", "name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "serviceAccountTokenID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceAccountTokenID"))
			data, err := ec.unmarshalNID2githubcomnaisapiinternalgraphidentIdent(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceAccountTokenID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamEnvironmentInput(ctx context.Context, obj any) (team.UpdateTeamEnvironmentInput, error) {
	var it team.UpdateTeamEnvironmentInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"slug", "environmentName", "slackAlertsChannel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "slug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slug = data
		case "environmentName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environmentName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnvironmentName = data
		case "slackAlertsChannel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackAlertsChannel"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackAlertsChannel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamInput(ctx context.Context, obj any) (team.UpdateTeamInput, error) {
	var it team.UpdateTeamInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"slug", "purpose", "slackChannel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "slug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slug = data
		case "purpose":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("purpose"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Purpose = data
		case "slackChannel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackChannel"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackChannel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserOrder(ctx context.Context, obj any) (user.UserOrder, error) {
	var it user.UserOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNUserOrderField2githubcomnaisapiinternaluserUserOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserTeamOrder(ctx context.Context, obj any) (team.UserTeamOrder, error) {
	var it team.UserTeamOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNUserTeamOrderField2githubcomnaisapiinternalteamUserTeamOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputValkeyInstanceAccessOrder(ctx context.Context, obj any) (valkey.ValkeyInstanceAccessOrder, error) {
	var it valkey.ValkeyInstanceAccessOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNValkeyInstanceAccessOrderField2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceAccessOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputValkeyInstanceOrder(ctx context.Context, obj any) (valkey.ValkeyInstanceOrder, error) {
	var it valkey.ValkeyInstanceOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNValkeyInstanceOrderField2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkloadLogSubscriptionFilter(ctx context.Context, obj any) (podlog.WorkloadLogSubscriptionFilter, error) {
	var it podlog.WorkloadLogSubscriptionFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"team", "environment", "application", "job", "instances"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			data, err := ec.unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx, v)
			if err != nil {
				return it, err
			}
			it.Team = data
		case "environment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("environment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Environment = data
		case "application":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("application"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Application = data
		case "job":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("job"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Job = data
		case "instances":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("instances"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Instances = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkloadOrder(ctx context.Context, obj any) (workload.WorkloadOrder, error) {
	var it workload.WorkloadOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNWorkloadOrderField2githubcomnaisapiinternalworkloadWorkloadOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkloadUtilizationSeriesInput(ctx context.Context, obj any) (utilization.WorkloadUtilizationSeriesInput, error) {
	var it utilization.WorkloadUtilizationSeriesInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"start", "end", "resourceType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "start":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Start = data
		case "end":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.End = data
		case "resourceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
			data, err := ec.unmarshalNUtilizationResourceType2githubcomnaisapiinternalutilizationUtilizationResourceType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _ActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj activitylog.ActivityLogEntry) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case vulnerability.VulnerabilityUpdatedActivityLogEntry:
		return ec._VulnerabilityUpdatedActivityLogEntry(ctx, sel, &obj)
	case *vulnerability.VulnerabilityUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._VulnerabilityUpdatedActivityLogEntry(ctx, sel, obj)
	case unleash.UnleashInstanceUpdatedActivityLogEntry:
		return ec._UnleashInstanceUpdatedActivityLogEntry(ctx, sel, &obj)
	case *unleash.UnleashInstanceUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnleashInstanceUpdatedActivityLogEntry(ctx, sel, obj)
	case unleash.UnleashInstanceCreatedActivityLogEntry:
		return ec._UnleashInstanceCreatedActivityLogEntry(ctx, sel, &obj)
	case *unleash.UnleashInstanceCreatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnleashInstanceCreatedActivityLogEntry(ctx, sel, obj)
	case team.TeamUpdatedActivityLogEntry:
		return ec._TeamUpdatedActivityLogEntry(ctx, sel, &obj)
	case *team.TeamUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamUpdatedActivityLogEntry(ctx, sel, obj)
	case team.TeamMemberSetRoleActivityLogEntry:
		return ec._TeamMemberSetRoleActivityLogEntry(ctx, sel, &obj)
	case *team.TeamMemberSetRoleActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberSetRoleActivityLogEntry(ctx, sel, obj)
	case team.TeamMemberRemovedActivityLogEntry:
		return ec._TeamMemberRemovedActivityLogEntry(ctx, sel, &obj)
	case *team.TeamMemberRemovedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberRemovedActivityLogEntry(ctx, sel, obj)
	case team.TeamMemberAddedActivityLogEntry:
		return ec._TeamMemberAddedActivityLogEntry(ctx, sel, &obj)
	case *team.TeamMemberAddedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberAddedActivityLogEntry(ctx, sel, obj)
	case team.TeamEnvironmentUpdatedActivityLogEntry:
		return ec._TeamEnvironmentUpdatedActivityLogEntry(ctx, sel, &obj)
	case *team.TeamEnvironmentUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamEnvironmentUpdatedActivityLogEntry(ctx, sel, obj)
	case deployment.TeamDeployKeyUpdatedActivityLogEntry:
		return ec._TeamDeployKeyUpdatedActivityLogEntry(ctx, sel, &obj)
	case *deployment.TeamDeployKeyUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamDeployKeyUpdatedActivityLogEntry(ctx, sel, obj)
	case team.TeamCreatedActivityLogEntry:
		return ec._TeamCreatedActivityLogEntry(ctx, sel, &obj)
	case *team.TeamCreatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamCreatedActivityLogEntry(ctx, sel, obj)
	case team.TeamCreateDeleteKeyActivityLogEntry:
		return ec._TeamCreateDeleteKeyActivityLogEntry(ctx, sel, &obj)
	case *team.TeamCreateDeleteKeyActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamCreateDeleteKeyActivityLogEntry(ctx, sel, obj)
	case team.TeamConfirmDeleteKeyActivityLogEntry:
		return ec._TeamConfirmDeleteKeyActivityLogEntry(ctx, sel, &obj)
	case *team.TeamConfirmDeleteKeyActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamConfirmDeleteKeyActivityLogEntry(ctx, sel, obj)
	case serviceaccount.ServiceAccountUpdatedActivityLogEntry:
		return ec._ServiceAccountUpdatedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountUpdatedActivityLogEntry(ctx, sel, obj)
	case serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry:
		return ec._ServiceAccountTokenUpdatedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountTokenUpdatedActivityLogEntry(ctx, sel, obj)
	case serviceaccount.ServiceAccountTokenDeletedActivityLogEntry:
		return ec._ServiceAccountTokenDeletedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountTokenDeletedActivityLogEntry(ctx, sel, obj)
	case serviceaccount.ServiceAccountTokenCreatedActivityLogEntry:
		return ec._ServiceAccountTokenCreatedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountTokenCreatedActivityLogEntry(ctx, sel, obj)
	case serviceaccount.ServiceAccountDeletedActivityLogEntry:
		return ec._ServiceAccountDeletedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountDeletedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountDeletedActivityLogEntry(ctx, sel, obj)
	case serviceaccount.ServiceAccountCreatedActivityLogEntry:
		return ec._ServiceAccountCreatedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountCreatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountCreatedActivityLogEntry(ctx, sel, obj)
	case secret.SecretValueUpdatedActivityLogEntry:
		return ec._SecretValueUpdatedActivityLogEntry(ctx, sel, &obj)
	case *secret.SecretValueUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._SecretValueUpdatedActivityLogEntry(ctx, sel, obj)
	case secret.SecretValueRemovedActivityLogEntry:
		return ec._SecretValueRemovedActivityLogEntry(ctx, sel, &obj)
	case *secret.SecretValueRemovedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._SecretValueRemovedActivityLogEntry(ctx, sel, obj)
	case secret.SecretValueAddedActivityLogEntry:
		return ec._SecretValueAddedActivityLogEntry(ctx, sel, &obj)
	case *secret.SecretValueAddedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._SecretValueAddedActivityLogEntry(ctx, sel, obj)
	case secret.SecretDeletedActivityLogEntry:
		return ec._SecretDeletedActivityLogEntry(ctx, sel, &obj)
	case *secret.SecretDeletedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._SecretDeletedActivityLogEntry(ctx, sel, obj)
	case secret.SecretCreatedActivityLogEntry:
		return ec._SecretCreatedActivityLogEntry(ctx, sel, &obj)
	case *secret.SecretCreatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._SecretCreatedActivityLogEntry(ctx, sel, obj)
	case serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry:
		return ec._RoleRevokedFromServiceAccountActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RoleRevokedFromServiceAccountActivityLogEntry(ctx, sel, obj)
	case serviceaccount.RoleAssignedToServiceAccountActivityLogEntry:
		return ec._RoleAssignedToServiceAccountActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RoleAssignedToServiceAccountActivityLogEntry(ctx, sel, obj)
	case repository.RepositoryRemovedActivityLogEntry:
		return ec._RepositoryRemovedActivityLogEntry(ctx, sel, &obj)
	case *repository.RepositoryRemovedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RepositoryRemovedActivityLogEntry(ctx, sel, obj)
	case repository.RepositoryAddedActivityLogEntry:
		return ec._RepositoryAddedActivityLogEntry(ctx, sel, &obj)
	case *repository.RepositoryAddedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RepositoryAddedActivityLogEntry(ctx, sel, obj)
	case reconciler.ReconcilerEnabledActivityLogEntry:
		return ec._ReconcilerEnabledActivityLogEntry(ctx, sel, &obj)
	case *reconciler.ReconcilerEnabledActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ReconcilerEnabledActivityLogEntry(ctx, sel, obj)
	case reconciler.ReconcilerDisabledActivityLogEntry:
		return ec._ReconcilerDisabledActivityLogEntry(ctx, sel, &obj)
	case *reconciler.ReconcilerDisabledActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ReconcilerDisabledActivityLogEntry(ctx, sel, obj)
	case reconciler.ReconcilerConfiguredActivityLogEntry:
		return ec._ReconcilerConfiguredActivityLogEntry(ctx, sel, &obj)
	case *reconciler.ReconcilerConfiguredActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ReconcilerConfiguredActivityLogEntry(ctx, sel, obj)
	case job.JobTriggeredActivityLogEntry:
		return ec._JobTriggeredActivityLogEntry(ctx, sel, &obj)
	case *job.JobTriggeredActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._JobTriggeredActivityLogEntry(ctx, sel, obj)
	case job.JobDeletedActivityLogEntry:
		return ec._JobDeletedActivityLogEntry(ctx, sel, &obj)
	case *job.JobDeletedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._JobDeletedActivityLogEntry(ctx, sel, obj)
	case application.ApplicationRestartedActivityLogEntry:
		return ec._ApplicationRestartedActivityLogEntry(ctx, sel, &obj)
	case *application.ApplicationRestartedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationRestartedActivityLogEntry(ctx, sel, obj)
	case application.ApplicationDeletedActivityLogEntry:
		return ec._ApplicationDeletedActivityLogEntry(ctx, sel, &obj)
	case *application.ApplicationDeletedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationDeletedActivityLogEntry(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ApplicationAuthIntegrations(ctx context.Context, sel ast.SelectionSet, obj workload.ApplicationAuthIntegrations) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case workload.TokenXAuthIntegration:
		return ec._TokenXAuthIntegration(ctx, sel, &obj)
	case *workload.TokenXAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._TokenXAuthIntegration(ctx, sel, obj)
	case workload.MaskinportenAuthIntegration:
		return ec._MaskinportenAuthIntegration(ctx, sel, &obj)
	case *workload.MaskinportenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._MaskinportenAuthIntegration(ctx, sel, obj)
	case workload.IDPortenAuthIntegration:
		return ec._IDPortenAuthIntegration(ctx, sel, &obj)
	case *workload.IDPortenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._IDPortenAuthIntegration(ctx, sel, obj)
	case workload.EntraIDAuthIntegration:
		return ec._EntraIDAuthIntegration(ctx, sel, &obj)
	case *workload.EntraIDAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._EntraIDAuthIntegration(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AuthIntegration(ctx context.Context, sel ast.SelectionSet, obj workload.AuthIntegration) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case workload.TokenXAuthIntegration:
		return ec._TokenXAuthIntegration(ctx, sel, &obj)
	case *workload.TokenXAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._TokenXAuthIntegration(ctx, sel, obj)
	case workload.MaskinportenAuthIntegration:
		return ec._MaskinportenAuthIntegration(ctx, sel, &obj)
	case *workload.MaskinportenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._MaskinportenAuthIntegration(ctx, sel, obj)
	case workload.IDPortenAuthIntegration:
		return ec._IDPortenAuthIntegration(ctx, sel, &obj)
	case *workload.IDPortenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._IDPortenAuthIntegration(ctx, sel, obj)
	case workload.EntraIDAuthIntegration:
		return ec._EntraIDAuthIntegration(ctx, sel, &obj)
	case *workload.EntraIDAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._EntraIDAuthIntegration(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AuthenticatedUser(ctx context.Context, sel ast.SelectionSet, obj authz.AuthenticatedUser) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *user.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case *serviceaccount.ServiceAccount:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccount(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ExternalNetworkPolicyTarget(ctx context.Context, sel ast.SelectionSet, obj netpol.ExternalNetworkPolicyTarget) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case netpol.ExternalNetworkPolicyIpv4:
		return ec._ExternalNetworkPolicyIpv4(ctx, sel, &obj)
	case *netpol.ExternalNetworkPolicyIpv4:
		if obj == nil {
			return graphql.Null
		}
		return ec._ExternalNetworkPolicyIpv4(ctx, sel, obj)
	case netpol.ExternalNetworkPolicyHost:
		return ec._ExternalNetworkPolicyHost(ctx, sel, &obj)
	case *netpol.ExternalNetworkPolicyHost:
		if obj == nil {
			return graphql.Null
		}
		return ec._ExternalNetworkPolicyHost(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _JobAuthIntegrations(ctx context.Context, sel ast.SelectionSet, obj workload.JobAuthIntegrations) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case workload.MaskinportenAuthIntegration:
		return ec._MaskinportenAuthIntegration(ctx, sel, &obj)
	case *workload.MaskinportenAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._MaskinportenAuthIntegration(ctx, sel, obj)
	case workload.EntraIDAuthIntegration:
		return ec._EntraIDAuthIntegration(ctx, sel, &obj)
	case *workload.EntraIDAuthIntegration:
		if obj == nil {
			return graphql.Null
		}
		return ec._EntraIDAuthIntegration(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _LogDestination(ctx context.Context, sel ast.SelectionSet, obj logging.LogDestination) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case logging.LogDestinationSecureLogs:
		return ec._LogDestinationSecureLogs(ctx, sel, &obj)
	case *logging.LogDestinationSecureLogs:
		if obj == nil {
			return graphql.Null
		}
		return ec._LogDestinationSecureLogs(ctx, sel, obj)
	case logging.LogDestinationLoki:
		return ec._LogDestinationLoki(ctx, sel, &obj)
	case *logging.LogDestinationLoki:
		if obj == nil {
			return graphql.Null
		}
		return ec._LogDestinationLoki(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj model.Node) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case vulnerability.VulnerabilityUpdatedActivityLogEntry:
		return ec._VulnerabilityUpdatedActivityLogEntry(ctx, sel, &obj)
	case *vulnerability.VulnerabilityUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._VulnerabilityUpdatedActivityLogEntry(ctx, sel, obj)
	case valkey.ValkeyInstance:
		return ec._ValkeyInstance(ctx, sel, &obj)
	case *valkey.ValkeyInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._ValkeyInstance(ctx, sel, obj)
	case usersync.UserUpdatedUserSyncLogEntry:
		return ec._UserUpdatedUserSyncLogEntry(ctx, sel, &obj)
	case *usersync.UserUpdatedUserSyncLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserUpdatedUserSyncLogEntry(ctx, sel, obj)
	case usersync.UserDeletedUserSyncLogEntry:
		return ec._UserDeletedUserSyncLogEntry(ctx, sel, &obj)
	case *usersync.UserDeletedUserSyncLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserDeletedUserSyncLogEntry(ctx, sel, obj)
	case usersync.UserCreatedUserSyncLogEntry:
		return ec._UserCreatedUserSyncLogEntry(ctx, sel, &obj)
	case *usersync.UserCreatedUserSyncLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserCreatedUserSyncLogEntry(ctx, sel, obj)
	case unleash.UnleashInstanceUpdatedActivityLogEntry:
		return ec._UnleashInstanceUpdatedActivityLogEntry(ctx, sel, &obj)
	case *unleash.UnleashInstanceUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnleashInstanceUpdatedActivityLogEntry(ctx, sel, obj)
	case unleash.UnleashInstanceCreatedActivityLogEntry:
		return ec._UnleashInstanceCreatedActivityLogEntry(ctx, sel, &obj)
	case *unleash.UnleashInstanceCreatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnleashInstanceCreatedActivityLogEntry(ctx, sel, obj)
	case team.TeamUpdatedActivityLogEntry:
		return ec._TeamUpdatedActivityLogEntry(ctx, sel, &obj)
	case *team.TeamUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamUpdatedActivityLogEntry(ctx, sel, obj)
	case team.TeamMemberSetRoleActivityLogEntry:
		return ec._TeamMemberSetRoleActivityLogEntry(ctx, sel, &obj)
	case *team.TeamMemberSetRoleActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberSetRoleActivityLogEntry(ctx, sel, obj)
	case team.TeamMemberRemovedActivityLogEntry:
		return ec._TeamMemberRemovedActivityLogEntry(ctx, sel, &obj)
	case *team.TeamMemberRemovedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberRemovedActivityLogEntry(ctx, sel, obj)
	case team.TeamMemberAddedActivityLogEntry:
		return ec._TeamMemberAddedActivityLogEntry(ctx, sel, &obj)
	case *team.TeamMemberAddedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamMemberAddedActivityLogEntry(ctx, sel, obj)
	case team.TeamEnvironmentUpdatedActivityLogEntry:
		return ec._TeamEnvironmentUpdatedActivityLogEntry(ctx, sel, &obj)
	case *team.TeamEnvironmentUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamEnvironmentUpdatedActivityLogEntry(ctx, sel, obj)
	case deployment.TeamDeployKeyUpdatedActivityLogEntry:
		return ec._TeamDeployKeyUpdatedActivityLogEntry(ctx, sel, &obj)
	case *deployment.TeamDeployKeyUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamDeployKeyUpdatedActivityLogEntry(ctx, sel, obj)
	case team.TeamCreatedActivityLogEntry:
		return ec._TeamCreatedActivityLogEntry(ctx, sel, &obj)
	case *team.TeamCreatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamCreatedActivityLogEntry(ctx, sel, obj)
	case team.TeamCreateDeleteKeyActivityLogEntry:
		return ec._TeamCreateDeleteKeyActivityLogEntry(ctx, sel, &obj)
	case *team.TeamCreateDeleteKeyActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamCreateDeleteKeyActivityLogEntry(ctx, sel, obj)
	case team.TeamConfirmDeleteKeyActivityLogEntry:
		return ec._TeamConfirmDeleteKeyActivityLogEntry(ctx, sel, &obj)
	case *team.TeamConfirmDeleteKeyActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamConfirmDeleteKeyActivityLogEntry(ctx, sel, obj)
	case sqlinstance.SQLInstance:
		return ec._SqlInstance(ctx, sel, &obj)
	case *sqlinstance.SQLInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlInstance(ctx, sel, obj)
	case sqlinstance.SQLDatabase:
		return ec._SqlDatabase(ctx, sel, &obj)
	case *sqlinstance.SQLDatabase:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlDatabase(ctx, sel, obj)
	case serviceaccount.ServiceAccountUpdatedActivityLogEntry:
		return ec._ServiceAccountUpdatedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountUpdatedActivityLogEntry(ctx, sel, obj)
	case serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry:
		return ec._ServiceAccountTokenUpdatedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountTokenUpdatedActivityLogEntry(ctx, sel, obj)
	case serviceaccount.ServiceAccountTokenDeletedActivityLogEntry:
		return ec._ServiceAccountTokenDeletedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountTokenDeletedActivityLogEntry(ctx, sel, obj)
	case serviceaccount.ServiceAccountTokenCreatedActivityLogEntry:
		return ec._ServiceAccountTokenCreatedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountTokenCreatedActivityLogEntry(ctx, sel, obj)
	case serviceaccount.ServiceAccountDeletedActivityLogEntry:
		return ec._ServiceAccountDeletedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountDeletedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountDeletedActivityLogEntry(ctx, sel, obj)
	case serviceaccount.ServiceAccountCreatedActivityLogEntry:
		return ec._ServiceAccountCreatedActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountCreatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountCreatedActivityLogEntry(ctx, sel, obj)
	case secret.SecretValueUpdatedActivityLogEntry:
		return ec._SecretValueUpdatedActivityLogEntry(ctx, sel, &obj)
	case *secret.SecretValueUpdatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._SecretValueUpdatedActivityLogEntry(ctx, sel, obj)
	case secret.SecretValueRemovedActivityLogEntry:
		return ec._SecretValueRemovedActivityLogEntry(ctx, sel, &obj)
	case *secret.SecretValueRemovedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._SecretValueRemovedActivityLogEntry(ctx, sel, obj)
	case secret.SecretValueAddedActivityLogEntry:
		return ec._SecretValueAddedActivityLogEntry(ctx, sel, &obj)
	case *secret.SecretValueAddedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._SecretValueAddedActivityLogEntry(ctx, sel, obj)
	case secret.SecretDeletedActivityLogEntry:
		return ec._SecretDeletedActivityLogEntry(ctx, sel, &obj)
	case *secret.SecretDeletedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._SecretDeletedActivityLogEntry(ctx, sel, obj)
	case secret.SecretCreatedActivityLogEntry:
		return ec._SecretCreatedActivityLogEntry(ctx, sel, &obj)
	case *secret.SecretCreatedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._SecretCreatedActivityLogEntry(ctx, sel, obj)
	case usersync.RoleRevokedUserSyncLogEntry:
		return ec._RoleRevokedUserSyncLogEntry(ctx, sel, &obj)
	case *usersync.RoleRevokedUserSyncLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RoleRevokedUserSyncLogEntry(ctx, sel, obj)
	case serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry:
		return ec._RoleRevokedFromServiceAccountActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RoleRevokedFromServiceAccountActivityLogEntry(ctx, sel, obj)
	case usersync.RoleAssignedUserSyncLogEntry:
		return ec._RoleAssignedUserSyncLogEntry(ctx, sel, &obj)
	case *usersync.RoleAssignedUserSyncLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RoleAssignedUserSyncLogEntry(ctx, sel, obj)
	case serviceaccount.RoleAssignedToServiceAccountActivityLogEntry:
		return ec._RoleAssignedToServiceAccountActivityLogEntry(ctx, sel, &obj)
	case *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RoleAssignedToServiceAccountActivityLogEntry(ctx, sel, obj)
	case repository.RepositoryRemovedActivityLogEntry:
		return ec._RepositoryRemovedActivityLogEntry(ctx, sel, &obj)
	case *repository.RepositoryRemovedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RepositoryRemovedActivityLogEntry(ctx, sel, obj)
	case repository.RepositoryAddedActivityLogEntry:
		return ec._RepositoryAddedActivityLogEntry(ctx, sel, &obj)
	case *repository.RepositoryAddedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RepositoryAddedActivityLogEntry(ctx, sel, obj)
	case redis.RedisInstance:
		return ec._RedisInstance(ctx, sel, &obj)
	case *redis.RedisInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._RedisInstance(ctx, sel, obj)
	case reconciler.ReconcilerEnabledActivityLogEntry:
		return ec._ReconcilerEnabledActivityLogEntry(ctx, sel, &obj)
	case *reconciler.ReconcilerEnabledActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ReconcilerEnabledActivityLogEntry(ctx, sel, obj)
	case reconciler.ReconcilerDisabledActivityLogEntry:
		return ec._ReconcilerDisabledActivityLogEntry(ctx, sel, &obj)
	case *reconciler.ReconcilerDisabledActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ReconcilerDisabledActivityLogEntry(ctx, sel, obj)
	case reconciler.ReconcilerConfiguredActivityLogEntry:
		return ec._ReconcilerConfiguredActivityLogEntry(ctx, sel, &obj)
	case *reconciler.ReconcilerConfiguredActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ReconcilerConfiguredActivityLogEntry(ctx, sel, obj)
	case opensearch.OpenSearch:
		return ec._OpenSearch(ctx, sel, &obj)
	case *opensearch.OpenSearch:
		if obj == nil {
			return graphql.Null
		}
		return ec._OpenSearch(ctx, sel, obj)
	case logging.LogDestinationSecureLogs:
		return ec._LogDestinationSecureLogs(ctx, sel, &obj)
	case *logging.LogDestinationSecureLogs:
		if obj == nil {
			return graphql.Null
		}
		return ec._LogDestinationSecureLogs(ctx, sel, obj)
	case logging.LogDestinationLoki:
		return ec._LogDestinationLoki(ctx, sel, &obj)
	case *logging.LogDestinationLoki:
		if obj == nil {
			return graphql.Null
		}
		return ec._LogDestinationLoki(ctx, sel, obj)
	case kafkatopic.KafkaTopic:
		return ec._KafkaTopic(ctx, sel, &obj)
	case *kafkatopic.KafkaTopic:
		if obj == nil {
			return graphql.Null
		}
		return ec._KafkaTopic(ctx, sel, obj)
	case job.JobTriggeredActivityLogEntry:
		return ec._JobTriggeredActivityLogEntry(ctx, sel, &obj)
	case *job.JobTriggeredActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._JobTriggeredActivityLogEntry(ctx, sel, obj)
	case job.JobDeletedActivityLogEntry:
		return ec._JobDeletedActivityLogEntry(ctx, sel, &obj)
	case *job.JobDeletedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._JobDeletedActivityLogEntry(ctx, sel, obj)
	case job.Job:
		return ec._Job(ctx, sel, &obj)
	case *job.Job:
		if obj == nil {
			return graphql.Null
		}
		return ec._Job(ctx, sel, obj)
	case bucket.Bucket:
		return ec._Bucket(ctx, sel, &obj)
	case *bucket.Bucket:
		if obj == nil {
			return graphql.Null
		}
		return ec._Bucket(ctx, sel, obj)
	case bigquery.BigQueryDataset:
		return ec._BigQueryDataset(ctx, sel, &obj)
	case *bigquery.BigQueryDataset:
		if obj == nil {
			return graphql.Null
		}
		return ec._BigQueryDataset(ctx, sel, obj)
	case application.ApplicationRestartedActivityLogEntry:
		return ec._ApplicationRestartedActivityLogEntry(ctx, sel, &obj)
	case *application.ApplicationRestartedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationRestartedActivityLogEntry(ctx, sel, obj)
	case application.ApplicationDeletedActivityLogEntry:
		return ec._ApplicationDeletedActivityLogEntry(ctx, sel, &obj)
	case *application.ApplicationDeletedActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationDeletedActivityLogEntry(ctx, sel, obj)
	case application.Application:
		return ec._Application(ctx, sel, &obj)
	case *application.Application:
		if obj == nil {
			return graphql.Null
		}
		return ec._Application(ctx, sel, obj)
	case workload.Workload:
		if obj == nil {
			return graphql.Null
		}
		return ec._Workload(ctx, sel, obj)
	case usersync.UserSyncLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserSyncLogEntry(ctx, sel, obj)
	case user.User:
		return ec._User(ctx, sel, &obj)
	case *user.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case unleash.UnleashInstance:
		return ec._UnleashInstance(ctx, sel, &obj)
	case *unleash.UnleashInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnleashInstance(ctx, sel, obj)
	case team.TeamEnvironment:
		return ec._TeamEnvironment(ctx, sel, &obj)
	case *team.TeamEnvironment:
		if obj == nil {
			return graphql.Null
		}
		return ec._TeamEnvironment(ctx, sel, obj)
	case team.Team:
		return ec._Team(ctx, sel, &obj)
	case *team.Team:
		if obj == nil {
			return graphql.Null
		}
		return ec._Team(ctx, sel, obj)
	case serviceaccount.ServiceAccountToken:
		return ec._ServiceAccountToken(ctx, sel, &obj)
	case *serviceaccount.ServiceAccountToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccountToken(ctx, sel, obj)
	case serviceaccount.ServiceAccount:
		return ec._ServiceAccount(ctx, sel, &obj)
	case *serviceaccount.ServiceAccount:
		if obj == nil {
			return graphql.Null
		}
		return ec._ServiceAccount(ctx, sel, obj)
	case secret.Secret:
		return ec._Secret(ctx, sel, &obj)
	case *secret.Secret:
		if obj == nil {
			return graphql.Null
		}
		return ec._Secret(ctx, sel, obj)
	case *authz.Role:
		if obj == nil {
			return graphql.Null
		}
		return ec._Role(ctx, sel, obj)
	case repository.Repository:
		return ec._Repository(ctx, sel, &obj)
	case *repository.Repository:
		if obj == nil {
			return graphql.Null
		}
		return ec._Repository(ctx, sel, obj)
	case reconciler.ReconcilerError:
		return ec._ReconcilerError(ctx, sel, &obj)
	case *reconciler.ReconcilerError:
		if obj == nil {
			return graphql.Null
		}
		return ec._ReconcilerError(ctx, sel, obj)
	case reconciler.Reconciler:
		return ec._Reconciler(ctx, sel, &obj)
	case *reconciler.Reconciler:
		if obj == nil {
			return graphql.Null
		}
		return ec._Reconciler(ctx, sel, obj)
	case persistence.Persistence:
		if obj == nil {
			return graphql.Null
		}
		return ec._Persistence(ctx, sel, obj)
	case logging.LogDestination:
		if obj == nil {
			return graphql.Null
		}
		return ec._LogDestination(ctx, sel, obj)
	case job.JobRunInstance:
		return ec._JobRunInstance(ctx, sel, &obj)
	case *job.JobRunInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._JobRunInstance(ctx, sel, obj)
	case job.JobRun:
		return ec._JobRun(ctx, sel, &obj)
	case *job.JobRun:
		if obj == nil {
			return graphql.Null
		}
		return ec._JobRun(ctx, sel, obj)
	case vulnerability.ImageVulnerability:
		return ec._ImageVulnerability(ctx, sel, &obj)
	case *vulnerability.ImageVulnerability:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageVulnerability(ctx, sel, obj)
	case feature.Features:
		return ec._Features(ctx, sel, &obj)
	case *feature.Features:
		if obj == nil {
			return graphql.Null
		}
		return ec._Features(ctx, sel, obj)
	case feature.FeatureValkey:
		return ec._FeatureValkey(ctx, sel, &obj)
	case *feature.FeatureValkey:
		if obj == nil {
			return graphql.Null
		}
		return ec._FeatureValkey(ctx, sel, obj)
	case feature.FeatureUnleash:
		return ec._FeatureUnleash(ctx, sel, &obj)
	case *feature.FeatureUnleash:
		if obj == nil {
			return graphql.Null
		}
		return ec._FeatureUnleash(ctx, sel, obj)
	case feature.FeatureRedis:
		return ec._FeatureRedis(ctx, sel, &obj)
	case *feature.FeatureRedis:
		if obj == nil {
			return graphql.Null
		}
		return ec._FeatureRedis(ctx, sel, obj)
	case feature.FeatureOpenSearch:
		return ec._FeatureOpenSearch(ctx, sel, &obj)
	case *feature.FeatureOpenSearch:
		if obj == nil {
			return graphql.Null
		}
		return ec._FeatureOpenSearch(ctx, sel, obj)
	case feature.FeatureKafka:
		return ec._FeatureKafka(ctx, sel, &obj)
	case *feature.FeatureKafka:
		if obj == nil {
			return graphql.Null
		}
		return ec._FeatureKafka(ctx, sel, obj)
	case environment.Environment:
		return ec._Environment(ctx, sel, &obj)
	case *environment.Environment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Environment(ctx, sel, obj)
	case deployment.DeploymentStatus:
		return ec._DeploymentStatus(ctx, sel, &obj)
	case *deployment.DeploymentStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeploymentStatus(ctx, sel, obj)
	case deployment.DeploymentResource:
		return ec._DeploymentResource(ctx, sel, &obj)
	case *deployment.DeploymentResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeploymentResource(ctx, sel, obj)
	case deployment.DeploymentKey:
		return ec._DeploymentKey(ctx, sel, &obj)
	case *deployment.DeploymentKey:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeploymentKey(ctx, sel, obj)
	case deployment.Deployment:
		return ec._Deployment(ctx, sel, &obj)
	case *deployment.Deployment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Deployment(ctx, sel, obj)
	case workload.ContainerImage:
		return ec._ContainerImage(ctx, sel, &obj)
	case *workload.ContainerImage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ContainerImage(ctx, sel, obj)
	case application.ApplicationInstance:
		return ec._ApplicationInstance(ctx, sel, &obj)
	case *application.ApplicationInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationInstance(ctx, sel, obj)
	case activitylog.ActivityLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._ActivityLogEntry(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Persistence(ctx context.Context, sel ast.SelectionSet, obj persistence.Persistence) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case valkey.ValkeyInstance:
		return ec._ValkeyInstance(ctx, sel, &obj)
	case *valkey.ValkeyInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._ValkeyInstance(ctx, sel, obj)
	case sqlinstance.SQLInstance:
		return ec._SqlInstance(ctx, sel, &obj)
	case *sqlinstance.SQLInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlInstance(ctx, sel, obj)
	case sqlinstance.SQLDatabase:
		return ec._SqlDatabase(ctx, sel, &obj)
	case *sqlinstance.SQLDatabase:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlDatabase(ctx, sel, obj)
	case redis.RedisInstance:
		return ec._RedisInstance(ctx, sel, &obj)
	case *redis.RedisInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._RedisInstance(ctx, sel, obj)
	case opensearch.OpenSearch:
		return ec._OpenSearch(ctx, sel, &obj)
	case *opensearch.OpenSearch:
		if obj == nil {
			return graphql.Null
		}
		return ec._OpenSearch(ctx, sel, obj)
	case kafkatopic.KafkaTopic:
		return ec._KafkaTopic(ctx, sel, &obj)
	case *kafkatopic.KafkaTopic:
		if obj == nil {
			return graphql.Null
		}
		return ec._KafkaTopic(ctx, sel, obj)
	case bucket.Bucket:
		return ec._Bucket(ctx, sel, &obj)
	case *bucket.Bucket:
		if obj == nil {
			return graphql.Null
		}
		return ec._Bucket(ctx, sel, obj)
	case bigquery.BigQueryDataset:
		return ec._BigQueryDataset(ctx, sel, &obj)
	case *bigquery.BigQueryDataset:
		if obj == nil {
			return graphql.Null
		}
		return ec._BigQueryDataset(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ScalingStrategy(ctx context.Context, sel ast.SelectionSet, obj application.ScalingStrategy) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case application.KafkaLagScalingStrategy:
		return ec._KafkaLagScalingStrategy(ctx, sel, &obj)
	case *application.KafkaLagScalingStrategy:
		if obj == nil {
			return graphql.Null
		}
		return ec._KafkaLagScalingStrategy(ctx, sel, obj)
	case application.CPUScalingStrategy:
		return ec._CPUScalingStrategy(ctx, sel, &obj)
	case *application.CPUScalingStrategy:
		if obj == nil {
			return graphql.Null
		}
		return ec._CPUScalingStrategy(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SearchNode(ctx context.Context, sel ast.SelectionSet, obj search.SearchNode) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case valkey.ValkeyInstance:
		return ec._ValkeyInstance(ctx, sel, &obj)
	case *valkey.ValkeyInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._ValkeyInstance(ctx, sel, obj)
	case sqlinstance.SQLInstance:
		return ec._SqlInstance(ctx, sel, &obj)
	case *sqlinstance.SQLInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._SqlInstance(ctx, sel, obj)
	case redis.RedisInstance:
		return ec._RedisInstance(ctx, sel, &obj)
	case *redis.RedisInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._RedisInstance(ctx, sel, obj)
	case opensearch.OpenSearch:
		return ec._OpenSearch(ctx, sel, &obj)
	case *opensearch.OpenSearch:
		if obj == nil {
			return graphql.Null
		}
		return ec._OpenSearch(ctx, sel, obj)
	case kafkatopic.KafkaTopic:
		return ec._KafkaTopic(ctx, sel, &obj)
	case *kafkatopic.KafkaTopic:
		if obj == nil {
			return graphql.Null
		}
		return ec._KafkaTopic(ctx, sel, obj)
	case job.Job:
		return ec._Job(ctx, sel, &obj)
	case *job.Job:
		if obj == nil {
			return graphql.Null
		}
		return ec._Job(ctx, sel, obj)
	case bucket.Bucket:
		return ec._Bucket(ctx, sel, &obj)
	case *bucket.Bucket:
		if obj == nil {
			return graphql.Null
		}
		return ec._Bucket(ctx, sel, obj)
	case bigquery.BigQueryDataset:
		return ec._BigQueryDataset(ctx, sel, &obj)
	case *bigquery.BigQueryDataset:
		if obj == nil {
			return graphql.Null
		}
		return ec._BigQueryDataset(ctx, sel, obj)
	case application.Application:
		return ec._Application(ctx, sel, &obj)
	case *application.Application:
		if obj == nil {
			return graphql.Null
		}
		return ec._Application(ctx, sel, obj)
	case team.Team:
		return ec._Team(ctx, sel, &obj)
	case *team.Team:
		if obj == nil {
			return graphql.Null
		}
		return ec._Team(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UserSyncLogEntry(ctx context.Context, sel ast.SelectionSet, obj usersync.UserSyncLogEntry) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *usersync.UserUpdatedUserSyncLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserUpdatedUserSyncLogEntry(ctx, sel, obj)
	case *usersync.UserDeletedUserSyncLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserDeletedUserSyncLogEntry(ctx, sel, obj)
	case *usersync.UserCreatedUserSyncLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserCreatedUserSyncLogEntry(ctx, sel, obj)
	case *usersync.RoleRevokedUserSyncLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RoleRevokedUserSyncLogEntry(ctx, sel, obj)
	case *usersync.RoleAssignedUserSyncLogEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._RoleAssignedUserSyncLogEntry(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Workload(ctx context.Context, sel ast.SelectionSet, obj workload.Workload) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *job.Job:
		if obj == nil {
			return graphql.Null
		}
		return ec._Job(ctx, sel, obj)
	case *application.Application:
		if obj == nil {
			return graphql.Null
		}
		return ec._Application(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _WorkloadManifest(ctx context.Context, sel ast.SelectionSet, obj workload.WorkloadManifest) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case job.JobManifest:
		return ec._JobManifest(ctx, sel, &obj)
	case *job.JobManifest:
		if obj == nil {
			return graphql.Null
		}
		return ec._JobManifest(ctx, sel, obj)
	case application.ApplicationManifest:
		return ec._ApplicationManifest(ctx, sel, &obj)
	case *application.ApplicationManifest:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationManifest(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _WorkloadResources(ctx context.Context, sel ast.SelectionSet, obj workload.WorkloadResources) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case job.JobResources:
		return ec._JobResources(ctx, sel, &obj)
	case *job.JobResources:
		if obj == nil {
			return graphql.Null
		}
		return ec._JobResources(ctx, sel, obj)
	case application.ApplicationResources:
		return ec._ApplicationResources(ctx, sel, &obj)
	case *application.ApplicationResources:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationResources(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _WorkloadStatusError(ctx context.Context, sel ast.SelectionSet, obj status.WorkloadStatusError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case status.WorkloadStatusVulnerable:
		return ec._WorkloadStatusVulnerable(ctx, sel, &obj)
	case *status.WorkloadStatusVulnerable:
		if obj == nil {
			return graphql.Null
		}
		return ec._WorkloadStatusVulnerable(ctx, sel, obj)
	case status.WorkloadStatusSynchronizationFailing:
		return ec._WorkloadStatusSynchronizationFailing(ctx, sel, &obj)
	case *status.WorkloadStatusSynchronizationFailing:
		if obj == nil {
			return graphql.Null
		}
		return ec._WorkloadStatusSynchronizationFailing(ctx, sel, obj)
	case status.WorkloadStatusOutboundNetwork:
		return ec._WorkloadStatusOutboundNetwork(ctx, sel, &obj)
	case *status.WorkloadStatusOutboundNetwork:
		if obj == nil {
			return graphql.Null
		}
		return ec._WorkloadStatusOutboundNetwork(ctx, sel, obj)
	case status.WorkloadStatusNoRunningInstances:
		return ec._WorkloadStatusNoRunningInstances(ctx, sel, &obj)
	case *status.WorkloadStatusNoRunningInstances:
		if obj == nil {
			return graphql.Null
		}
		return ec._WorkloadStatusNoRunningInstances(ctx, sel, obj)
	case status.WorkloadStatusNewInstancesFailing:
		return ec._WorkloadStatusNewInstancesFailing(ctx, sel, &obj)
	case *status.WorkloadStatusNewInstancesFailing:
		if obj == nil {
			return graphql.Null
		}
		return ec._WorkloadStatusNewInstancesFailing(ctx, sel, obj)
	case status.WorkloadStatusMissingSBOM:
		return ec._WorkloadStatusMissingSBOM(ctx, sel, &obj)
	case *status.WorkloadStatusMissingSBOM:
		if obj == nil {
			return graphql.Null
		}
		return ec._WorkloadStatusMissingSBOM(ctx, sel, obj)
	case status.WorkloadStatusInvalidNaisYaml:
		return ec._WorkloadStatusInvalidNaisYaml(ctx, sel, &obj)
	case *status.WorkloadStatusInvalidNaisYaml:
		if obj == nil {
			return graphql.Null
		}
		return ec._WorkloadStatusInvalidNaisYaml(ctx, sel, obj)
	case status.WorkloadStatusInboundNetwork:
		return ec._WorkloadStatusInboundNetwork(ctx, sel, &obj)
	case *status.WorkloadStatusInboundNetwork:
		if obj == nil {
			return graphql.Null
		}
		return ec._WorkloadStatusInboundNetwork(ctx, sel, obj)
	case status.WorkloadStatusFailedRun:
		return ec._WorkloadStatusFailedRun(ctx, sel, &obj)
	case *status.WorkloadStatusFailedRun:
		if obj == nil {
			return graphql.Null
		}
		return ec._WorkloadStatusFailedRun(ctx, sel, obj)
	case status.WorkloadStatusDeprecatedRegistry:
		return ec._WorkloadStatusDeprecatedRegistry(ctx, sel, &obj)
	case *status.WorkloadStatusDeprecatedRegistry:
		if obj == nil {
			return graphql.Null
		}
		return ec._WorkloadStatusDeprecatedRegistry(ctx, sel, obj)
	case status.WorkloadStatusDeprecatedIngress:
		return ec._WorkloadStatusDeprecatedIngress(ctx, sel, &obj)
	case *status.WorkloadStatusDeprecatedIngress:
		if obj == nil {
			return graphql.Null
		}
		return ec._WorkloadStatusDeprecatedIngress(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var activityLogEntryConnectionImplementors = []string{"ActivityLogEntryConnection"}

func (ec *executionContext) _ActivityLogEntryConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[activitylog.ActivityLogEntry]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, activityLogEntryConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActivityLogEntryConnection")
		case "pageInfo":
			out.Values[i] = ec._ActivityLogEntryConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ActivityLogEntryConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ActivityLogEntryConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var activityLogEntryEdgeImplementors = []string{"ActivityLogEntryEdge"}

func (ec *executionContext) _ActivityLogEntryEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[activitylog.ActivityLogEntry]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, activityLogEntryEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActivityLogEntryEdge")
		case "cursor":
			out.Values[i] = ec._ActivityLogEntryEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ActivityLogEntryEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var addRepositoryToTeamPayloadImplementors = []string{"AddRepositoryToTeamPayload"}

func (ec *executionContext) _AddRepositoryToTeamPayload(ctx context.Context, sel ast.SelectionSet, obj *repository.AddRepositoryToTeamPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addRepositoryToTeamPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddRepositoryToTeamPayload")
		case "repository":
			out.Values[i] = ec._AddRepositoryToTeamPayload_repository(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var addSecretValuePayloadImplementors = []string{"AddSecretValuePayload"}

func (ec *executionContext) _AddSecretValuePayload(ctx context.Context, sel ast.SelectionSet, obj *secret.AddSecretValuePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addSecretValuePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddSecretValuePayload")
		case "secret":
			out.Values[i] = ec._AddSecretValuePayload_secret(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var addTeamMemberPayloadImplementors = []string{"AddTeamMemberPayload"}

func (ec *executionContext) _AddTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, obj *team.AddTeamMemberPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addTeamMemberPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddTeamMemberPayload")
		case "member":
			out.Values[i] = ec._AddTeamMemberPayload_member(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var allowTeamAccessToUnleashPayloadImplementors = []string{"AllowTeamAccessToUnleashPayload"}

func (ec *executionContext) _AllowTeamAccessToUnleashPayload(ctx context.Context, sel ast.SelectionSet, obj *unleash.AllowTeamAccessToUnleashPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, allowTeamAccessToUnleashPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AllowTeamAccessToUnleashPayload")
		case "unleash":
			out.Values[i] = ec._AllowTeamAccessToUnleashPayload_unleash(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationImplementors = []string{"Application", "Node", "Workload", "SearchNode"}

func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *application.Application) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "id":
			out.Values[i] = ec._Application_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Application_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "image":
			out.Values[i] = ec._Application_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resources":
			out.Values[i] = ec._Application_resources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ingresses":
			out.Values[i] = ec._Application_ingresses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authIntegrations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_authIntegrations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "manifest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_manifest(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "instances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_instances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deletionStartedAt":
			out.Values[i] = ec._Application_deletionStartedAt(ctx, field, obj)
		case "bigQueryDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_bigQueryDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buckets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_buckets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deployments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_deployments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "kafkaTopicAcls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_kafkaTopicAcls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logDestinations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_logDestinations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "networkPolicy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_networkPolicy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "openSearch":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_openSearch(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "redisInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_redisInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "secrets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_secrets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sqlInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_sqlInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "utilization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_utilization(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "valkeyInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_valkeyInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationConnectionImplementors = []string{"ApplicationConnection"}

func (ec *executionContext) _ApplicationConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*application.Application]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationConnection")
		case "pageInfo":
			out.Values[i] = ec._ApplicationConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ApplicationConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ApplicationConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationDeletedActivityLogEntryImplementors = []string{"ApplicationDeletedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ApplicationDeletedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationDeletedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationDeletedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationDeletedActivityLogEntry")
		case "id":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._ApplicationDeletedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationEdgeImplementors = []string{"ApplicationEdge"}

func (ec *executionContext) _ApplicationEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*application.Application]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationEdge")
		case "cursor":
			out.Values[i] = ec._ApplicationEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ApplicationEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationInstanceImplementors = []string{"ApplicationInstance", "Node"}

func (ec *executionContext) _ApplicationInstance(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationInstance")
		case "id":
			out.Values[i] = ec._ApplicationInstance_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ApplicationInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "image":
			out.Values[i] = ec._ApplicationInstance_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restarts":
			out.Values[i] = ec._ApplicationInstance_restarts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "created":
			out.Values[i] = ec._ApplicationInstance_created(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ApplicationInstance_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationInstanceConnectionImplementors = []string{"ApplicationInstanceConnection"}

func (ec *executionContext) _ApplicationInstanceConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*application.ApplicationInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationInstanceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationInstanceConnection")
		case "pageInfo":
			out.Values[i] = ec._ApplicationInstanceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ApplicationInstanceConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ApplicationInstanceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationInstanceEdgeImplementors = []string{"ApplicationInstanceEdge"}

func (ec *executionContext) _ApplicationInstanceEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*application.ApplicationInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationInstanceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationInstanceEdge")
		case "cursor":
			out.Values[i] = ec._ApplicationInstanceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ApplicationInstanceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationInstanceStatusImplementors = []string{"ApplicationInstanceStatus"}

func (ec *executionContext) _ApplicationInstanceStatus(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationInstanceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationInstanceStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationInstanceStatus")
		case "state":
			out.Values[i] = ec._ApplicationInstanceStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ApplicationInstanceStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationManifestImplementors = []string{"ApplicationManifest", "WorkloadManifest"}

func (ec *executionContext) _ApplicationManifest(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationManifest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationManifestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationManifest")
		case "content":
			out.Values[i] = ec._ApplicationManifest_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationResourcesImplementors = []string{"ApplicationResources", "WorkloadResources"}

func (ec *executionContext) _ApplicationResources(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationResourcesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationResources")
		case "limits":
			out.Values[i] = ec._ApplicationResources_limits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requests":
			out.Values[i] = ec._ApplicationResources_requests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scaling":
			out.Values[i] = ec._ApplicationResources_scaling(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationRestartedActivityLogEntryImplementors = []string{"ApplicationRestartedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ApplicationRestartedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationRestartedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationRestartedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationRestartedActivityLogEntry")
		case "id":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._ApplicationRestartedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationScalingImplementors = []string{"ApplicationScaling"}

func (ec *executionContext) _ApplicationScaling(ctx context.Context, sel ast.SelectionSet, obj *application.ApplicationScaling) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationScalingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationScaling")
		case "minInstances":
			out.Values[i] = ec._ApplicationScaling_minInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxInstances":
			out.Values[i] = ec._ApplicationScaling_maxInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "strategies":
			out.Values[i] = ec._ApplicationScaling_strategies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var assignRoleToServiceAccountPayloadImplementors = []string{"AssignRoleToServiceAccountPayload"}

func (ec *executionContext) _AssignRoleToServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.AssignRoleToServiceAccountPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assignRoleToServiceAccountPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssignRoleToServiceAccountPayload")
		case "serviceAccount":
			out.Values[i] = ec._AssignRoleToServiceAccountPayload_serviceAccount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetImplementors = []string{"BigQueryDataset", "Persistence", "Node", "SearchNode"}

func (ec *executionContext) _BigQueryDataset(ctx context.Context, sel ast.SelectionSet, obj *bigquery.BigQueryDataset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDataset")
		case "id":
			out.Values[i] = ec._BigQueryDataset_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._BigQueryDataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BigQueryDataset_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BigQueryDataset_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BigQueryDataset_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cascadingDelete":
			out.Values[i] = ec._BigQueryDataset_cascadingDelete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._BigQueryDataset_description(ctx, field, obj)
		case "access":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BigQueryDataset_access(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._BigQueryDataset_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BigQueryDataset_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BigQueryDataset_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetAccessImplementors = []string{"BigQueryDatasetAccess"}

func (ec *executionContext) _BigQueryDatasetAccess(ctx context.Context, sel ast.SelectionSet, obj *bigquery.BigQueryDatasetAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetAccessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetAccess")
		case "role":
			out.Values[i] = ec._BigQueryDatasetAccess_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "email":
			out.Values[i] = ec._BigQueryDatasetAccess_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetAccessConnectionImplementors = []string{"BigQueryDatasetAccessConnection"}

func (ec *executionContext) _BigQueryDatasetAccessConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetAccessConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetAccessConnection")
		case "pageInfo":
			out.Values[i] = ec._BigQueryDatasetAccessConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._BigQueryDatasetAccessConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._BigQueryDatasetAccessConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetAccessEdgeImplementors = []string{"BigQueryDatasetAccessEdge"}

func (ec *executionContext) _BigQueryDatasetAccessEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetAccessEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetAccessEdge")
		case "cursor":
			out.Values[i] = ec._BigQueryDatasetAccessEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._BigQueryDatasetAccessEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetConnectionImplementors = []string{"BigQueryDatasetConnection"}

func (ec *executionContext) _BigQueryDatasetConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*bigquery.BigQueryDataset]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetConnection")
		case "pageInfo":
			out.Values[i] = ec._BigQueryDatasetConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._BigQueryDatasetConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._BigQueryDatasetConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetCostImplementors = []string{"BigQueryDatasetCost"}

func (ec *executionContext) _BigQueryDatasetCost(ctx context.Context, sel ast.SelectionSet, obj *cost.BigQueryDatasetCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetCost")
		case "sum":
			out.Values[i] = ec._BigQueryDatasetCost_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetEdgeImplementors = []string{"BigQueryDatasetEdge"}

func (ec *executionContext) _BigQueryDatasetEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*bigquery.BigQueryDataset]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetEdge")
		case "cursor":
			out.Values[i] = ec._BigQueryDatasetEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._BigQueryDatasetEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bigQueryDatasetStatusImplementors = []string{"BigQueryDatasetStatus"}

func (ec *executionContext) _BigQueryDatasetStatus(ctx context.Context, sel ast.SelectionSet, obj *bigquery.BigQueryDatasetStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bigQueryDatasetStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BigQueryDatasetStatus")
		case "creationTime":
			out.Values[i] = ec._BigQueryDatasetStatus_creationTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastModifiedTime":
			out.Values[i] = ec._BigQueryDatasetStatus_lastModifiedTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bucketImplementors = []string{"Bucket", "Persistence", "Node", "SearchNode"}

func (ec *executionContext) _Bucket(ctx context.Context, sel ast.SelectionSet, obj *bucket.Bucket) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bucketImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bucket")
		case "id":
			out.Values[i] = ec._Bucket_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Bucket_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bucket_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bucket_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bucket_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cascadingDelete":
			out.Values[i] = ec._Bucket_cascadingDelete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "publicAccessPrevention":
			out.Values[i] = ec._Bucket_publicAccessPrevention(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "uniformBucketLevelAccess":
			out.Values[i] = ec._Bucket_uniformBucketLevelAccess(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bucket_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._Bucket_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bucketConnectionImplementors = []string{"BucketConnection"}

func (ec *executionContext) _BucketConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*bucket.Bucket]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bucketConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BucketConnection")
		case "pageInfo":
			out.Values[i] = ec._BucketConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._BucketConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._BucketConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bucketEdgeImplementors = []string{"BucketEdge"}

func (ec *executionContext) _BucketEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*bucket.Bucket]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bucketEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BucketEdge")
		case "cursor":
			out.Values[i] = ec._BucketEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._BucketEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bucketErrorImplementors = []string{"BucketError"}

func (ec *executionContext) _BucketError(ctx context.Context, sel ast.SelectionSet, obj *bucket.BucketError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bucketErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BucketError")
		case "message":
			out.Values[i] = ec._BucketError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "details":
			out.Values[i] = ec._BucketError_details(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bucketStatusImplementors = []string{"BucketStatus"}

func (ec *executionContext) _BucketStatus(ctx context.Context, sel ast.SelectionSet, obj *bucket.BucketStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bucketStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BucketStatus")
		case "state":
			out.Values[i] = ec._BucketStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._BucketStatus_errors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cPUScalingStrategyImplementors = []string{"CPUScalingStrategy", "ScalingStrategy"}

func (ec *executionContext) _CPUScalingStrategy(ctx context.Context, sel ast.SelectionSet, obj *application.CPUScalingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cPUScalingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CPUScalingStrategy")
		case "threshold":
			out.Values[i] = ec._CPUScalingStrategy_threshold(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var changeDeploymentKeyPayloadImplementors = []string{"ChangeDeploymentKeyPayload"}

func (ec *executionContext) _ChangeDeploymentKeyPayload(ctx context.Context, sel ast.SelectionSet, obj *deployment.ChangeDeploymentKeyPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changeDeploymentKeyPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeDeploymentKeyPayload")
		case "deploymentKey":
			out.Values[i] = ec._ChangeDeploymentKeyPayload_deploymentKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var confirmTeamDeletionPayloadImplementors = []string{"ConfirmTeamDeletionPayload"}

func (ec *executionContext) _ConfirmTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, obj *team.ConfirmTeamDeletionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, confirmTeamDeletionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfirmTeamDeletionPayload")
		case "deletionStarted":
			out.Values[i] = ec._ConfirmTeamDeletionPayload_deletionStarted(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerImageImplementors = []string{"ContainerImage", "Node"}

func (ec *executionContext) _ContainerImage(ctx context.Context, sel ast.SelectionSet, obj *workload.ContainerImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerImage")
		case "id":
			out.Values[i] = ec._ContainerImage_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._ContainerImage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tag":
			out.Values[i] = ec._ContainerImage_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hasSBOM":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerImage_hasSBOM(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vulnerabilities":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerImage_vulnerabilities(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vulnerabilitySummary":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerImage_vulnerabilitySummary(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workloadReferences":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerImage_workloadReferences(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerImageWorkloadReferenceImplementors = []string{"ContainerImageWorkloadReference"}

func (ec *executionContext) _ContainerImageWorkloadReference(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.ContainerImageWorkloadReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerImageWorkloadReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerImageWorkloadReference")
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerImageWorkloadReference_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerImageWorkloadReferenceConnectionImplementors = []string{"ContainerImageWorkloadReferenceConnection"}

func (ec *executionContext) _ContainerImageWorkloadReferenceConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerImageWorkloadReferenceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerImageWorkloadReferenceConnection")
		case "pageInfo":
			out.Values[i] = ec._ContainerImageWorkloadReferenceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ContainerImageWorkloadReferenceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ContainerImageWorkloadReferenceConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerImageWorkloadReferenceEdgeImplementors = []string{"ContainerImageWorkloadReferenceEdge"}

func (ec *executionContext) _ContainerImageWorkloadReferenceEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerImageWorkloadReferenceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerImageWorkloadReferenceEdge")
		case "cursor":
			out.Values[i] = ec._ContainerImageWorkloadReferenceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ContainerImageWorkloadReferenceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createSecretPayloadImplementors = []string{"CreateSecretPayload"}

func (ec *executionContext) _CreateSecretPayload(ctx context.Context, sel ast.SelectionSet, obj *secret.CreateSecretPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createSecretPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateSecretPayload")
		case "secret":
			out.Values[i] = ec._CreateSecretPayload_secret(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createServiceAccountPayloadImplementors = []string{"CreateServiceAccountPayload"}

func (ec *executionContext) _CreateServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.CreateServiceAccountPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createServiceAccountPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateServiceAccountPayload")
		case "serviceAccount":
			out.Values[i] = ec._CreateServiceAccountPayload_serviceAccount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createServiceAccountTokenPayloadImplementors = []string{"CreateServiceAccountTokenPayload"}

func (ec *executionContext) _CreateServiceAccountTokenPayload(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.CreateServiceAccountTokenPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createServiceAccountTokenPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateServiceAccountTokenPayload")
		case "serviceAccount":
			out.Values[i] = ec._CreateServiceAccountTokenPayload_serviceAccount(ctx, field, obj)
		case "serviceAccountToken":
			out.Values[i] = ec._CreateServiceAccountTokenPayload_serviceAccountToken(ctx, field, obj)
		case "secret":
			out.Values[i] = ec._CreateServiceAccountTokenPayload_secret(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createTeamPayloadImplementors = []string{"CreateTeamPayload"}

func (ec *executionContext) _CreateTeamPayload(ctx context.Context, sel ast.SelectionSet, obj *team.CreateTeamPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createTeamPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateTeamPayload")
		case "team":
			out.Values[i] = ec._CreateTeamPayload_team(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createUnleashForTeamPayloadImplementors = []string{"CreateUnleashForTeamPayload"}

func (ec *executionContext) _CreateUnleashForTeamPayload(ctx context.Context, sel ast.SelectionSet, obj *unleash.CreateUnleashForTeamPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createUnleashForTeamPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateUnleashForTeamPayload")
		case "unleash":
			out.Values[i] = ec._CreateUnleashForTeamPayload_unleash(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteApplicationPayloadImplementors = []string{"DeleteApplicationPayload"}

func (ec *executionContext) _DeleteApplicationPayload(ctx context.Context, sel ast.SelectionSet, obj *application.DeleteApplicationPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteApplicationPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteApplicationPayload")
		case "team":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteApplicationPayload_team(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "success":
			out.Values[i] = ec._DeleteApplicationPayload_success(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteJobPayloadImplementors = []string{"DeleteJobPayload"}

func (ec *executionContext) _DeleteJobPayload(ctx context.Context, sel ast.SelectionSet, obj *job.DeleteJobPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteJobPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteJobPayload")
		case "team":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteJobPayload_team(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "success":
			out.Values[i] = ec._DeleteJobPayload_success(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteSecretPayloadImplementors = []string{"DeleteSecretPayload"}

func (ec *executionContext) _DeleteSecretPayload(ctx context.Context, sel ast.SelectionSet, obj *secret.DeleteSecretPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteSecretPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteSecretPayload")
		case "secretDeleted":
			out.Values[i] = ec._DeleteSecretPayload_secretDeleted(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteServiceAccountPayloadImplementors = []string{"DeleteServiceAccountPayload"}

func (ec *executionContext) _DeleteServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.DeleteServiceAccountPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteServiceAccountPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteServiceAccountPayload")
		case "serviceAccountDeleted":
			out.Values[i] = ec._DeleteServiceAccountPayload_serviceAccountDeleted(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteServiceAccountTokenPayloadImplementors = []string{"DeleteServiceAccountTokenPayload"}

func (ec *executionContext) _DeleteServiceAccountTokenPayload(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.DeleteServiceAccountTokenPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteServiceAccountTokenPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteServiceAccountTokenPayload")
		case "serviceAccount":
			out.Values[i] = ec._DeleteServiceAccountTokenPayload_serviceAccount(ctx, field, obj)
		case "serviceAccountTokenDeleted":
			out.Values[i] = ec._DeleteServiceAccountTokenPayload_serviceAccountTokenDeleted(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deploymentImplementors = []string{"Deployment", "Node"}

func (ec *executionContext) _Deployment(ctx context.Context, sel ast.SelectionSet, obj *deployment.Deployment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deploymentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Deployment")
		case "id":
			out.Values[i] = ec._Deployment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Deployment_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamSlug":
			out.Values[i] = ec._Deployment_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "environmentName":
			out.Values[i] = ec._Deployment_environmentName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repository":
			out.Values[i] = ec._Deployment_repository(ctx, field, obj)
		case "deployerUsername":
			out.Values[i] = ec._Deployment_deployerUsername(ctx, field, obj)
		case "commitSha":
			out.Values[i] = ec._Deployment_commitSha(ctx, field, obj)
		case "triggerUrl":
			out.Values[i] = ec._Deployment_triggerUrl(ctx, field, obj)
		case "resources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Deployment_resources(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "statuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Deployment_statuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deploymentConnectionImplementors = []string{"DeploymentConnection"}

func (ec *executionContext) _DeploymentConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*deployment.Deployment]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deploymentConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentConnection")
		case "pageInfo":
			out.Values[i] = ec._DeploymentConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._DeploymentConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._DeploymentConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deploymentEdgeImplementors = []string{"DeploymentEdge"}

func (ec *executionContext) _DeploymentEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*deployment.Deployment]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deploymentEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentEdge")
		case "cursor":
			out.Values[i] = ec._DeploymentEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._DeploymentEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deploymentKeyImplementors = []string{"DeploymentKey", "Node"}

func (ec *executionContext) _DeploymentKey(ctx context.Context, sel ast.SelectionSet, obj *deployment.DeploymentKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deploymentKeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentKey")
		case "id":
			out.Values[i] = ec._DeploymentKey_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "key":
			out.Values[i] = ec._DeploymentKey_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "created":
			out.Values[i] = ec._DeploymentKey_created(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expires":
			out.Values[i] = ec._DeploymentKey_expires(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deploymentResourceImplementors = []string{"DeploymentResource", "Node"}

func (ec *executionContext) _DeploymentResource(ctx context.Context, sel ast.SelectionSet, obj *deployment.DeploymentResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deploymentResourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentResource")
		case "id":
			out.Values[i] = ec._DeploymentResource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "kind":
			out.Values[i] = ec._DeploymentResource_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._DeploymentResource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deploymentResourceConnectionImplementors = []string{"DeploymentResourceConnection"}

func (ec *executionContext) _DeploymentResourceConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*deployment.DeploymentResource]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deploymentResourceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentResourceConnection")
		case "pageInfo":
			out.Values[i] = ec._DeploymentResourceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._DeploymentResourceConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._DeploymentResourceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deploymentResourceEdgeImplementors = []string{"DeploymentResourceEdge"}

func (ec *executionContext) _DeploymentResourceEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*deployment.DeploymentResource]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deploymentResourceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentResourceEdge")
		case "cursor":
			out.Values[i] = ec._DeploymentResourceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._DeploymentResourceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deploymentStatusImplementors = []string{"DeploymentStatus", "Node"}

func (ec *executionContext) _DeploymentStatus(ctx context.Context, sel ast.SelectionSet, obj *deployment.DeploymentStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deploymentStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentStatus")
		case "id":
			out.Values[i] = ec._DeploymentStatus_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._DeploymentStatus_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "state":
			out.Values[i] = ec._DeploymentStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._DeploymentStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deploymentStatusConnectionImplementors = []string{"DeploymentStatusConnection"}

func (ec *executionContext) _DeploymentStatusConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*deployment.DeploymentStatus]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deploymentStatusConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentStatusConnection")
		case "pageInfo":
			out.Values[i] = ec._DeploymentStatusConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._DeploymentStatusConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._DeploymentStatusConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deploymentStatusEdgeImplementors = []string{"DeploymentStatusEdge"}

func (ec *executionContext) _DeploymentStatusEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*deployment.DeploymentStatus]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deploymentStatusEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentStatusEdge")
		case "cursor":
			out.Values[i] = ec._DeploymentStatusEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._DeploymentStatusEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var entraIDAuthIntegrationImplementors = []string{"EntraIDAuthIntegration", "ApplicationAuthIntegrations", "JobAuthIntegrations", "AuthIntegration"}

func (ec *executionContext) _EntraIDAuthIntegration(ctx context.Context, sel ast.SelectionSet, obj *workload.EntraIDAuthIntegration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entraIDAuthIntegrationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EntraIDAuthIntegration")
		case "name":
			out.Values[i] = ec._EntraIDAuthIntegration_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var environmentImplementors = []string{"Environment", "Node"}

func (ec *executionContext) _Environment(ctx context.Context, sel ast.SelectionSet, obj *environment.Environment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, environmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Environment")
		case "id":
			out.Values[i] = ec._Environment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Environment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workloads":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_workloads(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var environmentConnectionImplementors = []string{"EnvironmentConnection"}

func (ec *executionContext) _EnvironmentConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*environment.Environment]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, environmentConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EnvironmentConnection")
		case "pageInfo":
			out.Values[i] = ec._EnvironmentConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._EnvironmentConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._EnvironmentConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var environmentEdgeImplementors = []string{"EnvironmentEdge"}

func (ec *executionContext) _EnvironmentEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*environment.Environment]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, environmentEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EnvironmentEdge")
		case "cursor":
			out.Values[i] = ec._EnvironmentEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._EnvironmentEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var externalNetworkPolicyHostImplementors = []string{"ExternalNetworkPolicyHost", "ExternalNetworkPolicyTarget"}

func (ec *executionContext) _ExternalNetworkPolicyHost(ctx context.Context, sel ast.SelectionSet, obj *netpol.ExternalNetworkPolicyHost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalNetworkPolicyHostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalNetworkPolicyHost")
		case "target":
			out.Values[i] = ec._ExternalNetworkPolicyHost_target(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ports":
			out.Values[i] = ec._ExternalNetworkPolicyHost_ports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var externalNetworkPolicyIpv4Implementors = []string{"ExternalNetworkPolicyIpv4", "ExternalNetworkPolicyTarget"}

func (ec *executionContext) _ExternalNetworkPolicyIpv4(ctx context.Context, sel ast.SelectionSet, obj *netpol.ExternalNetworkPolicyIpv4) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalNetworkPolicyIpv4Implementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalNetworkPolicyIpv4")
		case "target":
			out.Values[i] = ec._ExternalNetworkPolicyIpv4_target(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ports":
			out.Values[i] = ec._ExternalNetworkPolicyIpv4_ports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureKafkaImplementors = []string{"FeatureKafka", "Node"}

func (ec *executionContext) _FeatureKafka(ctx context.Context, sel ast.SelectionSet, obj *feature.FeatureKafka) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureKafkaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureKafka")
		case "id":
			out.Values[i] = ec._FeatureKafka_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._FeatureKafka_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureOpenSearchImplementors = []string{"FeatureOpenSearch", "Node"}

func (ec *executionContext) _FeatureOpenSearch(ctx context.Context, sel ast.SelectionSet, obj *feature.FeatureOpenSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureOpenSearchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureOpenSearch")
		case "id":
			out.Values[i] = ec._FeatureOpenSearch_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._FeatureOpenSearch_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureRedisImplementors = []string{"FeatureRedis", "Node"}

func (ec *executionContext) _FeatureRedis(ctx context.Context, sel ast.SelectionSet, obj *feature.FeatureRedis) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureRedisImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureRedis")
		case "id":
			out.Values[i] = ec._FeatureRedis_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._FeatureRedis_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureUnleashImplementors = []string{"FeatureUnleash", "Node"}

func (ec *executionContext) _FeatureUnleash(ctx context.Context, sel ast.SelectionSet, obj *feature.FeatureUnleash) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureUnleashImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureUnleash")
		case "id":
			out.Values[i] = ec._FeatureUnleash_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._FeatureUnleash_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureValkeyImplementors = []string{"FeatureValkey", "Node"}

func (ec *executionContext) _FeatureValkey(ctx context.Context, sel ast.SelectionSet, obj *feature.FeatureValkey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureValkeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureValkey")
		case "id":
			out.Values[i] = ec._FeatureValkey_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._FeatureValkey_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featuresImplementors = []string{"Features", "Node"}

func (ec *executionContext) _Features(ctx context.Context, sel ast.SelectionSet, obj *feature.Features) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featuresImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Features")
		case "id":
			out.Values[i] = ec._Features_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unleash":
			out.Values[i] = ec._Features_unleash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "redis":
			out.Values[i] = ec._Features_redis(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "valkey":
			out.Values[i] = ec._Features_valkey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "kafka":
			out.Values[i] = ec._Features_kafka(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "openSearch":
			out.Values[i] = ec._Features_openSearch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iDPortenAuthIntegrationImplementors = []string{"IDPortenAuthIntegration", "ApplicationAuthIntegrations", "AuthIntegration"}

func (ec *executionContext) _IDPortenAuthIntegration(ctx context.Context, sel ast.SelectionSet, obj *workload.IDPortenAuthIntegration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iDPortenAuthIntegrationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IDPortenAuthIntegration")
		case "name":
			out.Values[i] = ec._IDPortenAuthIntegration_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilityImplementors = []string{"ImageVulnerability", "Node"}

func (ec *executionContext) _ImageVulnerability(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.ImageVulnerability) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerability")
		case "id":
			out.Values[i] = ec._ImageVulnerability_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "identifier":
			out.Values[i] = ec._ImageVulnerability_identifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "severity":
			out.Values[i] = ec._ImageVulnerability_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._ImageVulnerability_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "package":
			out.Values[i] = ec._ImageVulnerability_package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "state":
			out.Values[i] = ec._ImageVulnerability_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "analysisTrail":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ImageVulnerability_analysisTrail(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilityAnalysisCommentImplementors = []string{"ImageVulnerabilityAnalysisComment"}

func (ec *executionContext) _ImageVulnerabilityAnalysisComment(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.ImageVulnerabilityAnalysisComment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilityAnalysisCommentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerabilityAnalysisComment")
		case "comment":
			out.Values[i] = ec._ImageVulnerabilityAnalysisComment_comment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suppressed":
			out.Values[i] = ec._ImageVulnerabilityAnalysisComment_suppressed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "state":
			out.Values[i] = ec._ImageVulnerabilityAnalysisComment_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ImageVulnerabilityAnalysisComment_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "onBehalfOf":
			out.Values[i] = ec._ImageVulnerabilityAnalysisComment_onBehalfOf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilityAnalysisCommentConnectionImplementors = []string{"ImageVulnerabilityAnalysisCommentConnection"}

func (ec *executionContext) _ImageVulnerabilityAnalysisCommentConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilityAnalysisCommentConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerabilityAnalysisCommentConnection")
		case "pageInfo":
			out.Values[i] = ec._ImageVulnerabilityAnalysisCommentConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ImageVulnerabilityAnalysisCommentConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ImageVulnerabilityAnalysisCommentConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilityAnalysisCommentEdgeImplementors = []string{"ImageVulnerabilityAnalysisCommentEdge"}

func (ec *executionContext) _ImageVulnerabilityAnalysisCommentEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*vulnerability.ImageVulnerabilityAnalysisComment]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilityAnalysisCommentEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerabilityAnalysisCommentEdge")
		case "cursor":
			out.Values[i] = ec._ImageVulnerabilityAnalysisCommentEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ImageVulnerabilityAnalysisCommentEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilityAnalysisTrailImplementors = []string{"ImageVulnerabilityAnalysisTrail"}

func (ec *executionContext) _ImageVulnerabilityAnalysisTrail(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.ImageVulnerabilityAnalysisTrail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilityAnalysisTrailImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerabilityAnalysisTrail")
		case "state":
			out.Values[i] = ec._ImageVulnerabilityAnalysisTrail_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "comments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ImageVulnerabilityAnalysisTrail_comments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "suppressed":
			out.Values[i] = ec._ImageVulnerabilityAnalysisTrail_suppressed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilityConnectionImplementors = []string{"ImageVulnerabilityConnection"}

func (ec *executionContext) _ImageVulnerabilityConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilityConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerabilityConnection")
		case "pageInfo":
			out.Values[i] = ec._ImageVulnerabilityConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ImageVulnerabilityConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ImageVulnerabilityConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilityEdgeImplementors = []string{"ImageVulnerabilityEdge"}

func (ec *executionContext) _ImageVulnerabilityEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilityEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerabilityEdge")
		case "cursor":
			out.Values[i] = ec._ImageVulnerabilityEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ImageVulnerabilityEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageVulnerabilitySummaryImplementors = []string{"ImageVulnerabilitySummary"}

func (ec *executionContext) _ImageVulnerabilitySummary(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.ImageVulnerabilitySummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageVulnerabilitySummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageVulnerabilitySummary")
		case "total":
			out.Values[i] = ec._ImageVulnerabilitySummary_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "riskScore":
			out.Values[i] = ec._ImageVulnerabilitySummary_riskScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "low":
			out.Values[i] = ec._ImageVulnerabilitySummary_low(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "medium":
			out.Values[i] = ec._ImageVulnerabilitySummary_medium(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "high":
			out.Values[i] = ec._ImageVulnerabilitySummary_high(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "critical":
			out.Values[i] = ec._ImageVulnerabilitySummary_critical(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unassigned":
			out.Values[i] = ec._ImageVulnerabilitySummary_unassigned(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inboundNetworkPolicyImplementors = []string{"InboundNetworkPolicy"}

func (ec *executionContext) _InboundNetworkPolicy(ctx context.Context, sel ast.SelectionSet, obj *netpol.InboundNetworkPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inboundNetworkPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InboundNetworkPolicy")
		case "rules":
			out.Values[i] = ec._InboundNetworkPolicy_rules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ingressImplementors = []string{"Ingress"}

func (ec *executionContext) _Ingress(ctx context.Context, sel ast.SelectionSet, obj *application.Ingress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ingressImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Ingress")
		case "url":
			out.Values[i] = ec._Ingress_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ingress_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobImplementors = []string{"Job", "Node", "Workload", "SearchNode"}

func (ec *executionContext) _Job(ctx context.Context, sel ast.SelectionSet, obj *job.Job) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Job")
		case "id":
			out.Values[i] = ec._Job_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Job_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "image":
			out.Values[i] = ec._Job_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resources":
			out.Values[i] = ec._Job_resources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authIntegrations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_authIntegrations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "schedule":
			out.Values[i] = ec._Job_schedule(ctx, field, obj)
		case "runs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_runs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "manifest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_manifest(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deletionStartedAt":
			out.Values[i] = ec._Job_deletionStartedAt(ctx, field, obj)
		case "bigQueryDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_bigQueryDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buckets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_buckets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deployments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_deployments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "kafkaTopicAcls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_kafkaTopicAcls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logDestinations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_logDestinations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "networkPolicy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_networkPolicy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "openSearch":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_openSearch(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "redisInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_redisInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "secrets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_secrets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sqlInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_sqlInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "valkeyInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_valkeyInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobConnectionImplementors = []string{"JobConnection"}

func (ec *executionContext) _JobConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*job.Job]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobConnection")
		case "pageInfo":
			out.Values[i] = ec._JobConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._JobConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._JobConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobDeletedActivityLogEntryImplementors = []string{"JobDeletedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _JobDeletedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *job.JobDeletedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobDeletedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobDeletedActivityLogEntry")
		case "id":
			out.Values[i] = ec._JobDeletedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._JobDeletedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._JobDeletedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._JobDeletedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._JobDeletedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._JobDeletedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._JobDeletedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._JobDeletedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobEdgeImplementors = []string{"JobEdge"}

func (ec *executionContext) _JobEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*job.Job]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobEdge")
		case "cursor":
			out.Values[i] = ec._JobEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._JobEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobManifestImplementors = []string{"JobManifest", "WorkloadManifest"}

func (ec *executionContext) _JobManifest(ctx context.Context, sel ast.SelectionSet, obj *job.JobManifest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobManifestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobManifest")
		case "content":
			out.Values[i] = ec._JobManifest_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobResourcesImplementors = []string{"JobResources", "WorkloadResources"}

func (ec *executionContext) _JobResources(ctx context.Context, sel ast.SelectionSet, obj *job.JobResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobResourcesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobResources")
		case "limits":
			out.Values[i] = ec._JobResources_limits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requests":
			out.Values[i] = ec._JobResources_requests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRunImplementors = []string{"JobRun", "Node"}

func (ec *executionContext) _JobRun(ctx context.Context, sel ast.SelectionSet, obj *job.JobRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRunImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRun")
		case "id":
			out.Values[i] = ec._JobRun_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._JobRun_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "startTime":
			out.Values[i] = ec._JobRun_startTime(ctx, field, obj)
		case "completionTime":
			out.Values[i] = ec._JobRun_completionTime(ctx, field, obj)
		case "status":
			out.Values[i] = ec._JobRun_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "image":
			out.Values[i] = ec._JobRun_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "duration":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JobRun_duration(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "instances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JobRun_instances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trigger":
			out.Values[i] = ec._JobRun_trigger(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRunConnectionImplementors = []string{"JobRunConnection"}

func (ec *executionContext) _JobRunConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*job.JobRun]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRunConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRunConnection")
		case "pageInfo":
			out.Values[i] = ec._JobRunConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._JobRunConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._JobRunConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRunEdgeImplementors = []string{"JobRunEdge"}

func (ec *executionContext) _JobRunEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*job.JobRun]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRunEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRunEdge")
		case "cursor":
			out.Values[i] = ec._JobRunEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._JobRunEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRunInstanceImplementors = []string{"JobRunInstance", "Node"}

func (ec *executionContext) _JobRunInstance(ctx context.Context, sel ast.SelectionSet, obj *job.JobRunInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRunInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRunInstance")
		case "id":
			out.Values[i] = ec._JobRunInstance_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._JobRunInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRunInstanceConnectionImplementors = []string{"JobRunInstanceConnection"}

func (ec *executionContext) _JobRunInstanceConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*job.JobRunInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRunInstanceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRunInstanceConnection")
		case "pageInfo":
			out.Values[i] = ec._JobRunInstanceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._JobRunInstanceConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._JobRunInstanceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRunInstanceEdgeImplementors = []string{"JobRunInstanceEdge"}

func (ec *executionContext) _JobRunInstanceEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*job.JobRunInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRunInstanceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRunInstanceEdge")
		case "cursor":
			out.Values[i] = ec._JobRunInstanceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._JobRunInstanceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRunStatusImplementors = []string{"JobRunStatus"}

func (ec *executionContext) _JobRunStatus(ctx context.Context, sel ast.SelectionSet, obj *job.JobRunStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRunStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRunStatus")
		case "state":
			out.Values[i] = ec._JobRunStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._JobRunStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRunTriggerImplementors = []string{"JobRunTrigger"}

func (ec *executionContext) _JobRunTrigger(ctx context.Context, sel ast.SelectionSet, obj *job.JobRunTrigger) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRunTriggerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRunTrigger")
		case "type":
			out.Values[i] = ec._JobRunTrigger_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._JobRunTrigger_actor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobScheduleImplementors = []string{"JobSchedule"}

func (ec *executionContext) _JobSchedule(ctx context.Context, sel ast.SelectionSet, obj *job.JobSchedule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobScheduleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobSchedule")
		case "expression":
			out.Values[i] = ec._JobSchedule_expression(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timeZone":
			out.Values[i] = ec._JobSchedule_timeZone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobTriggeredActivityLogEntryImplementors = []string{"JobTriggeredActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _JobTriggeredActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *job.JobTriggeredActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobTriggeredActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobTriggeredActivityLogEntry")
		case "id":
			out.Values[i] = ec._JobTriggeredActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._JobTriggeredActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._JobTriggeredActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._JobTriggeredActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._JobTriggeredActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._JobTriggeredActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._JobTriggeredActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._JobTriggeredActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaLagScalingStrategyImplementors = []string{"KafkaLagScalingStrategy", "ScalingStrategy"}

func (ec *executionContext) _KafkaLagScalingStrategy(ctx context.Context, sel ast.SelectionSet, obj *application.KafkaLagScalingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaLagScalingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaLagScalingStrategy")
		case "threshold":
			out.Values[i] = ec._KafkaLagScalingStrategy_threshold(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consumerGroup":
			out.Values[i] = ec._KafkaLagScalingStrategy_consumerGroup(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "topicName":
			out.Values[i] = ec._KafkaLagScalingStrategy_topicName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicImplementors = []string{"KafkaTopic", "Persistence", "Node", "SearchNode"}

func (ec *executionContext) _KafkaTopic(ctx context.Context, sel ast.SelectionSet, obj *kafkatopic.KafkaTopic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopic")
		case "id":
			out.Values[i] = ec._KafkaTopic_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._KafkaTopic_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopic_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopic_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopic_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "acl":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopic_acl(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "configuration":
			out.Values[i] = ec._KafkaTopic_configuration(ctx, field, obj)
		case "pool":
			out.Values[i] = ec._KafkaTopic_pool(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicAclImplementors = []string{"KafkaTopicAcl"}

func (ec *executionContext) _KafkaTopicAcl(ctx context.Context, sel ast.SelectionSet, obj *kafkatopic.KafkaTopicACL) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicAclImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicAcl")
		case "access":
			out.Values[i] = ec._KafkaTopicAcl_access(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workloadName":
			out.Values[i] = ec._KafkaTopicAcl_workloadName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teamName":
			out.Values[i] = ec._KafkaTopicAcl_teamName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopicAcl_team(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopicAcl_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KafkaTopicAcl_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicAclConnectionImplementors = []string{"KafkaTopicAclConnection"}

func (ec *executionContext) _KafkaTopicAclConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicAclConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicAclConnection")
		case "pageInfo":
			out.Values[i] = ec._KafkaTopicAclConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._KafkaTopicAclConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._KafkaTopicAclConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicAclEdgeImplementors = []string{"KafkaTopicAclEdge"}

func (ec *executionContext) _KafkaTopicAclEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicAclEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicAclEdge")
		case "cursor":
			out.Values[i] = ec._KafkaTopicAclEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._KafkaTopicAclEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicConfigurationImplementors = []string{"KafkaTopicConfiguration"}

func (ec *executionContext) _KafkaTopicConfiguration(ctx context.Context, sel ast.SelectionSet, obj *kafkatopic.KafkaTopicConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicConfigurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicConfiguration")
		case "cleanupPolicy":
			out.Values[i] = ec._KafkaTopicConfiguration_cleanupPolicy(ctx, field, obj)
		case "maxMessageBytes":
			out.Values[i] = ec._KafkaTopicConfiguration_maxMessageBytes(ctx, field, obj)
		case "minimumInSyncReplicas":
			out.Values[i] = ec._KafkaTopicConfiguration_minimumInSyncReplicas(ctx, field, obj)
		case "partitions":
			out.Values[i] = ec._KafkaTopicConfiguration_partitions(ctx, field, obj)
		case "replication":
			out.Values[i] = ec._KafkaTopicConfiguration_replication(ctx, field, obj)
		case "retentionBytes":
			out.Values[i] = ec._KafkaTopicConfiguration_retentionBytes(ctx, field, obj)
		case "retentionHours":
			out.Values[i] = ec._KafkaTopicConfiguration_retentionHours(ctx, field, obj)
		case "segmentHours":
			out.Values[i] = ec._KafkaTopicConfiguration_segmentHours(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicConnectionImplementors = []string{"KafkaTopicConnection"}

func (ec *executionContext) _KafkaTopicConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicConnection")
		case "pageInfo":
			out.Values[i] = ec._KafkaTopicConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._KafkaTopicConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._KafkaTopicConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kafkaTopicEdgeImplementors = []string{"KafkaTopicEdge"}

func (ec *executionContext) _KafkaTopicEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kafkaTopicEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KafkaTopicEdge")
		case "cursor":
			out.Values[i] = ec._KafkaTopicEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._KafkaTopicEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logDestinationLokiImplementors = []string{"LogDestinationLoki", "LogDestination", "Node"}

func (ec *executionContext) _LogDestinationLoki(ctx context.Context, sel ast.SelectionSet, obj *logging.LogDestinationLoki) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logDestinationLokiImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogDestinationLoki")
		case "id":
			out.Values[i] = ec._LogDestinationLoki_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "grafanaURL":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LogDestinationLoki_grafanaURL(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logDestinationSecureLogsImplementors = []string{"LogDestinationSecureLogs", "LogDestination", "Node"}

func (ec *executionContext) _LogDestinationSecureLogs(ctx context.Context, sel ast.SelectionSet, obj *logging.LogDestinationSecureLogs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logDestinationSecureLogsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogDestinationSecureLogs")
		case "id":
			out.Values[i] = ec._LogDestinationSecureLogs_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var maskinportenAuthIntegrationImplementors = []string{"MaskinportenAuthIntegration", "ApplicationAuthIntegrations", "JobAuthIntegrations", "AuthIntegration"}

func (ec *executionContext) _MaskinportenAuthIntegration(ctx context.Context, sel ast.SelectionSet, obj *workload.MaskinportenAuthIntegration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maskinportenAuthIntegrationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MaskinportenAuthIntegration")
		case "name":
			out.Values[i] = ec._MaskinportenAuthIntegration_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "deleteApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changeDeploymentKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_changeDeploymentKey(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteJob":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteJob(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerJob":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_triggerJob(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enableReconciler":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_enableReconciler(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disableReconciler":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_disableReconciler(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configureReconciler":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_configureReconciler(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addRepositoryToTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addRepositoryToTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeRepositoryFromTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeRepositoryFromTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSecret":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSecret(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addSecretValue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addSecretValue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSecretValue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSecretValue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeSecretValue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeSecretValue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSecret":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSecret(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createServiceAccount":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createServiceAccount(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateServiceAccount":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateServiceAccount(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteServiceAccount":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteServiceAccount(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "assignRoleToServiceAccount":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_assignRoleToServiceAccount(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revokeRoleFromServiceAccount":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_revokeRoleFromServiceAccount(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createServiceAccountToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createServiceAccountToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateServiceAccountToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateServiceAccountToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteServiceAccountToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteServiceAccountToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTeamEnvironment":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTeamEnvironment(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestTeamDeletion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestTeamDeletion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "confirmTeamDeletion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_confirmTeamDeletion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addTeamMember":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addTeamMember(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeTeamMember":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeTeamMember(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setTeamMemberRole":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setTeamMemberRole(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createUnleashForTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUnleashForTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowTeamAccessToUnleash":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_allowTeamAccessToUnleash(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revokeTeamAccessToUnleash":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_revokeTeamAccessToUnleash(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateImageVulnerability":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateImageVulnerability(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var networkPolicyImplementors = []string{"NetworkPolicy"}

func (ec *executionContext) _NetworkPolicy(ctx context.Context, sel ast.SelectionSet, obj *netpol.NetworkPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkPolicy")
		case "inbound":
			out.Values[i] = ec._NetworkPolicy_inbound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "outbound":
			out.Values[i] = ec._NetworkPolicy_outbound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var networkPolicyRuleImplementors = []string{"NetworkPolicyRule"}

func (ec *executionContext) _NetworkPolicyRule(ctx context.Context, sel ast.SelectionSet, obj *netpol.NetworkPolicyRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkPolicyRuleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkPolicyRule")
		case "targetWorkloadName":
			out.Values[i] = ec._NetworkPolicyRule_targetWorkloadName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetWorkload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._NetworkPolicyRule_targetWorkload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "targetTeamSlug":
			out.Values[i] = ec._NetworkPolicyRule_targetTeamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetTeam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._NetworkPolicyRule_targetTeam(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mutual":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._NetworkPolicyRule_mutual(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchImplementors = []string{"OpenSearch", "Persistence", "Node", "SearchNode"}

func (ec *executionContext) _OpenSearch(ctx context.Context, sel ast.SelectionSet, obj *opensearch.OpenSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearch")
		case "id":
			out.Values[i] = ec._OpenSearch_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._OpenSearch_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearch_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearch_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearch_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._OpenSearch_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearch_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "access":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearch_access(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearch_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchAccessImplementors = []string{"OpenSearchAccess"}

func (ec *executionContext) _OpenSearchAccess(ctx context.Context, sel ast.SelectionSet, obj *opensearch.OpenSearchAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchAccessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchAccess")
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpenSearchAccess_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "access":
			out.Values[i] = ec._OpenSearchAccess_access(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchAccessConnectionImplementors = []string{"OpenSearchAccessConnection"}

func (ec *executionContext) _OpenSearchAccessConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchAccessConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchAccessConnection")
		case "pageInfo":
			out.Values[i] = ec._OpenSearchAccessConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._OpenSearchAccessConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._OpenSearchAccessConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchAccessEdgeImplementors = []string{"OpenSearchAccessEdge"}

func (ec *executionContext) _OpenSearchAccessEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchAccessEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchAccessEdge")
		case "cursor":
			out.Values[i] = ec._OpenSearchAccessEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._OpenSearchAccessEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchConnectionImplementors = []string{"OpenSearchConnection"}

func (ec *executionContext) _OpenSearchConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*opensearch.OpenSearch]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchConnection")
		case "pageInfo":
			out.Values[i] = ec._OpenSearchConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._OpenSearchConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._OpenSearchConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchCostImplementors = []string{"OpenSearchCost"}

func (ec *executionContext) _OpenSearchCost(ctx context.Context, sel ast.SelectionSet, obj *cost.OpenSearchCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchCost")
		case "sum":
			out.Values[i] = ec._OpenSearchCost_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchEdgeImplementors = []string{"OpenSearchEdge"}

func (ec *executionContext) _OpenSearchEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*opensearch.OpenSearch]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchEdge")
		case "cursor":
			out.Values[i] = ec._OpenSearchEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._OpenSearchEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSearchStatusImplementors = []string{"OpenSearchStatus"}

func (ec *executionContext) _OpenSearchStatus(ctx context.Context, sel ast.SelectionSet, obj *opensearch.OpenSearchStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSearchStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSearchStatus")
		case "state":
			out.Values[i] = ec._OpenSearchStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var outboundNetworkPolicyImplementors = []string{"OutboundNetworkPolicy"}

func (ec *executionContext) _OutboundNetworkPolicy(ctx context.Context, sel ast.SelectionSet, obj *netpol.OutboundNetworkPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, outboundNetworkPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OutboundNetworkPolicy")
		case "rules":
			out.Values[i] = ec._OutboundNetworkPolicy_rules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "external":
			out.Values[i] = ec._OutboundNetworkPolicy_external(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *pagination.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._PageInfo_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageStart":
			out.Values[i] = ec._PageInfo_pageStart(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageEnd":
			out.Values[i] = ec._PageInfo_pageEnd(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "roles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_roles(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "environments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_environments(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_environment(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "features":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_features(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "reconcilers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_reconcilers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "search":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_search(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "serviceAccounts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_serviceAccounts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "serviceAccount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_serviceAccount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "teams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_teams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_team(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "me":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userSyncLog":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userSyncLog(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "teamsUtilization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_teamsUtilization(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerImplementors = []string{"Reconciler", "Node"}

func (ec *executionContext) _Reconciler(ctx context.Context, sel ast.SelectionSet, obj *reconciler.Reconciler) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Reconciler")
		case "id":
			out.Values[i] = ec._Reconciler_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Reconciler_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._Reconciler_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Reconciler_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "enabled":
			out.Values[i] = ec._Reconciler_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "config":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Reconciler_config(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "configured":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Reconciler_configured(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "errors":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Reconciler_errors(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "activityLog":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Reconciler_activityLog(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerConfigImplementors = []string{"ReconcilerConfig"}

func (ec *executionContext) _ReconcilerConfig(ctx context.Context, sel ast.SelectionSet, obj *reconciler.ReconcilerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerConfig")
		case "key":
			out.Values[i] = ec._ReconcilerConfig_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._ReconcilerConfig_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ReconcilerConfig_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configured":
			out.Values[i] = ec._ReconcilerConfig_configured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secret":
			out.Values[i] = ec._ReconcilerConfig_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._ReconcilerConfig_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerConfiguredActivityLogEntryImplementors = []string{"ReconcilerConfiguredActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *reconciler.ReconcilerConfiguredActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerConfiguredActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerConfiguredActivityLogEntry")
		case "id":
			out.Values[i] = ec._ReconcilerConfiguredActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ReconcilerConfiguredActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ReconcilerConfiguredActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ReconcilerConfiguredActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ReconcilerConfiguredActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ReconcilerConfiguredActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ReconcilerConfiguredActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._ReconcilerConfiguredActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._ReconcilerConfiguredActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerConfiguredActivityLogEntryDataImplementors = []string{"ReconcilerConfiguredActivityLogEntryData"}

func (ec *executionContext) _ReconcilerConfiguredActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *reconciler.ReconcilerConfiguredActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerConfiguredActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerConfiguredActivityLogEntryData")
		case "updatedKeys":
			out.Values[i] = ec._ReconcilerConfiguredActivityLogEntryData_updatedKeys(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerConnectionImplementors = []string{"ReconcilerConnection"}

func (ec *executionContext) _ReconcilerConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*reconciler.Reconciler]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerConnection")
		case "pageInfo":
			out.Values[i] = ec._ReconcilerConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ReconcilerConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ReconcilerConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerDisabledActivityLogEntryImplementors = []string{"ReconcilerDisabledActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ReconcilerDisabledActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *reconciler.ReconcilerDisabledActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerDisabledActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerDisabledActivityLogEntry")
		case "id":
			out.Values[i] = ec._ReconcilerDisabledActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ReconcilerDisabledActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ReconcilerDisabledActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ReconcilerDisabledActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ReconcilerDisabledActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ReconcilerDisabledActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ReconcilerDisabledActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._ReconcilerDisabledActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerEdgeImplementors = []string{"ReconcilerEdge"}

func (ec *executionContext) _ReconcilerEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*reconciler.Reconciler]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerEdge")
		case "cursor":
			out.Values[i] = ec._ReconcilerEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ReconcilerEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerEnabledActivityLogEntryImplementors = []string{"ReconcilerEnabledActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ReconcilerEnabledActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *reconciler.ReconcilerEnabledActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerEnabledActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerEnabledActivityLogEntry")
		case "id":
			out.Values[i] = ec._ReconcilerEnabledActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ReconcilerEnabledActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ReconcilerEnabledActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ReconcilerEnabledActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ReconcilerEnabledActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ReconcilerEnabledActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ReconcilerEnabledActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._ReconcilerEnabledActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerErrorImplementors = []string{"ReconcilerError", "Node"}

func (ec *executionContext) _ReconcilerError(ctx context.Context, sel ast.SelectionSet, obj *reconciler.ReconcilerError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerError")
		case "id":
			out.Values[i] = ec._ReconcilerError_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "correlationID":
			out.Values[i] = ec._ReconcilerError_correlationID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._ReconcilerError_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._ReconcilerError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ReconcilerError_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerErrorConnectionImplementors = []string{"ReconcilerErrorConnection"}

func (ec *executionContext) _ReconcilerErrorConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*reconciler.ReconcilerError]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerErrorConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerErrorConnection")
		case "pageInfo":
			out.Values[i] = ec._ReconcilerErrorConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ReconcilerErrorConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ReconcilerErrorConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconcilerErrorEdgeImplementors = []string{"ReconcilerErrorEdge"}

func (ec *executionContext) _ReconcilerErrorEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*reconciler.ReconcilerError]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconcilerErrorEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconcilerErrorEdge")
		case "cursor":
			out.Values[i] = ec._ReconcilerErrorEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ReconcilerErrorEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceImplementors = []string{"RedisInstance", "Persistence", "Node", "SearchNode"}

func (ec *executionContext) _RedisInstance(ctx context.Context, sel ast.SelectionSet, obj *redis.RedisInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstance")
		case "id":
			out.Values[i] = ec._RedisInstance_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._RedisInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstance_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstance_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstance_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "access":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstance_access(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstance_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._RedisInstance_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstance_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceAccessImplementors = []string{"RedisInstanceAccess"}

func (ec *executionContext) _RedisInstanceAccess(ctx context.Context, sel ast.SelectionSet, obj *redis.RedisInstanceAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceAccessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceAccess")
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RedisInstanceAccess_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "access":
			out.Values[i] = ec._RedisInstanceAccess_access(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceAccessConnectionImplementors = []string{"RedisInstanceAccessConnection"}

func (ec *executionContext) _RedisInstanceAccessConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*redis.RedisInstanceAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceAccessConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceAccessConnection")
		case "pageInfo":
			out.Values[i] = ec._RedisInstanceAccessConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._RedisInstanceAccessConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._RedisInstanceAccessConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceAccessEdgeImplementors = []string{"RedisInstanceAccessEdge"}

func (ec *executionContext) _RedisInstanceAccessEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*redis.RedisInstanceAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceAccessEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceAccessEdge")
		case "cursor":
			out.Values[i] = ec._RedisInstanceAccessEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._RedisInstanceAccessEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceConnectionImplementors = []string{"RedisInstanceConnection"}

func (ec *executionContext) _RedisInstanceConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*redis.RedisInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceConnection")
		case "pageInfo":
			out.Values[i] = ec._RedisInstanceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._RedisInstanceConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._RedisInstanceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceCostImplementors = []string{"RedisInstanceCost"}

func (ec *executionContext) _RedisInstanceCost(ctx context.Context, sel ast.SelectionSet, obj *cost.RedisInstanceCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceCost")
		case "sum":
			out.Values[i] = ec._RedisInstanceCost_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceEdgeImplementors = []string{"RedisInstanceEdge"}

func (ec *executionContext) _RedisInstanceEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*redis.RedisInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceEdge")
		case "cursor":
			out.Values[i] = ec._RedisInstanceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._RedisInstanceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var redisInstanceStatusImplementors = []string{"RedisInstanceStatus"}

func (ec *executionContext) _RedisInstanceStatus(ctx context.Context, sel ast.SelectionSet, obj *redis.RedisInstanceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, redisInstanceStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RedisInstanceStatus")
		case "state":
			out.Values[i] = ec._RedisInstanceStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var removeRepositoryFromTeamPayloadImplementors = []string{"RemoveRepositoryFromTeamPayload"}

func (ec *executionContext) _RemoveRepositoryFromTeamPayload(ctx context.Context, sel ast.SelectionSet, obj *repository.RemoveRepositoryFromTeamPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, removeRepositoryFromTeamPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RemoveRepositoryFromTeamPayload")
		case "success":
			out.Values[i] = ec._RemoveRepositoryFromTeamPayload_success(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var removeSecretValuePayloadImplementors = []string{"RemoveSecretValuePayload"}

func (ec *executionContext) _RemoveSecretValuePayload(ctx context.Context, sel ast.SelectionSet, obj *secret.RemoveSecretValuePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, removeSecretValuePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RemoveSecretValuePayload")
		case "secret":
			out.Values[i] = ec._RemoveSecretValuePayload_secret(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var removeTeamMemberPayloadImplementors = []string{"RemoveTeamMemberPayload"}

func (ec *executionContext) _RemoveTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, obj *team.RemoveTeamMemberPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, removeTeamMemberPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RemoveTeamMemberPayload")
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RemoveTeamMemberPayload_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "team":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RemoveTeamMemberPayload_team(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repositoryImplementors = []string{"Repository", "Node"}

func (ec *executionContext) _Repository(ctx context.Context, sel ast.SelectionSet, obj *repository.Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "id":
			out.Values[i] = ec._Repository_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Repository_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repositoryAddedActivityLogEntryImplementors = []string{"RepositoryAddedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _RepositoryAddedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *repository.RepositoryAddedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryAddedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryAddedActivityLogEntry")
		case "id":
			out.Values[i] = ec._RepositoryAddedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._RepositoryAddedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._RepositoryAddedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RepositoryAddedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._RepositoryAddedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._RepositoryAddedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._RepositoryAddedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._RepositoryAddedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repositoryConnectionImplementors = []string{"RepositoryConnection"}

func (ec *executionContext) _RepositoryConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*repository.Repository]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryConnection")
		case "pageInfo":
			out.Values[i] = ec._RepositoryConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._RepositoryConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._RepositoryConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repositoryEdgeImplementors = []string{"RepositoryEdge"}

func (ec *executionContext) _RepositoryEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*repository.Repository]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryEdge")
		case "cursor":
			out.Values[i] = ec._RepositoryEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._RepositoryEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repositoryRemovedActivityLogEntryImplementors = []string{"RepositoryRemovedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _RepositoryRemovedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *repository.RepositoryRemovedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryRemovedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryRemovedActivityLogEntry")
		case "id":
			out.Values[i] = ec._RepositoryRemovedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._RepositoryRemovedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._RepositoryRemovedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RepositoryRemovedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._RepositoryRemovedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._RepositoryRemovedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._RepositoryRemovedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._RepositoryRemovedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var requestTeamDeletionPayloadImplementors = []string{"RequestTeamDeletionPayload"}

func (ec *executionContext) _RequestTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, obj *team.RequestTeamDeletionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, requestTeamDeletionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RequestTeamDeletionPayload")
		case "key":
			out.Values[i] = ec._RequestTeamDeletionPayload_key(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var restartApplicationPayloadImplementors = []string{"RestartApplicationPayload"}

func (ec *executionContext) _RestartApplicationPayload(ctx context.Context, sel ast.SelectionSet, obj *application.RestartApplicationPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, restartApplicationPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestartApplicationPayload")
		case "application":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RestartApplicationPayload_application(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var revokeRoleFromServiceAccountPayloadImplementors = []string{"RevokeRoleFromServiceAccountPayload"}

func (ec *executionContext) _RevokeRoleFromServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.RevokeRoleFromServiceAccountPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, revokeRoleFromServiceAccountPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RevokeRoleFromServiceAccountPayload")
		case "serviceAccount":
			out.Values[i] = ec._RevokeRoleFromServiceAccountPayload_serviceAccount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var revokeTeamAccessToUnleashPayloadImplementors = []string{"RevokeTeamAccessToUnleashPayload"}

func (ec *executionContext) _RevokeTeamAccessToUnleashPayload(ctx context.Context, sel ast.SelectionSet, obj *unleash.RevokeTeamAccessToUnleashPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, revokeTeamAccessToUnleashPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RevokeTeamAccessToUnleashPayload")
		case "unleash":
			out.Values[i] = ec._RevokeTeamAccessToUnleashPayload_unleash(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roleImplementors = []string{"Role", "Node"}

func (ec *executionContext) _Role(ctx context.Context, sel ast.SelectionSet, obj *authz.Role) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Role")
		case "id":
			out.Values[i] = ec._Role_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Role_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Role_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roleAssignedToServiceAccountActivityLogEntryImplementors = []string{"RoleAssignedToServiceAccountActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roleAssignedToServiceAccountActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoleAssignedToServiceAccountActivityLogEntry")
		case "id":
			out.Values[i] = ec._RoleAssignedToServiceAccountActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._RoleAssignedToServiceAccountActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._RoleAssignedToServiceAccountActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RoleAssignedToServiceAccountActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._RoleAssignedToServiceAccountActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._RoleAssignedToServiceAccountActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._RoleAssignedToServiceAccountActivityLogEntry_teamSlug(ctx, field, obj)
		case "environmentName":
			out.Values[i] = ec._RoleAssignedToServiceAccountActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._RoleAssignedToServiceAccountActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roleAssignedToServiceAccountActivityLogEntryDataImplementors = []string{"RoleAssignedToServiceAccountActivityLogEntryData"}

func (ec *executionContext) _RoleAssignedToServiceAccountActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.RoleAssignedToServiceAccountActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roleAssignedToServiceAccountActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoleAssignedToServiceAccountActivityLogEntryData")
		case "roleName":
			out.Values[i] = ec._RoleAssignedToServiceAccountActivityLogEntryData_roleName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roleAssignedUserSyncLogEntryImplementors = []string{"RoleAssignedUserSyncLogEntry", "UserSyncLogEntry", "Node"}

func (ec *executionContext) _RoleAssignedUserSyncLogEntry(ctx context.Context, sel ast.SelectionSet, obj *usersync.RoleAssignedUserSyncLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roleAssignedUserSyncLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoleAssignedUserSyncLogEntry")
		case "id":
			out.Values[i] = ec._RoleAssignedUserSyncLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._RoleAssignedUserSyncLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RoleAssignedUserSyncLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userID":
			out.Values[i] = ec._RoleAssignedUserSyncLogEntry_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userName":
			out.Values[i] = ec._RoleAssignedUserSyncLogEntry_userName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userEmail":
			out.Values[i] = ec._RoleAssignedUserSyncLogEntry_userEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roleName":
			out.Values[i] = ec._RoleAssignedUserSyncLogEntry_roleName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roleConnectionImplementors = []string{"RoleConnection"}

func (ec *executionContext) _RoleConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*authz.Role]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roleConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoleConnection")
		case "nodes":
			out.Values[i] = ec._RoleConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._RoleConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._RoleConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roleEdgeImplementors = []string{"RoleEdge"}

func (ec *executionContext) _RoleEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*authz.Role]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roleEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoleEdge")
		case "node":
			out.Values[i] = ec._RoleEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._RoleEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roleRevokedFromServiceAccountActivityLogEntryImplementors = []string{"RoleRevokedFromServiceAccountActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roleRevokedFromServiceAccountActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoleRevokedFromServiceAccountActivityLogEntry")
		case "id":
			out.Values[i] = ec._RoleRevokedFromServiceAccountActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._RoleRevokedFromServiceAccountActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._RoleRevokedFromServiceAccountActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RoleRevokedFromServiceAccountActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._RoleRevokedFromServiceAccountActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._RoleRevokedFromServiceAccountActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._RoleRevokedFromServiceAccountActivityLogEntry_teamSlug(ctx, field, obj)
		case "environmentName":
			out.Values[i] = ec._RoleRevokedFromServiceAccountActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._RoleRevokedFromServiceAccountActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roleRevokedFromServiceAccountActivityLogEntryDataImplementors = []string{"RoleRevokedFromServiceAccountActivityLogEntryData"}

func (ec *executionContext) _RoleRevokedFromServiceAccountActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roleRevokedFromServiceAccountActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoleRevokedFromServiceAccountActivityLogEntryData")
		case "roleName":
			out.Values[i] = ec._RoleRevokedFromServiceAccountActivityLogEntryData_roleName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roleRevokedUserSyncLogEntryImplementors = []string{"RoleRevokedUserSyncLogEntry", "UserSyncLogEntry", "Node"}

func (ec *executionContext) _RoleRevokedUserSyncLogEntry(ctx context.Context, sel ast.SelectionSet, obj *usersync.RoleRevokedUserSyncLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roleRevokedUserSyncLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoleRevokedUserSyncLogEntry")
		case "id":
			out.Values[i] = ec._RoleRevokedUserSyncLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._RoleRevokedUserSyncLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RoleRevokedUserSyncLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userID":
			out.Values[i] = ec._RoleRevokedUserSyncLogEntry_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userName":
			out.Values[i] = ec._RoleRevokedUserSyncLogEntry_userName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userEmail":
			out.Values[i] = ec._RoleRevokedUserSyncLogEntry_userEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roleName":
			out.Values[i] = ec._RoleRevokedUserSyncLogEntry_roleName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchNodeConnectionImplementors = []string{"SearchNodeConnection"}

func (ec *executionContext) _SearchNodeConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[search.SearchNode]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchNodeConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchNodeConnection")
		case "pageInfo":
			out.Values[i] = ec._SearchNodeConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._SearchNodeConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._SearchNodeConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchNodeEdgeImplementors = []string{"SearchNodeEdge"}

func (ec *executionContext) _SearchNodeEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[search.SearchNode]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchNodeEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchNodeEdge")
		case "cursor":
			out.Values[i] = ec._SearchNodeEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._SearchNodeEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretImplementors = []string{"Secret", "Node"}

func (ec *executionContext) _Secret(ctx context.Context, sel ast.SelectionSet, obj *secret.Secret) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Secret")
		case "id":
			out.Values[i] = ec._Secret_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Secret_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Secret_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Secret_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Secret_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "values":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Secret_values(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "applications":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Secret_applications(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "jobs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Secret_jobs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workloads":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Secret_workloads(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lastModifiedAt":
			out.Values[i] = ec._Secret_lastModifiedAt(ctx, field, obj)
		case "lastModifiedBy":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Secret_lastModifiedBy(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretConnectionImplementors = []string{"SecretConnection"}

func (ec *executionContext) _SecretConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*secret.Secret]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretConnection")
		case "pageInfo":
			out.Values[i] = ec._SecretConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._SecretConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._SecretConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretCreatedActivityLogEntryImplementors = []string{"SecretCreatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _SecretCreatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *secret.SecretCreatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretCreatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretCreatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._SecretCreatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._SecretCreatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._SecretCreatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._SecretCreatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._SecretCreatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._SecretCreatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._SecretCreatedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._SecretCreatedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretDeletedActivityLogEntryImplementors = []string{"SecretDeletedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _SecretDeletedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *secret.SecretDeletedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretDeletedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretDeletedActivityLogEntry")
		case "id":
			out.Values[i] = ec._SecretDeletedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._SecretDeletedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._SecretDeletedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._SecretDeletedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._SecretDeletedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._SecretDeletedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._SecretDeletedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._SecretDeletedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretEdgeImplementors = []string{"SecretEdge"}

func (ec *executionContext) _SecretEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*secret.Secret]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretEdge")
		case "cursor":
			out.Values[i] = ec._SecretEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._SecretEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretValueImplementors = []string{"SecretValue"}

func (ec *executionContext) _SecretValue(ctx context.Context, sel ast.SelectionSet, obj *secret.SecretValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretValue")
		case "name":
			out.Values[i] = ec._SecretValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._SecretValue_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretValueAddedActivityLogEntryImplementors = []string{"SecretValueAddedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _SecretValueAddedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *secret.SecretValueAddedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretValueAddedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretValueAddedActivityLogEntry")
		case "id":
			out.Values[i] = ec._SecretValueAddedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._SecretValueAddedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._SecretValueAddedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._SecretValueAddedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._SecretValueAddedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._SecretValueAddedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._SecretValueAddedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._SecretValueAddedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._SecretValueAddedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretValueAddedActivityLogEntryDataImplementors = []string{"SecretValueAddedActivityLogEntryData"}

func (ec *executionContext) _SecretValueAddedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *secret.SecretValueAddedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretValueAddedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretValueAddedActivityLogEntryData")
		case "valueName":
			out.Values[i] = ec._SecretValueAddedActivityLogEntryData_valueName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretValueRemovedActivityLogEntryImplementors = []string{"SecretValueRemovedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _SecretValueRemovedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *secret.SecretValueRemovedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretValueRemovedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretValueRemovedActivityLogEntry")
		case "id":
			out.Values[i] = ec._SecretValueRemovedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._SecretValueRemovedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._SecretValueRemovedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._SecretValueRemovedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._SecretValueRemovedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._SecretValueRemovedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._SecretValueRemovedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._SecretValueRemovedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._SecretValueRemovedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretValueRemovedActivityLogEntryDataImplementors = []string{"SecretValueRemovedActivityLogEntryData"}

func (ec *executionContext) _SecretValueRemovedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *secret.SecretValueRemovedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretValueRemovedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretValueRemovedActivityLogEntryData")
		case "valueName":
			out.Values[i] = ec._SecretValueRemovedActivityLogEntryData_valueName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretValueUpdatedActivityLogEntryImplementors = []string{"SecretValueUpdatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *secret.SecretValueUpdatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretValueUpdatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretValueUpdatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._SecretValueUpdatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._SecretValueUpdatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._SecretValueUpdatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._SecretValueUpdatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._SecretValueUpdatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._SecretValueUpdatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._SecretValueUpdatedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._SecretValueUpdatedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._SecretValueUpdatedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretValueUpdatedActivityLogEntryDataImplementors = []string{"SecretValueUpdatedActivityLogEntryData"}

func (ec *executionContext) _SecretValueUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *secret.SecretValueUpdatedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretValueUpdatedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretValueUpdatedActivityLogEntryData")
		case "valueName":
			out.Values[i] = ec._SecretValueUpdatedActivityLogEntryData_valueName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountImplementors = []string{"ServiceAccount", "Node", "AuthenticatedUser"}

func (ec *executionContext) _ServiceAccount(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccount")
		case "id":
			out.Values[i] = ec._ServiceAccount_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._ServiceAccount_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._ServiceAccount_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._ServiceAccount_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._ServiceAccount_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastUsedAt":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServiceAccount_lastUsedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "team":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServiceAccount_team(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "roles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServiceAccount_roles(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tokens":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServiceAccount_tokens(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountConnectionImplementors = []string{"ServiceAccountConnection"}

func (ec *executionContext) _ServiceAccountConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*serviceaccount.ServiceAccount]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountConnection")
		case "nodes":
			out.Values[i] = ec._ServiceAccountConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ServiceAccountConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._ServiceAccountConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountCreatedActivityLogEntryImplementors = []string{"ServiceAccountCreatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ServiceAccountCreatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountCreatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountCreatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountCreatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._ServiceAccountCreatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ServiceAccountCreatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ServiceAccountCreatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ServiceAccountCreatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ServiceAccountCreatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ServiceAccountCreatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ServiceAccountCreatedActivityLogEntry_teamSlug(ctx, field, obj)
		case "environmentName":
			out.Values[i] = ec._ServiceAccountCreatedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountDeletedActivityLogEntryImplementors = []string{"ServiceAccountDeletedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ServiceAccountDeletedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountDeletedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountDeletedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountDeletedActivityLogEntry")
		case "id":
			out.Values[i] = ec._ServiceAccountDeletedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ServiceAccountDeletedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ServiceAccountDeletedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ServiceAccountDeletedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ServiceAccountDeletedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ServiceAccountDeletedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ServiceAccountDeletedActivityLogEntry_teamSlug(ctx, field, obj)
		case "environmentName":
			out.Values[i] = ec._ServiceAccountDeletedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountEdgeImplementors = []string{"ServiceAccountEdge"}

func (ec *executionContext) _ServiceAccountEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*serviceaccount.ServiceAccount]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountEdge")
		case "node":
			out.Values[i] = ec._ServiceAccountEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._ServiceAccountEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountTokenImplementors = []string{"ServiceAccountToken", "Node"}

func (ec *executionContext) _ServiceAccountToken(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountToken) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountTokenImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountToken")
		case "id":
			out.Values[i] = ec._ServiceAccountToken_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ServiceAccountToken_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ServiceAccountToken_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ServiceAccountToken_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ServiceAccountToken_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastUsedAt":
			out.Values[i] = ec._ServiceAccountToken_lastUsedAt(ctx, field, obj)
		case "expiresAt":
			out.Values[i] = ec._ServiceAccountToken_expiresAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountTokenConnectionImplementors = []string{"ServiceAccountTokenConnection"}

func (ec *executionContext) _ServiceAccountTokenConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*serviceaccount.ServiceAccountToken]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountTokenConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountTokenConnection")
		case "nodes":
			out.Values[i] = ec._ServiceAccountTokenConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ServiceAccountTokenConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._ServiceAccountTokenConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountTokenCreatedActivityLogEntryImplementors = []string{"ServiceAccountTokenCreatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountTokenCreatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountTokenCreatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._ServiceAccountTokenCreatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ServiceAccountTokenCreatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ServiceAccountTokenCreatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ServiceAccountTokenCreatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ServiceAccountTokenCreatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ServiceAccountTokenCreatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ServiceAccountTokenCreatedActivityLogEntry_teamSlug(ctx, field, obj)
		case "environmentName":
			out.Values[i] = ec._ServiceAccountTokenCreatedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._ServiceAccountTokenCreatedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountTokenCreatedActivityLogEntryDataImplementors = []string{"ServiceAccountTokenCreatedActivityLogEntryData"}

func (ec *executionContext) _ServiceAccountTokenCreatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountTokenCreatedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountTokenCreatedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountTokenCreatedActivityLogEntryData")
		case "tokenName":
			out.Values[i] = ec._ServiceAccountTokenCreatedActivityLogEntryData_tokenName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountTokenDeletedActivityLogEntryImplementors = []string{"ServiceAccountTokenDeletedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountTokenDeletedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountTokenDeletedActivityLogEntry")
		case "id":
			out.Values[i] = ec._ServiceAccountTokenDeletedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ServiceAccountTokenDeletedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ServiceAccountTokenDeletedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ServiceAccountTokenDeletedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ServiceAccountTokenDeletedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ServiceAccountTokenDeletedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ServiceAccountTokenDeletedActivityLogEntry_teamSlug(ctx, field, obj)
		case "environmentName":
			out.Values[i] = ec._ServiceAccountTokenDeletedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._ServiceAccountTokenDeletedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountTokenDeletedActivityLogEntryDataImplementors = []string{"ServiceAccountTokenDeletedActivityLogEntryData"}

func (ec *executionContext) _ServiceAccountTokenDeletedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountTokenDeletedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountTokenDeletedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountTokenDeletedActivityLogEntryData")
		case "tokenName":
			out.Values[i] = ec._ServiceAccountTokenDeletedActivityLogEntryData_tokenName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountTokenEdgeImplementors = []string{"ServiceAccountTokenEdge"}

func (ec *executionContext) _ServiceAccountTokenEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*serviceaccount.ServiceAccountToken]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountTokenEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountTokenEdge")
		case "node":
			out.Values[i] = ec._ServiceAccountTokenEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._ServiceAccountTokenEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountTokenUpdatedActivityLogEntryImplementors = []string{"ServiceAccountTokenUpdatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountTokenUpdatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountTokenUpdatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntry_teamSlug(ctx, field, obj)
		case "environmentName":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountTokenUpdatedActivityLogEntryDataImplementors = []string{"ServiceAccountTokenUpdatedActivityLogEntryData"}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountTokenUpdatedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountTokenUpdatedActivityLogEntryData")
		case "updatedFields":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntryData_updatedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountTokenUpdatedActivityLogEntryDataUpdatedFieldImplementors = []string{"ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField"}

func (ec *executionContext) _ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountTokenUpdatedActivityLogEntryDataUpdatedFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField")
		case "field":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldValue":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field, obj)
		case "newValue":
			out.Values[i] = ec._ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountUpdatedActivityLogEntryImplementors = []string{"ServiceAccountUpdatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountUpdatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountUpdatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntry_teamSlug(ctx, field, obj)
		case "environmentName":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountUpdatedActivityLogEntryDataImplementors = []string{"ServiceAccountUpdatedActivityLogEntryData"}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountUpdatedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountUpdatedActivityLogEntryData")
		case "updatedFields":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntryData_updatedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceAccountUpdatedActivityLogEntryDataUpdatedFieldImplementors = []string{"ServiceAccountUpdatedActivityLogEntryDataUpdatedField"}

func (ec *executionContext) _ServiceAccountUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.ServiceAccountUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceAccountUpdatedActivityLogEntryDataUpdatedFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceAccountUpdatedActivityLogEntryDataUpdatedField")
		case "field":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntryDataUpdatedField_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldValue":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field, obj)
		case "newValue":
			out.Values[i] = ec._ServiceAccountUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceCostSampleImplementors = []string{"ServiceCostSample"}

func (ec *executionContext) _ServiceCostSample(ctx context.Context, sel ast.SelectionSet, obj *cost.ServiceCostSample) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceCostSampleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceCostSample")
		case "service":
			out.Values[i] = ec._ServiceCostSample_service(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cost":
			out.Values[i] = ec._ServiceCostSample_cost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceCostSeriesImplementors = []string{"ServiceCostSeries"}

func (ec *executionContext) _ServiceCostSeries(ctx context.Context, sel ast.SelectionSet, obj *cost.ServiceCostSeries) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceCostSeriesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceCostSeries")
		case "date":
			out.Values[i] = ec._ServiceCostSeries_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sum":
			out.Values[i] = ec._ServiceCostSeries_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "services":
			out.Values[i] = ec._ServiceCostSeries_services(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var setTeamMemberRolePayloadImplementors = []string{"SetTeamMemberRolePayload"}

func (ec *executionContext) _SetTeamMemberRolePayload(ctx context.Context, sel ast.SelectionSet, obj *team.SetTeamMemberRolePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setTeamMemberRolePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetTeamMemberRolePayload")
		case "member":
			out.Values[i] = ec._SetTeamMemberRolePayload_member(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlDatabaseImplementors = []string{"SqlDatabase", "Persistence", "Node"}

func (ec *executionContext) _SqlDatabase(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLDatabase) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlDatabaseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlDatabase")
		case "id":
			out.Values[i] = ec._SqlDatabase_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._SqlDatabase_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlDatabase_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlDatabase_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlDatabase_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "charset":
			out.Values[i] = ec._SqlDatabase_charset(ctx, field, obj)
		case "collation":
			out.Values[i] = ec._SqlDatabase_collation(ctx, field, obj)
		case "deletionPolicy":
			out.Values[i] = ec._SqlDatabase_deletionPolicy(ctx, field, obj)
		case "healthy":
			out.Values[i] = ec._SqlDatabase_healthy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceImplementors = []string{"SqlInstance", "SearchNode", "Persistence", "Node"}

func (ec *executionContext) _SqlInstance(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstance")
		case "id":
			out.Values[i] = ec._SqlInstance_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._SqlInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cascadingDelete":
			out.Values[i] = ec._SqlInstance_cascadingDelete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "connectionName":
			out.Values[i] = ec._SqlInstance_connectionName(ctx, field, obj)
		case "diskAutoresize":
			out.Values[i] = ec._SqlInstance_diskAutoresize(ctx, field, obj)
		case "diskAutoresizeLimit":
			out.Values[i] = ec._SqlInstance_diskAutoresizeLimit(ctx, field, obj)
		case "highAvailability":
			out.Values[i] = ec._SqlInstance_highAvailability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "healthy":
			out.Values[i] = ec._SqlInstance_healthy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "maintenanceVersion":
			out.Values[i] = ec._SqlInstance_maintenanceVersion(ctx, field, obj)
		case "maintenanceWindow":
			out.Values[i] = ec._SqlInstance_maintenanceWindow(ctx, field, obj)
		case "backupConfiguration":
			out.Values[i] = ec._SqlInstance_backupConfiguration(ctx, field, obj)
		case "projectID":
			out.Values[i] = ec._SqlInstance_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tier":
			out.Values[i] = ec._SqlInstance_tier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._SqlInstance_version(ctx, field, obj)
		case "status":
			out.Values[i] = ec._SqlInstance_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "database":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_database(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "flags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_flags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metrics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_metrics(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "state":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstance_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceBackupConfigurationImplementors = []string{"SqlInstanceBackupConfiguration"}

func (ec *executionContext) _SqlInstanceBackupConfiguration(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceBackupConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceBackupConfigurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceBackupConfiguration")
		case "enabled":
			out.Values[i] = ec._SqlInstanceBackupConfiguration_enabled(ctx, field, obj)
		case "startTime":
			out.Values[i] = ec._SqlInstanceBackupConfiguration_startTime(ctx, field, obj)
		case "retainedBackups":
			out.Values[i] = ec._SqlInstanceBackupConfiguration_retainedBackups(ctx, field, obj)
		case "pointInTimeRecovery":
			out.Values[i] = ec._SqlInstanceBackupConfiguration_pointInTimeRecovery(ctx, field, obj)
		case "transactionLogRetentionDays":
			out.Values[i] = ec._SqlInstanceBackupConfiguration_transactionLogRetentionDays(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceConnectionImplementors = []string{"SqlInstanceConnection"}

func (ec *executionContext) _SqlInstanceConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*sqlinstance.SQLInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceConnection")
		case "pageInfo":
			out.Values[i] = ec._SqlInstanceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._SqlInstanceConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._SqlInstanceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceCostImplementors = []string{"SqlInstanceCost"}

func (ec *executionContext) _SqlInstanceCost(ctx context.Context, sel ast.SelectionSet, obj *cost.SQLInstanceCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceCost")
		case "sum":
			out.Values[i] = ec._SqlInstanceCost_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceCpuImplementors = []string{"SqlInstanceCpu"}

func (ec *executionContext) _SqlInstanceCpu(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceCPU) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceCpuImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceCpu")
		case "cores":
			out.Values[i] = ec._SqlInstanceCpu_cores(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "utilization":
			out.Values[i] = ec._SqlInstanceCpu_utilization(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceDiskImplementors = []string{"SqlInstanceDisk"}

func (ec *executionContext) _SqlInstanceDisk(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceDisk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceDiskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceDisk")
		case "quotaBytes":
			out.Values[i] = ec._SqlInstanceDisk_quotaBytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "utilization":
			out.Values[i] = ec._SqlInstanceDisk_utilization(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceEdgeImplementors = []string{"SqlInstanceEdge"}

func (ec *executionContext) _SqlInstanceEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*sqlinstance.SQLInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceEdge")
		case "cursor":
			out.Values[i] = ec._SqlInstanceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._SqlInstanceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceFlagImplementors = []string{"SqlInstanceFlag"}

func (ec *executionContext) _SqlInstanceFlag(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceFlag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceFlagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceFlag")
		case "name":
			out.Values[i] = ec._SqlInstanceFlag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._SqlInstanceFlag_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceFlagConnectionImplementors = []string{"SqlInstanceFlagConnection"}

func (ec *executionContext) _SqlInstanceFlagConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceFlagConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceFlagConnection")
		case "pageInfo":
			out.Values[i] = ec._SqlInstanceFlagConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._SqlInstanceFlagConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._SqlInstanceFlagConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceFlagEdgeImplementors = []string{"SqlInstanceFlagEdge"}

func (ec *executionContext) _SqlInstanceFlagEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceFlagEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceFlagEdge")
		case "cursor":
			out.Values[i] = ec._SqlInstanceFlagEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._SqlInstanceFlagEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceMaintenanceWindowImplementors = []string{"SqlInstanceMaintenanceWindow"}

func (ec *executionContext) _SqlInstanceMaintenanceWindow(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceMaintenanceWindow) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceMaintenanceWindowImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceMaintenanceWindow")
		case "day":
			out.Values[i] = ec._SqlInstanceMaintenanceWindow_day(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hour":
			out.Values[i] = ec._SqlInstanceMaintenanceWindow_hour(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceMemoryImplementors = []string{"SqlInstanceMemory"}

func (ec *executionContext) _SqlInstanceMemory(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceMemory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceMemoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceMemory")
		case "quotaBytes":
			out.Values[i] = ec._SqlInstanceMemory_quotaBytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "utilization":
			out.Values[i] = ec._SqlInstanceMemory_utilization(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceMetricsImplementors = []string{"SqlInstanceMetrics"}

func (ec *executionContext) _SqlInstanceMetrics(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceMetrics")
		case "cpu":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstanceMetrics_cpu(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "memory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstanceMetrics_memory(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "disk":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SqlInstanceMetrics_disk(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceStatusImplementors = []string{"SqlInstanceStatus"}

func (ec *executionContext) _SqlInstanceStatus(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceStatus")
		case "publicIpAddress":
			out.Values[i] = ec._SqlInstanceStatus_publicIpAddress(ctx, field, obj)
		case "privateIpAddress":
			out.Values[i] = ec._SqlInstanceStatus_privateIpAddress(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceUserImplementors = []string{"SqlInstanceUser"}

func (ec *executionContext) _SqlInstanceUser(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.SQLInstanceUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceUser")
		case "name":
			out.Values[i] = ec._SqlInstanceUser_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "authentication":
			out.Values[i] = ec._SqlInstanceUser_authentication(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceUserConnectionImplementors = []string{"SqlInstanceUserConnection"}

func (ec *executionContext) _SqlInstanceUserConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceUserConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceUserConnection")
		case "pageInfo":
			out.Values[i] = ec._SqlInstanceUserConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._SqlInstanceUserConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._SqlInstanceUserConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sqlInstanceUserEdgeImplementors = []string{"SqlInstanceUserEdge"}

func (ec *executionContext) _SqlInstanceUserEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sqlInstanceUserEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SqlInstanceUserEdge")
		case "cursor":
			out.Values[i] = ec._SqlInstanceUserEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._SqlInstanceUserEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "workloadLog":
		return ec._Subscription_workloadLog(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var teamImplementors = []string{"Team", "SearchNode", "Node"}

func (ec *executionContext) _Team(ctx context.Context, sel ast.SelectionSet, obj *team.Team) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Team")
		case "id":
			out.Values[i] = ec._Team_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "slug":
			out.Values[i] = ec._Team_slug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "slackChannel":
			out.Values[i] = ec._Team_slackChannel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "purpose":
			out.Values[i] = ec._Team_purpose(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "externalResources":
			out.Values[i] = ec._Team_externalResources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "member":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_member(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "members":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_members(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lastSuccessfulSync":
			out.Values[i] = ec._Team_lastSuccessfulSync(ctx, field, obj)
		case "deletionInProgress":
			out.Values[i] = ec._Team_deletionInProgress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "viewerIsOwner":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_viewerIsOwner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "viewerIsMember":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_viewerIsMember(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_environments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteKey":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_deleteKey(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "inventoryCounts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_inventoryCounts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "activityLog":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_activityLog(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "applications":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_applications(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bigQueryDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_bigQueryDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buckets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_buckets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deploymentKey":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_deploymentKey(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deployments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_deployments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "jobs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_jobs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "kafkaTopics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_kafkaTopics(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "openSearchInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_openSearchInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "redisInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_redisInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "repositories":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_repositories(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "secrets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_secrets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sqlInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_sqlInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "unleash":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_unleash(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workloadUtilization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_workloadUtilization(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "serviceUtilization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_serviceUtilization(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "valkeyInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_valkeyInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vulnerabilitySummary":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_vulnerabilitySummary(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workloads":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_workloads(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCDNImplementors = []string{"TeamCDN"}

func (ec *executionContext) _TeamCDN(ctx context.Context, sel ast.SelectionSet, obj *team.TeamCDN) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCDNImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCDN")
		case "bucket":
			out.Values[i] = ec._TeamCDN_bucket(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamConfirmDeleteKeyActivityLogEntryImplementors = []string{"TeamConfirmDeleteKeyActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _TeamConfirmDeleteKeyActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamConfirmDeleteKeyActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamConfirmDeleteKeyActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamConfirmDeleteKeyActivityLogEntry")
		case "id":
			out.Values[i] = ec._TeamConfirmDeleteKeyActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamConfirmDeleteKeyActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamConfirmDeleteKeyActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamConfirmDeleteKeyActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamConfirmDeleteKeyActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamConfirmDeleteKeyActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamConfirmDeleteKeyActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamConfirmDeleteKeyActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamConnectionImplementors = []string{"TeamConnection"}

func (ec *executionContext) _TeamConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*team.Team]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamConnection")
		case "pageInfo":
			out.Values[i] = ec._TeamConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._TeamConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._TeamConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCostImplementors = []string{"TeamCost"}

func (ec *executionContext) _TeamCost(ctx context.Context, sel ast.SelectionSet, obj *cost.TeamCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCost")
		case "daily":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamCost_daily(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "monthlySummary":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamCost_monthlySummary(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCostMonthlySampleImplementors = []string{"TeamCostMonthlySample"}

func (ec *executionContext) _TeamCostMonthlySample(ctx context.Context, sel ast.SelectionSet, obj *cost.TeamCostMonthlySample) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCostMonthlySampleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCostMonthlySample")
		case "date":
			out.Values[i] = ec._TeamCostMonthlySample_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cost":
			out.Values[i] = ec._TeamCostMonthlySample_cost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCostMonthlySummaryImplementors = []string{"TeamCostMonthlySummary"}

func (ec *executionContext) _TeamCostMonthlySummary(ctx context.Context, sel ast.SelectionSet, obj *cost.TeamCostMonthlySummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCostMonthlySummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCostMonthlySummary")
		case "sum":
			out.Values[i] = ec._TeamCostMonthlySummary_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "series":
			out.Values[i] = ec._TeamCostMonthlySummary_series(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCostPeriodImplementors = []string{"TeamCostPeriod"}

func (ec *executionContext) _TeamCostPeriod(ctx context.Context, sel ast.SelectionSet, obj *cost.TeamCostPeriod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCostPeriodImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCostPeriod")
		case "sum":
			out.Values[i] = ec._TeamCostPeriod_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "series":
			out.Values[i] = ec._TeamCostPeriod_series(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCreateDeleteKeyActivityLogEntryImplementors = []string{"TeamCreateDeleteKeyActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _TeamCreateDeleteKeyActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamCreateDeleteKeyActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCreateDeleteKeyActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCreateDeleteKeyActivityLogEntry")
		case "id":
			out.Values[i] = ec._TeamCreateDeleteKeyActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamCreateDeleteKeyActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamCreateDeleteKeyActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamCreateDeleteKeyActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamCreateDeleteKeyActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamCreateDeleteKeyActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamCreateDeleteKeyActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamCreateDeleteKeyActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamCreatedActivityLogEntryImplementors = []string{"TeamCreatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _TeamCreatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamCreatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamCreatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCreatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._TeamCreatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamCreatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamCreatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamCreatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamCreatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamCreatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamCreatedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamCreatedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamDeleteKeyImplementors = []string{"TeamDeleteKey"}

func (ec *executionContext) _TeamDeleteKey(ctx context.Context, sel ast.SelectionSet, obj *team.TeamDeleteKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamDeleteKeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamDeleteKey")
		case "key":
			out.Values[i] = ec._TeamDeleteKey_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._TeamDeleteKey_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expires":
			out.Values[i] = ec._TeamDeleteKey_expires(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamDeleteKey_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamDeleteKey_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamDeployKeyUpdatedActivityLogEntryImplementors = []string{"TeamDeployKeyUpdatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _TeamDeployKeyUpdatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *deployment.TeamDeployKeyUpdatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamDeployKeyUpdatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamDeployKeyUpdatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._TeamDeployKeyUpdatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamDeployKeyUpdatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamDeployKeyUpdatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamDeployKeyUpdatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamDeployKeyUpdatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamDeployKeyUpdatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamDeployKeyUpdatedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamDeployKeyUpdatedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEdgeImplementors = []string{"TeamEdge"}

func (ec *executionContext) _TeamEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*team.Team]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEdge")
		case "cursor":
			out.Values[i] = ec._TeamEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._TeamEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEntraIDGroupImplementors = []string{"TeamEntraIDGroup"}

func (ec *executionContext) _TeamEntraIDGroup(ctx context.Context, sel ast.SelectionSet, obj *team.TeamEntraIDGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEntraIDGroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEntraIDGroup")
		case "groupID":
			out.Values[i] = ec._TeamEntraIDGroup_groupID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEnvironmentImplementors = []string{"TeamEnvironment", "Node"}

func (ec *executionContext) _TeamEnvironment(ctx context.Context, sel ast.SelectionSet, obj *team.TeamEnvironment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEnvironmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEnvironment")
		case "id":
			out.Values[i] = ec._TeamEnvironment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._TeamEnvironment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "gcpProjectID":
			out.Values[i] = ec._TeamEnvironment_gcpProjectID(ctx, field, obj)
		case "slackAlertsChannel":
			out.Values[i] = ec._TeamEnvironment_slackAlertsChannel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "application":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_application(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bigQueryDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_bigQueryDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bucket":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_bucket(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "job":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_job(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "kafkaTopic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_kafkaTopic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "openSearchInstance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_openSearchInstance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "redisInstance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_redisInstance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "secret":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_secret(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sqlInstance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_sqlInstance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "valkeyInstance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_valkeyInstance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironment_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEnvironmentCostImplementors = []string{"TeamEnvironmentCost"}

func (ec *executionContext) _TeamEnvironmentCost(ctx context.Context, sel ast.SelectionSet, obj *cost.TeamEnvironmentCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEnvironmentCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEnvironmentCost")
		case "daily":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamEnvironmentCost_daily(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEnvironmentCostPeriodImplementors = []string{"TeamEnvironmentCostPeriod"}

func (ec *executionContext) _TeamEnvironmentCostPeriod(ctx context.Context, sel ast.SelectionSet, obj *cost.TeamEnvironmentCostPeriod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEnvironmentCostPeriodImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEnvironmentCostPeriod")
		case "sum":
			out.Values[i] = ec._TeamEnvironmentCostPeriod_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "series":
			out.Values[i] = ec._TeamEnvironmentCostPeriod_series(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEnvironmentUpdatedActivityLogEntryImplementors = []string{"TeamEnvironmentUpdatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamEnvironmentUpdatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEnvironmentUpdatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEnvironmentUpdatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEnvironmentUpdatedActivityLogEntryDataImplementors = []string{"TeamEnvironmentUpdatedActivityLogEntryData"}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *team.TeamEnvironmentUpdatedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEnvironmentUpdatedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEnvironmentUpdatedActivityLogEntryData")
		case "updatedFields":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntryData_updatedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamEnvironmentUpdatedActivityLogEntryDataUpdatedFieldImplementors = []string{"TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField"}

func (ec *executionContext) _TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, obj *team.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamEnvironmentUpdatedActivityLogEntryDataUpdatedFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField")
		case "field":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldValue":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field, obj)
		case "newValue":
			out.Values[i] = ec._TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamExternalResourcesImplementors = []string{"TeamExternalResources"}

func (ec *executionContext) _TeamExternalResources(ctx context.Context, sel ast.SelectionSet, obj *team.TeamExternalResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamExternalResourcesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamExternalResources")
		case "entraIDGroup":
			out.Values[i] = ec._TeamExternalResources_entraIDGroup(ctx, field, obj)
		case "gitHubTeam":
			out.Values[i] = ec._TeamExternalResources_gitHubTeam(ctx, field, obj)
		case "googleGroup":
			out.Values[i] = ec._TeamExternalResources_googleGroup(ctx, field, obj)
		case "googleArtifactRegistry":
			out.Values[i] = ec._TeamExternalResources_googleArtifactRegistry(ctx, field, obj)
		case "cdn":
			out.Values[i] = ec._TeamExternalResources_cdn(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamGitHubTeamImplementors = []string{"TeamGitHubTeam"}

func (ec *executionContext) _TeamGitHubTeam(ctx context.Context, sel ast.SelectionSet, obj *team.TeamGitHubTeam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamGitHubTeamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamGitHubTeam")
		case "slug":
			out.Values[i] = ec._TeamGitHubTeam_slug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamGoogleArtifactRegistryImplementors = []string{"TeamGoogleArtifactRegistry"}

func (ec *executionContext) _TeamGoogleArtifactRegistry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamGoogleArtifactRegistry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamGoogleArtifactRegistryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamGoogleArtifactRegistry")
		case "repository":
			out.Values[i] = ec._TeamGoogleArtifactRegistry_repository(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamGoogleGroupImplementors = []string{"TeamGoogleGroup"}

func (ec *executionContext) _TeamGoogleGroup(ctx context.Context, sel ast.SelectionSet, obj *team.TeamGoogleGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamGoogleGroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamGoogleGroup")
		case "email":
			out.Values[i] = ec._TeamGoogleGroup_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamInventoryCountApplicationsImplementors = []string{"TeamInventoryCountApplications"}

func (ec *executionContext) _TeamInventoryCountApplications(ctx context.Context, sel ast.SelectionSet, obj *application.TeamInventoryCountApplications) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamInventoryCountApplicationsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamInventoryCountApplications")
		case "total":
			out.Values[i] = ec._TeamInventoryCountApplications_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "notNais":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamInventoryCountApplications_notNais(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamInventoryCountBigQueryDatasetsImplementors = []string{"TeamInventoryCountBigQueryDatasets"}

func (ec *executionContext) _TeamInventoryCountBigQueryDatasets(ctx context.Context, sel ast.SelectionSet, obj *bigquery.TeamInventoryCountBigQueryDatasets) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamInventoryCountBigQueryDatasetsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamInventoryCountBigQueryDatasets")
		case "total":
			out.Values[i] = ec._TeamInventoryCountBigQueryDatasets_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamInventoryCountBucketsImplementors = []string{"TeamInventoryCountBuckets"}

func (ec *executionContext) _TeamInventoryCountBuckets(ctx context.Context, sel ast.SelectionSet, obj *bucket.TeamInventoryCountBuckets) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamInventoryCountBucketsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamInventoryCountBuckets")
		case "total":
			out.Values[i] = ec._TeamInventoryCountBuckets_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamInventoryCountJobsImplementors = []string{"TeamInventoryCountJobs"}

func (ec *executionContext) _TeamInventoryCountJobs(ctx context.Context, sel ast.SelectionSet, obj *job.TeamInventoryCountJobs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamInventoryCountJobsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamInventoryCountJobs")
		case "total":
			out.Values[i] = ec._TeamInventoryCountJobs_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "notNais":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamInventoryCountJobs_notNais(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamInventoryCountKafkaTopicsImplementors = []string{"TeamInventoryCountKafkaTopics"}

func (ec *executionContext) _TeamInventoryCountKafkaTopics(ctx context.Context, sel ast.SelectionSet, obj *kafkatopic.TeamInventoryCountKafkaTopics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamInventoryCountKafkaTopicsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamInventoryCountKafkaTopics")
		case "total":
			out.Values[i] = ec._TeamInventoryCountKafkaTopics_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamInventoryCountOpenSearchInstancesImplementors = []string{"TeamInventoryCountOpenSearchInstances"}

func (ec *executionContext) _TeamInventoryCountOpenSearchInstances(ctx context.Context, sel ast.SelectionSet, obj *opensearch.TeamInventoryCountOpenSearchInstances) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamInventoryCountOpenSearchInstancesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamInventoryCountOpenSearchInstances")
		case "total":
			out.Values[i] = ec._TeamInventoryCountOpenSearchInstances_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamInventoryCountRedisInstancesImplementors = []string{"TeamInventoryCountRedisInstances"}

func (ec *executionContext) _TeamInventoryCountRedisInstances(ctx context.Context, sel ast.SelectionSet, obj *redis.TeamInventoryCountRedisInstances) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamInventoryCountRedisInstancesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamInventoryCountRedisInstances")
		case "total":
			out.Values[i] = ec._TeamInventoryCountRedisInstances_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamInventoryCountSqlInstancesImplementors = []string{"TeamInventoryCountSqlInstances"}

func (ec *executionContext) _TeamInventoryCountSqlInstances(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.TeamInventoryCountSQLInstances) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamInventoryCountSqlInstancesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamInventoryCountSqlInstances")
		case "total":
			out.Values[i] = ec._TeamInventoryCountSqlInstances_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamInventoryCountValkeyInstancesImplementors = []string{"TeamInventoryCountValkeyInstances"}

func (ec *executionContext) _TeamInventoryCountValkeyInstances(ctx context.Context, sel ast.SelectionSet, obj *valkey.TeamInventoryCountValkeyInstances) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamInventoryCountValkeyInstancesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamInventoryCountValkeyInstances")
		case "total":
			out.Values[i] = ec._TeamInventoryCountValkeyInstances_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamInventoryCountsImplementors = []string{"TeamInventoryCounts"}

func (ec *executionContext) _TeamInventoryCounts(ctx context.Context, sel ast.SelectionSet, obj *team.TeamInventoryCounts) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamInventoryCountsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamInventoryCounts")
		case "applications":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamInventoryCounts_applications(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bigQueryDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamInventoryCounts_bigQueryDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buckets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamInventoryCounts_buckets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "jobs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamInventoryCounts_jobs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "kafkaTopics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamInventoryCounts_kafkaTopics(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "openSearchInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamInventoryCounts_openSearchInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "redisInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamInventoryCounts_redisInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sqlInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamInventoryCounts_sqlInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "valkeyInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamInventoryCounts_valkeyInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberImplementors = []string{"TeamMember"}

func (ec *executionContext) _TeamMember(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMember) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMember")
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamMember_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamMember_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "role":
			out.Values[i] = ec._TeamMember_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberAddedActivityLogEntryImplementors = []string{"TeamMemberAddedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _TeamMemberAddedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberAddedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberAddedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberAddedActivityLogEntry")
		case "id":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberAddedActivityLogEntryDataImplementors = []string{"TeamMemberAddedActivityLogEntryData"}

func (ec *executionContext) _TeamMemberAddedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberAddedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberAddedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberAddedActivityLogEntryData")
		case "role":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntryData_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userID":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntryData_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userEmail":
			out.Values[i] = ec._TeamMemberAddedActivityLogEntryData_userEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberConnectionImplementors = []string{"TeamMemberConnection"}

func (ec *executionContext) _TeamMemberConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*team.TeamMember]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberConnection")
		case "pageInfo":
			out.Values[i] = ec._TeamMemberConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._TeamMemberConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._TeamMemberConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberEdgeImplementors = []string{"TeamMemberEdge"}

func (ec *executionContext) _TeamMemberEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*team.TeamMember]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberEdge")
		case "cursor":
			out.Values[i] = ec._TeamMemberEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._TeamMemberEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberRemovedActivityLogEntryImplementors = []string{"TeamMemberRemovedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberRemovedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberRemovedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberRemovedActivityLogEntry")
		case "id":
			out.Values[i] = ec._TeamMemberRemovedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamMemberRemovedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamMemberRemovedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamMemberRemovedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamMemberRemovedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamMemberRemovedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamMemberRemovedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamMemberRemovedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._TeamMemberRemovedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberRemovedActivityLogEntryDataImplementors = []string{"TeamMemberRemovedActivityLogEntryData"}

func (ec *executionContext) _TeamMemberRemovedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberRemovedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberRemovedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberRemovedActivityLogEntryData")
		case "userID":
			out.Values[i] = ec._TeamMemberRemovedActivityLogEntryData_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userEmail":
			out.Values[i] = ec._TeamMemberRemovedActivityLogEntryData_userEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberSetRoleActivityLogEntryImplementors = []string{"TeamMemberSetRoleActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberSetRoleActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberSetRoleActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberSetRoleActivityLogEntry")
		case "id":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberSetRoleActivityLogEntryDataImplementors = []string{"TeamMemberSetRoleActivityLogEntryData"}

func (ec *executionContext) _TeamMemberSetRoleActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *team.TeamMemberSetRoleActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberSetRoleActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMemberSetRoleActivityLogEntryData")
		case "role":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntryData_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userID":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntryData_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userEmail":
			out.Values[i] = ec._TeamMemberSetRoleActivityLogEntryData_userEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamServiceUtilizationImplementors = []string{"TeamServiceUtilization"}

func (ec *executionContext) _TeamServiceUtilization(ctx context.Context, sel ast.SelectionSet, obj *utilization.TeamServiceUtilization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamServiceUtilizationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamServiceUtilization")
		case "sqlInstances":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamServiceUtilization_sqlInstances(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamServiceUtilizationSqlInstancesImplementors = []string{"TeamServiceUtilizationSqlInstances"}

func (ec *executionContext) _TeamServiceUtilizationSqlInstances(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.TeamServiceUtilizationSQLInstances) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamServiceUtilizationSqlInstancesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamServiceUtilizationSqlInstances")
		case "cpu":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamServiceUtilizationSqlInstances_cpu(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "memory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamServiceUtilizationSqlInstances_memory(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "disk":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamServiceUtilizationSqlInstances_disk(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamServiceUtilizationSqlInstancesCPUImplementors = []string{"TeamServiceUtilizationSqlInstancesCPU"}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesCPU(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.TeamServiceUtilizationSQLInstancesCPU) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamServiceUtilizationSqlInstancesCPUImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamServiceUtilizationSqlInstancesCPU")
		case "used":
			out.Values[i] = ec._TeamServiceUtilizationSqlInstancesCPU_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requested":
			out.Values[i] = ec._TeamServiceUtilizationSqlInstancesCPU_requested(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "utilization":
			out.Values[i] = ec._TeamServiceUtilizationSqlInstancesCPU_utilization(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamServiceUtilizationSqlInstancesDiskImplementors = []string{"TeamServiceUtilizationSqlInstancesDisk"}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesDisk(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.TeamServiceUtilizationSQLInstancesDisk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamServiceUtilizationSqlInstancesDiskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamServiceUtilizationSqlInstancesDisk")
		case "used":
			out.Values[i] = ec._TeamServiceUtilizationSqlInstancesDisk_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requested":
			out.Values[i] = ec._TeamServiceUtilizationSqlInstancesDisk_requested(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "utilization":
			out.Values[i] = ec._TeamServiceUtilizationSqlInstancesDisk_utilization(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamServiceUtilizationSqlInstancesMemoryImplementors = []string{"TeamServiceUtilizationSqlInstancesMemory"}

func (ec *executionContext) _TeamServiceUtilizationSqlInstancesMemory(ctx context.Context, sel ast.SelectionSet, obj *sqlinstance.TeamServiceUtilizationSQLInstancesMemory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamServiceUtilizationSqlInstancesMemoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamServiceUtilizationSqlInstancesMemory")
		case "used":
			out.Values[i] = ec._TeamServiceUtilizationSqlInstancesMemory_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requested":
			out.Values[i] = ec._TeamServiceUtilizationSqlInstancesMemory_requested(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "utilization":
			out.Values[i] = ec._TeamServiceUtilizationSqlInstancesMemory_utilization(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamUpdatedActivityLogEntryImplementors = []string{"TeamUpdatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _TeamUpdatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *team.TeamUpdatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamUpdatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamUpdatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._TeamUpdatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._TeamUpdatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._TeamUpdatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TeamUpdatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TeamUpdatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._TeamUpdatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._TeamUpdatedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._TeamUpdatedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._TeamUpdatedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamUpdatedActivityLogEntryDataImplementors = []string{"TeamUpdatedActivityLogEntryData"}

func (ec *executionContext) _TeamUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *team.TeamUpdatedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamUpdatedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamUpdatedActivityLogEntryData")
		case "updatedFields":
			out.Values[i] = ec._TeamUpdatedActivityLogEntryData_updatedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamUpdatedActivityLogEntryDataUpdatedFieldImplementors = []string{"TeamUpdatedActivityLogEntryDataUpdatedField"}

func (ec *executionContext) _TeamUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, obj *team.TeamUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamUpdatedActivityLogEntryDataUpdatedFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamUpdatedActivityLogEntryDataUpdatedField")
		case "field":
			out.Values[i] = ec._TeamUpdatedActivityLogEntryDataUpdatedField_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldValue":
			out.Values[i] = ec._TeamUpdatedActivityLogEntryDataUpdatedField_oldValue(ctx, field, obj)
		case "newValue":
			out.Values[i] = ec._TeamUpdatedActivityLogEntryDataUpdatedField_newValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamUtilizationDataImplementors = []string{"TeamUtilizationData"}

func (ec *executionContext) _TeamUtilizationData(ctx context.Context, sel ast.SelectionSet, obj *utilization.TeamUtilizationData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamUtilizationDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamUtilizationData")
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamUtilizationData_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "requested":
			out.Values[i] = ec._TeamUtilizationData_requested(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "used":
			out.Values[i] = ec._TeamUtilizationData_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamUtilizationData_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamUtilizationData_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamVulnerabilityStatusImplementors = []string{"TeamVulnerabilityStatus"}

func (ec *executionContext) _TeamVulnerabilityStatus(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.TeamVulnerabilityStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamVulnerabilityStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamVulnerabilityStatus")
		case "state":
			out.Values[i] = ec._TeamVulnerabilityStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._TeamVulnerabilityStatus_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._TeamVulnerabilityStatus_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamVulnerabilitySummaryImplementors = []string{"TeamVulnerabilitySummary"}

func (ec *executionContext) _TeamVulnerabilitySummary(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.TeamVulnerabilitySummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamVulnerabilitySummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamVulnerabilitySummary")
		case "riskScore":
			out.Values[i] = ec._TeamVulnerabilitySummary_riskScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "critical":
			out.Values[i] = ec._TeamVulnerabilitySummary_critical(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "high":
			out.Values[i] = ec._TeamVulnerabilitySummary_high(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "medium":
			out.Values[i] = ec._TeamVulnerabilitySummary_medium(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "low":
			out.Values[i] = ec._TeamVulnerabilitySummary_low(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "unassigned":
			out.Values[i] = ec._TeamVulnerabilitySummary_unassigned(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "bomCount":
			out.Values[i] = ec._TeamVulnerabilitySummary_bomCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "coverage":
			out.Values[i] = ec._TeamVulnerabilitySummary_coverage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ranking":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamVulnerabilitySummary_ranking(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "riskScoreTrend":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamVulnerabilitySummary_riskScoreTrend(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamVulnerabilitySummary_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tokenXAuthIntegrationImplementors = []string{"TokenXAuthIntegration", "ApplicationAuthIntegrations", "AuthIntegration"}

func (ec *executionContext) _TokenXAuthIntegration(ctx context.Context, sel ast.SelectionSet, obj *workload.TokenXAuthIntegration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tokenXAuthIntegrationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TokenXAuthIntegration")
		case "name":
			out.Values[i] = ec._TokenXAuthIntegration_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var triggerJobPayloadImplementors = []string{"TriggerJobPayload"}

func (ec *executionContext) _TriggerJobPayload(ctx context.Context, sel ast.SelectionSet, obj *job.TriggerJobPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, triggerJobPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TriggerJobPayload")
		case "job":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TriggerJobPayload_job(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "jobRun":
			out.Values[i] = ec._TriggerJobPayload_jobRun(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unleashInstanceImplementors = []string{"UnleashInstance", "Node"}

func (ec *executionContext) _UnleashInstance(ctx context.Context, sel ast.SelectionSet, obj *unleash.UnleashInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unleashInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnleashInstance")
		case "id":
			out.Values[i] = ec._UnleashInstance_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._UnleashInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._UnleashInstance_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "allowedTeams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UnleashInstance_allowedTeams(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "webIngress":
			out.Values[i] = ec._UnleashInstance_webIngress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "apiIngress":
			out.Values[i] = ec._UnleashInstance_apiIngress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metrics":
			out.Values[i] = ec._UnleashInstance_metrics(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ready":
			out.Values[i] = ec._UnleashInstance_ready(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unleashInstanceCreatedActivityLogEntryImplementors = []string{"UnleashInstanceCreatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _UnleashInstanceCreatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *unleash.UnleashInstanceCreatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unleashInstanceCreatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnleashInstanceCreatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._UnleashInstanceCreatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._UnleashInstanceCreatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._UnleashInstanceCreatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._UnleashInstanceCreatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._UnleashInstanceCreatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._UnleashInstanceCreatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._UnleashInstanceCreatedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._UnleashInstanceCreatedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unleashInstanceMetricsImplementors = []string{"UnleashInstanceMetrics"}

func (ec *executionContext) _UnleashInstanceMetrics(ctx context.Context, sel ast.SelectionSet, obj *unleash.UnleashInstanceMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unleashInstanceMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnleashInstanceMetrics")
		case "toggles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UnleashInstanceMetrics_toggles(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "apiTokens":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UnleashInstanceMetrics_apiTokens(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cpuUtilization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UnleashInstanceMetrics_cpuUtilization(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cpuRequests":
			out.Values[i] = ec._UnleashInstanceMetrics_cpuRequests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "memoryUtilization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UnleashInstanceMetrics_memoryUtilization(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "memoryRequests":
			out.Values[i] = ec._UnleashInstanceMetrics_memoryRequests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unleashInstanceUpdatedActivityLogEntryImplementors = []string{"UnleashInstanceUpdatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *unleash.UnleashInstanceUpdatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unleashInstanceUpdatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnleashInstanceUpdatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._UnleashInstanceUpdatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._UnleashInstanceUpdatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._UnleashInstanceUpdatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._UnleashInstanceUpdatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._UnleashInstanceUpdatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._UnleashInstanceUpdatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._UnleashInstanceUpdatedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._UnleashInstanceUpdatedActivityLogEntry_environmentName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._UnleashInstanceUpdatedActivityLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unleashInstanceUpdatedActivityLogEntryDataImplementors = []string{"UnleashInstanceUpdatedActivityLogEntryData"}

func (ec *executionContext) _UnleashInstanceUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, obj *unleash.UnleashInstanceUpdatedActivityLogEntryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unleashInstanceUpdatedActivityLogEntryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnleashInstanceUpdatedActivityLogEntryData")
		case "revokedTeamSlug":
			out.Values[i] = ec._UnleashInstanceUpdatedActivityLogEntryData_revokedTeamSlug(ctx, field, obj)
		case "allowedTeamSlug":
			out.Values[i] = ec._UnleashInstanceUpdatedActivityLogEntryData_allowedTeamSlug(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateImageVulnerabilityPayloadImplementors = []string{"UpdateImageVulnerabilityPayload"}

func (ec *executionContext) _UpdateImageVulnerabilityPayload(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.UpdateImageVulnerabilityPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateImageVulnerabilityPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateImageVulnerabilityPayload")
		case "vulnerability":
			out.Values[i] = ec._UpdateImageVulnerabilityPayload_vulnerability(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateSecretValuePayloadImplementors = []string{"UpdateSecretValuePayload"}

func (ec *executionContext) _UpdateSecretValuePayload(ctx context.Context, sel ast.SelectionSet, obj *secret.UpdateSecretValuePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateSecretValuePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateSecretValuePayload")
		case "secret":
			out.Values[i] = ec._UpdateSecretValuePayload_secret(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateServiceAccountPayloadImplementors = []string{"UpdateServiceAccountPayload"}

func (ec *executionContext) _UpdateServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.UpdateServiceAccountPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateServiceAccountPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateServiceAccountPayload")
		case "serviceAccount":
			out.Values[i] = ec._UpdateServiceAccountPayload_serviceAccount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateServiceAccountTokenPayloadImplementors = []string{"UpdateServiceAccountTokenPayload"}

func (ec *executionContext) _UpdateServiceAccountTokenPayload(ctx context.Context, sel ast.SelectionSet, obj *serviceaccount.UpdateServiceAccountTokenPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateServiceAccountTokenPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateServiceAccountTokenPayload")
		case "serviceAccount":
			out.Values[i] = ec._UpdateServiceAccountTokenPayload_serviceAccount(ctx, field, obj)
		case "serviceAccountToken":
			out.Values[i] = ec._UpdateServiceAccountTokenPayload_serviceAccountToken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTeamEnvironmentPayloadImplementors = []string{"UpdateTeamEnvironmentPayload"}

func (ec *executionContext) _UpdateTeamEnvironmentPayload(ctx context.Context, sel ast.SelectionSet, obj *team.UpdateTeamEnvironmentPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTeamEnvironmentPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTeamEnvironmentPayload")
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateTeamEnvironmentPayload_environment(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			out.Values[i] = ec._UpdateTeamEnvironmentPayload_teamEnvironment(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTeamPayloadImplementors = []string{"UpdateTeamPayload"}

func (ec *executionContext) _UpdateTeamPayload(ctx context.Context, sel ast.SelectionSet, obj *team.UpdateTeamPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTeamPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTeamPayload")
		case "team":
			out.Values[i] = ec._UpdateTeamPayload_team(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User", "Node", "AuthenticatedUser"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *user.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "externalID":
			out.Values[i] = ec._User_externalID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_teams(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isAdmin":
			out.Values[i] = ec._User_isAdmin(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userConnectionImplementors = []string{"UserConnection"}

func (ec *executionContext) _UserConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*user.User]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConnection")
		case "pageInfo":
			out.Values[i] = ec._UserConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._UserConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._UserConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userCreatedUserSyncLogEntryImplementors = []string{"UserCreatedUserSyncLogEntry", "UserSyncLogEntry", "Node"}

func (ec *executionContext) _UserCreatedUserSyncLogEntry(ctx context.Context, sel ast.SelectionSet, obj *usersync.UserCreatedUserSyncLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userCreatedUserSyncLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserCreatedUserSyncLogEntry")
		case "id":
			out.Values[i] = ec._UserCreatedUserSyncLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._UserCreatedUserSyncLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._UserCreatedUserSyncLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userID":
			out.Values[i] = ec._UserCreatedUserSyncLogEntry_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userName":
			out.Values[i] = ec._UserCreatedUserSyncLogEntry_userName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userEmail":
			out.Values[i] = ec._UserCreatedUserSyncLogEntry_userEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userDeletedUserSyncLogEntryImplementors = []string{"UserDeletedUserSyncLogEntry", "UserSyncLogEntry", "Node"}

func (ec *executionContext) _UserDeletedUserSyncLogEntry(ctx context.Context, sel ast.SelectionSet, obj *usersync.UserDeletedUserSyncLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userDeletedUserSyncLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserDeletedUserSyncLogEntry")
		case "id":
			out.Values[i] = ec._UserDeletedUserSyncLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._UserDeletedUserSyncLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._UserDeletedUserSyncLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userID":
			out.Values[i] = ec._UserDeletedUserSyncLogEntry_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userName":
			out.Values[i] = ec._UserDeletedUserSyncLogEntry_userName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userEmail":
			out.Values[i] = ec._UserDeletedUserSyncLogEntry_userEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userEdgeImplementors = []string{"UserEdge"}

func (ec *executionContext) _UserEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*user.User]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserEdge")
		case "cursor":
			out.Values[i] = ec._UserEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._UserEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSyncLogEntryConnectionImplementors = []string{"UserSyncLogEntryConnection"}

func (ec *executionContext) _UserSyncLogEntryConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[usersync.UserSyncLogEntry]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSyncLogEntryConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSyncLogEntryConnection")
		case "pageInfo":
			out.Values[i] = ec._UserSyncLogEntryConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._UserSyncLogEntryConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._UserSyncLogEntryConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSyncLogEntryEdgeImplementors = []string{"UserSyncLogEntryEdge"}

func (ec *executionContext) _UserSyncLogEntryEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[usersync.UserSyncLogEntry]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSyncLogEntryEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSyncLogEntryEdge")
		case "cursor":
			out.Values[i] = ec._UserSyncLogEntryEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._UserSyncLogEntryEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userUpdatedUserSyncLogEntryImplementors = []string{"UserUpdatedUserSyncLogEntry", "UserSyncLogEntry", "Node"}

func (ec *executionContext) _UserUpdatedUserSyncLogEntry(ctx context.Context, sel ast.SelectionSet, obj *usersync.UserUpdatedUserSyncLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userUpdatedUserSyncLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserUpdatedUserSyncLogEntry")
		case "id":
			out.Values[i] = ec._UserUpdatedUserSyncLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._UserUpdatedUserSyncLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._UserUpdatedUserSyncLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userID":
			out.Values[i] = ec._UserUpdatedUserSyncLogEntry_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userName":
			out.Values[i] = ec._UserUpdatedUserSyncLogEntry_userName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userEmail":
			out.Values[i] = ec._UserUpdatedUserSyncLogEntry_userEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldUserName":
			out.Values[i] = ec._UserUpdatedUserSyncLogEntry_oldUserName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldUserEmail":
			out.Values[i] = ec._UserUpdatedUserSyncLogEntry_oldUserEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var utilizationSampleImplementors = []string{"UtilizationSample"}

func (ec *executionContext) _UtilizationSample(ctx context.Context, sel ast.SelectionSet, obj *utilization.UtilizationSample) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, utilizationSampleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UtilizationSample")
		case "timestamp":
			out.Values[i] = ec._UtilizationSample_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._UtilizationSample_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "instance":
			out.Values[i] = ec._UtilizationSample_instance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var valkeyInstanceImplementors = []string{"ValkeyInstance", "SearchNode", "Persistence", "Node"}

func (ec *executionContext) _ValkeyInstance(ctx context.Context, sel ast.SelectionSet, obj *valkey.ValkeyInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, valkeyInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValkeyInstance")
		case "id":
			out.Values[i] = ec._ValkeyInstance_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._ValkeyInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValkeyInstance_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "environment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValkeyInstance_environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "teamEnvironment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValkeyInstance_teamEnvironment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "access":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValkeyInstance_access(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValkeyInstance_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._ValkeyInstance_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValkeyInstance_cost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var valkeyInstanceAccessImplementors = []string{"ValkeyInstanceAccess"}

func (ec *executionContext) _ValkeyInstanceAccess(ctx context.Context, sel ast.SelectionSet, obj *valkey.ValkeyInstanceAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, valkeyInstanceAccessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValkeyInstanceAccess")
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValkeyInstanceAccess_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "access":
			out.Values[i] = ec._ValkeyInstanceAccess_access(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var valkeyInstanceAccessConnectionImplementors = []string{"ValkeyInstanceAccessConnection"}

func (ec *executionContext) _ValkeyInstanceAccessConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*valkey.ValkeyInstanceAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, valkeyInstanceAccessConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValkeyInstanceAccessConnection")
		case "pageInfo":
			out.Values[i] = ec._ValkeyInstanceAccessConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ValkeyInstanceAccessConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ValkeyInstanceAccessConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var valkeyInstanceAccessEdgeImplementors = []string{"ValkeyInstanceAccessEdge"}

func (ec *executionContext) _ValkeyInstanceAccessEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*valkey.ValkeyInstanceAccess]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, valkeyInstanceAccessEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValkeyInstanceAccessEdge")
		case "cursor":
			out.Values[i] = ec._ValkeyInstanceAccessEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ValkeyInstanceAccessEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var valkeyInstanceConnectionImplementors = []string{"ValkeyInstanceConnection"}

func (ec *executionContext) _ValkeyInstanceConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[*valkey.ValkeyInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, valkeyInstanceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValkeyInstanceConnection")
		case "pageInfo":
			out.Values[i] = ec._ValkeyInstanceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._ValkeyInstanceConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._ValkeyInstanceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var valkeyInstanceCostImplementors = []string{"ValkeyInstanceCost"}

func (ec *executionContext) _ValkeyInstanceCost(ctx context.Context, sel ast.SelectionSet, obj *cost.ValkeyInstanceCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, valkeyInstanceCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValkeyInstanceCost")
		case "sum":
			out.Values[i] = ec._ValkeyInstanceCost_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var valkeyInstanceEdgeImplementors = []string{"ValkeyInstanceEdge"}

func (ec *executionContext) _ValkeyInstanceEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[*valkey.ValkeyInstance]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, valkeyInstanceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValkeyInstanceEdge")
		case "cursor":
			out.Values[i] = ec._ValkeyInstanceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ValkeyInstanceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var valkeyInstanceStatusImplementors = []string{"ValkeyInstanceStatus"}

func (ec *executionContext) _ValkeyInstanceStatus(ctx context.Context, sel ast.SelectionSet, obj *valkey.ValkeyInstanceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, valkeyInstanceStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValkeyInstanceStatus")
		case "state":
			out.Values[i] = ec._ValkeyInstanceStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vulnerabilityUpdatedActivityLogEntryImplementors = []string{"VulnerabilityUpdatedActivityLogEntry", "ActivityLogEntry", "Node"}

func (ec *executionContext) _VulnerabilityUpdatedActivityLogEntry(ctx context.Context, sel ast.SelectionSet, obj *vulnerability.VulnerabilityUpdatedActivityLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vulnerabilityUpdatedActivityLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VulnerabilityUpdatedActivityLogEntry")
		case "id":
			out.Values[i] = ec._VulnerabilityUpdatedActivityLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actor":
			out.Values[i] = ec._VulnerabilityUpdatedActivityLogEntry_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._VulnerabilityUpdatedActivityLogEntry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._VulnerabilityUpdatedActivityLogEntry_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._VulnerabilityUpdatedActivityLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceName":
			out.Values[i] = ec._VulnerabilityUpdatedActivityLogEntry_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamSlug":
			out.Values[i] = ec._VulnerabilityUpdatedActivityLogEntry_teamSlug(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "environmentName":
			out.Values[i] = ec._VulnerabilityUpdatedActivityLogEntry_environmentName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadConnectionImplementors = []string{"WorkloadConnection"}

func (ec *executionContext) _WorkloadConnection(ctx context.Context, sel ast.SelectionSet, obj *pagination.Connection[workload.Workload]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadConnection")
		case "pageInfo":
			out.Values[i] = ec._WorkloadConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._WorkloadConnection_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._WorkloadConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadCostImplementors = []string{"WorkloadCost"}

func (ec *executionContext) _WorkloadCost(ctx context.Context, sel ast.SelectionSet, obj *cost.WorkloadCost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadCostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadCost")
		case "daily":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadCost_daily(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "monthly":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadCost_monthly(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadCostPeriodImplementors = []string{"WorkloadCostPeriod"}

func (ec *executionContext) _WorkloadCostPeriod(ctx context.Context, sel ast.SelectionSet, obj *cost.WorkloadCostPeriod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadCostPeriodImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadCostPeriod")
		case "sum":
			out.Values[i] = ec._WorkloadCostPeriod_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "series":
			out.Values[i] = ec._WorkloadCostPeriod_series(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadCostSampleImplementors = []string{"WorkloadCostSample"}

func (ec *executionContext) _WorkloadCostSample(ctx context.Context, sel ast.SelectionSet, obj *cost.WorkloadCostSample) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadCostSampleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadCostSample")
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadCostSample_workload(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workloadName":
			out.Values[i] = ec._WorkloadCostSample_workloadName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cost":
			out.Values[i] = ec._WorkloadCostSample_cost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadCostSeriesImplementors = []string{"WorkloadCostSeries"}

func (ec *executionContext) _WorkloadCostSeries(ctx context.Context, sel ast.SelectionSet, obj *cost.WorkloadCostSeries) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadCostSeriesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadCostSeries")
		case "date":
			out.Values[i] = ec._WorkloadCostSeries_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sum":
			out.Values[i] = ec._WorkloadCostSeries_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "workloads":
			out.Values[i] = ec._WorkloadCostSeries_workloads(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadEdgeImplementors = []string{"WorkloadEdge"}

func (ec *executionContext) _WorkloadEdge(ctx context.Context, sel ast.SelectionSet, obj *pagination.Edge[workload.Workload]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadEdge")
		case "cursor":
			out.Values[i] = ec._WorkloadEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._WorkloadEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadLogLineImplementors = []string{"WorkloadLogLine"}

func (ec *executionContext) _WorkloadLogLine(ctx context.Context, sel ast.SelectionSet, obj *podlog.WorkloadLogLine) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadLogLineImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadLogLine")
		case "time":
			out.Values[i] = ec._WorkloadLogLine_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._WorkloadLogLine_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "instance":
			out.Values[i] = ec._WorkloadLogLine_instance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadResourceQuantityImplementors = []string{"WorkloadResourceQuantity"}

func (ec *executionContext) _WorkloadResourceQuantity(ctx context.Context, sel ast.SelectionSet, obj *workload.WorkloadResourceQuantity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadResourceQuantityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadResourceQuantity")
		case "cpu":
			out.Values[i] = ec._WorkloadResourceQuantity_cpu(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "memory":
			out.Values[i] = ec._WorkloadResourceQuantity_memory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusImplementors = []string{"WorkloadStatus"}

func (ec *executionContext) _WorkloadStatus(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatus")
		case "state":
			out.Values[i] = ec._WorkloadStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._WorkloadStatus_errors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusDeprecatedIngressImplementors = []string{"WorkloadStatusDeprecatedIngress", "WorkloadStatusError"}

func (ec *executionContext) _WorkloadStatusDeprecatedIngress(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatusDeprecatedIngress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusDeprecatedIngressImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatusDeprecatedIngress")
		case "level":
			out.Values[i] = ec._WorkloadStatusDeprecatedIngress_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ingress":
			out.Values[i] = ec._WorkloadStatusDeprecatedIngress_ingress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusDeprecatedRegistryImplementors = []string{"WorkloadStatusDeprecatedRegistry", "WorkloadStatusError"}

func (ec *executionContext) _WorkloadStatusDeprecatedRegistry(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatusDeprecatedRegistry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusDeprecatedRegistryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatusDeprecatedRegistry")
		case "level":
			out.Values[i] = ec._WorkloadStatusDeprecatedRegistry_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registry":
			out.Values[i] = ec._WorkloadStatusDeprecatedRegistry_registry(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repository":
			out.Values[i] = ec._WorkloadStatusDeprecatedRegistry_repository(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._WorkloadStatusDeprecatedRegistry_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tag":
			out.Values[i] = ec._WorkloadStatusDeprecatedRegistry_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusFailedRunImplementors = []string{"WorkloadStatusFailedRun", "WorkloadStatusError"}

func (ec *executionContext) _WorkloadStatusFailedRun(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatusFailedRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusFailedRunImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatusFailedRun")
		case "level":
			out.Values[i] = ec._WorkloadStatusFailedRun_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detail":
			out.Values[i] = ec._WorkloadStatusFailedRun_detail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._WorkloadStatusFailedRun_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusInboundNetworkImplementors = []string{"WorkloadStatusInboundNetwork", "WorkloadStatusError"}

func (ec *executionContext) _WorkloadStatusInboundNetwork(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatusInboundNetwork) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusInboundNetworkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatusInboundNetwork")
		case "level":
			out.Values[i] = ec._WorkloadStatusInboundNetwork_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "policy":
			out.Values[i] = ec._WorkloadStatusInboundNetwork_policy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusInvalidNaisYamlImplementors = []string{"WorkloadStatusInvalidNaisYaml", "WorkloadStatusError"}

func (ec *executionContext) _WorkloadStatusInvalidNaisYaml(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatusInvalidNaisYaml) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusInvalidNaisYamlImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatusInvalidNaisYaml")
		case "level":
			out.Values[i] = ec._WorkloadStatusInvalidNaisYaml_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detail":
			out.Values[i] = ec._WorkloadStatusInvalidNaisYaml_detail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusMissingSBOMImplementors = []string{"WorkloadStatusMissingSBOM", "WorkloadStatusError"}

func (ec *executionContext) _WorkloadStatusMissingSBOM(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatusMissingSBOM) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusMissingSBOMImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatusMissingSBOM")
		case "level":
			out.Values[i] = ec._WorkloadStatusMissingSBOM_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusNewInstancesFailingImplementors = []string{"WorkloadStatusNewInstancesFailing", "WorkloadStatusError"}

func (ec *executionContext) _WorkloadStatusNewInstancesFailing(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatusNewInstancesFailing) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusNewInstancesFailingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatusNewInstancesFailing")
		case "level":
			out.Values[i] = ec._WorkloadStatusNewInstancesFailing_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failingInstances":
			out.Values[i] = ec._WorkloadStatusNewInstancesFailing_failingInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusNoRunningInstancesImplementors = []string{"WorkloadStatusNoRunningInstances", "WorkloadStatusError"}

func (ec *executionContext) _WorkloadStatusNoRunningInstances(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatusNoRunningInstances) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusNoRunningInstancesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatusNoRunningInstances")
		case "level":
			out.Values[i] = ec._WorkloadStatusNoRunningInstances_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusOutboundNetworkImplementors = []string{"WorkloadStatusOutboundNetwork", "WorkloadStatusError"}

func (ec *executionContext) _WorkloadStatusOutboundNetwork(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatusOutboundNetwork) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusOutboundNetworkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatusOutboundNetwork")
		case "level":
			out.Values[i] = ec._WorkloadStatusOutboundNetwork_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "policy":
			out.Values[i] = ec._WorkloadStatusOutboundNetwork_policy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusSynchronizationFailingImplementors = []string{"WorkloadStatusSynchronizationFailing", "WorkloadStatusError"}

func (ec *executionContext) _WorkloadStatusSynchronizationFailing(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatusSynchronizationFailing) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusSynchronizationFailingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatusSynchronizationFailing")
		case "level":
			out.Values[i] = ec._WorkloadStatusSynchronizationFailing_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detail":
			out.Values[i] = ec._WorkloadStatusSynchronizationFailing_detail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadStatusVulnerableImplementors = []string{"WorkloadStatusVulnerable", "WorkloadStatusError"}

func (ec *executionContext) _WorkloadStatusVulnerable(ctx context.Context, sel ast.SelectionSet, obj *status.WorkloadStatusVulnerable) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadStatusVulnerableImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadStatusVulnerable")
		case "level":
			out.Values[i] = ec._WorkloadStatusVulnerable_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "summary":
			out.Values[i] = ec._WorkloadStatusVulnerable_summary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadUtilizationImplementors = []string{"WorkloadUtilization"}

func (ec *executionContext) _WorkloadUtilization(ctx context.Context, sel ast.SelectionSet, obj *utilization.WorkloadUtilization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadUtilizationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadUtilization")
		case "current":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadUtilization_current(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "requested":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadUtilization_requested(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "limit":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadUtilization_limit(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "series":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadUtilization_series(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workloadUtilizationDataImplementors = []string{"WorkloadUtilizationData"}

func (ec *executionContext) _WorkloadUtilizationData(ctx context.Context, sel ast.SelectionSet, obj *utilization.WorkloadUtilizationData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workloadUtilizationDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkloadUtilizationData")
		case "workload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkloadUtilizationData_workload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "requested":
			out.Values[i] = ec._WorkloadUtilizationData_requested(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "used":
			out.Values[i] = ec._WorkloadUtilizationData_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNActivityLogEntry2githubcomnaisapiinternalactivitylogActivityLogEntry(ctx context.Context, sel ast.SelectionSet, v activitylog.ActivityLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ActivityLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNActivityLogEntry2githubcomnaisapiinternalactivitylogActivityLogEntry(ctx context.Context, sel ast.SelectionSet, v []activitylog.ActivityLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNActivityLogEntry2githubcomnaisapiinternalactivitylogActivityLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNActivityLogEntryConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[activitylog.ActivityLogEntry]) graphql.Marshaler {
	return ec._ActivityLogEntryConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNActivityLogEntryConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[activitylog.ActivityLogEntry]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ActivityLogEntryConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNActivityLogEntryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[activitylog.ActivityLogEntry]) graphql.Marshaler {
	return ec._ActivityLogEntryEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNActivityLogEntryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[activitylog.ActivityLogEntry]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNActivityLogEntryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx context.Context, v any) (activitylog.ActivityLogEntryResourceType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := activitylog.ActivityLogEntryResourceType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNActivityLogEntryResourceType2githubcomnaisapiinternalactivitylogActivityLogEntryResourceType(ctx context.Context, sel ast.SelectionSet, v activitylog.ActivityLogEntryResourceType) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNAddRepositoryToTeamInput2githubcomnaisapiinternalgithubrepositoryAddRepositoryToTeamInput(ctx context.Context, v any) (repository.AddRepositoryToTeamInput, error) {
	res, err := ec.unmarshalInputAddRepositoryToTeamInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddRepositoryToTeamPayload2githubcomnaisapiinternalgithubrepositoryAddRepositoryToTeamPayload(ctx context.Context, sel ast.SelectionSet, v repository.AddRepositoryToTeamPayload) graphql.Marshaler {
	return ec._AddRepositoryToTeamPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAddRepositoryToTeamPayload2githubcomnaisapiinternalgithubrepositoryAddRepositoryToTeamPayload(ctx context.Context, sel ast.SelectionSet, v *repository.AddRepositoryToTeamPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AddRepositoryToTeamPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAddSecretValueInput2githubcomnaisapiinternalworkloadsecretAddSecretValueInput(ctx context.Context, v any) (secret.AddSecretValueInput, error) {
	res, err := ec.unmarshalInputAddSecretValueInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddSecretValuePayload2githubcomnaisapiinternalworkloadsecretAddSecretValuePayload(ctx context.Context, sel ast.SelectionSet, v secret.AddSecretValuePayload) graphql.Marshaler {
	return ec._AddSecretValuePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAddSecretValuePayload2githubcomnaisapiinternalworkloadsecretAddSecretValuePayload(ctx context.Context, sel ast.SelectionSet, v *secret.AddSecretValuePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AddSecretValuePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAddTeamMemberInput2githubcomnaisapiinternalteamAddTeamMemberInput(ctx context.Context, v any) (team.AddTeamMemberInput, error) {
	res, err := ec.unmarshalInputAddTeamMemberInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddTeamMemberPayload2githubcomnaisapiinternalteamAddTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, v team.AddTeamMemberPayload) graphql.Marshaler {
	return ec._AddTeamMemberPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAddTeamMemberPayload2githubcomnaisapiinternalteamAddTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, v *team.AddTeamMemberPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AddTeamMemberPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAllowTeamAccessToUnleashInput2githubcomnaisapiinternalunleashAllowTeamAccessToUnleashInput(ctx context.Context, v any) (unleash.AllowTeamAccessToUnleashInput, error) {
	res, err := ec.unmarshalInputAllowTeamAccessToUnleashInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAllowTeamAccessToUnleashPayload2githubcomnaisapiinternalunleashAllowTeamAccessToUnleashPayload(ctx context.Context, sel ast.SelectionSet, v unleash.AllowTeamAccessToUnleashPayload) graphql.Marshaler {
	return ec._AllowTeamAccessToUnleashPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAllowTeamAccessToUnleashPayload2githubcomnaisapiinternalunleashAllowTeamAccessToUnleashPayload(ctx context.Context, sel ast.SelectionSet, v *unleash.AllowTeamAccessToUnleashPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AllowTeamAccessToUnleashPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNApplication2githubcomnaisapiinternalworkloadapplicationApplication(ctx context.Context, sel ast.SelectionSet, v application.Application) graphql.Marshaler {
	return ec._Application(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplication2githubcomnaisapiinternalworkloadapplicationApplication(ctx context.Context, sel ast.SelectionSet, v []*application.Application) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplication2githubcomnaisapiinternalworkloadapplicationApplication(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplication2githubcomnaisapiinternalworkloadapplicationApplication(ctx context.Context, sel ast.SelectionSet, v *application.Application) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationAuthIntegrations2githubcomnaisapiinternalworkloadApplicationAuthIntegrations(ctx context.Context, sel ast.SelectionSet, v workload.ApplicationAuthIntegrations) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationAuthIntegrations(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationAuthIntegrations2githubcomnaisapiinternalworkloadApplicationAuthIntegrations(ctx context.Context, sel ast.SelectionSet, v []workload.ApplicationAuthIntegrations) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationAuthIntegrations2githubcomnaisapiinternalworkloadApplicationAuthIntegrations(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*application.Application]) graphql.Marshaler {
	return ec._ApplicationConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*application.Application]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*application.Application]) graphql.Marshaler {
	return ec._ApplicationEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*application.Application]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationInstance2githubcomnaisapiinternalworkloadapplicationApplicationInstance(ctx context.Context, sel ast.SelectionSet, v []*application.ApplicationInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationInstance2githubcomnaisapiinternalworkloadapplicationApplicationInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationInstance2githubcomnaisapiinternalworkloadapplicationApplicationInstance(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*application.ApplicationInstance]) graphql.Marshaler {
	return ec._ApplicationInstanceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*application.ApplicationInstance]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationInstanceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*application.ApplicationInstance]) graphql.Marshaler {
	return ec._ApplicationInstanceEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*application.ApplicationInstance]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNApplicationInstanceState2githubcomnaisapiinternalworkloadapplicationApplicationInstanceState(ctx context.Context, v any) (application.ApplicationInstanceState, error) {
	var res application.ApplicationInstanceState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationInstanceState2githubcomnaisapiinternalworkloadapplicationApplicationInstanceState(ctx context.Context, sel ast.SelectionSet, v application.ApplicationInstanceState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNApplicationInstanceStatus2githubcomnaisapiinternalworkloadapplicationApplicationInstanceStatus(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationInstanceStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationInstanceStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationManifest2githubcomnaisapiinternalworkloadapplicationApplicationManifest(ctx context.Context, sel ast.SelectionSet, v application.ApplicationManifest) graphql.Marshaler {
	return ec._ApplicationManifest(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationManifest2githubcomnaisapiinternalworkloadapplicationApplicationManifest(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationManifest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationManifest(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationOrderField2githubcomnaisapiinternalworkloadapplicationApplicationOrderField(ctx context.Context, v any) (application.ApplicationOrderField, error) {
	var res application.ApplicationOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationOrderField2githubcomnaisapiinternalworkloadapplicationApplicationOrderField(ctx context.Context, sel ast.SelectionSet, v application.ApplicationOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNApplicationResources2githubcomnaisapiinternalworkloadapplicationApplicationResources(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationResources) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationResources(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationScaling2githubcomnaisapiinternalworkloadapplicationApplicationScaling(ctx context.Context, sel ast.SelectionSet, v *application.ApplicationScaling) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationScaling(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAssignRoleToServiceAccountInput2githubcomnaisapiinternalserviceaccountAssignRoleToServiceAccountInput(ctx context.Context, v any) (serviceaccount.AssignRoleToServiceAccountInput, error) {
	res, err := ec.unmarshalInputAssignRoleToServiceAccountInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAssignRoleToServiceAccountPayload2githubcomnaisapiinternalserviceaccountAssignRoleToServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, v serviceaccount.AssignRoleToServiceAccountPayload) graphql.Marshaler {
	return ec._AssignRoleToServiceAccountPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAssignRoleToServiceAccountPayload2githubcomnaisapiinternalserviceaccountAssignRoleToServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.AssignRoleToServiceAccountPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AssignRoleToServiceAccountPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAuthenticatedUser2githubcomnaisapiinternalauthauthzAuthenticatedUser(ctx context.Context, sel ast.SelectionSet, v authz.AuthenticatedUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthenticatedUser(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDataset2githubcomnaisapiinternalpersistencebigqueryBigQueryDataset(ctx context.Context, sel ast.SelectionSet, v bigquery.BigQueryDataset) graphql.Marshaler {
	return ec._BigQueryDataset(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDataset2githubcomnaisapiinternalpersistencebigqueryBigQueryDataset(ctx context.Context, sel ast.SelectionSet, v []*bigquery.BigQueryDataset) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBigQueryDataset2githubcomnaisapiinternalpersistencebigqueryBigQueryDataset(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBigQueryDataset2githubcomnaisapiinternalpersistencebigqueryBigQueryDataset(ctx context.Context, sel ast.SelectionSet, v *bigquery.BigQueryDataset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDataset(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDatasetAccess2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetAccess(ctx context.Context, sel ast.SelectionSet, v []*bigquery.BigQueryDatasetAccess) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBigQueryDatasetAccess2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBigQueryDatasetAccess2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetAccess(ctx context.Context, sel ast.SelectionSet, v *bigquery.BigQueryDatasetAccess) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDatasetAccess(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDatasetAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	return ec._BigQueryDatasetAccessConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDatasetAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDatasetAccessConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDatasetAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	return ec._BigQueryDatasetAccessEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDatasetAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*bigquery.BigQueryDatasetAccess]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBigQueryDatasetAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNBigQueryDatasetAccessOrderField2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetAccessOrderField(ctx context.Context, v any) (bigquery.BigQueryDatasetAccessOrderField, error) {
	var res bigquery.BigQueryDatasetAccessOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBigQueryDatasetAccessOrderField2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetAccessOrderField(ctx context.Context, sel ast.SelectionSet, v bigquery.BigQueryDatasetAccessOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBigQueryDatasetConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*bigquery.BigQueryDataset]) graphql.Marshaler {
	return ec._BigQueryDatasetConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDatasetConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*bigquery.BigQueryDataset]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDatasetConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDatasetCost2githubcomnaisapiinternalcostBigQueryDatasetCost(ctx context.Context, sel ast.SelectionSet, v cost.BigQueryDatasetCost) graphql.Marshaler {
	return ec._BigQueryDatasetCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDatasetCost2githubcomnaisapiinternalcostBigQueryDatasetCost(ctx context.Context, sel ast.SelectionSet, v *cost.BigQueryDatasetCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDatasetCost(ctx, sel, v)
}

func (ec *executionContext) marshalNBigQueryDatasetEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*bigquery.BigQueryDataset]) graphql.Marshaler {
	return ec._BigQueryDatasetEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNBigQueryDatasetEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*bigquery.BigQueryDataset]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBigQueryDatasetEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNBigQueryDatasetOrderField2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetOrderField(ctx context.Context, v any) (bigquery.BigQueryDatasetOrderField, error) {
	var res bigquery.BigQueryDatasetOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBigQueryDatasetOrderField2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetOrderField(ctx context.Context, sel ast.SelectionSet, v bigquery.BigQueryDatasetOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBigQueryDatasetStatus2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetStatus(ctx context.Context, sel ast.SelectionSet, v *bigquery.BigQueryDatasetStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BigQueryDatasetStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBucket2githubcomnaisapiinternalpersistencebucketBucket(ctx context.Context, sel ast.SelectionSet, v bucket.Bucket) graphql.Marshaler {
	return ec._Bucket(ctx, sel, &v)
}

func (ec *executionContext) marshalNBucket2githubcomnaisapiinternalpersistencebucketBucket(ctx context.Context, sel ast.SelectionSet, v []*bucket.Bucket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBucket2githubcomnaisapiinternalpersistencebucketBucket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBucket2githubcomnaisapiinternalpersistencebucketBucket(ctx context.Context, sel ast.SelectionSet, v *bucket.Bucket) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Bucket(ctx, sel, v)
}

func (ec *executionContext) marshalNBucketConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*bucket.Bucket]) graphql.Marshaler {
	return ec._BucketConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNBucketConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*bucket.Bucket]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BucketConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNBucketEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*bucket.Bucket]) graphql.Marshaler {
	return ec._BucketEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNBucketEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*bucket.Bucket]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBucketEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBucketError2githubcomnaisapiinternalpersistencebucketBucketError(ctx context.Context, sel ast.SelectionSet, v []*bucket.BucketError) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBucketError2githubcomnaisapiinternalpersistencebucketBucketError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBucketError2githubcomnaisapiinternalpersistencebucketBucketError(ctx context.Context, sel ast.SelectionSet, v *bucket.BucketError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BucketError(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBucketOrderField2githubcomnaisapiinternalpersistencebucketBucketOrderField(ctx context.Context, v any) (bucket.BucketOrderField, error) {
	var res bucket.BucketOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBucketOrderField2githubcomnaisapiinternalpersistencebucketBucketOrderField(ctx context.Context, sel ast.SelectionSet, v bucket.BucketOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBucketState2githubcomnaisapiinternalpersistencebucketBucketState(ctx context.Context, v any) (bucket.BucketState, error) {
	var res bucket.BucketState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBucketState2githubcomnaisapiinternalpersistencebucketBucketState(ctx context.Context, sel ast.SelectionSet, v bucket.BucketState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBucketStatus2githubcomnaisapiinternalpersistencebucketBucketStatus(ctx context.Context, sel ast.SelectionSet, v *bucket.BucketStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BucketStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChangeDeploymentKeyInput2githubcomnaisapiinternaldeploymentChangeDeploymentKeyInput(ctx context.Context, v any) (deployment.ChangeDeploymentKeyInput, error) {
	res, err := ec.unmarshalInputChangeDeploymentKeyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChangeDeploymentKeyPayload2githubcomnaisapiinternaldeploymentChangeDeploymentKeyPayload(ctx context.Context, sel ast.SelectionSet, v deployment.ChangeDeploymentKeyPayload) graphql.Marshaler {
	return ec._ChangeDeploymentKeyPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangeDeploymentKeyPayload2githubcomnaisapiinternaldeploymentChangeDeploymentKeyPayload(ctx context.Context, sel ast.SelectionSet, v *deployment.ChangeDeploymentKeyPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChangeDeploymentKeyPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConfigureReconcilerInput2githubcomnaisapiinternalreconcilerConfigureReconcilerInput(ctx context.Context, v any) (reconciler.ConfigureReconcilerInput, error) {
	res, err := ec.unmarshalInputConfigureReconcilerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNConfirmTeamDeletionInput2githubcomnaisapiinternalteamConfirmTeamDeletionInput(ctx context.Context, v any) (team.ConfirmTeamDeletionInput, error) {
	res, err := ec.unmarshalInputConfirmTeamDeletionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConfirmTeamDeletionPayload2githubcomnaisapiinternalteamConfirmTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, v team.ConfirmTeamDeletionPayload) graphql.Marshaler {
	return ec._ConfirmTeamDeletionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfirmTeamDeletionPayload2githubcomnaisapiinternalteamConfirmTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, v *team.ConfirmTeamDeletionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConfirmTeamDeletionPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNContainerImage2githubcomnaisapiinternalworkloadContainerImage(ctx context.Context, sel ast.SelectionSet, v *workload.ContainerImage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ContainerImage(ctx, sel, v)
}

func (ec *executionContext) marshalNContainerImageWorkloadReference2githubcomnaisapiinternalvulnerabilityContainerImageWorkloadReference(ctx context.Context, sel ast.SelectionSet, v []*vulnerability.ContainerImageWorkloadReference) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContainerImageWorkloadReference2githubcomnaisapiinternalvulnerabilityContainerImageWorkloadReference(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNContainerImageWorkloadReference2githubcomnaisapiinternalvulnerabilityContainerImageWorkloadReference(ctx context.Context, sel ast.SelectionSet, v *vulnerability.ContainerImageWorkloadReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ContainerImageWorkloadReference(ctx, sel, v)
}

func (ec *executionContext) marshalNContainerImageWorkloadReferenceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	return ec._ContainerImageWorkloadReferenceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNContainerImageWorkloadReferenceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ContainerImageWorkloadReferenceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNContainerImageWorkloadReferenceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	return ec._ContainerImageWorkloadReferenceEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNContainerImageWorkloadReferenceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*vulnerability.ContainerImageWorkloadReference]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContainerImageWorkloadReferenceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNCreateSecretInput2githubcomnaisapiinternalworkloadsecretCreateSecretInput(ctx context.Context, v any) (secret.CreateSecretInput, error) {
	res, err := ec.unmarshalInputCreateSecretInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateSecretPayload2githubcomnaisapiinternalworkloadsecretCreateSecretPayload(ctx context.Context, sel ast.SelectionSet, v secret.CreateSecretPayload) graphql.Marshaler {
	return ec._CreateSecretPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateSecretPayload2githubcomnaisapiinternalworkloadsecretCreateSecretPayload(ctx context.Context, sel ast.SelectionSet, v *secret.CreateSecretPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateSecretPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateServiceAccountInput2githubcomnaisapiinternalserviceaccountCreateServiceAccountInput(ctx context.Context, v any) (serviceaccount.CreateServiceAccountInput, error) {
	res, err := ec.unmarshalInputCreateServiceAccountInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateServiceAccountPayload2githubcomnaisapiinternalserviceaccountCreateServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, v serviceaccount.CreateServiceAccountPayload) graphql.Marshaler {
	return ec._CreateServiceAccountPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateServiceAccountPayload2githubcomnaisapiinternalserviceaccountCreateServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.CreateServiceAccountPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateServiceAccountPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateServiceAccountTokenInput2githubcomnaisapiinternalserviceaccountCreateServiceAccountTokenInput(ctx context.Context, v any) (serviceaccount.CreateServiceAccountTokenInput, error) {
	res, err := ec.unmarshalInputCreateServiceAccountTokenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateServiceAccountTokenPayload2githubcomnaisapiinternalserviceaccountCreateServiceAccountTokenPayload(ctx context.Context, sel ast.SelectionSet, v serviceaccount.CreateServiceAccountTokenPayload) graphql.Marshaler {
	return ec._CreateServiceAccountTokenPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateServiceAccountTokenPayload2githubcomnaisapiinternalserviceaccountCreateServiceAccountTokenPayload(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.CreateServiceAccountTokenPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateServiceAccountTokenPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTeamInput2githubcomnaisapiinternalteamCreateTeamInput(ctx context.Context, v any) (team.CreateTeamInput, error) {
	res, err := ec.unmarshalInputCreateTeamInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateTeamPayload2githubcomnaisapiinternalteamCreateTeamPayload(ctx context.Context, sel ast.SelectionSet, v team.CreateTeamPayload) graphql.Marshaler {
	return ec._CreateTeamPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateTeamPayload2githubcomnaisapiinternalteamCreateTeamPayload(ctx context.Context, sel ast.SelectionSet, v *team.CreateTeamPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateTeamPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateUnleashForTeamInput2githubcomnaisapiinternalunleashCreateUnleashForTeamInput(ctx context.Context, v any) (unleash.CreateUnleashForTeamInput, error) {
	res, err := ec.unmarshalInputCreateUnleashForTeamInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateUnleashForTeamPayload2githubcomnaisapiinternalunleashCreateUnleashForTeamPayload(ctx context.Context, sel ast.SelectionSet, v unleash.CreateUnleashForTeamPayload) graphql.Marshaler {
	return ec._CreateUnleashForTeamPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateUnleashForTeamPayload2githubcomnaisapiinternalunleashCreateUnleashForTeamPayload(ctx context.Context, sel ast.SelectionSet, v *unleash.CreateUnleashForTeamPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateUnleashForTeamPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx context.Context, v any) (pagination.Cursor, error) {
	var res pagination.Cursor
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx context.Context, sel ast.SelectionSet, v pagination.Cursor) graphql.Marshaler {
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) unmarshalNDate2githubcomnaisapiinternalgraphscalarDate(ctx context.Context, v any) (scalar.Date, error) {
	var res scalar.Date
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2githubcomnaisapiinternalgraphscalarDate(ctx context.Context, sel ast.SelectionSet, v scalar.Date) graphql.Marshaler {
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) unmarshalNDeleteApplicationInput2githubcomnaisapiinternalworkloadapplicationDeleteApplicationInput(ctx context.Context, v any) (application.DeleteApplicationInput, error) {
	res, err := ec.unmarshalInputDeleteApplicationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteApplicationPayload2githubcomnaisapiinternalworkloadapplicationDeleteApplicationPayload(ctx context.Context, sel ast.SelectionSet, v application.DeleteApplicationPayload) graphql.Marshaler {
	return ec._DeleteApplicationPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteApplicationPayload2githubcomnaisapiinternalworkloadapplicationDeleteApplicationPayload(ctx context.Context, sel ast.SelectionSet, v *application.DeleteApplicationPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteApplicationPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteJobInput2githubcomnaisapiinternalworkloadjobDeleteJobInput(ctx context.Context, v any) (job.DeleteJobInput, error) {
	res, err := ec.unmarshalInputDeleteJobInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteJobPayload2githubcomnaisapiinternalworkloadjobDeleteJobPayload(ctx context.Context, sel ast.SelectionSet, v job.DeleteJobPayload) graphql.Marshaler {
	return ec._DeleteJobPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteJobPayload2githubcomnaisapiinternalworkloadjobDeleteJobPayload(ctx context.Context, sel ast.SelectionSet, v *job.DeleteJobPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteJobPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteSecretInput2githubcomnaisapiinternalworkloadsecretDeleteSecretInput(ctx context.Context, v any) (secret.DeleteSecretInput, error) {
	res, err := ec.unmarshalInputDeleteSecretInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteSecretPayload2githubcomnaisapiinternalworkloadsecretDeleteSecretPayload(ctx context.Context, sel ast.SelectionSet, v secret.DeleteSecretPayload) graphql.Marshaler {
	return ec._DeleteSecretPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteSecretPayload2githubcomnaisapiinternalworkloadsecretDeleteSecretPayload(ctx context.Context, sel ast.SelectionSet, v *secret.DeleteSecretPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteSecretPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteServiceAccountInput2githubcomnaisapiinternalserviceaccountDeleteServiceAccountInput(ctx context.Context, v any) (serviceaccount.DeleteServiceAccountInput, error) {
	res, err := ec.unmarshalInputDeleteServiceAccountInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteServiceAccountPayload2githubcomnaisapiinternalserviceaccountDeleteServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, v serviceaccount.DeleteServiceAccountPayload) graphql.Marshaler {
	return ec._DeleteServiceAccountPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteServiceAccountPayload2githubcomnaisapiinternalserviceaccountDeleteServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.DeleteServiceAccountPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteServiceAccountPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteServiceAccountTokenInput2githubcomnaisapiinternalserviceaccountDeleteServiceAccountTokenInput(ctx context.Context, v any) (serviceaccount.DeleteServiceAccountTokenInput, error) {
	res, err := ec.unmarshalInputDeleteServiceAccountTokenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteServiceAccountTokenPayload2githubcomnaisapiinternalserviceaccountDeleteServiceAccountTokenPayload(ctx context.Context, sel ast.SelectionSet, v serviceaccount.DeleteServiceAccountTokenPayload) graphql.Marshaler {
	return ec._DeleteServiceAccountTokenPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteServiceAccountTokenPayload2githubcomnaisapiinternalserviceaccountDeleteServiceAccountTokenPayload(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.DeleteServiceAccountTokenPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteServiceAccountTokenPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNDeployment2githubcomnaisapiinternaldeploymentDeployment(ctx context.Context, sel ast.SelectionSet, v []*deployment.Deployment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDeployment2githubcomnaisapiinternaldeploymentDeployment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDeployment2githubcomnaisapiinternaldeploymentDeployment(ctx context.Context, sel ast.SelectionSet, v *deployment.Deployment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Deployment(ctx, sel, v)
}

func (ec *executionContext) marshalNDeploymentConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*deployment.Deployment]) graphql.Marshaler {
	return ec._DeploymentConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeploymentConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*deployment.Deployment]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeploymentConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNDeploymentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*deployment.Deployment]) graphql.Marshaler {
	return ec._DeploymentEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeploymentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*deployment.Deployment]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDeploymentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDeploymentResource2githubcomnaisapiinternaldeploymentDeploymentResource(ctx context.Context, sel ast.SelectionSet, v []*deployment.DeploymentResource) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDeploymentResource2githubcomnaisapiinternaldeploymentDeploymentResource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDeploymentResource2githubcomnaisapiinternaldeploymentDeploymentResource(ctx context.Context, sel ast.SelectionSet, v *deployment.DeploymentResource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeploymentResource(ctx, sel, v)
}

func (ec *executionContext) marshalNDeploymentResourceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*deployment.DeploymentResource]) graphql.Marshaler {
	return ec._DeploymentResourceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeploymentResourceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*deployment.DeploymentResource]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeploymentResourceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNDeploymentResourceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*deployment.DeploymentResource]) graphql.Marshaler {
	return ec._DeploymentResourceEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeploymentResourceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*deployment.DeploymentResource]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDeploymentResourceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDeploymentStatus2githubcomnaisapiinternaldeploymentDeploymentStatus(ctx context.Context, sel ast.SelectionSet, v []*deployment.DeploymentStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDeploymentStatus2githubcomnaisapiinternaldeploymentDeploymentStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDeploymentStatus2githubcomnaisapiinternaldeploymentDeploymentStatus(ctx context.Context, sel ast.SelectionSet, v *deployment.DeploymentStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeploymentStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNDeploymentStatusConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*deployment.DeploymentStatus]) graphql.Marshaler {
	return ec._DeploymentStatusConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeploymentStatusConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*deployment.DeploymentStatus]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeploymentStatusConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNDeploymentStatusEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*deployment.DeploymentStatus]) graphql.Marshaler {
	return ec._DeploymentStatusEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeploymentStatusEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*deployment.DeploymentStatus]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDeploymentStatusEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNDeploymentStatusState2githubcomnaisapiinternaldeploymentDeploymentStatusState(ctx context.Context, v any) (deployment.DeploymentStatusState, error) {
	var res deployment.DeploymentStatusState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeploymentStatusState2githubcomnaisapiinternaldeploymentDeploymentStatusState(ctx context.Context, sel ast.SelectionSet, v deployment.DeploymentStatusState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDisableReconcilerInput2githubcomnaisapiinternalreconcilerDisableReconcilerInput(ctx context.Context, v any) (reconciler.DisableReconcilerInput, error) {
	res, err := ec.unmarshalInputDisableReconcilerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEnableReconcilerInput2githubcomnaisapiinternalreconcilerEnableReconcilerInput(ctx context.Context, v any) (reconciler.EnableReconcilerInput, error) {
	res, err := ec.unmarshalInputEnableReconcilerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEnvironment2githubcomnaisapiinternalenvironmentEnvironment(ctx context.Context, sel ast.SelectionSet, v environment.Environment) graphql.Marshaler {
	return ec._Environment(ctx, sel, &v)
}

func (ec *executionContext) marshalNEnvironment2githubcomnaisapiinternalenvironmentEnvironment(ctx context.Context, sel ast.SelectionSet, v []*environment.Environment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEnvironment2githubcomnaisapiinternalenvironmentEnvironment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEnvironment2githubcomnaisapiinternalenvironmentEnvironment(ctx context.Context, sel ast.SelectionSet, v *environment.Environment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Environment(ctx, sel, v)
}

func (ec *executionContext) marshalNEnvironmentConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*environment.Environment]) graphql.Marshaler {
	return ec._EnvironmentConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNEnvironmentConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*environment.Environment]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EnvironmentConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNEnvironmentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*environment.Environment]) graphql.Marshaler {
	return ec._EnvironmentEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNEnvironmentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*environment.Environment]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEnvironmentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNEnvironmentOrderField2githubcomnaisapiinternalenvironmentEnvironmentOrderField(ctx context.Context, v any) (environment.EnvironmentOrderField, error) {
	var res environment.EnvironmentOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEnvironmentOrderField2githubcomnaisapiinternalenvironmentEnvironmentOrderField(ctx context.Context, sel ast.SelectionSet, v environment.EnvironmentOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEnvironmentWorkloadOrderField2githubcomnaisapiinternalworkloadEnvironmentWorkloadOrderField(ctx context.Context, v any) (workload.EnvironmentWorkloadOrderField, error) {
	var res workload.EnvironmentWorkloadOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEnvironmentWorkloadOrderField2githubcomnaisapiinternalworkloadEnvironmentWorkloadOrderField(ctx context.Context, sel ast.SelectionSet, v workload.EnvironmentWorkloadOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNExternalNetworkPolicyTarget2githubcomnaisapiinternalworkloadnetpolExternalNetworkPolicyTarget(ctx context.Context, sel ast.SelectionSet, v netpol.ExternalNetworkPolicyTarget) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExternalNetworkPolicyTarget(ctx, sel, v)
}

func (ec *executionContext) marshalNExternalNetworkPolicyTarget2githubcomnaisapiinternalworkloadnetpolExternalNetworkPolicyTarget(ctx context.Context, sel ast.SelectionSet, v []netpol.ExternalNetworkPolicyTarget) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExternalNetworkPolicyTarget2githubcomnaisapiinternalworkloadnetpolExternalNetworkPolicyTarget(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeatureKafka2githubcomnaisapiinternalfeatureFeatureKafka(ctx context.Context, sel ast.SelectionSet, v feature.FeatureKafka) graphql.Marshaler {
	return ec._FeatureKafka(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeatureOpenSearch2githubcomnaisapiinternalfeatureFeatureOpenSearch(ctx context.Context, sel ast.SelectionSet, v feature.FeatureOpenSearch) graphql.Marshaler {
	return ec._FeatureOpenSearch(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeatureRedis2githubcomnaisapiinternalfeatureFeatureRedis(ctx context.Context, sel ast.SelectionSet, v feature.FeatureRedis) graphql.Marshaler {
	return ec._FeatureRedis(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeatureUnleash2githubcomnaisapiinternalfeatureFeatureUnleash(ctx context.Context, sel ast.SelectionSet, v feature.FeatureUnleash) graphql.Marshaler {
	return ec._FeatureUnleash(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeatureValkey2githubcomnaisapiinternalfeatureFeatureValkey(ctx context.Context, sel ast.SelectionSet, v feature.FeatureValkey) graphql.Marshaler {
	return ec._FeatureValkey(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeatures2githubcomnaisapiinternalfeatureFeatures(ctx context.Context, sel ast.SelectionSet, v feature.Features) graphql.Marshaler {
	return ec._Features(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeatures2githubcomnaisapiinternalfeatureFeatures(ctx context.Context, sel ast.SelectionSet, v *feature.Features) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Features(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNID2githubcomnaisapiinternalgraphidentIdent(ctx context.Context, v any) (ident.Ident, error) {
	var res ident.Ident
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2githubcomnaisapiinternalgraphidentIdent(ctx context.Context, sel ast.SelectionSet, v ident.Ident) graphql.Marshaler {
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) marshalNImageVulnerability2githubcomnaisapiinternalvulnerabilityImageVulnerability(ctx context.Context, sel ast.SelectionSet, v []*vulnerability.ImageVulnerability) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageVulnerability2githubcomnaisapiinternalvulnerabilityImageVulnerability(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNImageVulnerability2githubcomnaisapiinternalvulnerabilityImageVulnerability(ctx context.Context, sel ast.SelectionSet, v *vulnerability.ImageVulnerability) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageVulnerability(ctx, sel, v)
}

func (ec *executionContext) marshalNImageVulnerabilityAnalysisComment2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisComment(ctx context.Context, sel ast.SelectionSet, v []*vulnerability.ImageVulnerabilityAnalysisComment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageVulnerabilityAnalysisComment2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisComment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNImageVulnerabilityAnalysisComment2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisComment(ctx context.Context, sel ast.SelectionSet, v *vulnerability.ImageVulnerabilityAnalysisComment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageVulnerabilityAnalysisComment(ctx, sel, v)
}

func (ec *executionContext) marshalNImageVulnerabilityAnalysisCommentConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment]) graphql.Marshaler {
	return ec._ImageVulnerabilityAnalysisCommentConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageVulnerabilityAnalysisCommentConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageVulnerabilityAnalysisCommentConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNImageVulnerabilityAnalysisCommentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*vulnerability.ImageVulnerabilityAnalysisComment]) graphql.Marshaler {
	return ec._ImageVulnerabilityAnalysisCommentEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageVulnerabilityAnalysisCommentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*vulnerability.ImageVulnerabilityAnalysisComment]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageVulnerabilityAnalysisCommentEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNImageVulnerabilityAnalysisState2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisState(ctx context.Context, v any) (vulnerability.ImageVulnerabilityAnalysisState, error) {
	var res vulnerability.ImageVulnerabilityAnalysisState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageVulnerabilityAnalysisState2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisState(ctx context.Context, sel ast.SelectionSet, v vulnerability.ImageVulnerabilityAnalysisState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNImageVulnerabilityAnalysisTrail2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisTrail(ctx context.Context, sel ast.SelectionSet, v vulnerability.ImageVulnerabilityAnalysisTrail) graphql.Marshaler {
	return ec._ImageVulnerabilityAnalysisTrail(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageVulnerabilityAnalysisTrail2githubcomnaisapiinternalvulnerabilityImageVulnerabilityAnalysisTrail(ctx context.Context, sel ast.SelectionSet, v *vulnerability.ImageVulnerabilityAnalysisTrail) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageVulnerabilityAnalysisTrail(ctx, sel, v)
}

func (ec *executionContext) marshalNImageVulnerabilityConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	return ec._ImageVulnerabilityConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageVulnerabilityConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageVulnerabilityConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNImageVulnerabilityEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	return ec._ImageVulnerabilityEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageVulnerabilityEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*vulnerability.ImageVulnerability]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageVulnerabilityEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNImageVulnerabilityOrderField2githubcomnaisapiinternalvulnerabilityImageVulnerabilityOrderField(ctx context.Context, v any) (vulnerability.ImageVulnerabilityOrderField, error) {
	var res vulnerability.ImageVulnerabilityOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageVulnerabilityOrderField2githubcomnaisapiinternalvulnerabilityImageVulnerabilityOrderField(ctx context.Context, sel ast.SelectionSet, v vulnerability.ImageVulnerabilityOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNImageVulnerabilitySeverity2githubcomnaisapiinternalvulnerabilityImageVulnerabilitySeverity(ctx context.Context, v any) (vulnerability.ImageVulnerabilitySeverity, error) {
	var res vulnerability.ImageVulnerabilitySeverity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageVulnerabilitySeverity2githubcomnaisapiinternalvulnerabilityImageVulnerabilitySeverity(ctx context.Context, sel ast.SelectionSet, v vulnerability.ImageVulnerabilitySeverity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNImageVulnerabilityState2githubcomnaisapiinternalvulnerabilityImageVulnerabilityState(ctx context.Context, v any) (vulnerability.ImageVulnerabilityState, error) {
	var res vulnerability.ImageVulnerabilityState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageVulnerabilityState2githubcomnaisapiinternalvulnerabilityImageVulnerabilityState(ctx context.Context, sel ast.SelectionSet, v vulnerability.ImageVulnerabilityState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNImageVulnerabilitySummary2githubcomnaisapiinternalvulnerabilityImageVulnerabilitySummary(ctx context.Context, sel ast.SelectionSet, v *vulnerability.ImageVulnerabilitySummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageVulnerabilitySummary(ctx, sel, v)
}

func (ec *executionContext) marshalNInboundNetworkPolicy2githubcomnaisapiinternalworkloadnetpolInboundNetworkPolicy(ctx context.Context, sel ast.SelectionSet, v *netpol.InboundNetworkPolicy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InboundNetworkPolicy(ctx, sel, v)
}

func (ec *executionContext) marshalNIngress2githubcomnaisapiinternalworkloadapplicationIngress(ctx context.Context, sel ast.SelectionSet, v []*application.Ingress) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIngress2githubcomnaisapiinternalworkloadapplicationIngress(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIngress2githubcomnaisapiinternalworkloadapplicationIngress(ctx context.Context, sel ast.SelectionSet, v *application.Ingress) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Ingress(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIngressType2githubcomnaisapiinternalworkloadapplicationIngressType(ctx context.Context, v any) (application.IngressType, error) {
	var res application.IngressType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIngressType2githubcomnaisapiinternalworkloadapplicationIngressType(ctx context.Context, sel ast.SelectionSet, v application.IngressType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) ([]int, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJob2githubcomnaisapiinternalworkloadjobJob(ctx context.Context, sel ast.SelectionSet, v job.Job) graphql.Marshaler {
	return ec._Job(ctx, sel, &v)
}

func (ec *executionContext) marshalNJob2githubcomnaisapiinternalworkloadjobJob(ctx context.Context, sel ast.SelectionSet, v []*job.Job) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJob2githubcomnaisapiinternalworkloadjobJob(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJob2githubcomnaisapiinternalworkloadjobJob(ctx context.Context, sel ast.SelectionSet, v *job.Job) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Job(ctx, sel, v)
}

func (ec *executionContext) marshalNJobAuthIntegrations2githubcomnaisapiinternalworkloadJobAuthIntegrations(ctx context.Context, sel ast.SelectionSet, v workload.JobAuthIntegrations) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobAuthIntegrations(ctx, sel, v)
}

func (ec *executionContext) marshalNJobAuthIntegrations2githubcomnaisapiinternalworkloadJobAuthIntegrations(ctx context.Context, sel ast.SelectionSet, v []workload.JobAuthIntegrations) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobAuthIntegrations2githubcomnaisapiinternalworkloadJobAuthIntegrations(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJobConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*job.Job]) graphql.Marshaler {
	return ec._JobConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*job.Job]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNJobEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*job.Job]) graphql.Marshaler {
	return ec._JobEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*job.Job]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJobManifest2githubcomnaisapiinternalworkloadjobJobManifest(ctx context.Context, sel ast.SelectionSet, v job.JobManifest) graphql.Marshaler {
	return ec._JobManifest(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobManifest2githubcomnaisapiinternalworkloadjobJobManifest(ctx context.Context, sel ast.SelectionSet, v *job.JobManifest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobManifest(ctx, sel, v)
}

func (ec *executionContext) unmarshalNJobOrderField2githubcomnaisapiinternalworkloadjobJobOrderField(ctx context.Context, v any) (job.JobOrderField, error) {
	var res job.JobOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobOrderField2githubcomnaisapiinternalworkloadjobJobOrderField(ctx context.Context, sel ast.SelectionSet, v job.JobOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNJobResources2githubcomnaisapiinternalworkloadjobJobResources(ctx context.Context, sel ast.SelectionSet, v *job.JobResources) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobResources(ctx, sel, v)
}

func (ec *executionContext) marshalNJobRun2githubcomnaisapiinternalworkloadjobJobRun(ctx context.Context, sel ast.SelectionSet, v []*job.JobRun) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobRun2githubcomnaisapiinternalworkloadjobJobRun(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJobRun2githubcomnaisapiinternalworkloadjobJobRun(ctx context.Context, sel ast.SelectionSet, v *job.JobRun) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobRun(ctx, sel, v)
}

func (ec *executionContext) marshalNJobRunConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*job.JobRun]) graphql.Marshaler {
	return ec._JobRunConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobRunConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*job.JobRun]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobRunConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNJobRunEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*job.JobRun]) graphql.Marshaler {
	return ec._JobRunEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobRunEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*job.JobRun]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobRunEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJobRunInstance2githubcomnaisapiinternalworkloadjobJobRunInstance(ctx context.Context, sel ast.SelectionSet, v []*job.JobRunInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobRunInstance2githubcomnaisapiinternalworkloadjobJobRunInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJobRunInstance2githubcomnaisapiinternalworkloadjobJobRunInstance(ctx context.Context, sel ast.SelectionSet, v *job.JobRunInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobRunInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNJobRunInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*job.JobRunInstance]) graphql.Marshaler {
	return ec._JobRunInstanceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobRunInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*job.JobRunInstance]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobRunInstanceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNJobRunInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*job.JobRunInstance]) graphql.Marshaler {
	return ec._JobRunInstanceEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobRunInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*job.JobRunInstance]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobRunInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNJobRunState2githubcomnaisapiinternalworkloadjobJobRunState(ctx context.Context, v any) (job.JobRunState, error) {
	var res job.JobRunState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobRunState2githubcomnaisapiinternalworkloadjobJobRunState(ctx context.Context, sel ast.SelectionSet, v job.JobRunState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNJobRunStatus2githubcomnaisapiinternalworkloadjobJobRunStatus(ctx context.Context, sel ast.SelectionSet, v *job.JobRunStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobRunStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNJobRunTrigger2githubcomnaisapiinternalworkloadjobJobRunTrigger(ctx context.Context, sel ast.SelectionSet, v *job.JobRunTrigger) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobRunTrigger(ctx, sel, v)
}

func (ec *executionContext) unmarshalNJobRunTriggerType2githubcomnaisapiinternalworkloadjobJobRunTriggerType(ctx context.Context, v any) (job.JobRunTriggerType, error) {
	var res job.JobRunTriggerType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobRunTriggerType2githubcomnaisapiinternalworkloadjobJobRunTriggerType(ctx context.Context, sel ast.SelectionSet, v job.JobRunTriggerType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNKafkaTopic2githubcomnaisapiinternalpersistencekafkatopicKafkaTopic(ctx context.Context, sel ast.SelectionSet, v kafkatopic.KafkaTopic) graphql.Marshaler {
	return ec._KafkaTopic(ctx, sel, &v)
}

func (ec *executionContext) marshalNKafkaTopic2githubcomnaisapiinternalpersistencekafkatopicKafkaTopic(ctx context.Context, sel ast.SelectionSet, v []*kafkatopic.KafkaTopic) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKafkaTopic2githubcomnaisapiinternalpersistencekafkatopicKafkaTopic(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNKafkaTopic2githubcomnaisapiinternalpersistencekafkatopicKafkaTopic(ctx context.Context, sel ast.SelectionSet, v *kafkatopic.KafkaTopic) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KafkaTopic(ctx, sel, v)
}

func (ec *executionContext) marshalNKafkaTopicAcl2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACL(ctx context.Context, sel ast.SelectionSet, v []*kafkatopic.KafkaTopicACL) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKafkaTopicAcl2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACL(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNKafkaTopicAcl2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACL(ctx context.Context, sel ast.SelectionSet, v *kafkatopic.KafkaTopicACL) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KafkaTopicAcl(ctx, sel, v)
}

func (ec *executionContext) marshalNKafkaTopicAclConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	return ec._KafkaTopicAclConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNKafkaTopicAclConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KafkaTopicAclConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNKafkaTopicAclEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	return ec._KafkaTopicAclEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNKafkaTopicAclEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*kafkatopic.KafkaTopicACL]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKafkaTopicAclEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNKafkaTopicAclOrderField2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACLOrderField(ctx context.Context, v any) (kafkatopic.KafkaTopicACLOrderField, error) {
	var res kafkatopic.KafkaTopicACLOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKafkaTopicAclOrderField2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACLOrderField(ctx context.Context, sel ast.SelectionSet, v kafkatopic.KafkaTopicACLOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNKafkaTopicConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	return ec._KafkaTopicConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNKafkaTopicConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KafkaTopicConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNKafkaTopicEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	return ec._KafkaTopicEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNKafkaTopicEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*kafkatopic.KafkaTopic]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKafkaTopicEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNKafkaTopicOrderField2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicOrderField(ctx context.Context, v any) (kafkatopic.KafkaTopicOrderField, error) {
	var res kafkatopic.KafkaTopicOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKafkaTopicOrderField2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicOrderField(ctx context.Context, sel ast.SelectionSet, v kafkatopic.KafkaTopicOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLogDestination2githubcomnaisapiinternalworkloadloggingLogDestination(ctx context.Context, sel ast.SelectionSet, v logging.LogDestination) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogDestination(ctx, sel, v)
}

func (ec *executionContext) marshalNLogDestination2githubcomnaisapiinternalworkloadloggingLogDestination(ctx context.Context, sel ast.SelectionSet, v []logging.LogDestination) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLogDestination2githubcomnaisapiinternalworkloadloggingLogDestination(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNetworkPolicy2githubcomnaisapiinternalworkloadnetpolNetworkPolicy(ctx context.Context, sel ast.SelectionSet, v netpol.NetworkPolicy) graphql.Marshaler {
	return ec._NetworkPolicy(ctx, sel, &v)
}

func (ec *executionContext) marshalNNetworkPolicy2githubcomnaisapiinternalworkloadnetpolNetworkPolicy(ctx context.Context, sel ast.SelectionSet, v *netpol.NetworkPolicy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NetworkPolicy(ctx, sel, v)
}

func (ec *executionContext) marshalNNetworkPolicyRule2githubcomnaisapiinternalworkloadnetpolNetworkPolicyRule(ctx context.Context, sel ast.SelectionSet, v []*netpol.NetworkPolicyRule) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNetworkPolicyRule2githubcomnaisapiinternalworkloadnetpolNetworkPolicyRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNetworkPolicyRule2githubcomnaisapiinternalworkloadnetpolNetworkPolicyRule(ctx context.Context, sel ast.SelectionSet, v *netpol.NetworkPolicyRule) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NetworkPolicyRule(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearch2githubcomnaisapiinternalpersistenceopensearchOpenSearch(ctx context.Context, sel ast.SelectionSet, v opensearch.OpenSearch) graphql.Marshaler {
	return ec._OpenSearch(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearch2githubcomnaisapiinternalpersistenceopensearchOpenSearch(ctx context.Context, sel ast.SelectionSet, v []*opensearch.OpenSearch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOpenSearch2githubcomnaisapiinternalpersistenceopensearchOpenSearch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOpenSearch2githubcomnaisapiinternalpersistenceopensearchOpenSearch(ctx context.Context, sel ast.SelectionSet, v *opensearch.OpenSearch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearch(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearchAccess2githubcomnaisapiinternalpersistenceopensearchOpenSearchAccess(ctx context.Context, sel ast.SelectionSet, v []*opensearch.OpenSearchAccess) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOpenSearchAccess2githubcomnaisapiinternalpersistenceopensearchOpenSearchAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOpenSearchAccess2githubcomnaisapiinternalpersistenceopensearchOpenSearchAccess(ctx context.Context, sel ast.SelectionSet, v *opensearch.OpenSearchAccess) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearchAccess(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearchAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	return ec._OpenSearchAccessConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearchAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearchAccessConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearchAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	return ec._OpenSearchAccessEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearchAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*opensearch.OpenSearchAccess]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOpenSearchAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNOpenSearchAccessOrderField2githubcomnaisapiinternalpersistenceopensearchOpenSearchAccessOrderField(ctx context.Context, v any) (opensearch.OpenSearchAccessOrderField, error) {
	var res opensearch.OpenSearchAccessOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOpenSearchAccessOrderField2githubcomnaisapiinternalpersistenceopensearchOpenSearchAccessOrderField(ctx context.Context, sel ast.SelectionSet, v opensearch.OpenSearchAccessOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOpenSearchConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*opensearch.OpenSearch]) graphql.Marshaler {
	return ec._OpenSearchConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearchConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*opensearch.OpenSearch]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearchConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearchCost2githubcomnaisapiinternalcostOpenSearchCost(ctx context.Context, sel ast.SelectionSet, v cost.OpenSearchCost) graphql.Marshaler {
	return ec._OpenSearchCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearchCost2githubcomnaisapiinternalcostOpenSearchCost(ctx context.Context, sel ast.SelectionSet, v *cost.OpenSearchCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearchCost(ctx, sel, v)
}

func (ec *executionContext) marshalNOpenSearchEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*opensearch.OpenSearch]) graphql.Marshaler {
	return ec._OpenSearchEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpenSearchEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*opensearch.OpenSearch]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOpenSearchEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNOpenSearchOrderField2githubcomnaisapiinternalpersistenceopensearchOpenSearchOrderField(ctx context.Context, v any) (opensearch.OpenSearchOrderField, error) {
	var res opensearch.OpenSearchOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOpenSearchOrderField2githubcomnaisapiinternalpersistenceopensearchOpenSearchOrderField(ctx context.Context, sel ast.SelectionSet, v opensearch.OpenSearchOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOpenSearchStatus2githubcomnaisapiinternalpersistenceopensearchOpenSearchStatus(ctx context.Context, sel ast.SelectionSet, v *opensearch.OpenSearchStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OpenSearchStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx context.Context, v any) (model.OrderDirection, error) {
	var res model.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2githubcomnaisapiinternalgraphmodelOrderDirection(ctx context.Context, sel ast.SelectionSet, v model.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOutboundNetworkPolicy2githubcomnaisapiinternalworkloadnetpolOutboundNetworkPolicy(ctx context.Context, sel ast.SelectionSet, v *netpol.OutboundNetworkPolicy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OutboundNetworkPolicy(ctx, sel, v)
}

func (ec *executionContext) marshalNPageInfo2githubcomnaisapiinternalgraphpaginationPageInfo(ctx context.Context, sel ast.SelectionSet, v pagination.PageInfo) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconciler2githubcomnaisapiinternalreconcilerReconciler(ctx context.Context, sel ast.SelectionSet, v reconciler.Reconciler) graphql.Marshaler {
	return ec._Reconciler(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconciler2githubcomnaisapiinternalreconcilerReconciler(ctx context.Context, sel ast.SelectionSet, v []*reconciler.Reconciler) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReconciler2githubcomnaisapiinternalreconcilerReconciler(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNReconciler2githubcomnaisapiinternalreconcilerReconciler(ctx context.Context, sel ast.SelectionSet, v *reconciler.Reconciler) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Reconciler(ctx, sel, v)
}

func (ec *executionContext) marshalNReconcilerConfig2githubcomnaisapiinternalreconcilerReconcilerConfig(ctx context.Context, sel ast.SelectionSet, v []*reconciler.ReconcilerConfig) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReconcilerConfig2githubcomnaisapiinternalreconcilerReconcilerConfig(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNReconcilerConfig2githubcomnaisapiinternalreconcilerReconcilerConfig(ctx context.Context, sel ast.SelectionSet, v *reconciler.ReconcilerConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ReconcilerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNReconcilerConfigInput2githubcomnaisapiinternalreconcilerReconcilerConfigInput(ctx context.Context, v any) ([]*reconciler.ReconcilerConfigInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*reconciler.ReconcilerConfigInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNReconcilerConfigInput2githubcomnaisapiinternalreconcilerReconcilerConfigInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNReconcilerConfigInput2githubcomnaisapiinternalreconcilerReconcilerConfigInput(ctx context.Context, v any) (*reconciler.ReconcilerConfigInput, error) {
	res, err := ec.unmarshalInputReconcilerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNReconcilerConfiguredActivityLogEntryData2githubcomnaisapiinternalreconcilerReconcilerConfiguredActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *reconciler.ReconcilerConfiguredActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ReconcilerConfiguredActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNReconcilerConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*reconciler.Reconciler]) graphql.Marshaler {
	return ec._ReconcilerConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconcilerConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*reconciler.Reconciler]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ReconcilerConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNReconcilerEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*reconciler.Reconciler]) graphql.Marshaler {
	return ec._ReconcilerEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconcilerEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*reconciler.Reconciler]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReconcilerEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNReconcilerError2githubcomnaisapiinternalreconcilerReconcilerError(ctx context.Context, sel ast.SelectionSet, v []*reconciler.ReconcilerError) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReconcilerError2githubcomnaisapiinternalreconcilerReconcilerError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNReconcilerError2githubcomnaisapiinternalreconcilerReconcilerError(ctx context.Context, sel ast.SelectionSet, v *reconciler.ReconcilerError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ReconcilerError(ctx, sel, v)
}

func (ec *executionContext) marshalNReconcilerErrorConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*reconciler.ReconcilerError]) graphql.Marshaler {
	return ec._ReconcilerErrorConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconcilerErrorConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*reconciler.ReconcilerError]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ReconcilerErrorConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNReconcilerErrorEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*reconciler.ReconcilerError]) graphql.Marshaler {
	return ec._ReconcilerErrorEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconcilerErrorEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*reconciler.ReconcilerError]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReconcilerErrorEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRedisInstance2githubcomnaisapiinternalpersistenceredisRedisInstance(ctx context.Context, sel ast.SelectionSet, v redis.RedisInstance) graphql.Marshaler {
	return ec._RedisInstance(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstance2githubcomnaisapiinternalpersistenceredisRedisInstance(ctx context.Context, sel ast.SelectionSet, v []*redis.RedisInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRedisInstance2githubcomnaisapiinternalpersistenceredisRedisInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRedisInstance2githubcomnaisapiinternalpersistenceredisRedisInstance(ctx context.Context, sel ast.SelectionSet, v *redis.RedisInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNRedisInstanceAccess2githubcomnaisapiinternalpersistenceredisRedisInstanceAccess(ctx context.Context, sel ast.SelectionSet, v []*redis.RedisInstanceAccess) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRedisInstanceAccess2githubcomnaisapiinternalpersistenceredisRedisInstanceAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRedisInstanceAccess2githubcomnaisapiinternalpersistenceredisRedisInstanceAccess(ctx context.Context, sel ast.SelectionSet, v *redis.RedisInstanceAccess) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstanceAccess(ctx, sel, v)
}

func (ec *executionContext) marshalNRedisInstanceAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*redis.RedisInstanceAccess]) graphql.Marshaler {
	return ec._RedisInstanceAccessConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstanceAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*redis.RedisInstanceAccess]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstanceAccessConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNRedisInstanceAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*redis.RedisInstanceAccess]) graphql.Marshaler {
	return ec._RedisInstanceAccessEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstanceAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*redis.RedisInstanceAccess]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRedisInstanceAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNRedisInstanceAccessOrderField2githubcomnaisapiinternalpersistenceredisRedisInstanceAccessOrderField(ctx context.Context, v any) (redis.RedisInstanceAccessOrderField, error) {
	var res redis.RedisInstanceAccessOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRedisInstanceAccessOrderField2githubcomnaisapiinternalpersistenceredisRedisInstanceAccessOrderField(ctx context.Context, sel ast.SelectionSet, v redis.RedisInstanceAccessOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRedisInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*redis.RedisInstance]) graphql.Marshaler {
	return ec._RedisInstanceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*redis.RedisInstance]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstanceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNRedisInstanceCost2githubcomnaisapiinternalcostRedisInstanceCost(ctx context.Context, sel ast.SelectionSet, v cost.RedisInstanceCost) graphql.Marshaler {
	return ec._RedisInstanceCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstanceCost2githubcomnaisapiinternalcostRedisInstanceCost(ctx context.Context, sel ast.SelectionSet, v *cost.RedisInstanceCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstanceCost(ctx, sel, v)
}

func (ec *executionContext) marshalNRedisInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*redis.RedisInstance]) graphql.Marshaler {
	return ec._RedisInstanceEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNRedisInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*redis.RedisInstance]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRedisInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNRedisInstanceOrderField2githubcomnaisapiinternalpersistenceredisRedisInstanceOrderField(ctx context.Context, v any) (redis.RedisInstanceOrderField, error) {
	var res redis.RedisInstanceOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRedisInstanceOrderField2githubcomnaisapiinternalpersistenceredisRedisInstanceOrderField(ctx context.Context, sel ast.SelectionSet, v redis.RedisInstanceOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRedisInstanceStatus2githubcomnaisapiinternalpersistenceredisRedisInstanceStatus(ctx context.Context, sel ast.SelectionSet, v *redis.RedisInstanceStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RedisInstanceStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRemoveRepositoryFromTeamInput2githubcomnaisapiinternalgithubrepositoryRemoveRepositoryFromTeamInput(ctx context.Context, v any) (repository.RemoveRepositoryFromTeamInput, error) {
	res, err := ec.unmarshalInputRemoveRepositoryFromTeamInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRemoveRepositoryFromTeamPayload2githubcomnaisapiinternalgithubrepositoryRemoveRepositoryFromTeamPayload(ctx context.Context, sel ast.SelectionSet, v repository.RemoveRepositoryFromTeamPayload) graphql.Marshaler {
	return ec._RemoveRepositoryFromTeamPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRemoveRepositoryFromTeamPayload2githubcomnaisapiinternalgithubrepositoryRemoveRepositoryFromTeamPayload(ctx context.Context, sel ast.SelectionSet, v *repository.RemoveRepositoryFromTeamPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RemoveRepositoryFromTeamPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRemoveSecretValueInput2githubcomnaisapiinternalworkloadsecretRemoveSecretValueInput(ctx context.Context, v any) (secret.RemoveSecretValueInput, error) {
	res, err := ec.unmarshalInputRemoveSecretValueInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRemoveSecretValuePayload2githubcomnaisapiinternalworkloadsecretRemoveSecretValuePayload(ctx context.Context, sel ast.SelectionSet, v secret.RemoveSecretValuePayload) graphql.Marshaler {
	return ec._RemoveSecretValuePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRemoveSecretValuePayload2githubcomnaisapiinternalworkloadsecretRemoveSecretValuePayload(ctx context.Context, sel ast.SelectionSet, v *secret.RemoveSecretValuePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RemoveSecretValuePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRemoveTeamMemberInput2githubcomnaisapiinternalteamRemoveTeamMemberInput(ctx context.Context, v any) (team.RemoveTeamMemberInput, error) {
	res, err := ec.unmarshalInputRemoveTeamMemberInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRemoveTeamMemberPayload2githubcomnaisapiinternalteamRemoveTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, v team.RemoveTeamMemberPayload) graphql.Marshaler {
	return ec._RemoveTeamMemberPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRemoveTeamMemberPayload2githubcomnaisapiinternalteamRemoveTeamMemberPayload(ctx context.Context, sel ast.SelectionSet, v *team.RemoveTeamMemberPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RemoveTeamMemberPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNRepository2githubcomnaisapiinternalgithubrepositoryRepository(ctx context.Context, sel ast.SelectionSet, v []*repository.Repository) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepository2githubcomnaisapiinternalgithubrepositoryRepository(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRepository2githubcomnaisapiinternalgithubrepositoryRepository(ctx context.Context, sel ast.SelectionSet, v *repository.Repository) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositoryConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*repository.Repository]) graphql.Marshaler {
	return ec._RepositoryConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepositoryConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*repository.Repository]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepositoryConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositoryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*repository.Repository]) graphql.Marshaler {
	return ec._RepositoryEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepositoryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*repository.Repository]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepositoryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNRepositoryOrderField2githubcomnaisapiinternalgithubrepositoryRepositoryOrderField(ctx context.Context, v any) (repository.RepositoryOrderField, error) {
	var res repository.RepositoryOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepositoryOrderField2githubcomnaisapiinternalgithubrepositoryRepositoryOrderField(ctx context.Context, sel ast.SelectionSet, v repository.RepositoryOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRequestTeamDeletionInput2githubcomnaisapiinternalteamRequestTeamDeletionInput(ctx context.Context, v any) (team.RequestTeamDeletionInput, error) {
	res, err := ec.unmarshalInputRequestTeamDeletionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRequestTeamDeletionPayload2githubcomnaisapiinternalteamRequestTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, v team.RequestTeamDeletionPayload) graphql.Marshaler {
	return ec._RequestTeamDeletionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRequestTeamDeletionPayload2githubcomnaisapiinternalteamRequestTeamDeletionPayload(ctx context.Context, sel ast.SelectionSet, v *team.RequestTeamDeletionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RequestTeamDeletionPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRestartApplicationInput2githubcomnaisapiinternalworkloadapplicationRestartApplicationInput(ctx context.Context, v any) (application.RestartApplicationInput, error) {
	res, err := ec.unmarshalInputRestartApplicationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRestartApplicationPayload2githubcomnaisapiinternalworkloadapplicationRestartApplicationPayload(ctx context.Context, sel ast.SelectionSet, v application.RestartApplicationPayload) graphql.Marshaler {
	return ec._RestartApplicationPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRestartApplicationPayload2githubcomnaisapiinternalworkloadapplicationRestartApplicationPayload(ctx context.Context, sel ast.SelectionSet, v *application.RestartApplicationPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RestartApplicationPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRevokeRoleFromServiceAccountInput2githubcomnaisapiinternalserviceaccountRevokeRoleFromServiceAccountInput(ctx context.Context, v any) (serviceaccount.RevokeRoleFromServiceAccountInput, error) {
	res, err := ec.unmarshalInputRevokeRoleFromServiceAccountInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRevokeRoleFromServiceAccountPayload2githubcomnaisapiinternalserviceaccountRevokeRoleFromServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, v serviceaccount.RevokeRoleFromServiceAccountPayload) graphql.Marshaler {
	return ec._RevokeRoleFromServiceAccountPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRevokeRoleFromServiceAccountPayload2githubcomnaisapiinternalserviceaccountRevokeRoleFromServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.RevokeRoleFromServiceAccountPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RevokeRoleFromServiceAccountPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRevokeTeamAccessToUnleashInput2githubcomnaisapiinternalunleashRevokeTeamAccessToUnleashInput(ctx context.Context, v any) (unleash.RevokeTeamAccessToUnleashInput, error) {
	res, err := ec.unmarshalInputRevokeTeamAccessToUnleashInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRevokeTeamAccessToUnleashPayload2githubcomnaisapiinternalunleashRevokeTeamAccessToUnleashPayload(ctx context.Context, sel ast.SelectionSet, v unleash.RevokeTeamAccessToUnleashPayload) graphql.Marshaler {
	return ec._RevokeTeamAccessToUnleashPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRevokeTeamAccessToUnleashPayload2githubcomnaisapiinternalunleashRevokeTeamAccessToUnleashPayload(ctx context.Context, sel ast.SelectionSet, v *unleash.RevokeTeamAccessToUnleashPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RevokeTeamAccessToUnleashPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNRole2githubcomnaisapiinternalauthauthzRole(ctx context.Context, sel ast.SelectionSet, v []*authz.Role) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRole2githubcomnaisapiinternalauthauthzRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRole2githubcomnaisapiinternalauthauthzRole(ctx context.Context, sel ast.SelectionSet, v *authz.Role) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Role(ctx, sel, v)
}

func (ec *executionContext) marshalNRoleAssignedToServiceAccountActivityLogEntryData2githubcomnaisapiinternalserviceaccountRoleAssignedToServiceAccountActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.RoleAssignedToServiceAccountActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RoleAssignedToServiceAccountActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNRoleConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*authz.Role]) graphql.Marshaler {
	return ec._RoleConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRoleConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*authz.Role]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RoleConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNRoleEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*authz.Role]) graphql.Marshaler {
	return ec._RoleEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNRoleEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*authz.Role]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoleEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRoleRevokedFromServiceAccountActivityLogEntryData2githubcomnaisapiinternalserviceaccountRoleRevokedFromServiceAccountActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.RoleRevokedFromServiceAccountActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RoleRevokedFromServiceAccountActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNScalingStrategy2githubcomnaisapiinternalworkloadapplicationScalingStrategy(ctx context.Context, sel ast.SelectionSet, v application.ScalingStrategy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScalingStrategy(ctx, sel, v)
}

func (ec *executionContext) marshalNScalingStrategy2githubcomnaisapiinternalworkloadapplicationScalingStrategy(ctx context.Context, sel ast.SelectionSet, v []application.ScalingStrategy) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNScalingStrategy2githubcomnaisapiinternalworkloadapplicationScalingStrategy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSearchFilter2githubcomnaisapiinternalsearchSearchFilter(ctx context.Context, v any) (search.SearchFilter, error) {
	res, err := ec.unmarshalInputSearchFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSearchNode2githubcomnaisapiinternalsearchSearchNode(ctx context.Context, sel ast.SelectionSet, v search.SearchNode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchNode(ctx, sel, v)
}

func (ec *executionContext) marshalNSearchNode2githubcomnaisapiinternalsearchSearchNode(ctx context.Context, sel ast.SelectionSet, v []search.SearchNode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSearchNode2githubcomnaisapiinternalsearchSearchNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSearchNodeConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[search.SearchNode]) graphql.Marshaler {
	return ec._SearchNodeConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchNodeConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[search.SearchNode]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchNodeConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNSearchNodeEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[search.SearchNode]) graphql.Marshaler {
	return ec._SearchNodeEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchNodeEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[search.SearchNode]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSearchNodeEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx context.Context, sel ast.SelectionSet, v secret.Secret) graphql.Marshaler {
	return ec._Secret(ctx, sel, &v)
}

func (ec *executionContext) marshalNSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx context.Context, sel ast.SelectionSet, v []*secret.Secret) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx context.Context, sel ast.SelectionSet, v *secret.Secret) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Secret(ctx, sel, v)
}

func (ec *executionContext) marshalNSecretConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*secret.Secret]) graphql.Marshaler {
	return ec._SecretConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSecretConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*secret.Secret]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SecretConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNSecretEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*secret.Secret]) graphql.Marshaler {
	return ec._SecretEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNSecretEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*secret.Secret]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSecretEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSecretOrderField2githubcomnaisapiinternalworkloadsecretSecretOrderField(ctx context.Context, v any) (secret.SecretOrderField, error) {
	var res secret.SecretOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSecretOrderField2githubcomnaisapiinternalworkloadsecretSecretOrderField(ctx context.Context, sel ast.SelectionSet, v secret.SecretOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSecretValue2githubcomnaisapiinternalworkloadsecretSecretValue(ctx context.Context, sel ast.SelectionSet, v []*secret.SecretValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSecretValue2githubcomnaisapiinternalworkloadsecretSecretValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSecretValue2githubcomnaisapiinternalworkloadsecretSecretValue(ctx context.Context, sel ast.SelectionSet, v *secret.SecretValue) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SecretValue(ctx, sel, v)
}

func (ec *executionContext) marshalNSecretValueAddedActivityLogEntryData2githubcomnaisapiinternalworkloadsecretSecretValueAddedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *secret.SecretValueAddedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SecretValueAddedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSecretValueInput2githubcomnaisapiinternalworkloadsecretSecretValueInput(ctx context.Context, v any) (*secret.SecretValueInput, error) {
	res, err := ec.unmarshalInputSecretValueInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSecretValueRemovedActivityLogEntryData2githubcomnaisapiinternalworkloadsecretSecretValueRemovedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *secret.SecretValueRemovedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SecretValueRemovedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNSecretValueUpdatedActivityLogEntryData2githubcomnaisapiinternalworkloadsecretSecretValueUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *secret.SecretValueUpdatedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SecretValueUpdatedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx context.Context, sel ast.SelectionSet, v serviceaccount.ServiceAccount) graphql.Marshaler {
	return ec._ServiceAccount(ctx, sel, &v)
}

func (ec *executionContext) marshalNServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx context.Context, sel ast.SelectionSet, v []*serviceaccount.ServiceAccount) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.ServiceAccount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceAccount(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceAccountConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*serviceaccount.ServiceAccount]) graphql.Marshaler {
	return ec._ServiceAccountConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNServiceAccountConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*serviceaccount.ServiceAccount]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceAccountConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceAccountEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*serviceaccount.ServiceAccount]) graphql.Marshaler {
	return ec._ServiceAccountEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNServiceAccountEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*serviceaccount.ServiceAccount]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServiceAccountEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServiceAccountToken2githubcomnaisapiinternalserviceaccountServiceAccountToken(ctx context.Context, sel ast.SelectionSet, v []*serviceaccount.ServiceAccountToken) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServiceAccountToken2githubcomnaisapiinternalserviceaccountServiceAccountToken(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServiceAccountToken2githubcomnaisapiinternalserviceaccountServiceAccountToken(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.ServiceAccountToken) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceAccountToken(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceAccountTokenConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*serviceaccount.ServiceAccountToken]) graphql.Marshaler {
	return ec._ServiceAccountTokenConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNServiceAccountTokenConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*serviceaccount.ServiceAccountToken]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceAccountTokenConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceAccountTokenCreatedActivityLogEntryData2githubcomnaisapiinternalserviceaccountServiceAccountTokenCreatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.ServiceAccountTokenCreatedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceAccountTokenCreatedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceAccountTokenDeletedActivityLogEntryData2githubcomnaisapiinternalserviceaccountServiceAccountTokenDeletedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.ServiceAccountTokenDeletedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceAccountTokenDeletedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceAccountTokenEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*serviceaccount.ServiceAccountToken]) graphql.Marshaler {
	return ec._ServiceAccountTokenEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNServiceAccountTokenEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*serviceaccount.ServiceAccountToken]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServiceAccountTokenEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServiceAccountTokenUpdatedActivityLogEntryData2githubcomnaisapiinternalserviceaccountServiceAccountTokenUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceAccountTokenUpdatedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalserviceaccountServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, v []*serviceaccount.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalserviceaccountServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalserviceaccountServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceAccountUpdatedActivityLogEntryData2githubcomnaisapiinternalserviceaccountServiceAccountUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.ServiceAccountUpdatedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceAccountUpdatedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceAccountUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalserviceaccountServiceAccountUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, v []*serviceaccount.ServiceAccountUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServiceAccountUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalserviceaccountServiceAccountUpdatedActivityLogEntryDataUpdatedField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServiceAccountUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalserviceaccountServiceAccountUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.ServiceAccountUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceAccountUpdatedActivityLogEntryDataUpdatedField(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceCostSample2githubcomnaisapiinternalcostServiceCostSample(ctx context.Context, sel ast.SelectionSet, v []*cost.ServiceCostSample) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServiceCostSample2githubcomnaisapiinternalcostServiceCostSample(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServiceCostSample2githubcomnaisapiinternalcostServiceCostSample(ctx context.Context, sel ast.SelectionSet, v *cost.ServiceCostSample) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceCostSample(ctx, sel, v)
}

func (ec *executionContext) marshalNServiceCostSeries2githubcomnaisapiinternalcostServiceCostSeries(ctx context.Context, sel ast.SelectionSet, v []*cost.ServiceCostSeries) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServiceCostSeries2githubcomnaisapiinternalcostServiceCostSeries(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServiceCostSeries2githubcomnaisapiinternalcostServiceCostSeries(ctx context.Context, sel ast.SelectionSet, v *cost.ServiceCostSeries) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServiceCostSeries(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSetTeamMemberRoleInput2githubcomnaisapiinternalteamSetTeamMemberRoleInput(ctx context.Context, v any) (team.SetTeamMemberRoleInput, error) {
	res, err := ec.unmarshalInputSetTeamMemberRoleInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSetTeamMemberRolePayload2githubcomnaisapiinternalteamSetTeamMemberRolePayload(ctx context.Context, sel ast.SelectionSet, v team.SetTeamMemberRolePayload) graphql.Marshaler {
	return ec._SetTeamMemberRolePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetTeamMemberRolePayload2githubcomnaisapiinternalteamSetTeamMemberRolePayload(ctx context.Context, sel ast.SelectionSet, v *team.SetTeamMemberRolePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SetTeamMemberRolePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx context.Context, v any) (slug.Slug, error) {
	var res slug.Slug
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSlug2githubcomnaisapiinternalslugSlug(ctx context.Context, sel ast.SelectionSet, v slug.Slug) graphql.Marshaler {
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) unmarshalNSlug2githubcomnaisapiinternalslugSlug(ctx context.Context, v any) (*slug.Slug, error) {
	var res = new(slug.Slug)
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSlug2githubcomnaisapiinternalslugSlug(ctx context.Context, sel ast.SelectionSet, v *slug.Slug) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) marshalNSqlInstance2githubcomnaisapiinternalpersistencesqlinstanceSQLInstance(ctx context.Context, sel ast.SelectionSet, v sqlinstance.SQLInstance) graphql.Marshaler {
	return ec._SqlInstance(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstance2githubcomnaisapiinternalpersistencesqlinstanceSQLInstance(ctx context.Context, sel ast.SelectionSet, v []*sqlinstance.SQLInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstance2githubcomnaisapiinternalpersistencesqlinstanceSQLInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSqlInstance2githubcomnaisapiinternalpersistencesqlinstanceSQLInstance(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*sqlinstance.SQLInstance]) graphql.Marshaler {
	return ec._SqlInstanceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*sqlinstance.SQLInstance]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceCost2githubcomnaisapiinternalcostSQLInstanceCost(ctx context.Context, sel ast.SelectionSet, v cost.SQLInstanceCost) graphql.Marshaler {
	return ec._SqlInstanceCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceCost2githubcomnaisapiinternalcostSQLInstanceCost(ctx context.Context, sel ast.SelectionSet, v *cost.SQLInstanceCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceCost(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceCpu2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceCPU(ctx context.Context, sel ast.SelectionSet, v sqlinstance.SQLInstanceCPU) graphql.Marshaler {
	return ec._SqlInstanceCpu(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceCpu2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceCPU(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceCPU) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceCpu(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceDisk2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceDisk(ctx context.Context, sel ast.SelectionSet, v sqlinstance.SQLInstanceDisk) graphql.Marshaler {
	return ec._SqlInstanceDisk(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceDisk2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceDisk(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceDisk) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceDisk(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*sqlinstance.SQLInstance]) graphql.Marshaler {
	return ec._SqlInstanceEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*sqlinstance.SQLInstance]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSqlInstanceFlag2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceFlag(ctx context.Context, sel ast.SelectionSet, v []*sqlinstance.SQLInstanceFlag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstanceFlag2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceFlag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSqlInstanceFlag2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceFlag(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceFlag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceFlag(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceFlagConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	return ec._SqlInstanceFlagConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceFlagConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceFlagConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceFlagEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	return ec._SqlInstanceFlagEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceFlagEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*sqlinstance.SQLInstanceFlag]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstanceFlagEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSqlInstanceMemory2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceMemory(ctx context.Context, sel ast.SelectionSet, v sqlinstance.SQLInstanceMemory) graphql.Marshaler {
	return ec._SqlInstanceMemory(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceMemory2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceMemory(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceMemory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceMemory(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceMetrics2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceMetrics(ctx context.Context, sel ast.SelectionSet, v sqlinstance.SQLInstanceMetrics) graphql.Marshaler {
	return ec._SqlInstanceMetrics(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceMetrics2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceMetrics(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceMetrics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceMetrics(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSqlInstanceOrderField2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceOrderField(ctx context.Context, v any) (sqlinstance.SQLInstanceOrderField, error) {
	var res sqlinstance.SQLInstanceOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSqlInstanceOrderField2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceOrderField(ctx context.Context, sel ast.SelectionSet, v sqlinstance.SQLInstanceOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSqlInstanceState2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceState(ctx context.Context, v any) (sqlinstance.SQLInstanceState, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := sqlinstance.SQLInstanceState(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSqlInstanceState2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceState(ctx context.Context, sel ast.SelectionSet, v sqlinstance.SQLInstanceState) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNSqlInstanceStatus2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceStatus(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceUser2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceUser(ctx context.Context, sel ast.SelectionSet, v []*sqlinstance.SQLInstanceUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstanceUser2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSqlInstanceUser2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceUser(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceUser(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceUserConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	return ec._SqlInstanceUserConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceUserConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SqlInstanceUserConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNSqlInstanceUserEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	return ec._SqlInstanceUserEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNSqlInstanceUserEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*sqlinstance.SQLInstanceUser]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSqlInstanceUserEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSqlInstanceUserOrderField2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceUserOrderField(ctx context.Context, v any) (sqlinstance.SQLInstanceUserOrderField, error) {
	var res sqlinstance.SQLInstanceUserOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSqlInstanceUserOrderField2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceUserOrderField(ctx context.Context, sel ast.SelectionSet, v sqlinstance.SQLInstanceUserOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeam2githubcomnaisapiinternalteamTeam(ctx context.Context, sel ast.SelectionSet, v team.Team) graphql.Marshaler {
	return ec._Team(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeam2githubcomnaisapiinternalteamTeam(ctx context.Context, sel ast.SelectionSet, v []*team.Team) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeam2githubcomnaisapiinternalteamTeam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeam2githubcomnaisapiinternalteamTeam(ctx context.Context, sel ast.SelectionSet, v *team.Team) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Team(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*team.Team]) graphql.Marshaler {
	return ec._TeamConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*team.Team]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamCost2githubcomnaisapiinternalcostTeamCost(ctx context.Context, sel ast.SelectionSet, v cost.TeamCost) graphql.Marshaler {
	return ec._TeamCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamCost2githubcomnaisapiinternalcostTeamCost(ctx context.Context, sel ast.SelectionSet, v *cost.TeamCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamCost(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamCostMonthlySample2githubcomnaisapiinternalcostTeamCostMonthlySample(ctx context.Context, sel ast.SelectionSet, v []*cost.TeamCostMonthlySample) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamCostMonthlySample2githubcomnaisapiinternalcostTeamCostMonthlySample(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamCostMonthlySample2githubcomnaisapiinternalcostTeamCostMonthlySample(ctx context.Context, sel ast.SelectionSet, v *cost.TeamCostMonthlySample) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamCostMonthlySample(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamCostMonthlySummary2githubcomnaisapiinternalcostTeamCostMonthlySummary(ctx context.Context, sel ast.SelectionSet, v cost.TeamCostMonthlySummary) graphql.Marshaler {
	return ec._TeamCostMonthlySummary(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamCostMonthlySummary2githubcomnaisapiinternalcostTeamCostMonthlySummary(ctx context.Context, sel ast.SelectionSet, v *cost.TeamCostMonthlySummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamCostMonthlySummary(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamCostPeriod2githubcomnaisapiinternalcostTeamCostPeriod(ctx context.Context, sel ast.SelectionSet, v cost.TeamCostPeriod) graphql.Marshaler {
	return ec._TeamCostPeriod(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamCostPeriod2githubcomnaisapiinternalcostTeamCostPeriod(ctx context.Context, sel ast.SelectionSet, v *cost.TeamCostPeriod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamCostPeriod(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamDeleteKey2githubcomnaisapiinternalteamTeamDeleteKey(ctx context.Context, sel ast.SelectionSet, v team.TeamDeleteKey) graphql.Marshaler {
	return ec._TeamDeleteKey(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamDeleteKey2githubcomnaisapiinternalteamTeamDeleteKey(ctx context.Context, sel ast.SelectionSet, v *team.TeamDeleteKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamDeleteKey(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*team.Team]) graphql.Marshaler {
	return ec._TeamEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*team.Team]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx context.Context, sel ast.SelectionSet, v team.TeamEnvironment) graphql.Marshaler {
	return ec._TeamEnvironment(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx context.Context, sel ast.SelectionSet, v []*team.TeamEnvironment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx context.Context, sel ast.SelectionSet, v *team.TeamEnvironment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamEnvironment(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamEnvironmentCost2githubcomnaisapiinternalcostTeamEnvironmentCost(ctx context.Context, sel ast.SelectionSet, v cost.TeamEnvironmentCost) graphql.Marshaler {
	return ec._TeamEnvironmentCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamEnvironmentCost2githubcomnaisapiinternalcostTeamEnvironmentCost(ctx context.Context, sel ast.SelectionSet, v *cost.TeamEnvironmentCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamEnvironmentCost(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamEnvironmentCostPeriod2githubcomnaisapiinternalcostTeamEnvironmentCostPeriod(ctx context.Context, sel ast.SelectionSet, v cost.TeamEnvironmentCostPeriod) graphql.Marshaler {
	return ec._TeamEnvironmentCostPeriod(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamEnvironmentCostPeriod2githubcomnaisapiinternalcostTeamEnvironmentCostPeriod(ctx context.Context, sel ast.SelectionSet, v *cost.TeamEnvironmentCostPeriod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamEnvironmentCostPeriod(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamEnvironmentUpdatedActivityLogEntryData2githubcomnaisapiinternalteamTeamEnvironmentUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *team.TeamEnvironmentUpdatedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamEnvironmentUpdatedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamEnvironmentUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalteamTeamEnvironmentUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, v []*team.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamEnvironmentUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalteamTeamEnvironmentUpdatedActivityLogEntryDataUpdatedField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamEnvironmentUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalteamTeamEnvironmentUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, v *team.TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamExternalResources2githubcomnaisapiinternalteamTeamExternalResources(ctx context.Context, sel ast.SelectionSet, v *team.TeamExternalResources) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamExternalResources(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamInventoryCountApplications2githubcomnaisapiinternalworkloadapplicationTeamInventoryCountApplications(ctx context.Context, sel ast.SelectionSet, v application.TeamInventoryCountApplications) graphql.Marshaler {
	return ec._TeamInventoryCountApplications(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamInventoryCountApplications2githubcomnaisapiinternalworkloadapplicationTeamInventoryCountApplications(ctx context.Context, sel ast.SelectionSet, v *application.TeamInventoryCountApplications) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamInventoryCountApplications(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamInventoryCountBigQueryDatasets2githubcomnaisapiinternalpersistencebigqueryTeamInventoryCountBigQueryDatasets(ctx context.Context, sel ast.SelectionSet, v bigquery.TeamInventoryCountBigQueryDatasets) graphql.Marshaler {
	return ec._TeamInventoryCountBigQueryDatasets(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamInventoryCountBigQueryDatasets2githubcomnaisapiinternalpersistencebigqueryTeamInventoryCountBigQueryDatasets(ctx context.Context, sel ast.SelectionSet, v *bigquery.TeamInventoryCountBigQueryDatasets) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamInventoryCountBigQueryDatasets(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamInventoryCountBuckets2githubcomnaisapiinternalpersistencebucketTeamInventoryCountBuckets(ctx context.Context, sel ast.SelectionSet, v bucket.TeamInventoryCountBuckets) graphql.Marshaler {
	return ec._TeamInventoryCountBuckets(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamInventoryCountBuckets2githubcomnaisapiinternalpersistencebucketTeamInventoryCountBuckets(ctx context.Context, sel ast.SelectionSet, v *bucket.TeamInventoryCountBuckets) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamInventoryCountBuckets(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamInventoryCountJobs2githubcomnaisapiinternalworkloadjobTeamInventoryCountJobs(ctx context.Context, sel ast.SelectionSet, v job.TeamInventoryCountJobs) graphql.Marshaler {
	return ec._TeamInventoryCountJobs(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamInventoryCountJobs2githubcomnaisapiinternalworkloadjobTeamInventoryCountJobs(ctx context.Context, sel ast.SelectionSet, v *job.TeamInventoryCountJobs) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamInventoryCountJobs(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamInventoryCountKafkaTopics2githubcomnaisapiinternalpersistencekafkatopicTeamInventoryCountKafkaTopics(ctx context.Context, sel ast.SelectionSet, v kafkatopic.TeamInventoryCountKafkaTopics) graphql.Marshaler {
	return ec._TeamInventoryCountKafkaTopics(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamInventoryCountKafkaTopics2githubcomnaisapiinternalpersistencekafkatopicTeamInventoryCountKafkaTopics(ctx context.Context, sel ast.SelectionSet, v *kafkatopic.TeamInventoryCountKafkaTopics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamInventoryCountKafkaTopics(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamInventoryCountOpenSearchInstances2githubcomnaisapiinternalpersistenceopensearchTeamInventoryCountOpenSearchInstances(ctx context.Context, sel ast.SelectionSet, v opensearch.TeamInventoryCountOpenSearchInstances) graphql.Marshaler {
	return ec._TeamInventoryCountOpenSearchInstances(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamInventoryCountOpenSearchInstances2githubcomnaisapiinternalpersistenceopensearchTeamInventoryCountOpenSearchInstances(ctx context.Context, sel ast.SelectionSet, v *opensearch.TeamInventoryCountOpenSearchInstances) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamInventoryCountOpenSearchInstances(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamInventoryCountRedisInstances2githubcomnaisapiinternalpersistenceredisTeamInventoryCountRedisInstances(ctx context.Context, sel ast.SelectionSet, v redis.TeamInventoryCountRedisInstances) graphql.Marshaler {
	return ec._TeamInventoryCountRedisInstances(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamInventoryCountRedisInstances2githubcomnaisapiinternalpersistenceredisTeamInventoryCountRedisInstances(ctx context.Context, sel ast.SelectionSet, v *redis.TeamInventoryCountRedisInstances) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamInventoryCountRedisInstances(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamInventoryCountSqlInstances2githubcomnaisapiinternalpersistencesqlinstanceTeamInventoryCountSQLInstances(ctx context.Context, sel ast.SelectionSet, v sqlinstance.TeamInventoryCountSQLInstances) graphql.Marshaler {
	return ec._TeamInventoryCountSqlInstances(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamInventoryCountSqlInstances2githubcomnaisapiinternalpersistencesqlinstanceTeamInventoryCountSQLInstances(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.TeamInventoryCountSQLInstances) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamInventoryCountSqlInstances(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamInventoryCountValkeyInstances2githubcomnaisapiinternalpersistencevalkeyTeamInventoryCountValkeyInstances(ctx context.Context, sel ast.SelectionSet, v valkey.TeamInventoryCountValkeyInstances) graphql.Marshaler {
	return ec._TeamInventoryCountValkeyInstances(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamInventoryCountValkeyInstances2githubcomnaisapiinternalpersistencevalkeyTeamInventoryCountValkeyInstances(ctx context.Context, sel ast.SelectionSet, v *valkey.TeamInventoryCountValkeyInstances) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamInventoryCountValkeyInstances(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamInventoryCounts2githubcomnaisapiinternalteamTeamInventoryCounts(ctx context.Context, sel ast.SelectionSet, v team.TeamInventoryCounts) graphql.Marshaler {
	return ec._TeamInventoryCounts(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamInventoryCounts2githubcomnaisapiinternalteamTeamInventoryCounts(ctx context.Context, sel ast.SelectionSet, v *team.TeamInventoryCounts) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamInventoryCounts(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamMember2githubcomnaisapiinternalteamTeamMember(ctx context.Context, sel ast.SelectionSet, v team.TeamMember) graphql.Marshaler {
	return ec._TeamMember(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamMember2githubcomnaisapiinternalteamTeamMember(ctx context.Context, sel ast.SelectionSet, v []*team.TeamMember) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamMember2githubcomnaisapiinternalteamTeamMember(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamMember2githubcomnaisapiinternalteamTeamMember(ctx context.Context, sel ast.SelectionSet, v *team.TeamMember) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamMember(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamMemberAddedActivityLogEntryData2githubcomnaisapiinternalteamTeamMemberAddedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *team.TeamMemberAddedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamMemberAddedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamMemberConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*team.TeamMember]) graphql.Marshaler {
	return ec._TeamMemberConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamMemberConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*team.TeamMember]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamMemberConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamMemberEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*team.TeamMember]) graphql.Marshaler {
	return ec._TeamMemberEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamMemberEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*team.TeamMember]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamMemberEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTeamMemberOrderField2githubcomnaisapiinternalteamTeamMemberOrderField(ctx context.Context, v any) (team.TeamMemberOrderField, error) {
	var res team.TeamMemberOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamMemberOrderField2githubcomnaisapiinternalteamTeamMemberOrderField(ctx context.Context, sel ast.SelectionSet, v team.TeamMemberOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTeamMemberRemovedActivityLogEntryData2githubcomnaisapiinternalteamTeamMemberRemovedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *team.TeamMemberRemovedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamMemberRemovedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTeamMemberRole2githubcomnaisapiinternalteamTeamMemberRole(ctx context.Context, v any) (team.TeamMemberRole, error) {
	var res team.TeamMemberRole
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamMemberRole2githubcomnaisapiinternalteamTeamMemberRole(ctx context.Context, sel ast.SelectionSet, v team.TeamMemberRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTeamMemberSetRoleActivityLogEntryData2githubcomnaisapiinternalteamTeamMemberSetRoleActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *team.TeamMemberSetRoleActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamMemberSetRoleActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTeamOrderField2githubcomnaisapiinternalteamTeamOrderField(ctx context.Context, v any) (team.TeamOrderField, error) {
	var res team.TeamOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamOrderField2githubcomnaisapiinternalteamTeamOrderField(ctx context.Context, sel ast.SelectionSet, v team.TeamOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTeamServiceUtilization2githubcomnaisapiinternalutilizationTeamServiceUtilization(ctx context.Context, sel ast.SelectionSet, v utilization.TeamServiceUtilization) graphql.Marshaler {
	return ec._TeamServiceUtilization(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamServiceUtilization2githubcomnaisapiinternalutilizationTeamServiceUtilization(ctx context.Context, sel ast.SelectionSet, v *utilization.TeamServiceUtilization) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamServiceUtilization(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamServiceUtilizationSqlInstances2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstances(ctx context.Context, sel ast.SelectionSet, v sqlinstance.TeamServiceUtilizationSQLInstances) graphql.Marshaler {
	return ec._TeamServiceUtilizationSqlInstances(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamServiceUtilizationSqlInstances2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstances(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.TeamServiceUtilizationSQLInstances) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamServiceUtilizationSqlInstances(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamServiceUtilizationSqlInstancesCPU2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstancesCPU(ctx context.Context, sel ast.SelectionSet, v sqlinstance.TeamServiceUtilizationSQLInstancesCPU) graphql.Marshaler {
	return ec._TeamServiceUtilizationSqlInstancesCPU(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamServiceUtilizationSqlInstancesCPU2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstancesCPU(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.TeamServiceUtilizationSQLInstancesCPU) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamServiceUtilizationSqlInstancesCPU(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamServiceUtilizationSqlInstancesDisk2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstancesDisk(ctx context.Context, sel ast.SelectionSet, v sqlinstance.TeamServiceUtilizationSQLInstancesDisk) graphql.Marshaler {
	return ec._TeamServiceUtilizationSqlInstancesDisk(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamServiceUtilizationSqlInstancesDisk2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstancesDisk(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.TeamServiceUtilizationSQLInstancesDisk) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamServiceUtilizationSqlInstancesDisk(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamServiceUtilizationSqlInstancesMemory2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstancesMemory(ctx context.Context, sel ast.SelectionSet, v sqlinstance.TeamServiceUtilizationSQLInstancesMemory) graphql.Marshaler {
	return ec._TeamServiceUtilizationSqlInstancesMemory(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamServiceUtilizationSqlInstancesMemory2githubcomnaisapiinternalpersistencesqlinstanceTeamServiceUtilizationSQLInstancesMemory(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.TeamServiceUtilizationSQLInstancesMemory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamServiceUtilizationSqlInstancesMemory(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamUpdatedActivityLogEntryData2githubcomnaisapiinternalteamTeamUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *team.TeamUpdatedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamUpdatedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalteamTeamUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, v []*team.TeamUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalteamTeamUpdatedActivityLogEntryDataUpdatedField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamUpdatedActivityLogEntryDataUpdatedField2githubcomnaisapiinternalteamTeamUpdatedActivityLogEntryDataUpdatedField(ctx context.Context, sel ast.SelectionSet, v *team.TeamUpdatedActivityLogEntryDataUpdatedField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamUpdatedActivityLogEntryDataUpdatedField(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamUtilizationData2githubcomnaisapiinternalutilizationTeamUtilizationData(ctx context.Context, sel ast.SelectionSet, v []*utilization.TeamUtilizationData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamUtilizationData2githubcomnaisapiinternalutilizationTeamUtilizationData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamUtilizationData2githubcomnaisapiinternalutilizationTeamUtilizationData(ctx context.Context, sel ast.SelectionSet, v *utilization.TeamUtilizationData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamUtilizationData(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTeamVulnerabilityRanking2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityRanking(ctx context.Context, v any) (vulnerability.TeamVulnerabilityRanking, error) {
	var res vulnerability.TeamVulnerabilityRanking
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamVulnerabilityRanking2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityRanking(ctx context.Context, sel ast.SelectionSet, v vulnerability.TeamVulnerabilityRanking) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTeamVulnerabilityRiskScoreTrend2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityRiskScoreTrend(ctx context.Context, v any) (vulnerability.TeamVulnerabilityRiskScoreTrend, error) {
	var res vulnerability.TeamVulnerabilityRiskScoreTrend
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamVulnerabilityRiskScoreTrend2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityRiskScoreTrend(ctx context.Context, sel ast.SelectionSet, v vulnerability.TeamVulnerabilityRiskScoreTrend) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTeamVulnerabilityState2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityState(ctx context.Context, v any) (vulnerability.TeamVulnerabilityState, error) {
	var res vulnerability.TeamVulnerabilityState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamVulnerabilityState2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityState(ctx context.Context, sel ast.SelectionSet, v vulnerability.TeamVulnerabilityState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTeamVulnerabilityStatus2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityStatus(ctx context.Context, sel ast.SelectionSet, v []*vulnerability.TeamVulnerabilityStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamVulnerabilityStatus2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeamVulnerabilityStatus2githubcomnaisapiinternalvulnerabilityTeamVulnerabilityStatus(ctx context.Context, sel ast.SelectionSet, v *vulnerability.TeamVulnerabilityStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamVulnerabilityStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamVulnerabilitySummary2githubcomnaisapiinternalvulnerabilityTeamVulnerabilitySummary(ctx context.Context, sel ast.SelectionSet, v vulnerability.TeamVulnerabilitySummary) graphql.Marshaler {
	return ec._TeamVulnerabilitySummary(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamVulnerabilitySummary2githubcomnaisapiinternalvulnerabilityTeamVulnerabilitySummary(ctx context.Context, sel ast.SelectionSet, v *vulnerability.TeamVulnerabilitySummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamVulnerabilitySummary(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := scalar.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := scalar.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTriggerJobInput2githubcomnaisapiinternalworkloadjobTriggerJobInput(ctx context.Context, v any) (job.TriggerJobInput, error) {
	res, err := ec.unmarshalInputTriggerJobInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTriggerJobPayload2githubcomnaisapiinternalworkloadjobTriggerJobPayload(ctx context.Context, sel ast.SelectionSet, v job.TriggerJobPayload) graphql.Marshaler {
	return ec._TriggerJobPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNTriggerJobPayload2githubcomnaisapiinternalworkloadjobTriggerJobPayload(ctx context.Context, sel ast.SelectionSet, v *job.TriggerJobPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TriggerJobPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNUnleashInstanceMetrics2githubcomnaisapiinternalunleashUnleashInstanceMetrics(ctx context.Context, sel ast.SelectionSet, v *unleash.UnleashInstanceMetrics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UnleashInstanceMetrics(ctx, sel, v)
}

func (ec *executionContext) marshalNUnleashInstanceUpdatedActivityLogEntryData2githubcomnaisapiinternalunleashUnleashInstanceUpdatedActivityLogEntryData(ctx context.Context, sel ast.SelectionSet, v *unleash.UnleashInstanceUpdatedActivityLogEntryData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UnleashInstanceUpdatedActivityLogEntryData(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateImageVulnerabilityInput2githubcomnaisapiinternalvulnerabilityUpdateImageVulnerabilityInput(ctx context.Context, v any) (vulnerability.UpdateImageVulnerabilityInput, error) {
	res, err := ec.unmarshalInputUpdateImageVulnerabilityInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateImageVulnerabilityPayload2githubcomnaisapiinternalvulnerabilityUpdateImageVulnerabilityPayload(ctx context.Context, sel ast.SelectionSet, v vulnerability.UpdateImageVulnerabilityPayload) graphql.Marshaler {
	return ec._UpdateImageVulnerabilityPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateImageVulnerabilityPayload2githubcomnaisapiinternalvulnerabilityUpdateImageVulnerabilityPayload(ctx context.Context, sel ast.SelectionSet, v *vulnerability.UpdateImageVulnerabilityPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateImageVulnerabilityPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateSecretValueInput2githubcomnaisapiinternalworkloadsecretUpdateSecretValueInput(ctx context.Context, v any) (secret.UpdateSecretValueInput, error) {
	res, err := ec.unmarshalInputUpdateSecretValueInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateSecretValuePayload2githubcomnaisapiinternalworkloadsecretUpdateSecretValuePayload(ctx context.Context, sel ast.SelectionSet, v secret.UpdateSecretValuePayload) graphql.Marshaler {
	return ec._UpdateSecretValuePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateSecretValuePayload2githubcomnaisapiinternalworkloadsecretUpdateSecretValuePayload(ctx context.Context, sel ast.SelectionSet, v *secret.UpdateSecretValuePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateSecretValuePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateServiceAccountInput2githubcomnaisapiinternalserviceaccountUpdateServiceAccountInput(ctx context.Context, v any) (serviceaccount.UpdateServiceAccountInput, error) {
	res, err := ec.unmarshalInputUpdateServiceAccountInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateServiceAccountPayload2githubcomnaisapiinternalserviceaccountUpdateServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, v serviceaccount.UpdateServiceAccountPayload) graphql.Marshaler {
	return ec._UpdateServiceAccountPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateServiceAccountPayload2githubcomnaisapiinternalserviceaccountUpdateServiceAccountPayload(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.UpdateServiceAccountPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateServiceAccountPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateServiceAccountTokenInput2githubcomnaisapiinternalserviceaccountUpdateServiceAccountTokenInput(ctx context.Context, v any) (serviceaccount.UpdateServiceAccountTokenInput, error) {
	res, err := ec.unmarshalInputUpdateServiceAccountTokenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateServiceAccountTokenPayload2githubcomnaisapiinternalserviceaccountUpdateServiceAccountTokenPayload(ctx context.Context, sel ast.SelectionSet, v serviceaccount.UpdateServiceAccountTokenPayload) graphql.Marshaler {
	return ec._UpdateServiceAccountTokenPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateServiceAccountTokenPayload2githubcomnaisapiinternalserviceaccountUpdateServiceAccountTokenPayload(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.UpdateServiceAccountTokenPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateServiceAccountTokenPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateTeamEnvironmentInput2githubcomnaisapiinternalteamUpdateTeamEnvironmentInput(ctx context.Context, v any) (team.UpdateTeamEnvironmentInput, error) {
	res, err := ec.unmarshalInputUpdateTeamEnvironmentInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTeamEnvironmentPayload2githubcomnaisapiinternalteamUpdateTeamEnvironmentPayload(ctx context.Context, sel ast.SelectionSet, v team.UpdateTeamEnvironmentPayload) graphql.Marshaler {
	return ec._UpdateTeamEnvironmentPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTeamEnvironmentPayload2githubcomnaisapiinternalteamUpdateTeamEnvironmentPayload(ctx context.Context, sel ast.SelectionSet, v *team.UpdateTeamEnvironmentPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTeamEnvironmentPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateTeamInput2githubcomnaisapiinternalteamUpdateTeamInput(ctx context.Context, v any) (team.UpdateTeamInput, error) {
	res, err := ec.unmarshalInputUpdateTeamInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTeamPayload2githubcomnaisapiinternalteamUpdateTeamPayload(ctx context.Context, sel ast.SelectionSet, v team.UpdateTeamPayload) graphql.Marshaler {
	return ec._UpdateTeamPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTeamPayload2githubcomnaisapiinternalteamUpdateTeamPayload(ctx context.Context, sel ast.SelectionSet, v *team.UpdateTeamPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTeamPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNUser2githubcomnaisapiinternaluserUser(ctx context.Context, sel ast.SelectionSet, v user.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcomnaisapiinternaluserUser(ctx context.Context, sel ast.SelectionSet, v []*user.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2githubcomnaisapiinternaluserUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2githubcomnaisapiinternaluserUser(ctx context.Context, sel ast.SelectionSet, v *user.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*user.User]) graphql.Marshaler {
	return ec._UserConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*user.User]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNUserEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*user.User]) graphql.Marshaler {
	return ec._UserEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*user.User]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNUserOrderField2githubcomnaisapiinternaluserUserOrderField(ctx context.Context, v any) (user.UserOrderField, error) {
	var res user.UserOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserOrderField2githubcomnaisapiinternaluserUserOrderField(ctx context.Context, sel ast.SelectionSet, v user.UserOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUserSyncLogEntry2githubcomnaisapiinternalusersyncUserSyncLogEntry(ctx context.Context, sel ast.SelectionSet, v usersync.UserSyncLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSyncLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNUserSyncLogEntry2githubcomnaisapiinternalusersyncUserSyncLogEntry(ctx context.Context, sel ast.SelectionSet, v []usersync.UserSyncLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserSyncLogEntry2githubcomnaisapiinternalusersyncUserSyncLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserSyncLogEntryConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[usersync.UserSyncLogEntry]) graphql.Marshaler {
	return ec._UserSyncLogEntryConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserSyncLogEntryConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[usersync.UserSyncLogEntry]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSyncLogEntryConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNUserSyncLogEntryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[usersync.UserSyncLogEntry]) graphql.Marshaler {
	return ec._UserSyncLogEntryEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserSyncLogEntryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[usersync.UserSyncLogEntry]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserSyncLogEntryEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNUserTeamOrderField2githubcomnaisapiinternalteamUserTeamOrderField(ctx context.Context, v any) (team.UserTeamOrderField, error) {
	var res team.UserTeamOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserTeamOrderField2githubcomnaisapiinternalteamUserTeamOrderField(ctx context.Context, sel ast.SelectionSet, v team.UserTeamOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUtilizationResourceType2githubcomnaisapiinternalutilizationUtilizationResourceType(ctx context.Context, v any) (utilization.UtilizationResourceType, error) {
	var res utilization.UtilizationResourceType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUtilizationResourceType2githubcomnaisapiinternalutilizationUtilizationResourceType(ctx context.Context, sel ast.SelectionSet, v utilization.UtilizationResourceType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUtilizationSample2githubcomnaisapiinternalutilizationUtilizationSample(ctx context.Context, sel ast.SelectionSet, v []*utilization.UtilizationSample) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUtilizationSample2githubcomnaisapiinternalutilizationUtilizationSample(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUtilizationSample2githubcomnaisapiinternalutilizationUtilizationSample(ctx context.Context, sel ast.SelectionSet, v *utilization.UtilizationSample) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UtilizationSample(ctx, sel, v)
}

func (ec *executionContext) marshalNValkeyInstance2githubcomnaisapiinternalpersistencevalkeyValkeyInstance(ctx context.Context, sel ast.SelectionSet, v valkey.ValkeyInstance) graphql.Marshaler {
	return ec._ValkeyInstance(ctx, sel, &v)
}

func (ec *executionContext) marshalNValkeyInstance2githubcomnaisapiinternalpersistencevalkeyValkeyInstance(ctx context.Context, sel ast.SelectionSet, v []*valkey.ValkeyInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValkeyInstance2githubcomnaisapiinternalpersistencevalkeyValkeyInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNValkeyInstance2githubcomnaisapiinternalpersistencevalkeyValkeyInstance(ctx context.Context, sel ast.SelectionSet, v *valkey.ValkeyInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValkeyInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNValkeyInstanceAccess2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceAccess(ctx context.Context, sel ast.SelectionSet, v []*valkey.ValkeyInstanceAccess) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValkeyInstanceAccess2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNValkeyInstanceAccess2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceAccess(ctx context.Context, sel ast.SelectionSet, v *valkey.ValkeyInstanceAccess) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValkeyInstanceAccess(ctx, sel, v)
}

func (ec *executionContext) marshalNValkeyInstanceAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*valkey.ValkeyInstanceAccess]) graphql.Marshaler {
	return ec._ValkeyInstanceAccessConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNValkeyInstanceAccessConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*valkey.ValkeyInstanceAccess]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValkeyInstanceAccessConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNValkeyInstanceAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*valkey.ValkeyInstanceAccess]) graphql.Marshaler {
	return ec._ValkeyInstanceAccessEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNValkeyInstanceAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*valkey.ValkeyInstanceAccess]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValkeyInstanceAccessEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNValkeyInstanceAccessOrderField2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceAccessOrderField(ctx context.Context, v any) (valkey.ValkeyInstanceAccessOrderField, error) {
	var res valkey.ValkeyInstanceAccessOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNValkeyInstanceAccessOrderField2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceAccessOrderField(ctx context.Context, sel ast.SelectionSet, v valkey.ValkeyInstanceAccessOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNValkeyInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[*valkey.ValkeyInstance]) graphql.Marshaler {
	return ec._ValkeyInstanceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNValkeyInstanceConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[*valkey.ValkeyInstance]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValkeyInstanceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNValkeyInstanceCost2githubcomnaisapiinternalcostValkeyInstanceCost(ctx context.Context, sel ast.SelectionSet, v cost.ValkeyInstanceCost) graphql.Marshaler {
	return ec._ValkeyInstanceCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNValkeyInstanceCost2githubcomnaisapiinternalcostValkeyInstanceCost(ctx context.Context, sel ast.SelectionSet, v *cost.ValkeyInstanceCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValkeyInstanceCost(ctx, sel, v)
}

func (ec *executionContext) marshalNValkeyInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[*valkey.ValkeyInstance]) graphql.Marshaler {
	return ec._ValkeyInstanceEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNValkeyInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[*valkey.ValkeyInstance]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValkeyInstanceEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNValkeyInstanceOrderField2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceOrderField(ctx context.Context, v any) (valkey.ValkeyInstanceOrderField, error) {
	var res valkey.ValkeyInstanceOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNValkeyInstanceOrderField2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceOrderField(ctx context.Context, sel ast.SelectionSet, v valkey.ValkeyInstanceOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNValkeyInstanceStatus2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceStatus(ctx context.Context, sel ast.SelectionSet, v *valkey.ValkeyInstanceStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValkeyInstanceStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkload2githubcomnaisapiinternalworkloadWorkload(ctx context.Context, sel ast.SelectionSet, v workload.Workload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Workload(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkload2githubcomnaisapiinternalworkloadWorkload(ctx context.Context, sel ast.SelectionSet, v []workload.Workload) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkload2githubcomnaisapiinternalworkloadWorkload(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorkloadConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v pagination.Connection[workload.Workload]) graphql.Marshaler {
	return ec._WorkloadConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadConnection2githubcomnaisapiinternalgraphpaginationConnection(ctx context.Context, sel ast.SelectionSet, v *pagination.Connection[workload.Workload]) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadCost2githubcomnaisapiinternalcostWorkloadCost(ctx context.Context, sel ast.SelectionSet, v cost.WorkloadCost) graphql.Marshaler {
	return ec._WorkloadCost(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadCost2githubcomnaisapiinternalcostWorkloadCost(ctx context.Context, sel ast.SelectionSet, v *cost.WorkloadCost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadCost(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadCostPeriod2githubcomnaisapiinternalcostWorkloadCostPeriod(ctx context.Context, sel ast.SelectionSet, v cost.WorkloadCostPeriod) graphql.Marshaler {
	return ec._WorkloadCostPeriod(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadCostPeriod2githubcomnaisapiinternalcostWorkloadCostPeriod(ctx context.Context, sel ast.SelectionSet, v *cost.WorkloadCostPeriod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadCostPeriod(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadCostSample2githubcomnaisapiinternalcostWorkloadCostSample(ctx context.Context, sel ast.SelectionSet, v []*cost.WorkloadCostSample) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkloadCostSample2githubcomnaisapiinternalcostWorkloadCostSample(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorkloadCostSample2githubcomnaisapiinternalcostWorkloadCostSample(ctx context.Context, sel ast.SelectionSet, v *cost.WorkloadCostSample) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadCostSample(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadCostSeries2githubcomnaisapiinternalcostWorkloadCostSeries(ctx context.Context, sel ast.SelectionSet, v []*cost.WorkloadCostSeries) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkloadCostSeries2githubcomnaisapiinternalcostWorkloadCostSeries(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorkloadCostSeries2githubcomnaisapiinternalcostWorkloadCostSeries(ctx context.Context, sel ast.SelectionSet, v *cost.WorkloadCostSeries) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadCostSeries(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v pagination.Edge[workload.Workload]) graphql.Marshaler {
	return ec._WorkloadEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx context.Context, sel ast.SelectionSet, v []pagination.Edge[workload.Workload]) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkloadEdge2githubcomnaisapiinternalgraphpaginationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorkloadLogLine2githubcomnaisapiinternalworkloadpodlogWorkloadLogLine(ctx context.Context, sel ast.SelectionSet, v podlog.WorkloadLogLine) graphql.Marshaler {
	return ec._WorkloadLogLine(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadLogLine2githubcomnaisapiinternalworkloadpodlogWorkloadLogLine(ctx context.Context, sel ast.SelectionSet, v *podlog.WorkloadLogLine) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadLogLine(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWorkloadLogSubscriptionFilter2githubcomnaisapiinternalworkloadpodlogWorkloadLogSubscriptionFilter(ctx context.Context, v any) (podlog.WorkloadLogSubscriptionFilter, error) {
	res, err := ec.unmarshalInputWorkloadLogSubscriptionFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWorkloadOrderField2githubcomnaisapiinternalworkloadWorkloadOrderField(ctx context.Context, v any) (workload.WorkloadOrderField, error) {
	var res workload.WorkloadOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorkloadOrderField2githubcomnaisapiinternalworkloadWorkloadOrderField(ctx context.Context, sel ast.SelectionSet, v workload.WorkloadOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWorkloadResourceQuantity2githubcomnaisapiinternalworkloadWorkloadResourceQuantity(ctx context.Context, sel ast.SelectionSet, v *workload.WorkloadResourceQuantity) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadResourceQuantity(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWorkloadState2githubcomnaisapiinternalstatusWorkloadState(ctx context.Context, v any) (status.WorkloadState, error) {
	var res status.WorkloadState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorkloadState2githubcomnaisapiinternalstatusWorkloadState(ctx context.Context, sel ast.SelectionSet, v status.WorkloadState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWorkloadStatus2githubcomnaisapiinternalstatusWorkloadStatus(ctx context.Context, sel ast.SelectionSet, v status.WorkloadStatus) graphql.Marshaler {
	return ec._WorkloadStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadStatus2githubcomnaisapiinternalstatusWorkloadStatus(ctx context.Context, sel ast.SelectionSet, v *status.WorkloadStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadStatusError2githubcomnaisapiinternalstatusWorkloadStatusError(ctx context.Context, sel ast.SelectionSet, v status.WorkloadStatusError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadStatusError(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadStatusError2githubcomnaisapiinternalstatusWorkloadStatusError(ctx context.Context, sel ast.SelectionSet, v []status.WorkloadStatusError) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkloadStatusError2githubcomnaisapiinternalstatusWorkloadStatusError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx context.Context, v any) (status.WorkloadStatusErrorLevel, error) {
	var res status.WorkloadStatusErrorLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorkloadStatusErrorLevel2githubcomnaisapiinternalstatusWorkloadStatusErrorLevel(ctx context.Context, sel ast.SelectionSet, v status.WorkloadStatusErrorLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWorkloadUtilization2githubcomnaisapiinternalutilizationWorkloadUtilization(ctx context.Context, sel ast.SelectionSet, v utilization.WorkloadUtilization) graphql.Marshaler {
	return ec._WorkloadUtilization(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkloadUtilization2githubcomnaisapiinternalutilizationWorkloadUtilization(ctx context.Context, sel ast.SelectionSet, v *utilization.WorkloadUtilization) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkloadUtilization(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkloadUtilizationData2githubcomnaisapiinternalutilizationWorkloadUtilizationData(ctx context.Context, sel ast.SelectionSet, v []*utilization.WorkloadUtilizationData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkloadUtilizationData2githubcomnaisapiinternalutilizationWorkloadUtilizationData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNWorkloadUtilizationSeriesInput2githubcomnaisapiinternalutilizationWorkloadUtilizationSeriesInput(ctx context.Context, v any) (utilization.WorkloadUtilizationSeriesInput, error) {
	res, err := ec.unmarshalInputWorkloadUtilizationSeriesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOApplication2githubcomnaisapiinternalworkloadapplicationApplication(ctx context.Context, sel ast.SelectionSet, v *application.Application) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) unmarshalOApplicationOrder2githubcomnaisapiinternalworkloadapplicationApplicationOrder(ctx context.Context, v any) (*application.ApplicationOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputApplicationOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBigQueryDatasetAccessOrder2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetAccessOrder(ctx context.Context, v any) (*bigquery.BigQueryDatasetAccessOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBigQueryDatasetAccessOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBigQueryDatasetOrder2githubcomnaisapiinternalpersistencebigqueryBigQueryDatasetOrder(ctx context.Context, v any) (*bigquery.BigQueryDatasetOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBigQueryDatasetOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOBucketOrder2githubcomnaisapiinternalpersistencebucketBucketOrder(ctx context.Context, v any) (*bucket.BucketOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBucketOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx context.Context, v any) (*pagination.Cursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(pagination.Cursor)
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2githubcomnaisapiinternalgraphpaginationCursor(ctx context.Context, sel ast.SelectionSet, v *pagination.Cursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) unmarshalODate2githubcomnaisapiinternalgraphscalarDate(ctx context.Context, v any) (*scalar.Date, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(scalar.Date)
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2githubcomnaisapiinternalgraphscalarDate(ctx context.Context, sel ast.SelectionSet, v *scalar.Date) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) marshalODeploymentKey2githubcomnaisapiinternaldeploymentDeploymentKey(ctx context.Context, sel ast.SelectionSet, v *deployment.DeploymentKey) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeploymentKey(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEnvironmentOrder2githubcomnaisapiinternalenvironmentEnvironmentOrder(ctx context.Context, v any) (*environment.EnvironmentOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEnvironmentOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEnvironmentWorkloadOrder2githubcomnaisapiinternalworkloadEnvironmentWorkloadOrder(ctx context.Context, v any) (*workload.EnvironmentWorkloadOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEnvironmentWorkloadOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOImageVulnerability2githubcomnaisapiinternalvulnerabilityImageVulnerability(ctx context.Context, sel ast.SelectionSet, v *vulnerability.ImageVulnerability) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImageVulnerability(ctx, sel, v)
}

func (ec *executionContext) unmarshalOImageVulnerabilityOrder2githubcomnaisapiinternalvulnerabilityImageVulnerabilityOrder(ctx context.Context, v any) (*vulnerability.ImageVulnerabilityOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputImageVulnerabilityOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOImageVulnerabilitySummary2githubcomnaisapiinternalvulnerabilityImageVulnerabilitySummary(ctx context.Context, sel ast.SelectionSet, v *vulnerability.ImageVulnerabilitySummary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImageVulnerabilitySummary(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v any) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOJob2githubcomnaisapiinternalworkloadjobJob(ctx context.Context, sel ast.SelectionSet, v *job.Job) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Job(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJobOrder2githubcomnaisapiinternalworkloadjobJobOrder(ctx context.Context, v any) (*job.JobOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJobOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJobRun2githubcomnaisapiinternalworkloadjobJobRun(ctx context.Context, sel ast.SelectionSet, v *job.JobRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JobRun(ctx, sel, v)
}

func (ec *executionContext) marshalOJobSchedule2githubcomnaisapiinternalworkloadjobJobSchedule(ctx context.Context, sel ast.SelectionSet, v *job.JobSchedule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JobSchedule(ctx, sel, v)
}

func (ec *executionContext) unmarshalOKafkaTopicAclFilter2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACLFilter(ctx context.Context, v any) (*kafkatopic.KafkaTopicACLFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputKafkaTopicAclFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOKafkaTopicAclOrder2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicACLOrder(ctx context.Context, v any) (*kafkatopic.KafkaTopicACLOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputKafkaTopicAclOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOKafkaTopicConfiguration2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicConfiguration(ctx context.Context, sel ast.SelectionSet, v *kafkatopic.KafkaTopicConfiguration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KafkaTopicConfiguration(ctx, sel, v)
}

func (ec *executionContext) unmarshalOKafkaTopicOrder2githubcomnaisapiinternalpersistencekafkatopicKafkaTopicOrder(ctx context.Context, v any) (*kafkatopic.KafkaTopicOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputKafkaTopicOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2githubcomnaisapiinternalgraphmodelNode(ctx context.Context, sel ast.SelectionSet, v model.Node) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOOpenSearch2githubcomnaisapiinternalpersistenceopensearchOpenSearch(ctx context.Context, sel ast.SelectionSet, v *opensearch.OpenSearch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OpenSearch(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOpenSearchAccessOrder2githubcomnaisapiinternalpersistenceopensearchOpenSearchAccessOrder(ctx context.Context, v any) (*opensearch.OpenSearchAccessOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOpenSearchAccessOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOOpenSearchOrder2githubcomnaisapiinternalpersistenceopensearchOpenSearchOrder(ctx context.Context, v any) (*opensearch.OpenSearchOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOpenSearchOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORedisInstanceAccessOrder2githubcomnaisapiinternalpersistenceredisRedisInstanceAccessOrder(ctx context.Context, v any) (*redis.RedisInstanceAccessOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRedisInstanceAccessOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORedisInstanceOrder2githubcomnaisapiinternalpersistenceredisRedisInstanceOrder(ctx context.Context, v any) (*redis.RedisInstanceOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRedisInstanceOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepository2githubcomnaisapiinternalgithubrepositoryRepository(ctx context.Context, sel ast.SelectionSet, v *repository.Repository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) unmarshalORepositoryOrder2githubcomnaisapiinternalgithubrepositoryRepositoryOrder(ctx context.Context, v any) (*repository.RepositoryOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRepositoryOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchType2githubcomnaisapiinternalsearchSearchType(ctx context.Context, v any) (*search.SearchType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(search.SearchType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSearchType2githubcomnaisapiinternalsearchSearchType(ctx context.Context, sel ast.SelectionSet, v *search.SearchType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSecret2githubcomnaisapiinternalworkloadsecretSecret(ctx context.Context, sel ast.SelectionSet, v *secret.Secret) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Secret(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSecretFilter2githubcomnaisapiinternalworkloadsecretSecretFilter(ctx context.Context, v any) (*secret.SecretFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSecretFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSecretOrder2githubcomnaisapiinternalworkloadsecretSecretOrder(ctx context.Context, v any) (*secret.SecretOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSecretOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOServiceAccount2githubcomnaisapiinternalserviceaccountServiceAccount(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.ServiceAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ServiceAccount(ctx, sel, v)
}

func (ec *executionContext) marshalOServiceAccountToken2githubcomnaisapiinternalserviceaccountServiceAccountToken(ctx context.Context, sel ast.SelectionSet, v *serviceaccount.ServiceAccountToken) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ServiceAccountToken(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSlug2githubcomnaisapiinternalslugSlug(ctx context.Context, v any) (*slug.Slug, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(slug.Slug)
	err := res.UnmarshalGQLContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSlug2githubcomnaisapiinternalslugSlug(ctx context.Context, sel ast.SelectionSet, v *slug.Slug) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.WrapContextMarshaler(ctx, v)
}

func (ec *executionContext) marshalOSqlDatabase2githubcomnaisapiinternalpersistencesqlinstanceSQLDatabase(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLDatabase) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SqlDatabase(ctx, sel, v)
}

func (ec *executionContext) marshalOSqlInstanceBackupConfiguration2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceBackupConfiguration(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceBackupConfiguration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SqlInstanceBackupConfiguration(ctx, sel, v)
}

func (ec *executionContext) marshalOSqlInstanceMaintenanceWindow2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceMaintenanceWindow(ctx context.Context, sel ast.SelectionSet, v *sqlinstance.SQLInstanceMaintenanceWindow) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SqlInstanceMaintenanceWindow(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSqlInstanceOrder2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceOrder(ctx context.Context, v any) (*sqlinstance.SQLInstanceOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSqlInstanceOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSqlInstanceUserOrder2githubcomnaisapiinternalpersistencesqlinstanceSQLInstanceUserOrder(ctx context.Context, v any) (*sqlinstance.SQLInstanceUserOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSqlInstanceUserOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTeam2githubcomnaisapiinternalteamTeam(ctx context.Context, sel ast.SelectionSet, v *team.Team) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Team(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTeamApplicationsFilter2githubcomnaisapiinternalworkloadapplicationTeamApplicationsFilter(ctx context.Context, v any) (*application.TeamApplicationsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamApplicationsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTeamCDN2githubcomnaisapiinternalteamTeamCDN(ctx context.Context, sel ast.SelectionSet, v *team.TeamCDN) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamCDN(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTeamCostDailyFilter2githubcomnaisapiinternalcostTeamCostDailyFilter(ctx context.Context, v any) (*cost.TeamCostDailyFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamCostDailyFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTeamDeleteKey2githubcomnaisapiinternalteamTeamDeleteKey(ctx context.Context, sel ast.SelectionSet, v *team.TeamDeleteKey) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamDeleteKey(ctx, sel, v)
}

func (ec *executionContext) marshalOTeamEntraIDGroup2githubcomnaisapiinternalteamTeamEntraIDGroup(ctx context.Context, sel ast.SelectionSet, v *team.TeamEntraIDGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamEntraIDGroup(ctx, sel, v)
}

func (ec *executionContext) marshalOTeamEnvironment2githubcomnaisapiinternalteamTeamEnvironment(ctx context.Context, sel ast.SelectionSet, v *team.TeamEnvironment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamEnvironment(ctx, sel, v)
}

func (ec *executionContext) marshalOTeamGitHubTeam2githubcomnaisapiinternalteamTeamGitHubTeam(ctx context.Context, sel ast.SelectionSet, v *team.TeamGitHubTeam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamGitHubTeam(ctx, sel, v)
}

func (ec *executionContext) marshalOTeamGoogleArtifactRegistry2githubcomnaisapiinternalteamTeamGoogleArtifactRegistry(ctx context.Context, sel ast.SelectionSet, v *team.TeamGoogleArtifactRegistry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamGoogleArtifactRegistry(ctx, sel, v)
}

func (ec *executionContext) marshalOTeamGoogleGroup2githubcomnaisapiinternalteamTeamGoogleGroup(ctx context.Context, sel ast.SelectionSet, v *team.TeamGoogleGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamGoogleGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTeamJobsFilter2githubcomnaisapiinternalworkloadjobTeamJobsFilter(ctx context.Context, v any) (*job.TeamJobsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamJobsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTeamMember2githubcomnaisapiinternalteamTeamMember(ctx context.Context, sel ast.SelectionSet, v *team.TeamMember) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamMember(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTeamMemberOrder2githubcomnaisapiinternalteamTeamMemberOrder(ctx context.Context, v any) (*team.TeamMemberOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamMemberOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTeamOrder2githubcomnaisapiinternalteamTeamOrder(ctx context.Context, v any) (*team.TeamOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTeamRepositoryFilter2githubcomnaisapiinternalgithubrepositoryTeamRepositoryFilter(ctx context.Context, v any) (*repository.TeamRepositoryFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamRepositoryFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTeamVulnerabilitySummaryFilter2githubcomnaisapiinternalvulnerabilityTeamVulnerabilitySummaryFilter(ctx context.Context, v any) (*vulnerability.TeamVulnerabilitySummaryFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamVulnerabilitySummaryFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTeamWorkloadsFilter2githubcomnaisapiinternalworkloadTeamWorkloadsFilter(ctx context.Context, v any) (*workload.TeamWorkloadsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamWorkloadsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := scalar.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := scalar.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOUnleashInstance2githubcomnaisapiinternalunleashUnleashInstance(ctx context.Context, sel ast.SelectionSet, v *unleash.UnleashInstance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UnleashInstance(ctx, sel, v)
}

func (ec *executionContext) marshalOUser2githubcomnaisapiinternaluserUser(ctx context.Context, sel ast.SelectionSet, v *user.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserOrder2githubcomnaisapiinternaluserUserOrder(ctx context.Context, v any) (*user.UserOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserTeamOrder2githubcomnaisapiinternalteamUserTeamOrder(ctx context.Context, v any) (*team.UserTeamOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserTeamOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOValkeyInstanceAccessOrder2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceAccessOrder(ctx context.Context, v any) (*valkey.ValkeyInstanceAccessOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputValkeyInstanceAccessOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOValkeyInstanceOrder2githubcomnaisapiinternalpersistencevalkeyValkeyInstanceOrder(ctx context.Context, v any) (*valkey.ValkeyInstanceOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputValkeyInstanceOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWorkload2githubcomnaisapiinternalworkloadWorkload(ctx context.Context, sel ast.SelectionSet, v workload.Workload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Workload(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorkloadOrder2githubcomnaisapiinternalworkloadWorkloadOrder(ctx context.Context, v any) (*workload.WorkloadOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWorkloadOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWorkloadUtilizationData2githubcomnaisapiinternalutilizationWorkloadUtilizationData(ctx context.Context, sel ast.SelectionSet, v *utilization.WorkloadUtilizationData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkloadUtilizationData(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************

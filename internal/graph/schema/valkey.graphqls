extend type Team {
	"Valkey instances owned by the team."
	valkeys(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: ValkeyOrder
	): ValkeyConnection!
}

extend type TeamEnvironment {
	"Valkey instance in the team environment."
	valkey(name: String!): Valkey!
}

extend interface Workload {
	"Valkey instances referenced by the workload. This does not currently support pagination, but will return all available Valkey instances."
	valkeys(
		"Ordering options for items returned from the connection."
		orderBy: ValkeyOrder
	): ValkeyConnection!
}

extend type Application {
	"Valkey instances referenced by the application. This does not currently support pagination, but will return all available Valkey instances."
	valkeys(
		"Ordering options for items returned from the connection."
		orderBy: ValkeyOrder
	): ValkeyConnection!
}

extend type Job {
	"Valkey instances referenced by the job. This does not currently support pagination, but will return all available Valkey instances."
	valkeys(
		"Ordering options for items returned from the connection."
		orderBy: ValkeyOrder
	): ValkeyConnection!
}

extend type TeamInventoryCounts {
	valkeys: TeamInventoryCountValkeys!
}

type TeamInventoryCountValkeys {
	"Total number of Valkey instances."
	total: Int!
}

type Valkey implements Persistence & Node {
	id: ID!
	name: String!
	terminationProtection: Boolean!
	team: Team!
	environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")
	teamEnvironment: TeamEnvironment!
	access(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		orderBy: ValkeyAccessOrder
	): ValkeyAccessConnection!
	workload: Workload
		@deprecated(reason: "Owners of valkeys have been removed, so this will always be null.")
	state: ValkeyState!
	"Availability tier for the Valkey instance."
	tier: ValkeyTier!
	"Available memory for the Valkey instance."
	memory: ValkeyMemory!
	maxMemoryPolicy: ValkeyMaxMemoryPolicy
	"Issues that affects the instance."
	issues(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: IssueOrder

		"Filtering options for items returned from the connection."
		filter: ResourceIssueFilter
	): IssueConnection!
}

enum ValkeyState {
	POWEROFF
	REBALANCING
	REBUILDING
	RUNNING
	UNKNOWN
}

type ValkeyAccess {
	workload: Workload!
	access: String!
}

type ValkeyAccessConnection {
	pageInfo: PageInfo!
	nodes: [ValkeyAccess!]!
	edges: [ValkeyAccessEdge!]!
}

type ValkeyConnection {
	pageInfo: PageInfo!
	nodes: [Valkey!]!
	edges: [ValkeyEdge!]!
}

type ValkeyAccessEdge {
	cursor: Cursor!
	node: ValkeyAccess!
}

type ValkeyEdge {
	cursor: Cursor!
	node: Valkey!
}

input ValkeyAccessOrder {
	field: ValkeyAccessOrderField!
	direction: OrderDirection!
}

input ValkeyOrder {
	field: ValkeyOrderField!
	direction: OrderDirection!
}

enum ValkeyAccessOrderField {
	ACCESS
	WORKLOAD
}

enum ValkeyOrderField {
	NAME
	ENVIRONMENT
	STATE
}

extend union SearchNode = Valkey

extend enum SearchType {
	VALKEY
}

enum ValkeyTier {
	SINGLE_NODE
	HIGH_AVAILABILITY
}

enum ValkeyMemory {
	GB_1
	GB_4
	GB_8
	GB_14
	GB_28
	GB_56
	GB_112
	GB_200
}

enum ValkeyMaxMemoryPolicy {
	"Keeps frequently used keys; removes least frequently used (LFU) keys"
	ALLKEYS_LFU

	"Keeps most recently used keys; removes least recently used (LRU) keys"
	ALLKEYS_LRU

	"Randomly removes keys to make space for the new data added."
	ALLKEYS_RANDOM

	"New values aren't saved when memory limit is reached. When a database uses replication, this applies to the primary database."
	NO_EVICTION

	"Removes least frequently used keys with a TTL set."
	VOLATILE_LFU

	"Removes least recently used keys with a time-to-live (TTL) set."
	VOLATILE_LRU

	"Randomly removes keys with a TTL set."
	VOLATILE_RANDOM

	"Removes keys with a TTL set, the keys with the shortest remaining time-to-live value first."
	VOLATILE_TTL
}

input CreateValkeyInput {
	"Name of the Valkey instance."
	name: String!
	"The environment name that the entry belongs to."
	environmentName: String!
	"The team that owns the Valkey instance."
	teamSlug: Slug!
	"Tier of the Valkey instance."
	tier: ValkeyTier!
	"Available memory for the Valkey instance."
	memory: ValkeyMemory!
	"Maximum memory policy for the Valkey instance."
	maxMemoryPolicy: ValkeyMaxMemoryPolicy
}

type CreateValkeyPayload {
	"Valkey instance that was created."
	valkey: Valkey!
}

input UpdateValkeyInput {
	"Name of the Valkey instance."
	name: String!
	"The environment name that the entry belongs to."
	environmentName: String!
	"The team that owns the Valkey instance."
	teamSlug: Slug!
	"Tier of the Valkey instance."
	tier: ValkeyTier!
	"Available memory for the Valkey instance."
	memory: ValkeyMemory!
	"Maximum memory policy for the Valkey instance."
	maxMemoryPolicy: ValkeyMaxMemoryPolicy
}

type UpdateValkeyPayload {
	"Valkey instance that was updated."
	valkey: Valkey!
}

input DeleteValkeyInput {
	"Name of the Valkey instance."
	name: String!
	"The environment name that the entry belongs to."
	environmentName: String!
	"The team that owns the Valkey instance."
	teamSlug: Slug!
}

type DeleteValkeyPayload {
	"Whether or not the job was deleted."
	valkeyDeleted: Boolean
}

extend type Mutation {
	"Create a new Valkey instance."
	createValkey(input: CreateValkeyInput!): CreateValkeyPayload!
	"Update an existing Valkey instance."
	updateValkey(input: UpdateValkeyInput!): UpdateValkeyPayload!
	"Delete an existing Valkey instance."
	deleteValkey(input: DeleteValkeyInput!): DeleteValkeyPayload!
}

extend enum ActivityLogEntryResourceType {
	"All activity log entries related to Valkeys will use this resource type."
	VALKEY
}

extend enum ActivityLogActivityType {
	"Valkey was created."
	VALKEY_CREATED
	"Valkey was updated."
	VALKEY_UPDATED
	"Valkey was deleted."
	VALKEY_DELETED
	"Started service maintenance on Valkey instance."
	VALKEY_MAINTENANCE_STARTED
}

type ValkeyCreatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type ValkeyUpdatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"""
	Data associated with the entry.
	"""
	data: ValkeyUpdatedActivityLogEntryData!
}

type ValkeyUpdatedActivityLogEntryDataUpdatedField {
	"""
	The name of the field.
	"""
	field: String!

	"""
	The old value of the field.
	"""
	oldValue: String

	"""
	The new value of the field.
	"""
	newValue: String
}

type ValkeyUpdatedActivityLogEntryData {
	updatedFields: [ValkeyUpdatedActivityLogEntryDataUpdatedField!]!
}

type ValkeyDeletedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

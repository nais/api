extend type Team {
	"OpenSearch instances owned by the team."
	openSearches(
		"Get the first n items in the connection. This can be used in combination with the after parameter."
		first: Int

		"Get items after this cursor."
		after: Cursor

		"Get the last n items in the connection. This can be used in combination with the before parameter."
		last: Int

		"Get items before this cursor."
		before: Cursor

		"Ordering options for items returned from the connection."
		orderBy: OpenSearchOrder
	): OpenSearchConnection!
}

extend type TeamEnvironment {
	"OpenSearch instance in the team environment."
	openSearch(name: String!): OpenSearch!
}

extend interface Workload {
	"OpenSearch instance referenced by the workload."
	openSearch: OpenSearch
}

extend type Application {
	"OpenSearch instance referenced by the workload."
	openSearch: OpenSearch
}

extend type Job {
	"OpenSearch instance referenced by the workload."
	openSearch: OpenSearch
}

extend type TeamInventoryCounts {
	openSearches: TeamInventoryCountOpenSearches!
}

type TeamInventoryCountOpenSearches {
	"Total number of OpenSearch instances."
	total: Int!
}

type OpenSearchVersion {
	"The full version string of the OpenSearch instance. This will be available after the instance is created."
	actual: String
	"The desired major version of the OpenSearch instance."
	desiredMajor: OpenSearchMajorVersion!
}

type OpenSearch implements Persistence & Node {
	id: ID!
	name: String!
	team: Team!
	environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")
	teamEnvironment: TeamEnvironment!
	terminationProtection: Boolean!
	state: OpenSearchState!
	status: OpenSearchStatus!
	workload: Workload
	access(
		first: Int
		after: Cursor
		last: Int
		before: Cursor
		orderBy: OpenSearchAccessOrder
	): OpenSearchAccessConnection!
	"Fetch version for the OpenSearch instance."
	version: OpenSearchVersion!
	"Availability tier for the OpenSearch instance."
	tier: OpenSearchTier!
	"Available memory for the OpenSearch instance."
	memory: OpenSearchMemory!
	"Available storage in GB."
	storageGB: Int!
}

enum OpenSearchState {
	POWEROFF
	REBALANCING
	REBUILDING
	RUNNING
	UNKNOWN
}

type OpenSearchAccess {
	workload: Workload!
	access: String!
}

type OpenSearchStatus {
	state: String!
}

type OpenSearchAccessConnection {
	pageInfo: PageInfo!
	nodes: [OpenSearchAccess!]!
	edges: [OpenSearchAccessEdge!]!
}

type OpenSearchConnection {
	pageInfo: PageInfo!
	nodes: [OpenSearch!]!
	edges: [OpenSearchEdge!]!
}

type OpenSearchAccessEdge {
	cursor: Cursor!
	node: OpenSearchAccess!
}

type OpenSearchEdge {
	cursor: Cursor!
	node: OpenSearch!
}

input OpenSearchAccessOrder {
	field: OpenSearchAccessOrderField!
	direction: OrderDirection!
}

input OpenSearchOrder {
	field: OpenSearchOrderField!
	direction: OrderDirection!
}

enum OpenSearchAccessOrderField {
	ACCESS
	WORKLOAD
	STATE
}

enum OpenSearchOrderField {
	NAME
	ENVIRONMENT
}

extend union SearchNode = OpenSearch

extend enum SearchType {
	OPENSEARCH
}

enum OpenSearchTier {
	SINGLE_NODE
	HIGH_AVAILABILITY
}

enum OpenSearchMemory {
	GB_2
	GB_4
	GB_8
	GB_16
	GB_32
	GB_64
}

enum OpenSearchMajorVersion {
	"OpenSearch Version 2.x"
	V2
	"OpenSearch Version 1.x"
	V1
}

input CreateOpenSearchInput {
	"Name of the OpenSearch instance."
	name: String!
	"The environment name that the OpenSearch instance belongs to."
	environmentName: String!
	"The team that owns the OpenSearch instance."
	teamSlug: Slug!
	"Tier of the OpenSearch instance."
	tier: OpenSearchTier!
	"Available memory for the OpenSearch instance."
	memory: OpenSearchMemory!
	"Major version of the OpenSearch instance."
	version: OpenSearchMajorVersion!
	"Available storage in GB."
	storageGB: Int!
}

type CreateOpenSearchPayload {
	"OpenSearch instance that was created."
	openSearch: OpenSearch!
}

input UpdateOpenSearchInput {
	"Name of the OpenSearch instance."
	name: String!
	"The environment name that the OpenSearch instance belongs to."
	environmentName: String!
	"The team that owns the OpenSearch instance."
	teamSlug: Slug!
	"Tier of the OpenSearch instance."
	tier: OpenSearchTier!
	"Available memory for the OpenSearch instance."
	memory: OpenSearchMemory!
	"Major version of the OpenSearch instance."
	version: OpenSearchMajorVersion!
	"Available storage in GB."
	storageGB: Int!
}

type UpdateOpenSearchPayload {
	"OpenSearch instance that was updated."
	openSearch: OpenSearch!
}

input DeleteOpenSearchInput {
	"Name of the OpenSearch instance."
	name: String!
	"The environment name that the OpenSearch instance belongs to."
	environmentName: String!
	"The team that owns the OpenSearch instance."
	teamSlug: Slug!
}

type DeleteOpenSearchPayload {
	"Whether or not the OpenSearch instance was deleted."
	openSearchDeleted: Boolean
}

extend type Mutation {
	"Create a new OpenSearch instance."
	createOpenSearch(input: CreateOpenSearchInput!): CreateOpenSearchPayload!
	"Update an existing OpenSearch instance."
	updateOpenSearch(input: UpdateOpenSearchInput!): UpdateOpenSearchPayload!
	"Delete an existing OpenSearch instance."
	deleteOpenSearch(input: DeleteOpenSearchInput!): DeleteOpenSearchPayload!
}

extend enum ActivityLogEntryResourceType {
	"All activity log entries related to OpenSearches will use this resource type."
	OPENSEARCH
}

extend enum ActivityLogActivityType {
	"OpenSearch was created."
	OPENSEARCH_CREATED
	"OpenSearch was updated."
	OPENSEARCH_UPDATED
	"OpenSearch was deleted."
	OPENSEARCH_DELETED
	"Started service maintenance on OpenSearch instance."
	OPENSEARCH_MAINTENANCE_STARTED
}

type OpenSearchCreatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

type OpenSearchUpdatedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String

	"""
	Data associated with the entry.
	"""
	data: OpenSearchUpdatedActivityLogEntryData!
}

type OpenSearchUpdatedActivityLogEntryDataUpdatedField {
	"""
	The name of the field.
	"""
	field: String!

	"""
	The old value of the field.
	"""
	oldValue: String

	"""
	The new value of the field.
	"""
	newValue: String
}

type OpenSearchUpdatedActivityLogEntryData {
	updatedFields: [OpenSearchUpdatedActivityLogEntryDataUpdatedField!]!
}

type OpenSearchDeletedActivityLogEntry implements ActivityLogEntry & Node {
	"ID of the entry."
	id: ID!

	"The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user."
	actor: String!

	"Creation time of the entry."
	createdAt: Time!

	"Message that summarizes the entry."
	message: String!

	"Type of the resource that was affected by the action."
	resourceType: ActivityLogEntryResourceType!

	"Name of the resource that was affected by the action."
	resourceName: String!

	"The team slug that the entry belongs to."
	teamSlug: Slug!

	"The environment name that the entry belongs to."
	environmentName: String
}

package graph

import (
	"context"
	"fmt"

	"github.com/nais/api/internal/auth/authz"
	"github.com/nais/api/internal/environmentmapper"
	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/team"
	"github.com/nais/api/internal/vulnerability"
	"github.com/nais/api/internal/workload"
	"github.com/nais/api/internal/workload/application"
	"github.com/nais/api/internal/workload/job"
)

func (r *applicationResolver) ImageVulnerabilityHistory(ctx context.Context, obj *application.Application, from scalar.Date) (*vulnerability.ImageVulnerabilityHistory, error) {
	return vulnerability.GetWorkloadVulnerabilityHistoryForWorkload(ctx, obj, from.Time())
}

func (r *containerImageResolver) HasSbom(ctx context.Context, obj *workload.ContainerImage) (bool, error) {
	return vulnerability.GetImageHasSBOM(ctx, obj.Ref())
}

func (r *containerImageResolver) Vulnerabilities(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, filter *vulnerability.ImageVulnerabilityFilter, orderBy *vulnerability.ImageVulnerabilityOrder) (*pagination.Connection[*vulnerability.ImageVulnerability], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListImageVulnerabilities(ctx, obj.Ref(), filter, page, orderBy)
}

func (r *containerImageResolver) VulnerabilitySummary(ctx context.Context, obj *workload.ContainerImage) (*vulnerability.ImageVulnerabilitySummary, error) {
	return vulnerability.GetImageVulnerabilitySummary(ctx, obj.Ref())
}

func (r *containerImageResolver) WorkloadReferences(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ContainerImageWorkloadReference], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListWorkloadReferences(ctx, obj.Ref(), page)
}

func (r *containerImageWorkloadReferenceResolver) Workload(ctx context.Context, obj *vulnerability.ContainerImageWorkloadReference) (workload.Workload, error) {
	return getWorkload(ctx, obj.Reference, obj.TeamSlug, environmentmapper.EnvironmentName(obj.EnvironmentName))
}

func (r *jobResolver) ImageVulnerabilityHistory(ctx context.Context, obj *job.Job, from scalar.Date) (*vulnerability.ImageVulnerabilityHistory, error) {
	return vulnerability.GetWorkloadVulnerabilityHistoryForWorkload(ctx, obj, from.Time())
}

func (r *mutationResolver) UpdateImageVulnerability(ctx context.Context, input vulnerability.UpdateImageVulnerabilityInput) (*vulnerability.UpdateImageVulnerabilityPayload, error) {
	vulnWorkloads, err := vulnerability.ListWorkloadsForVulnerabilityByID(ctx, input.VulnerabilityID.ID)
	if err != nil {
		return nil, err
	}

	var canUpdate bool
	for _, wl := range vulnWorkloads {
		err = authz.CanUpdateVulnerability(ctx, slug.Slug(wl.Team))
		if err == nil {
			canUpdate = true
			break
		}
	}
	if !canUpdate {
		return nil, err
	}

	return vulnerability.UpdateImageVulnerability(ctx, input)
}

func (r *queryResolver) ImageVulnerabilityHistory(ctx context.Context, from scalar.Date) (*vulnerability.ImageVulnerabilityHistory, error) {
	return vulnerability.GetWorkloadVulnerabilityHistoryForTenant(ctx, from.Time())
}

func (r *queryResolver) VulnerabilitySummary(ctx context.Context) (*vulnerability.TenantVulnerabilitySummary, error) {
	return vulnerability.GetTenantVulnerabilitySummary(ctx)
}

func (r *teamResolver) ImageVulnerabilityHistory(ctx context.Context, obj *team.Team, from scalar.Date) (*vulnerability.ImageVulnerabilityHistory, error) {
	return vulnerability.GetWorkloadVulnerabilityHistoryForTeam(ctx, obj.Slug, from.Time())
}

func (r *teamResolver) VulnerabilitySummary(ctx context.Context, obj *team.Team, filter *vulnerability.TeamVulnerabilitySummaryFilter) (*vulnerability.TeamVulnerabilitySummary, error) {
	return vulnerability.GetVulnerabilitySummary(ctx, obj.Slug, filter)
}

func (r *teamResolver) VulnerabilitySummaries(ctx context.Context, obj *team.Team, filter *vulnerability.TeamVulnerabilitySummaryFilter, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *vulnerability.VulnerabilitySummaryOrder) (*pagination.Connection[*vulnerability.WorkloadVulnerabilitySummary], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListVulnerabilitySummaries(ctx, obj.Slug, filter, page, orderBy)
}

func (r *teamVulnerabilitySummaryResolver) RiskScoreTrend(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRiskScoreTrend, error) {
	return vulnerability.GetTeamRiskScoreTrend(ctx, obj.TeamSlug)
}

func (r *vulnerabilityUpdatedActivityLogEntryResolver) Data(ctx context.Context, obj *vulnerability.VulnerabilityUpdatedActivityLogEntry) (*vulnerability.VulnerabilityActivityLogEntryData, error) {
	panic(fmt.Errorf("not implemented: Data - data"))
}

func (r *workloadVulnerabilitySummaryResolver) Workload(ctx context.Context, obj *vulnerability.WorkloadVulnerabilitySummary) (workload.Workload, error) {
	return getWorkload(ctx, obj.WorkloadReference, obj.TeamSlug, obj.EnvironmentName)
}

func (r *Resolver) ContainerImageWorkloadReference() gengql.ContainerImageWorkloadReferenceResolver {
	return &containerImageWorkloadReferenceResolver{r}
}

func (r *Resolver) TeamVulnerabilitySummary() gengql.TeamVulnerabilitySummaryResolver {
	return &teamVulnerabilitySummaryResolver{r}
}

func (r *Resolver) VulnerabilityUpdatedActivityLogEntry() gengql.VulnerabilityUpdatedActivityLogEntryResolver {
	return &vulnerabilityUpdatedActivityLogEntryResolver{r}
}

func (r *Resolver) WorkloadVulnerabilitySummary() gengql.WorkloadVulnerabilitySummaryResolver {
	return &workloadVulnerabilitySummaryResolver{r}
}

type (
	containerImageWorkloadReferenceResolver      struct{ *Resolver }
	teamVulnerabilitySummaryResolver             struct{ *Resolver }
	vulnerabilityUpdatedActivityLogEntryResolver struct{ *Resolver }
	workloadVulnerabilitySummaryResolver         struct{ *Resolver }
)

package graph

import (
	"context"
	"github.com/nais/v13s/pkg/api/vulnerabilities"

	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/team"
	"github.com/nais/api/internal/vulnerability"
	"github.com/nais/api/internal/workload"
)

func (r *containerImageResolver) HasSbom(ctx context.Context, obj *workload.ContainerImage) (bool, error) {
	metadata, err := vulnerability.GetImageMetadata(ctx, obj.Ref())
	if err != nil {
		return false, err
	}
	return metadata.HasSBOM, nil
}

func (r *containerImageResolver) Vulnerabilities(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *vulnerability.ImageVulnerabilityOrder) (*pagination.Connection[*vulnerability.ImageVulnerability], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListImageVulnerabilities(ctx, obj.Ref(), page, orderBy)
}

func (r *containerImageResolver) VulnerabilitySummary(ctx context.Context, obj *workload.ContainerImage) (*vulnerability.ImageVulnerabilitySummary, error) {
	metadata, err := vulnerability.GetImageMetadata(ctx, obj.Ref())
	if err != nil {
		return nil, err
	}

	return metadata.Summary, nil
}

func (r *containerImageResolver) WorkloadReferences(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ContainerImageWorkloadReference], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListWorkloadReferences(ctx, obj.Ref(), page)
}

func (r *containerImageWorkloadReferenceResolver) Workload(ctx context.Context, obj *vulnerability.ContainerImageWorkloadReference) (workload.Workload, error) {
	return getWorkload(ctx, obj.Reference, obj.TeamSlug, r.mappedEnvironmentName(obj.EnvironmentName))
}

func (r *imageVulnerabilityResolver) AnalysisTrail(ctx context.Context, obj *vulnerability.ImageVulnerability) (*vulnerability.ImageVulnerabilityAnalysisTrail, error) {
	return vulnerability.GetImageAnalysisTrail(ctx, obj)
}

func (r *imageVulnerabilityAnalysisTrailResolver) Comments(ctx context.Context, obj *vulnerability.ImageVulnerabilityAnalysisTrail, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	ret := pagination.Slice(obj.AllComments, page)
	return pagination.NewConnection(ret, page, len(obj.AllComments)), nil
}

func (r *mutationResolver) UpdateImageVulnerability(ctx context.Context, input vulnerability.UpdateImageVulnerabilityInput) (*vulnerability.UpdateImageVulnerabilityPayload, error) {
	// TODO(thokra): If we want to make this only availiable for members of teams
	// that uses this image, we need to check if the user is a member of one of the
	// teams that uses this image.

	return vulnerability.UpdateImageVulnerability(ctx, input)
}

func (r *teamResolver) VulnerabilitySummary(ctx context.Context, obj *team.Team, filter *vulnerability.TeamVulnerabilitySummaryFilter) (*vulnerability.TeamVulnerabilitySummary, error) {

	opts := make([]vulnerabilities.Option, 0)
	opts = append(opts, vulnerabilities.NamespaceFilter(obj.Slug.String()))
	if filter != nil {
		for _, env := range filter.Environments {
			// TODO: the api does not support filtering by multiple environments
			opts = append(opts, vulnerabilities.ClusterFilter(env))
		}
	}

	retVal := &vulnerability.TeamVulnerabilitySummary{
		TeamSlug: obj.Slug,
	}

	resp, err := vulnerability.GetVulnerabilitySummary(ctx, opts...)
	if err != nil {
		return nil, err
	}
	retVal.Critical = int(resp.GetVulnerabilitySummary().Critical)
	retVal.High = int(resp.GetVulnerabilitySummary().High)
	retVal.Medium = int(resp.GetVulnerabilitySummary().Medium)
	retVal.Low = int(resp.GetVulnerabilitySummary().Low)
	retVal.Unassigned = int(resp.GetVulnerabilitySummary().Unassigned)
	retVal.RiskScore = int(resp.GetVulnerabilitySummary().RiskScore)
	// TODO: bomCount must be returned from the API

	/*
		if len(apps) == 0 && len(jobs) == 0 {
			retVal.Coverage = 0.0
		} else {
			retVal.Coverage = float64(retVal.BomCount) / float64(len(apps)+len(jobs)) * 100
		}*/

	return retVal, nil
}

func (r *teamVulnerabilitySummaryResolver) Ranking(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRanking, error) {
	return vulnerability.GetTeamRanking(ctx, obj.TeamSlug)
}

func (r *teamVulnerabilitySummaryResolver) RiskScoreTrend(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRiskScoreTrend, error) {
	return vulnerability.GetTeamRiskScoreTrend(ctx, obj.TeamSlug)
}

func (r *teamVulnerabilitySummaryResolver) Status(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) ([]*vulnerability.TeamVulnerabilityStatus, error) {
	return vulnerability.GetTeamVulnerabilityStatus(ctx, obj.TeamSlug)
}

func (r *Resolver) ContainerImageWorkloadReference() gengql.ContainerImageWorkloadReferenceResolver {
	return &containerImageWorkloadReferenceResolver{r}
}

func (r *Resolver) ImageVulnerability() gengql.ImageVulnerabilityResolver {
	return &imageVulnerabilityResolver{r}
}

func (r *Resolver) ImageVulnerabilityAnalysisTrail() gengql.ImageVulnerabilityAnalysisTrailResolver {
	return &imageVulnerabilityAnalysisTrailResolver{r}
}

func (r *Resolver) TeamVulnerabilitySummary() gengql.TeamVulnerabilitySummaryResolver {
	return &teamVulnerabilitySummaryResolver{r}
}

type (
	containerImageWorkloadReferenceResolver struct{ *Resolver }
	imageVulnerabilityResolver              struct{ *Resolver }
	imageVulnerabilityAnalysisTrailResolver struct{ *Resolver }
	teamVulnerabilitySummaryResolver        struct{ *Resolver }
)

package graph

import (
	"context"
	"fmt"

	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/team"
	"github.com/nais/api/internal/vulnerability"
	"github.com/nais/api/internal/workload"
	"github.com/nais/api/internal/workload/application"
	"github.com/nais/api/internal/workload/job"
)

func (r *containerImageResolver) HasSbom(ctx context.Context, obj *workload.ContainerImage) (bool, error) {
	metadata, err := vulnerability.GetImageMetadata(ctx, obj.Ref())
	if err != nil {
		return false, err
	}
	return metadata.HasSBOM, nil
}

func (r *containerImageResolver) Vulnerabilities(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *vulnerability.ImageVulnerabilityOrder) (*pagination.Connection[*vulnerability.ImageVulnerability], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListImageVulnerabilities(ctx, obj.Ref(), page, orderBy)
}

func (r *containerImageResolver) VulnerabilitySummary(ctx context.Context, obj *workload.ContainerImage) (*vulnerability.ImageVulnerabilitySummary, error) {
	metadata, err := vulnerability.GetImageMetadata(ctx, obj.Ref())
	if err != nil {
		return nil, err
	}

	return metadata.Summary, nil
}

func (r *containerImageResolver) WorkloadReferences(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ContainerImageWorkloadReference], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListWorkloadReferences(ctx, obj.Ref(), page)
}

func (r *containerImageWorkloadReferenceResolver) Workload(ctx context.Context, obj *vulnerability.ContainerImageWorkloadReference) (workload.Workload, error) {
	panic(fmt.Errorf("not implemented: Workload - workload"))
}

func (r *imageVulnerabilityResolver) AnalysisTrail(ctx context.Context, obj *vulnerability.ImageVulnerability) (*vulnerability.ImageVulnerabilityAnalysisTrail, error) {
	panic(fmt.Errorf("not implemented: AnalysisTrail - analysisTrail"))
}

func (r *imageVulnerabilityAnalysisTrailResolver) Comments(ctx context.Context, obj *vulnerability.ImageVulnerabilityAnalysisTrail, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment], error) {
	panic(fmt.Errorf("not implemented: Comments - comments"))
}

func (r *mutationResolver) UpdateImageVulnerability(ctx context.Context, input vulnerability.UpdateImageVulnerabilityInput) (*vulnerability.UpdateImageVulnerabilityPayload, error) {
	// TODO(thokra): If we want to make this only availiable for members of teams
	// that uses this image, we need to check if the user is a member of one of the
	// teams that uses this image.

	return vulnerability.UpdateImageVulnerability(ctx, input)
}

func (r *teamResolver) VulnerabilitySummary(ctx context.Context, obj *team.Team, filter *vulnerability.TeamVulnerabilitySummaryFilter) (*vulnerability.TeamVulnerabilitySummary, error) {
	var apps []*application.Application
	var jobs []*job.Job

	if filter != nil {
		for _, env := range filter.Environments {
			apps = append(apps, application.ListAllForTeamInEnvironment(ctx, obj.Slug, env)...)
			jobs = append(jobs, job.ListAllForTeamInEnvironment(ctx, obj.Slug, env)...)
		}
	} else {
		apps = application.ListAllForTeam(ctx, obj.Slug)
		jobs = job.ListAllForTeam(ctx, obj.Slug)
	}

	retVal := &vulnerability.TeamVulnerabilitySummary{
		TeamSlug: obj.Slug,
	}

	var images []*vulnerability.ImageDetails

	for _, app := range apps {
		image, err := vulnerability.GetImageMetadata(ctx, app.Image().Ref())
		if err != nil {
			return nil, fmt.Errorf("getting metadata for image %q: %w", app.Name, err)
		}
		images = append(images, image)
	}

	for _, job := range jobs {
		image, err := vulnerability.GetImageMetadata(ctx, job.Image().Ref())
		if err != nil {
			return nil, fmt.Errorf("getting metadata for image %q: %w", job.Name, err)
		}
		images = append(images, image)
	}

	for _, image := range images {
		if image.Summary == nil {
			continue
		}
		if image.Summary.Critical > 0 {
			retVal.Critical += image.Summary.Critical
		}
		if image.Summary.High > 0 {
			retVal.High += image.Summary.High
		}
		if image.Summary.Medium > 0 {
			retVal.Medium += image.Summary.Medium
		}
		if image.Summary.Low > 0 {
			retVal.Low += image.Summary.Low
		}
		if image.Summary.Unassigned > 0 {
			retVal.Unassigned += image.Summary.Unassigned
		}
		if image.Summary.RiskScore > 0 {
			retVal.RiskScore += image.Summary.RiskScore
		}
		if image.HasSBOM {
			retVal.BomCount++
		}
	}

	if len(apps) == 0 && len(jobs) == 0 {
		retVal.Coverage = 0.0
	} else {
		retVal.Coverage = float64(retVal.BomCount) / float64(len(apps)+len(jobs)) * 100
	}

	return retVal, nil
}

func (r *teamVulnerabilitySummaryResolver) Ranking(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRanking, error) {
	panic(fmt.Errorf("not implemented: Ranking - ranking"))
}

func (r *teamVulnerabilitySummaryResolver) RiskScoreTrend(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRiskScoreTrend, error) {
	panic(fmt.Errorf("not implemented: RiskScoreTrend - riskScoreTrend"))
}

func (r *teamVulnerabilitySummaryResolver) Status(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) ([]*vulnerability.TeamVulnerabilityStatus, error) {
	panic(fmt.Errorf("not implemented: Status - status"))
}

func (r *Resolver) ContainerImageWorkloadReference() gengql.ContainerImageWorkloadReferenceResolver {
	return &containerImageWorkloadReferenceResolver{r}
}

func (r *Resolver) ImageVulnerability() gengql.ImageVulnerabilityResolver {
	return &imageVulnerabilityResolver{r}
}

func (r *Resolver) ImageVulnerabilityAnalysisTrail() gengql.ImageVulnerabilityAnalysisTrailResolver {
	return &imageVulnerabilityAnalysisTrailResolver{r}
}

func (r *Resolver) TeamVulnerabilitySummary() gengql.TeamVulnerabilitySummaryResolver {
	return &teamVulnerabilitySummaryResolver{r}
}

type (
	containerImageWorkloadReferenceResolver struct{ *Resolver }
	imageVulnerabilityResolver              struct{ *Resolver }
	imageVulnerabilityAnalysisTrailResolver struct{ *Resolver }
	teamVulnerabilitySummaryResolver        struct{ *Resolver }
)

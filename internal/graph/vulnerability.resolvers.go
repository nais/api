package graph

import (
	"context"

	"github.com/nais/api/internal/environmentmapper"
	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/team"
	"github.com/nais/api/internal/vulnerability"
	"github.com/nais/api/internal/workload"
	"github.com/nais/api/internal/workload/application"
	"github.com/nais/api/internal/workload/job"
)

func (r *applicationResolver) ImageVulnerabilityHistory(ctx context.Context, obj *application.Application, from scalar.Date) (*vulnerability.ImageVulnerabilityHistory, error) {
	return vulnerability.GetWorkloadVulnerabilityHistoryForWorkload(ctx, obj, from.Time())
}

func (r *containerImageResolver) HasSbom(ctx context.Context, obj *workload.ContainerImage) (bool, error) {
	metadata, err := vulnerability.GetImageMetadata(ctx, obj.Ref())
	if err != nil {
		return false, err
	}
	return metadata.HasSBOM, nil
}

func (r *containerImageResolver) Vulnerabilities(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *vulnerability.ImageVulnerabilityOrder) (*pagination.Connection[*vulnerability.ImageVulnerability], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListImageVulnerabilities(ctx, obj.Ref(), page, orderBy)
}

func (r *containerImageResolver) VulnerabilitySummary(ctx context.Context, obj *workload.ContainerImage) (*vulnerability.ImageVulnerabilitySummary, error) {
	return vulnerability.GetImageVulnerabilitySummary(ctx, obj.Ref())
}

func (r *containerImageResolver) WorkloadReferences(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ContainerImageWorkloadReference], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListWorkloadReferences(ctx, obj.Ref(), page)
}

func (r *containerImageWorkloadReferenceResolver) Workload(ctx context.Context, obj *vulnerability.ContainerImageWorkloadReference) (workload.Workload, error) {
	return getWorkload(ctx, obj.Reference, obj.TeamSlug, environmentmapper.EnvironmentName(obj.EnvironmentName))
}

func (r *imageVulnerabilityAnalysisTrailResolver) Comments(ctx context.Context, obj *vulnerability.ImageVulnerabilityAnalysisTrail, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	ret := pagination.Slice(obj.AllComments, page)
	return pagination.NewConnection(ret, page, len(obj.AllComments)), nil
}

func (r *jobResolver) ImageVulnerabilityHistory(ctx context.Context, obj *job.Job, from scalar.Date) (*vulnerability.ImageVulnerabilityHistory, error) {
	return vulnerability.GetWorkloadVulnerabilityHistoryForWorkload(ctx, obj, from.Time())
}

func (r *mutationResolver) UpdateImageVulnerability(ctx context.Context, input vulnerability.UpdateImageVulnerabilityInput) (*vulnerability.UpdateImageVulnerabilityPayload, error) {
	// TODO(thokra): If we want to make this only availiable for members of teams
	// that uses this image, we need to check if the user is a member of one of the
	// teams that uses this image.

	return vulnerability.UpdateImageVulnerability(ctx, input)
}

func (r *queryResolver) ImageVulnerabilityHistory(ctx context.Context, from scalar.Date) (*vulnerability.ImageVulnerabilityHistory, error) {
	return vulnerability.GetWorkloadVulnerabilityHistoryForTenant(ctx, from.Time())
}

func (r *teamResolver) ImageVulnerabilityHistory(ctx context.Context, obj *team.Team, from scalar.Date) (*vulnerability.ImageVulnerabilityHistory, error) {
	return vulnerability.GetWorkloadVulnerabilityHistoryForTeam(ctx, obj.Slug, from.Time())
}

func (r *teamResolver) VulnerabilitySummary(ctx context.Context, obj *team.Team, filter *vulnerability.TeamVulnerabilitySummaryFilter) (*vulnerability.TeamVulnerabilitySummary, error) {
	return vulnerability.GetVulnerabilitySummary(ctx, obj.Slug, filter)
}

func (r *teamResolver) VulnerabilitySummaries(ctx context.Context, obj *team.Team, filter *vulnerability.TeamVulnerabilitySummaryFilter, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *vulnerability.VulnerabilitySummaryOrder) (*pagination.Connection[*vulnerability.WorkloadVulnerabilitySummary], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListVulnerabilitySummaries(ctx, obj.Slug, filter, page, orderBy)
}

// TODO: not implemented in v13s api
func (r *teamVulnerabilitySummaryResolver) Ranking(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRanking, error) {
	return vulnerability.GetTeamRanking(ctx, obj.TeamSlug)
}

// TODO: not implemented in v13s api
func (r *teamVulnerabilitySummaryResolver) RiskScoreTrend(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRiskScoreTrend, error) {
	return vulnerability.GetTeamRiskScoreTrend(ctx, obj.TeamSlug)
}

// TODO: it doesn't seem to be in use from console frontend
func (r *teamVulnerabilitySummaryResolver) Status(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) ([]*vulnerability.TeamVulnerabilityStatus, error) {
	return vulnerability.GetTeamVulnerabilityStatus(ctx, obj.TeamSlug)
}

func (r *workloadVulnerabilitySummaryResolver) Workload(ctx context.Context, obj *vulnerability.WorkloadVulnerabilitySummary) (workload.Workload, error) {
	return getWorkload(ctx, obj.WorkloadReference, obj.TeamSlug, obj.EnvironmentName)
}

func (r *Resolver) ContainerImageWorkloadReference() gengql.ContainerImageWorkloadReferenceResolver {
	return &containerImageWorkloadReferenceResolver{r}
}

func (r *Resolver) ImageVulnerabilityAnalysisTrail() gengql.ImageVulnerabilityAnalysisTrailResolver {
	return &imageVulnerabilityAnalysisTrailResolver{r}
}

func (r *Resolver) TeamVulnerabilitySummary() gengql.TeamVulnerabilitySummaryResolver {
	return &teamVulnerabilitySummaryResolver{r}
}

func (r *Resolver) WorkloadVulnerabilitySummary() gengql.WorkloadVulnerabilitySummaryResolver {
	return &workloadVulnerabilitySummaryResolver{r}
}

type (
	containerImageWorkloadReferenceResolver struct{ *Resolver }
	imageVulnerabilityAnalysisTrailResolver struct{ *Resolver }
	teamVulnerabilitySummaryResolver        struct{ *Resolver }
	workloadVulnerabilitySummaryResolver    struct{ *Resolver }
)

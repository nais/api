package graph

import (
	"context"

	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/team"
	"github.com/nais/api/internal/vulnerability"
	"github.com/nais/api/internal/workload"
	"github.com/nais/api/internal/workload/application"
	"github.com/nais/api/internal/workload/job"
	"github.com/sourcegraph/conc/pool"
)

func (r *containerImageResolver) HasSbom(ctx context.Context, obj *workload.ContainerImage) (bool, error) {
	metadata, err := vulnerability.GetImageMetadata(ctx, obj.Ref())
	if err != nil {
		return false, err
	}
	return metadata.HasSBOM, nil
}

func (r *containerImageResolver) Vulnerabilities(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor, orderBy *vulnerability.ImageVulnerabilityOrder) (*pagination.Connection[*vulnerability.ImageVulnerability], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListImageVulnerabilities(ctx, obj.Ref(), page, orderBy)
}

func (r *containerImageResolver) VulnerabilitySummary(ctx context.Context, obj *workload.ContainerImage) (*vulnerability.ImageVulnerabilitySummary, error) {
	metadata, err := vulnerability.GetImageMetadata(ctx, obj.Ref())
	if err != nil {
		return nil, err
	}

	return metadata.Summary, nil
}

func (r *containerImageResolver) WorkloadReferences(ctx context.Context, obj *workload.ContainerImage, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ContainerImageWorkloadReference], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	return vulnerability.ListWorkloadReferences(ctx, obj.Ref(), page)
}

func (r *containerImageWorkloadReferenceResolver) Workload(ctx context.Context, obj *vulnerability.ContainerImageWorkloadReference) (workload.Workload, error) {
	return getWorkload(ctx, obj.Reference, obj.TeamSlug, r.mappedEnvironmentName(obj.EnvironmentName))
}

func (r *imageVulnerabilityResolver) AnalysisTrail(ctx context.Context, obj *vulnerability.ImageVulnerability) (*vulnerability.ImageVulnerabilityAnalysisTrail, error) {
	return vulnerability.GetImageAnalysisTrail(ctx, obj)
}

func (r *imageVulnerabilityAnalysisTrailResolver) Comments(ctx context.Context, obj *vulnerability.ImageVulnerabilityAnalysisTrail, first *int, after *pagination.Cursor, last *int, before *pagination.Cursor) (*pagination.Connection[*vulnerability.ImageVulnerabilityAnalysisComment], error) {
	page, err := pagination.ParsePage(first, after, last, before)
	if err != nil {
		return nil, err
	}

	ret := pagination.Slice(obj.AllComments, page)
	return pagination.NewConnection(ret, page, len(obj.AllComments)), nil
}

func (r *mutationResolver) UpdateImageVulnerability(ctx context.Context, input vulnerability.UpdateImageVulnerabilityInput) (*vulnerability.UpdateImageVulnerabilityPayload, error) {
	// TODO(thokra): If we want to make this only availiable for members of teams
	// that uses this image, we need to check if the user is a member of one of the
	// teams that uses this image.

	return vulnerability.UpdateImageVulnerability(ctx, input)
}

func (r *teamResolver) VulnerabilitySummary(ctx context.Context, obj *team.Team, filter *vulnerability.TeamVulnerabilitySummaryFilter) (*vulnerability.TeamVulnerabilitySummary, error) {
	var apps []*application.Application
	var jobs []*job.Job

	if filter != nil {
		for _, env := range filter.Environments {
			apps = append(apps, application.ListAllForTeamInEnvironment(ctx, obj.Slug, env)...)
			jobs = append(jobs, job.ListAllForTeamInEnvironment(ctx, obj.Slug, env)...)
		}
	} else {
		apps = application.ListAllForTeam(ctx, obj.Slug)
		jobs = job.ListAllForTeam(ctx, obj.Slug)
	}

	retVal := &vulnerability.TeamVulnerabilitySummary{
		TeamSlug: obj.Slug,
	}

	wg := pool.NewWithResults[*vulnerability.ImageDetails]().WithContext(ctx).WithMaxGoroutines(15)
	fetchImage := func(wl workload.Workload) func(ctx context.Context) (*vulnerability.ImageDetails, error) {
		return func(ctx context.Context) (*vulnerability.ImageDetails, error) {
			return vulnerability.GetImageMetadata(ctx, wl.Image().Ref())
		}
	}
	for _, app := range apps {
		wg.Go(fetchImage(app))
	}

	for _, job := range jobs {
		wg.Go(fetchImage(job))
	}

	images, err := wg.Wait()
	if err != nil {
		return nil, err
	}

	for _, image := range images {
		if image.Summary == nil {
			continue
		}
		if image.Summary.Critical > 0 {
			retVal.Critical += image.Summary.Critical
		}
		if image.Summary.High > 0 {
			retVal.High += image.Summary.High
		}
		if image.Summary.Medium > 0 {
			retVal.Medium += image.Summary.Medium
		}
		if image.Summary.Low > 0 {
			retVal.Low += image.Summary.Low
		}
		if image.Summary.Unassigned > 0 {
			retVal.Unassigned += image.Summary.Unassigned
		}
		if image.Summary.RiskScore > 0 {
			retVal.RiskScore += image.Summary.RiskScore
		}
		if image.HasSBOM {
			retVal.BomCount++
		}
	}

	if len(apps) == 0 && len(jobs) == 0 {
		retVal.Coverage = 0.0
	} else {
		retVal.Coverage = float64(retVal.BomCount) / float64(len(apps)+len(jobs)) * 100
	}

	return retVal, nil
}

func (r *teamVulnerabilitySummaryResolver) Ranking(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRanking, error) {
	return vulnerability.GetTeamRanking(ctx, obj.TeamSlug)
}

func (r *teamVulnerabilitySummaryResolver) RiskScoreTrend(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) (vulnerability.TeamVulnerabilityRiskScoreTrend, error) {
	return vulnerability.GetTeamRiskScoreTrend(ctx, obj.TeamSlug)
}

func (r *teamVulnerabilitySummaryResolver) Status(ctx context.Context, obj *vulnerability.TeamVulnerabilitySummary) ([]*vulnerability.TeamVulnerabilityStatus, error) {
	return vulnerability.GetTeamVulnerabilityStatus(ctx, obj.TeamSlug)
}

func (r *Resolver) ContainerImageWorkloadReference() gengql.ContainerImageWorkloadReferenceResolver {
	return &containerImageWorkloadReferenceResolver{r}
}

func (r *Resolver) ImageVulnerability() gengql.ImageVulnerabilityResolver {
	return &imageVulnerabilityResolver{r}
}

func (r *Resolver) ImageVulnerabilityAnalysisTrail() gengql.ImageVulnerabilityAnalysisTrailResolver {
	return &imageVulnerabilityAnalysisTrailResolver{r}
}

func (r *Resolver) TeamVulnerabilitySummary() gengql.TeamVulnerabilitySummaryResolver {
	return &teamVulnerabilitySummaryResolver{r}
}

type (
	containerImageWorkloadReferenceResolver struct{ *Resolver }
	imageVulnerabilityResolver              struct{ *Resolver }
	imageVulnerabilityAnalysisTrailResolver struct{ *Resolver }
	teamVulnerabilitySummaryResolver        struct{ *Resolver }
)

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"

	"github.com/nais/api/internal/graph/apierror"
	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/loader"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/sqlinstance"
)

// SQLInstance is the resolver for the sqlInstance field.
func (r *queryResolver) SQLInstance(ctx context.Context, name string, team slug.Slug, env string) (*model.SQLInstance, error) {
	return r.k8sClient.SqlInstance(ctx, env, team, name)
}

// App is the resolver for the app field.
func (r *sqlInstanceResolver) App(ctx context.Context, obj *model.SQLInstance) (*model.App, error) {
	appName, ok := obj.GQLVars.Labels["app"]
	if !ok {
		return nil, nil
	}

	app, err := r.k8sClient.App(ctx, appName, string(obj.GQLVars.TeamSlug), obj.Env.Name)
	if err != nil {
		return nil, nil
	}

	return app, nil
}

// Cost is the resolver for the cost field.
func (r *sqlInstanceResolver) Cost(ctx context.Context, obj *model.SQLInstance, from scalar.Date, to scalar.Date) (float64, error) {
	if err := ValidateDateInterval(from, to); err != nil {
		return 0, err
	}

	fromDate, err := from.PgDate()
	if err != nil {
		return 0, err
	}

	toDate, err := to.PgDate()
	if err != nil {
		return 0, err
	}

	sum, err := r.database.CostForSqlInstance(ctx, fromDate, toDate, obj.GQLVars.TeamSlug, obj.Name, obj.Env.Name)
	if err != nil {
		return 0, err
	}

	return float64(sum), nil
}

// Databases is the resolver for the databases field.
func (r *sqlInstanceResolver) Databases(ctx context.Context, obj *model.SQLInstance) ([]*model.SQLDatabase, error) {
	return r.k8sClient.SqlDatabases(ctx, obj)
}

// Metrics is the resolver for the metrics field.
func (r *sqlInstanceResolver) Metrics(ctx context.Context, obj *model.SQLInstance) (*model.SQLInstanceMetrics, error) {
	return &model.SQLInstanceMetrics{
		GQLVars: model.SQLInstanceMetricsGQLVars{
			DatabaseID: obj.ProjectID + ":" + obj.Name,
			ProjectID:  obj.ProjectID,
		},
	}, nil
}

// Team is the resolver for the team field.
func (r *sqlInstanceResolver) Team(ctx context.Context, obj *model.SQLInstance) (*model.Team, error) {
	return loader.GetTeam(ctx, obj.GQLVars.TeamSlug)
}

// CPU is the resolver for the cpu field.
func (r *sqlInstanceMetricsResolver) CPU(ctx context.Context, obj *model.SQLInstanceMetrics) (*model.SQLInstanceCPU, error) {
	cpu, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.GQLVars.ProjectID, sqlinstance.WithQuery(sqlinstance.CpuUtilization, obj.GQLVars.DatabaseID))
	if err != nil {
		return nil, apierror.ErrGoogleCloudMonitoringMetricsApi
	}

	cpuCores, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.GQLVars.ProjectID, sqlinstance.WithQuery(sqlinstance.CpuCores, obj.GQLVars.DatabaseID))
	if err != nil {
		return nil, apierror.ErrGoogleCloudMonitoringMetricsApi
	}

	return &model.SQLInstanceCPU{
		Utilization: cpu * 100,
		Cores:       cpuCores,
	}, nil
}

// Memory is the resolver for the memory field.
func (r *sqlInstanceMetricsResolver) Memory(ctx context.Context, obj *model.SQLInstanceMetrics) (*model.SQLInstanceMemory, error) {
	memory, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.GQLVars.ProjectID, sqlinstance.WithQuery(sqlinstance.MemoryUtilization, obj.GQLVars.DatabaseID))
	if err != nil {
		return nil, apierror.ErrGoogleCloudMonitoringMetricsApi
	}

	memoryQuota, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.GQLVars.ProjectID, sqlinstance.WithQuery(sqlinstance.MemoryQuota, obj.GQLVars.DatabaseID))
	if err != nil {
		return nil, apierror.ErrGoogleCloudMonitoringMetricsApi
	}

	return &model.SQLInstanceMemory{
		Utilization: memory * 100,
		QuotaBytes:  memoryQuota,
	}, nil
}

// Disk is the resolver for the disk field.
func (r *sqlInstanceMetricsResolver) Disk(ctx context.Context, obj *model.SQLInstanceMetrics) (*model.SQLInstanceDisk, error) {
	disk, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.GQLVars.ProjectID, sqlinstance.WithQuery(sqlinstance.DiskUtilization, obj.GQLVars.DatabaseID))
	if err != nil {
		return nil, apierror.ErrGoogleCloudMonitoringMetricsApi
	}

	diskQuota, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.GQLVars.ProjectID, sqlinstance.WithQuery(sqlinstance.DiskQuota, obj.GQLVars.DatabaseID))
	if err != nil {
		return nil, apierror.ErrGoogleCloudMonitoringMetricsApi
	}

	return &model.SQLInstanceDisk{
		Utilization: disk * 100,
		QuotaBytes:  int(diskQuota),
	}, nil
}

// SqlInstance returns gengql.SqlInstanceResolver implementation.
func (r *Resolver) SqlInstance() gengql.SqlInstanceResolver { return &sqlInstanceResolver{r} }

// SqlInstanceMetrics returns gengql.SqlInstanceMetricsResolver implementation.
func (r *Resolver) SqlInstanceMetrics() gengql.SqlInstanceMetricsResolver {
	return &sqlInstanceMetricsResolver{r}
}

type (
	sqlInstanceResolver        struct{ *Resolver }
	sqlInstanceMetricsResolver struct{ *Resolver }
)

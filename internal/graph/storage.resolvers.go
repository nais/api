package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"

	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/loader"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/scalar"
)

// App is the resolver for the app field.
func (r *sqlInstanceResolver) App(ctx context.Context, obj *model.SQLInstance) (*model.App, error) {
	appName, ok := obj.GQLVars.Labels["app"]
	if !ok {
		return nil, nil
	}

	app, err := r.k8sClient.App(ctx, appName, string(obj.GQLVars.TeamSlug), obj.Env.Name)
	if err != nil {
		return nil, nil
	}

	return app, nil
}

// Cost is the resolver for the cost field.
func (r *sqlInstanceResolver) Cost(ctx context.Context, obj *model.SQLInstance, from scalar.Date, to scalar.Date) (float64, error) {
	// TODO: fix error handling / validation for dates
	fromDate, _ := from.PgDate()
	toDate, _ := to.PgDate()
	sum, err := r.database.CostForSqlInstance(ctx, fromDate, toDate, obj.GQLVars.TeamSlug, obj.Name, obj.Env.Name)
	if err != nil {
		return 0, err
	}

	return float64(sum), nil
}

// Team is the resolver for the team field.
func (r *sqlInstanceResolver) Team(ctx context.Context, obj *model.SQLInstance) (*model.Team, error) {
	return loader.GetTeam(ctx, obj.GQLVars.TeamSlug)
}

// SqlInstance returns gengql.SqlInstanceResolver implementation.
func (r *Resolver) SqlInstance() gengql.SqlInstanceResolver { return &sqlInstanceResolver{r} }

type sqlInstanceResolver struct{ *Resolver }

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"

	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/sqlinstance"
)

// App is the resolver for the app field.
func (r *sqlInstanceResolver) App(ctx context.Context, obj *model.SQLInstance) (*model.App, error) {
	appName, ok := obj.GQLVars.Labels["app"]
	if !ok {
		return nil, nil
	}

	app, err := r.k8sClient.App(ctx, appName, string(obj.Team.Slug), obj.Env.Name)
	if err != nil {
		return nil, nil
	}

	return app, nil
}

// Cost is the resolver for the cost field.
func (r *sqlInstanceResolver) Cost(ctx context.Context, obj *model.SQLInstance, from scalar.Date, to scalar.Date) (float64, error) {
	// TODO: fix error handling / validation for dates
	fromDate, _ := from.PgDate()
	toDate, _ := to.PgDate()
	sum, err := r.database.CostForSqlInstance(ctx, fromDate, toDate, obj.Team.Slug, obj.Name, obj.Env.Name)
	if err != nil {
		return 0, err
	}

	return float64(sum), nil
}

// Metrics is the resolver for the metrics field.
func (r *sqlInstanceResolver) Metrics(ctx context.Context, obj *model.SQLInstance) (*model.SQLInstanceMetrics, error) {
	projectID := obj.GQLVars.Annotations["cnrm.cloud.google.com/project-id"]
	databaseID := fmt.Sprintf("%s:%s", projectID, obj.Name)
	cpuTs, err := r.sqlinstanceMetrics.ListTimeSeries(ctx, projectID, sqlinstance.WithFilter(sqlinstance.CpuUtilizationFilter, databaseID))
	if err != nil {
		return nil, err
	}

	cpuSum := 0.0
	cpuAverage := 0.0
	for _, t := range cpuTs {
		for _, p := range t.Points {
			cpuSum += p.Value.GetDoubleValue()
		}
		cpuAverage = cpuSum / float64(len(t.Points))
	}

	memoryTs, err := r.sqlinstanceMetrics.ListTimeSeries(ctx, projectID, sqlinstance.WithFilter(sqlinstance.MemoryUtilizationFilter, databaseID))
	if err != nil {
		return nil, err
	}

	memorySum := 0.0
	memoryAverage := 0.0
	for _, t := range memoryTs {
		for _, p := range t.Points {
			memorySum += p.Value.GetDoubleValue()
		}
		memoryAverage = memorySum / float64(len(t.Points))
	}

	return &model.SQLInstanceMetrics{
		CPUUtilization:    cpuAverage * 100,
		MemoryUtilization: memoryAverage * 100,
	}, nil
}

// SqlInstance returns gengql.SqlInstanceResolver implementation.
func (r *Resolver) SqlInstance() gengql.SqlInstanceResolver { return &sqlInstanceResolver{r} }

type sqlInstanceResolver struct{ *Resolver }

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"

	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/loader"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/sqlinstance"
)

// SQLInstance is the resolver for the sqlInstance field.
func (r *queryResolver) SQLInstance(ctx context.Context, name string, team slug.Slug, env string) (*model.SQLInstance, error) {
	t, _ := loader.GetTeam(ctx, team)
	return r.k8sClient.SqlInstance(ctx, env, t, name)
}

// App is the resolver for the app field.
func (r *sqlInstanceResolver) App(ctx context.Context, obj *model.SQLInstance) (*model.App, error) {
	appName, ok := obj.GQLVars.Labels["app"]
	if !ok {
		return nil, nil
	}

	app, err := r.k8sClient.App(ctx, appName, string(obj.Team.Slug), obj.Env.Name)
	if err != nil {
		return nil, nil
	}

	return app, nil
}

// Cost is the resolver for the cost field.
func (r *sqlInstanceResolver) Cost(ctx context.Context, obj *model.SQLInstance, from scalar.Date, to scalar.Date) (float64, error) {
	// TODO: fix error handling / validation for dates
	fromDate, _ := from.PgDate()
	toDate, _ := to.PgDate()
	sum, err := r.database.CostForSqlInstance(ctx, fromDate, toDate, obj.Team.Slug, obj.Name, obj.Env.Name)
	if err != nil {
		return 0, err
	}

	return float64(sum), nil
}

// Databases is the resolver for the databases field.
func (r *sqlInstanceResolver) Databases(ctx context.Context, obj *model.SQLInstance) ([]*model.SQLDatabase, error) {
	return r.k8sClient.SqlDatabases(ctx, obj)
}

// Metrics is the resolver for the metrics field.
func (r *sqlInstanceResolver) Metrics(ctx context.Context, obj *model.SQLInstance) (*model.SQLInstanceMetrics, error) {
	databaseID := fmt.Sprintf("%s:%s", obj.ProjectID, obj.Name)

	cpu, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.ProjectID, sqlinstance.WithQuery(sqlinstance.CpuUtilization, databaseID))
	if err != nil {
		return nil, err
	}

	cpuCores, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.ProjectID, sqlinstance.WithQuery(sqlinstance.CpuCores, databaseID))
	if err != nil {
		return nil, err
	}

	memory, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.ProjectID, sqlinstance.WithQuery(sqlinstance.MemoryUtilization, databaseID))
	if err != nil {
		return nil, err
	}

	memoryQuota, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.ProjectID, sqlinstance.WithQuery(sqlinstance.MemoryQuota, databaseID))
	if err != nil {
		return nil, err
	}

	disk, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.ProjectID, sqlinstance.WithQuery(sqlinstance.DiskUtilization, databaseID))
	if err != nil {
		return nil, err
	}

	diskQuota, err := r.sqlinstanceMetrics.AverageFor(ctx, obj.ProjectID, sqlinstance.WithQuery(sqlinstance.DiskQuota, databaseID))
	if err != nil {
		return nil, err
	}

	return &model.SQLInstanceMetrics{
		CPU: model.SQLInstanceCPU{
			Utilization: cpu * 100,
			Cores:       cpuCores,
		},
		Memory: model.SQLInstanceMemory{
			Utilization: memory * 100,
			QuotaBytes:  memoryQuota,
		},
		Disk: model.SQLInstanceDisk{
			Utilization: disk * 100,
			QuotaBytes:  int(diskQuota),
		},
	}, nil
}

// SqlInstance returns gengql.SqlInstanceResolver implementation.
func (r *Resolver) SqlInstance() gengql.SqlInstanceResolver { return &sqlInstanceResolver{r} }

type sqlInstanceResolver struct{ *Resolver }

// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/nais/api/internal/slug"
)

// Authenticated user type. Can be a user or a service account.
type AuthenticatedUser interface {
	IsAuthenticatedUser()
}

type Authz interface {
	IsAuthz()
}

type ScalingStrategy interface {
	IsScalingStrategy()
}

type StateError interface {
	IsStateError()
}

type Workload interface {
	IsWorkload()
}

type AppList struct {
	Nodes    []*App   `json:"nodes"`
	PageInfo PageInfo `json:"pageInfo"`
}

// Team status for apps.
type AppsStatus struct {
	Failing         int `json:"failing"`
	NotNais         int `json:"notNais"`
	Vulnerabilities int `json:"vulnerabilities"`
}

type AzureAd struct {
	Application *AzureApplication `json:"application,omitempty"`
	Sidecar     *Sidecar          `json:"sidecar,omitempty"`
}

func (AzureAd) IsAuthz() {}

type AzureApplication struct {
	AllowAllUsers         bool     `json:"allowAllUsers"`
	Claims                Claims   `json:"claims"`
	ReplyURLs             []string `json:"replyURLs"`
	SinglePageApplication bool     `json:"singlePageApplication"`
	Tenant                string   `json:"tenant"`
}

type CPUScalingStrategy struct {
	Threshold int `json:"threshold"`
}

func (CPUScalingStrategy) IsScalingStrategy() {}

type Claims struct {
	Extra  []string `json:"extra"`
	Groups []*Group `json:"groups"`
}

type Consume struct {
	Name string `json:"name"`
}

type Consumer struct {
	Name  string `json:"name"`
	Orgno string `json:"orgno"`
}

type DeleteAppResult struct {
	// Whether the app was deleted or not.
	Deleted bool    `json:"deleted"`
	Error   *string `json:"error,omitempty"`
}

type DeleteJobResult struct {
	// Whether the job was deleted or not.
	Deleted bool    `json:"deleted"`
	Error   *string `json:"error,omitempty"`
}

type DeprecatedIngressError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Ingress  string     `json:"ingress"`
}

func (DeprecatedIngressError) IsStateError() {}

type DeprecatedRegistryError struct {
	Revision   string     `json:"revision"`
	Level      ErrorLevel `json:"level"`
	Registry   string     `json:"registry"`
	Repository string     `json:"repository"`
	Name       string     `json:"name"`
	Tag        string     `json:"tag"`
}

func (DeprecatedRegistryError) IsStateError() {}

type Expose struct {
	AllowedIntegrations []string    `json:"allowedIntegrations"`
	AtMaxAge            int         `json:"atMaxAge"`
	Consumers           []*Consumer `json:"consumers"`
	Enabled             bool        `json:"enabled"`
	Name                string      `json:"name"`
	Product             string      `json:"product"`
}

type FailedRunError struct {
	Revision   string     `json:"revision"`
	Level      ErrorLevel `json:"level"`
	RunMessage string     `json:"runMessage"`
	RunName    string     `json:"runName"`
}

func (FailedRunError) IsStateError() {}

// GCP project type.
type GCPProject struct {
	// The environment for the project.
	Environment string `json:"environment"`
	// The display name of the project.
	ProjectName string `json:"projectName"`
	// The GCP project ID.
	ProjectID string `json:"projectId"`
}

type Group struct {
	ID string `json:"id"`
}

type IDPorten struct {
	AccessTokenLifetime    *int             `json:"accessTokenLifetime,omitempty"`
	ClientURI              *string          `json:"clientURI,omitempty"`
	FrontchannelLogoutPath *string          `json:"frontchannelLogoutPath,omitempty"`
	IntegrationType        *string          `json:"integrationType,omitempty"`
	PostLogoutRedirectURIs []*string        `json:"postLogoutRedirectURIs,omitempty"`
	RedirectPath           *string          `json:"redirectPath,omitempty"`
	Scopes                 []*string        `json:"scopes,omitempty"`
	SessionLifetime        *int             `json:"sessionLifetime,omitempty"`
	Sidecar                *IDPortenSidecar `json:"sidecar,omitempty"`
}

func (IDPorten) IsAuthz() {}

type IDPortenSidecar struct {
	AutoLogin            *bool      `json:"autoLogin,omitempty"`
	AutoLoginIgnorePaths []*string  `json:"autoLoginIgnorePaths,omitempty"`
	Enabled              *bool      `json:"enabled,omitempty"`
	Level                *string    `json:"level,omitempty"`
	Locale               *string    `json:"locale,omitempty"`
	Resources            *Resources `json:"resources,omitempty"`
}

type InboundAccessError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
}

func (InboundAccessError) IsStateError() {}

type InvalidNaisYamlError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Detail   string     `json:"detail"`
}

func (InvalidNaisYamlError) IsStateError() {}

// Team status for jobs.
type JobsStatus struct {
	Failing         int `json:"failing"`
	NotNais         int `json:"notNais"`
	Vulnerabilities int `json:"vulnerabilities"`
}

type KafkaLagScalingStrategy struct {
	Threshold     int    `json:"threshold"`
	ConsumerGroup string `json:"consumerGroup"`
	Topic         string `json:"topic"`
}

func (KafkaLagScalingStrategy) IsScalingStrategy() {}

type Limits struct {
	CPU    string `json:"cpu"`
	Memory string `json:"memory"`
}

type Maskinporten struct {
	Scopes  MaskinportenScope `json:"scopes"`
	Enabled bool              `json:"enabled"`
}

func (Maskinporten) IsAuthz() {}

type MaskinportenScope struct {
	Consumes []*Consume `json:"consumes"`
	Exposes  []*Expose  `json:"exposes"`
}

type MissingSbomError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
}

func (MissingSbomError) IsStateError() {}

// The root query for implementing GraphQL mutations.
type Mutation struct {
}

type NaisJobList struct {
	Nodes    []*NaisJob `json:"nodes"`
	PageInfo PageInfo   `json:"pageInfo"`
}

// NAIS namespace type.
type NaisNamespace struct {
	// The environment for the namespace.
	Environment string `json:"environment"`
	// The namespace.
	Namespace slug.Slug `json:"namespace"`
}

type NewInstancesFailingError struct {
	Revision         string     `json:"revision"`
	Level            ErrorLevel `json:"level"`
	FailingInstances []string   `json:"failingInstances"`
}

func (NewInstancesFailingError) IsStateError() {}

type NoRunningInstancesError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
}

func (NoRunningInstancesError) IsStateError() {}

type OrderBy struct {
	// Order direction.
	Direction SortOrder `json:"direction"`
	// The field to order by.
	Field OrderByField `json:"field"`
}

type OutboundAccessError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
}

func (OutboundAccessError) IsStateError() {}

// Pagination information.
type PageInfo struct {
	// The total amount if items accessible.
	TotalCount int `json:"totalCount"`
	// Whether or not there exists a next page in the data set.
	HasNextPage bool `json:"hasNextPage"`
	// Whether or not there exists a previous page in the data set.
	HasPreviousPage bool `json:"hasPreviousPage"`
}

// The query root for the NAIS GraphQL API.
type Query struct {
}

type Requests struct {
	CPU    string `json:"cpu"`
	Memory string `json:"memory"`
}

// A teams inventory of resources.
type ResourceInventory struct {
	TotalJobs int  `json:"totalJobs"`
	TotalApps int  `json:"totalApps"`
	IsEmpty   bool `json:"isEmpty"`
}

type RestartAppResult struct {
	Error *string `json:"error,omitempty"`
}

type Scaling struct {
	Min        int               `json:"min"`
	Max        int               `json:"max"`
	Strategies []ScalingStrategy `json:"strategies"`
}

type Sidecar struct {
	AutoLogin            bool      `json:"autoLogin"`
	AutoLoginIgnorePaths []string  `json:"autoLoginIgnorePaths"`
	Resources            Resources `json:"resources"`
}

// Slack alerts channel type.
type SlackAlertsChannel struct {
	// The environment for the alerts sent to the channel.
	Environment string `json:"environment"`
	// The name of the Slack channel.
	ChannelName string `json:"channelName"`
}

// Sync error type.
type SyncError struct {
	// Creation time of the error.
	CreatedAt time.Time `json:"createdAt"`
	// The name of the reconciler.
	Reconciler string `json:"reconciler"`
	// Error message.
	Error string `json:"error"`
}

type SynchronizationFailingError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Detail   string     `json:"detail"`
}

func (SynchronizationFailingError) IsStateError() {}

// Paginated teams type.
type TeamList struct {
	// The list of teams.
	Nodes []*Team `json:"nodes"`
	// Pagination information.
	PageInfo PageInfo `json:"pageInfo"`
}

type TeamMemberList struct {
	Nodes    []*TeamMember `json:"nodes"`
	PageInfo PageInfo      `json:"pageInfo"`
}

type TokenX struct {
	MountSecretsAsFilesOnly bool `json:"mountSecretsAsFilesOnly"`
}

func (TokenX) IsAuthz() {}

// Slack alerts channel input.
type UpdateTeamSlackAlertsChannelInput struct {
	// The environment for the alerts sent to the channel.
	Environment string `json:"environment"`
	// The name of the Slack channel.
	ChannelName *string `json:"channelName,omitempty"`
}

type UserList struct {
	Nodes    []*User  `json:"nodes"`
	PageInfo PageInfo `json:"pageInfo"`
}

type UsersyncRunList struct {
	Nodes    []*UsersyncRun `json:"nodes"`
	PageInfo PageInfo       `json:"pageInfo"`
}

type Variable struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type VariableInput struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type ErrorLevel string

const (
	ErrorLevelTodo    ErrorLevel = "TODO"
	ErrorLevelWarning ErrorLevel = "WARNING"
	ErrorLevelError   ErrorLevel = "ERROR"
)

var AllErrorLevel = []ErrorLevel{
	ErrorLevelTodo,
	ErrorLevelWarning,
	ErrorLevelError,
}

func (e ErrorLevel) IsValid() bool {
	switch e {
	case ErrorLevelTodo, ErrorLevelWarning, ErrorLevelError:
		return true
	}
	return false
}

func (e ErrorLevel) String() string {
	return string(e)
}

func (e *ErrorLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorLevel", str)
	}
	return nil
}

func (e ErrorLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstanceState string

const (
	InstanceStateRunning InstanceState = "RUNNING"
	InstanceStateFailing InstanceState = "FAILING"
	InstanceStateUnknown InstanceState = "UNKNOWN"
)

var AllInstanceState = []InstanceState{
	InstanceStateRunning,
	InstanceStateFailing,
	InstanceStateUnknown,
}

func (e InstanceState) IsValid() bool {
	switch e {
	case InstanceStateRunning, InstanceStateFailing, InstanceStateUnknown:
		return true
	}
	return false
}

func (e InstanceState) String() string {
	return string(e)
}

func (e *InstanceState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstanceState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstanceState", str)
	}
	return nil
}

func (e InstanceState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderByField string

const (
	// Order by name
	OrderByFieldName OrderByField = "NAME"
	// Order by env
	OrderByFieldEnv OrderByField = "ENV"
	// Order by status
	OrderByFieldStatus OrderByField = "STATUS"
)

var AllOrderByField = []OrderByField{
	OrderByFieldName,
	OrderByFieldEnv,
	OrderByFieldStatus,
}

func (e OrderByField) IsValid() bool {
	switch e {
	case OrderByFieldName, OrderByFieldEnv, OrderByFieldStatus:
		return true
	}
	return false
}

func (e OrderByField) String() string {
	return string(e)
}

func (e *OrderByField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderByField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderByField", str)
	}
	return nil
}

func (e OrderByField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortOrder string

const (
	// Ascending sort order.
	SortOrderAsc SortOrder = "ASC"
	// Descending sort order.
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type State string

const (
	StateNais    State = "NAIS"
	StateNotnais State = "NOTNAIS"
	StateFailing State = "FAILING"
	StateUnknown State = "UNKNOWN"
)

var AllState = []State{
	StateNais,
	StateNotnais,
	StateFailing,
	StateUnknown,
}

func (e State) IsValid() bool {
	switch e {
	case StateNais, StateNotnais, StateFailing, StateUnknown:
		return true
	}
	return false
}

func (e State) String() string {
	return string(e)
}

func (e *State) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = State(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid State", str)
	}
	return nil
}

func (e State) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Available team roles.
type TeamRole string

const (
	// Regular member, read only access.
	TeamRoleMember TeamRole = "MEMBER"
	// Team owner, full access to the team.
	TeamRoleOwner TeamRole = "OWNER"
)

var AllTeamRole = []TeamRole{
	TeamRoleMember,
	TeamRoleOwner,
}

func (e TeamRole) IsValid() bool {
	switch e {
	case TeamRoleMember, TeamRoleOwner:
		return true
	}
	return false
}

func (e TeamRole) String() string {
	return string(e)
}

func (e *TeamRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamRole", str)
	}
	return nil
}

func (e TeamRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// User sync run status.
type UsersyncRunStatus string

const (
	// Successful user sync run.
	UsersyncRunStatusSuccess UsersyncRunStatus = "SUCCESS"
	// Failed user sync run.
	UsersyncRunStatusFailure UsersyncRunStatus = "FAILURE"
)

var AllUsersyncRunStatus = []UsersyncRunStatus{
	UsersyncRunStatusSuccess,
	UsersyncRunStatusFailure,
}

func (e UsersyncRunStatus) IsValid() bool {
	switch e {
	case UsersyncRunStatusSuccess, UsersyncRunStatusFailure:
		return true
	}
	return false
}

func (e UsersyncRunStatus) String() string {
	return string(e)
}

func (e *UsersyncRunStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersyncRunStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UsersyncRunStatus", str)
	}
	return nil
}

func (e UsersyncRunStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WorkloadType string

const (
	WorkloadTypeApp     WorkloadType = "APP"
	WorkloadTypeNaisjob WorkloadType = "NAISJOB"
)

var AllWorkloadType = []WorkloadType{
	WorkloadTypeApp,
	WorkloadTypeNaisjob,
}

func (e WorkloadType) IsValid() bool {
	switch e {
	case WorkloadTypeApp, WorkloadTypeNaisjob:
		return true
	}
	return false
}

func (e WorkloadType) String() string {
	return string(e)
}

func (e *WorkloadType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkloadType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkloadType", str)
	}
	return nil
}

func (e WorkloadType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/slug"
)

// Authenticated user type. Can be a user or a service account.
type AuthenticatedUser interface {
	IsAuthenticatedUser()
}

type Authz interface {
	IsAuthz()
}

type DeploymentResponse interface {
	IsDeploymentResponse()
}

type SearchNode interface {
	IsSearchNode()
}

type StateError interface {
	IsStateError()
	GetRevision() string
	GetLevel() ErrorLevel
}

type Storage interface {
	IsStorage()
	GetName() string
}

type AccessPolicy struct {
	Inbound  Inbound  `json:"inbound"`
	Outbound Outbound `json:"outbound"`
}

type ACL struct {
	Access      string    `json:"access"`
	Application string    `json:"application"`
	Team        slug.Slug `json:"team"`
}

// App cost type.
type AppCost struct {
	// The name of the application.
	App string `json:"app"`
	// The sum of all cost entries for the application in euros.
	Sum float64 `json:"sum"`
	// A list of cost entries for the application.
	Cost []*CostEntry `json:"cost"`
}

type AppList struct {
	Nodes    []*App   `json:"nodes"`
	PageInfo PageInfo `json:"pageInfo"`
}

type AppState struct {
	State  State        `json:"state"`
	Errors []StateError `json:"errors"`
}

// Resource utilization overage cost for an app.
type AppWithResourceUtilizationOverage struct {
	// The overage for the app.
	Overage float64 `json:"overage"`
	// The overage cost for the app.
	OverageCost float64 `json:"overageCost"`
	// Estimated annual cost of the request overage.
	EstimatedAnnualOverageCost float64 `json:"estimatedAnnualOverageCost"`
	// The utilization in percent.
	Utilization float64 `json:"utilization"`
	// The environment where the app is running.
	Env string `json:"env"`
	// The name of the team who owns the app.
	Team slug.Slug `json:"team"`
	// The name of the app.
	App string `json:"app"`
}

// Team status for apps.
type AppsStatus struct {
	Total   int `json:"total"`
	Failing int `json:"failing"`
}

// Audit log type.
type AuditLog struct {
	// ID of the log entry.
	ID scalar.Ident `json:"id"`
	// String representation of the action performed.
	Action string `json:"action"`
	// The related correlation ID.
	CorrelationID string `json:"correlationID"`
	// The identity of the actor who performed the action. When this field is empty it means that some backend process performed the action. The value, when present, is either the name of a service account, or the email address of a user.
	Actor *string `json:"actor,omitempty"`
	// The type of the audit log target.
	TargetType string `json:"targetType"`
	// The identifier of the target.
	TargetIdentifier string `json:"targetIdentifier"`
	// Log entry message.
	Message string `json:"message"`
	// Creation time of the log entry.
	CreatedAt time.Time `json:"createdAt"`
}

type AuditLogList struct {
	Nodes    []*AuditLog `json:"nodes"`
	PageInfo PageInfo    `json:"pageInfo"`
}

type AutoScaling struct {
	Disabled bool `json:"disabled"`
	// CPU threshold in percent
	CPUThreshold int `json:"cpuThreshold"`
	Max          int `json:"max"`
	Min          int `json:"min"`
}

type AzureAd struct {
	Application *AzureApplication `json:"application,omitempty"`
	Sidecar     *Sidecar          `json:"sidecar,omitempty"`
}

func (AzureAd) IsAuthz() {}

type AzureApplication struct {
	AllowAllUsers         bool     `json:"allowAllUsers"`
	Claims                Claims   `json:"claims"`
	ReplyURLs             []string `json:"replyURLs"`
	SinglePageApplication bool     `json:"singlePageApplication"`
	Tenant                string   `json:"tenant"`
}

type BigQueryDataset struct {
	CascadingDelete bool   `json:"cascadingDelete"`
	Description     string `json:"description"`
	Name            string `json:"name"`
	Permission      string `json:"permission"`
}

func (BigQueryDataset) IsStorage()           {}
func (this BigQueryDataset) GetName() string { return this.Name }

type Bucket struct {
	CascadingDelete          bool   `json:"cascadingDelete"`
	Name                     string `json:"name"`
	PublicAccessPrevention   bool   `json:"publicAccessPrevention"`
	RetentionPeriodDays      int    `json:"retentionPeriodDays"`
	UniformBucketLevelAccess bool   `json:"uniformBucketLevelAccess"`
}

func (Bucket) IsStorage()           {}
func (this Bucket) GetName() string { return this.Name }

type Claims struct {
	Extra  []string `json:"extra"`
	Groups []*Group `json:"groups"`
}

type Consume struct {
	Name string `json:"name"`
}

type Consumer struct {
	Name  string `json:"name"`
	Orgno string `json:"orgno"`
}

// Cost entry type.
type CostEntry struct {
	// The date for the entry.
	Date scalar.Date `json:"date"`
	// The cost in euros.
	Cost float64 `json:"cost"`
}

// Cost series type.
type CostSeries struct {
	// The type of cost.
	CostType string `json:"costType"`
	// The sum of all daily costs in the series for this cost type in euros.
	Sum float64 `json:"sum"`
	// The cost data.
	Data []*CostEntry `json:"data"`
}

// Input for creating a new team.
type CreateTeamInput struct {
	// Team slug. After creation, this value can not be changed.
	Slug slug.Slug `json:"slug"`
	// Team purpose.
	Purpose string `json:"purpose"`
	// Specify the Slack channel for the team.
	SlackChannel string `json:"slackChannel"`
}

// Current resource utilization type.
type CurrentResourceUtilization struct {
	// The timestamp used for the calculated values.
	Timestamp time.Time `json:"timestamp"`
	// The CPU utilization.
	CPU ResourceUtilization `json:"cpu"`
	// The memory utilization.
	Memory ResourceUtilization `json:"memory"`
}

// Daily cost type.
type DailyCost struct {
	// The sum of all costs in the cost series in euros.
	Sum float64 `json:"sum"`
	// The cost series.
	Series []*CostSeries `json:"series"`
}

type Database struct {
	EnvVarPrefix string          `json:"envVarPrefix"`
	Name         string          `json:"name"`
	Users        []*DatabaseUser `json:"users"`
}

type DatabaseUser struct {
	Name string `json:"name"`
}

type DeleteAppResult struct {
	// Whether the app was deleted or not.
	Deleted bool    `json:"deleted"`
	Error   *string `json:"error,omitempty"`
}

type DeleteJobResult struct {
	// Whether the job was deleted or not.
	Deleted bool    `json:"deleted"`
	Error   *string `json:"error,omitempty"`
}

type Deployment struct {
	ID         scalar.Ident          `json:"id"`
	Team       Team                  `json:"team"`
	Resources  []*DeploymentResource `json:"resources"`
	Env        string                `json:"env"`
	Statuses   []*DeploymentStatus   `json:"statuses"`
	Created    time.Time             `json:"created"`
	Repository string                `json:"repository"`
}

// Deployment key type.
type DeploymentKey struct {
	// The unique identifier of the deployment key.
	ID scalar.Ident `json:"id"`
	// The actual key.
	Key string `json:"key"`
	// The date the deployment key was created.
	Created time.Time `json:"created"`
	// The date the deployment key expires.
	Expires time.Time `json:"expires"`
}

type DeploymentList struct {
	Nodes    []*Deployment `json:"nodes"`
	PageInfo PageInfo      `json:"pageInfo"`
}

func (DeploymentList) IsDeploymentResponse() {}

type DeploymentResource struct {
	ID        scalar.Ident `json:"id"`
	Group     string       `json:"group"`
	Kind      string       `json:"kind"`
	Name      string       `json:"name"`
	Version   string       `json:"version"`
	Namespace string       `json:"namespace"`
}

type DeploymentStatus struct {
	ID      scalar.Ident `json:"id"`
	Status  string       `json:"status"`
	Message *string      `json:"message,omitempty"`
	Created time.Time    `json:"created"`
}

type DeprecatedIngressError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Ingress  string     `json:"ingress"`
}

func (DeprecatedIngressError) IsStateError()             {}
func (this DeprecatedIngressError) GetRevision() string  { return this.Revision }
func (this DeprecatedIngressError) GetLevel() ErrorLevel { return this.Level }

type DeprecatedRegistryError struct {
	Revision   string     `json:"revision"`
	Level      ErrorLevel `json:"level"`
	Registry   string     `json:"registry"`
	Repository string     `json:"repository"`
	Name       string     `json:"name"`
	Tag        string     `json:"tag"`
}

func (DeprecatedRegistryError) IsStateError()             {}
func (this DeprecatedRegistryError) GetRevision() string  { return this.Revision }
func (this DeprecatedRegistryError) GetLevel() ErrorLevel { return this.Level }

// Env cost type.
type EnvCost struct {
	// The name of the environment.
	Env string `json:"env"`
	// The sum of all app costs for the environment in euros.
	Sum float64 `json:"sum"`
	// A list of app costs in the environment.
	Apps []*AppCost `json:"apps"`
}

// Env cost filter input type.
type EnvCostFilter struct {
	// Start date for the cost series, inclusive.
	From scalar.Date `json:"from"`
	// End date for cost series, inclusive.
	To scalar.Date `json:"to"`
	// The name of the team to get costs for.
	Team slug.Slug `json:"team"`
}

type Error struct {
	Message string `json:"message"`
}

func (Error) IsDeploymentResponse() {}

type Expose struct {
	AllowedIntegrations []string    `json:"allowedIntegrations"`
	AtMaxAge            int         `json:"atMaxAge"`
	Consumers           []*Consumer `json:"consumers"`
	Enabled             bool        `json:"enabled"`
	Name                string      `json:"name"`
	Product             string      `json:"product"`
}

type External struct {
	Host  string  `json:"host"`
	Ports []*Port `json:"ports"`
}

type FailedRunError struct {
	Revision   string     `json:"revision"`
	Level      ErrorLevel `json:"level"`
	RunMessage string     `json:"runMessage"`
	RunName    string     `json:"runName"`
}

func (FailedRunError) IsStateError()             {}
func (this FailedRunError) GetRevision() string  { return this.Revision }
func (this FailedRunError) GetLevel() ErrorLevel { return this.Level }

type Flag struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// GCP project type.
type GcpProject struct {
	// The environment for the project.
	Environment string `json:"environment"`
	// The display name of the project.
	ProjectName string `json:"projectName"`
	// The GCP project ID.
	ProjectID string `json:"projectId"`
}

// Input for filtering GitHub repositories.
type GitHubRepositoriesFilter struct {
	// Whether or not to include archived repositories. Defaults to false.
	IncludeArchivedRepositories *bool `json:"includeArchivedRepositories,omitempty"`
}

// Paginated GitHub repository type.
type GitHubRepositoryList struct {
	// The list of GitHub repositories.
	Nodes []*GitHubRepository `json:"nodes"`
	// Pagination information.
	PageInfo PageInfo `json:"pageInfo"`
}

// GitHub repository permission type.
type GitHubRepositoryPermission struct {
	// Name of the permission.
	Name string `json:"name"`
	// Whether or not the permission is granted for the repository.
	Granted bool `json:"granted"`
}

type Group struct {
	ID string `json:"id"`
}

type IDPorten struct {
	AccessTokenLifetime    *int             `json:"accessTokenLifetime,omitempty"`
	ClientURI              *string          `json:"clientURI,omitempty"`
	FrontchannelLogoutPath *string          `json:"frontchannelLogoutPath,omitempty"`
	IntegrationType        *string          `json:"integrationType,omitempty"`
	PostLogoutRedirectURIs []*string        `json:"postLogoutRedirectURIs,omitempty"`
	RedirectPath           *string          `json:"redirectPath,omitempty"`
	Scopes                 []*string        `json:"scopes,omitempty"`
	SessionLifetime        *int             `json:"sessionLifetime,omitempty"`
	Sidecar                *IDPortenSidecar `json:"sidecar,omitempty"`
}

func (IDPorten) IsAuthz() {}

type IDPortenSidecar struct {
	AutoLogin            *bool      `json:"autoLogin,omitempty"`
	AutoLoginIgnorePaths []*string  `json:"autoLoginIgnorePaths,omitempty"`
	Enabled              *bool      `json:"enabled,omitempty"`
	Level                *string    `json:"level,omitempty"`
	Locale               *string    `json:"locale,omitempty"`
	Resources            *Resources `json:"resources,omitempty"`
}

type Inbound struct {
	Rules []*Rule `json:"rules"`
}

type InboundAccessError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Rule     Rule       `json:"rule"`
}

func (InboundAccessError) IsStateError()             {}
func (this InboundAccessError) GetRevision() string  { return this.Revision }
func (this InboundAccessError) GetLevel() ErrorLevel { return this.Level }

type InfluxDb struct {
	Name string `json:"name"`
}

func (InfluxDb) IsStorage()           {}
func (this InfluxDb) GetName() string { return this.Name }

type Insights struct {
	Enabled               bool `json:"enabled"`
	QueryStringLength     int  `json:"queryStringLength"`
	RecordApplicationTags bool `json:"recordApplicationTags"`
	RecordClientAddress   bool `json:"recordClientAddress"`
}

type InvalidNaisYamlError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Detail   string     `json:"detail"`
}

func (InvalidNaisYamlError) IsStateError()             {}
func (this InvalidNaisYamlError) GetRevision() string  { return this.Revision }
func (this InvalidNaisYamlError) GetLevel() ErrorLevel { return this.Level }

type JobState struct {
	State  State        `json:"state"`
	Errors []StateError `json:"errors"`
}

// Team status for jobs.
type JobsStatus struct {
	Total   int `json:"total"`
	Failing int `json:"failing"`
}

type Kafka struct {
	// The kafka pool name
	Name    string   `json:"name"`
	Streams bool     `json:"streams"`
	Topics  []*Topic `json:"topics"`
}

func (Kafka) IsStorage()           {}
func (this Kafka) GetName() string { return this.Name }

type Limits struct {
	CPU    string `json:"cpu"`
	Memory string `json:"memory"`
}

type LogLine struct {
	Time     time.Time `json:"time"`
	Message  string    `json:"message"`
	Instance string    `json:"instance"`
}

type LogSubscriptionInput struct {
	App       *string   `json:"app,omitempty"`
	Job       *string   `json:"job,omitempty"`
	Env       string    `json:"env"`
	Team      slug.Slug `json:"team"`
	Instances []string  `json:"instances,omitempty"`
}

type Maintenance struct {
	Day  int `json:"day"`
	Hour int `json:"hour"`
}

type Maskinporten struct {
	Scopes  MaskinportenScope `json:"scopes"`
	Enabled bool              `json:"enabled"`
}

func (Maskinporten) IsAuthz() {}

type MaskinportenScope struct {
	Consumes []*Consume `json:"consumes"`
	Exposes  []*Expose  `json:"exposes"`
}

type Metrics struct {
	CPUUtilization float64 `json:"cpuUtilization"`
}

// Montly cost type.
type MonthlyCost struct {
	// Sum for all months in the series in euros.
	Sum float64 `json:"sum"`
	// A list of monthly cost entries.
	Cost []*CostEntry `json:"cost"`
}

// Monthly cost filter input type.
type MonthlyCostFilter struct {
	// The name of the team to get costs for.
	Team slug.Slug `json:"team"`
	// The name of the application to get costs for.
	App string `json:"app"`
	// The name of the environment to get costs for.
	Env string `json:"env"`
}

// The root query for implementing GraphQL mutations.
type Mutation struct {
}

type NaisJobList struct {
	Nodes    []*NaisJob `json:"nodes"`
	PageInfo PageInfo   `json:"pageInfo"`
}

// NAIS namespace type.
type NaisNamespace struct {
	// The environment for the namespace.
	Environment string `json:"environment"`
	// The namespace.
	Namespace slug.Slug `json:"namespace"`
}

type NewInstancesFailingError struct {
	Revision         string     `json:"revision"`
	Level            ErrorLevel `json:"level"`
	FailingInstances []string   `json:"failingInstances"`
}

func (NewInstancesFailingError) IsStateError()             {}
func (this NewInstancesFailingError) GetRevision() string  { return this.Revision }
func (this NewInstancesFailingError) GetLevel() ErrorLevel { return this.Level }

type NoRunningInstancesError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
}

func (NoRunningInstancesError) IsStateError()             {}
func (this NoRunningInstancesError) GetRevision() string  { return this.Revision }
func (this NoRunningInstancesError) GetLevel() ErrorLevel { return this.Level }

type OpenSearch struct {
	// The opensearch instance name
	Name   string `json:"name"`
	Access string `json:"access"`
}

func (OpenSearch) IsStorage()           {}
func (this OpenSearch) GetName() string { return this.Name }

type OrderBy struct {
	// Order direction.
	Direction SortOrder `json:"direction"`
	// The field to order by.
	Field OrderByField `json:"field"`
}

type Outbound struct {
	Rules    []*Rule     `json:"rules"`
	External []*External `json:"external"`
}

type OutboundAccessError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Rule     Rule       `json:"rule"`
}

func (OutboundAccessError) IsStateError()             {}
func (this OutboundAccessError) GetRevision() string  { return this.Revision }
func (this OutboundAccessError) GetLevel() ErrorLevel { return this.Level }

// Pagination information.
type PageInfo struct {
	// The total amount if items accessible.
	TotalCount int `json:"totalCount"`
	// Whether or not there exists a next page in the data set.
	HasNextPage bool `json:"hasNextPage"`
	// Whether or not there exists a previous page in the data set.
	HasPreviousPage bool `json:"hasPreviousPage"`
}

type Port struct {
	Port int `json:"port"`
}

// The query root for the NAIS GraphQL API.
type Query struct {
}

// Reconciler configuration type.
type ReconcilerConfig struct {
	// Configuration key.
	Key string `json:"key"`
	// The human-friendly name of the configuration key.
	DisplayName string `json:"displayName"`
	// Configuration description.
	Description string `json:"description"`
	// Whether or not the configuration key has a value.
	Configured bool `json:"configured"`
	// Whether or not the configuration value is considered a secret. Secret values will not be exposed through the API.
	Secret bool `json:"secret"`
	// Configuration value. This will be set to null if the value is considered a secret.
	Value *string `json:"value,omitempty"`
}

// Reconciler configuration input.
type ReconcilerConfigInput struct {
	// Configuration key.
	Key string `json:"key"`
	// Configuration value.
	Value string `json:"value"`
}

// Paginated reconcilers type.
type ReconcilerList struct {
	// The list of reconcilers.
	Nodes []*Reconciler `json:"nodes"`
	// Pagination information.
	PageInfo PageInfo `json:"pageInfo"`
}

type Redis struct {
	Name   string `json:"name"`
	Access string `json:"access"`
}

func (Redis) IsStorage()           {}
func (this Redis) GetName() string { return this.Name }

type Requests struct {
	CPU    string `json:"cpu"`
	Memory string `json:"memory"`
}

// Resource utilization type.
type ResourceUtilization struct {
	// Timestamp of the value.
	Timestamp time.Time `json:"timestamp"`
	// The requested resource amount per pod.
	Request float64 `json:"request"`
	// The cost associated with the requested resource amount.
	RequestCost float64 `json:"requestCost"`
	// The actual resource usage.
	Usage float64 `json:"usage"`
	// The cost associated with the actual resource usage.
	UsageCost float64 `json:"usageCost"`
	// The overage of the requested resource amount.
	RequestCostOverage float64 `json:"requestCostOverage"`
	// The utilization in percent.
	Utilization float64 `json:"utilization"`
	// Estimated annual cost of the request overage.
	EstimatedAnnualOverageCost float64 `json:"estimatedAnnualOverageCost"`
}

// Date range type.
type ResourceUtilizationDateRange struct {
	// The start of the range.
	From *scalar.Date `json:"from,omitempty"`
	// The end of the range.
	To *scalar.Date `json:"to,omitempty"`
}

// Resource utilization for app type.
type ResourceUtilizationForApp struct {
	// CPU resource utilization data for the environment.
	CPU []*ResourceUtilization `json:"cpu"`
	// Memory resource utilization data for the environment.
	Memory []*ResourceUtilization `json:"memory"`
}

// Resource utilization for env type.
type ResourceUtilizationForEnv struct {
	// Name of the environment.
	Env string `json:"env"`
	// CPU resource utilization data for the environment.
	CPU []*ResourceUtilization `json:"cpu"`
	// Memory resource utilization data for the environment.
	Memory []*ResourceUtilization `json:"memory"`
}

// Resource utilization overage cost for team type.
type ResourceUtilizationOverageForTeam struct {
	// The sum of the overage cost for all apps.
	OverageCost float64 `json:"overageCost"`
	// Timestamp used for the calculated values.
	Timestamp time.Time `json:"timestamp"`
	// List of CPU overage data for all apps.
	CPU []*AppWithResourceUtilizationOverage `json:"cpu"`
	// List of memory overage data for all apps.
	Memory []*AppWithResourceUtilizationOverage `json:"memory"`
}

// Resource utilization trend type.
type ResourceUtilizationTrend struct {
	// The current CPU utilization.
	CurrentCPUUtilization float64 `json:"currentCpuUtilization"`
	// The average CPU utilization from the previous week.
	AverageCPUUtilization float64 `json:"averageCpuUtilization"`
	// The CPU utilization trend in percentage.
	CPUUtilizationTrend float64 `json:"cpuUtilizationTrend"`
	// The current memory utilization.
	CurrentMemoryUtilization float64 `json:"currentMemoryUtilization"`
	// The average memory utilization from the previous week.
	AverageMemoryUtilization float64 `json:"averageMemoryUtilization"`
	// The memory utilization trend in percentage.
	MemoryUtilizationTrend float64 `json:"memoryUtilizationTrend"`
}

type Resources struct {
	Limits   Limits   `json:"limits"`
	Requests Requests `json:"requests"`
}

type RestartAppResult struct {
	Error *string `json:"error,omitempty"`
}

type Rule struct {
	Application       string `json:"application"`
	Namespace         string `json:"namespace"`
	Cluster           string `json:"cluster"`
	Mutual            bool   `json:"mutual"`
	MutualExplanation string `json:"mutualExplanation"`
	IsJob             bool   `json:"isJob"`
}

type SearchFilter struct {
	Type *SearchType `json:"type,omitempty"`
}

type SearchList struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Nodes    []SearchNode `json:"nodes"`
}

type Sidecar struct {
	AutoLogin            bool      `json:"autoLogin"`
	AutoLoginIgnorePaths []string  `json:"autoLoginIgnorePaths"`
	Resources            Resources `json:"resources"`
}

// Slack alerts channel type.
type SlackAlertsChannel struct {
	// The environment for the alerts sent to the channel.
	Environment string `json:"environment"`
	// The name of the Slack channel.
	ChannelName string `json:"channelName"`
}

// Slack alerts channel input.
type SlackAlertsChannelInput struct {
	// The environment for the alerts sent to the channel.
	Environment string `json:"environment"`
	// The name of the Slack channel.
	ChannelName *string `json:"channelName,omitempty"`
}

type SQLInstanceCondition struct {
	Message string `json:"message"`
	Reason  string `json:"reason"`
	Status  string `json:"status"`
	Type    string `json:"type"`
}

type SQLInstanceStatus struct {
	Conditions []*SQLInstanceCondition `json:"conditions"`
}

type SQLInstancesList struct {
	Nodes    []*SQLInstance `json:"nodes"`
	PageInfo PageInfo       `json:"pageInfo"`
}

type SQLInstancesStatus struct {
	Total   int `json:"total"`
	Failing int `json:"failing"`
}

type Subscription struct {
}

// Sync error type.
type SyncError struct {
	// Creation time of the error.
	CreatedAt time.Time `json:"createdAt"`
	// The name of the reconciler.
	Reconciler string `json:"reconciler"`
	// Error message.
	Error string `json:"error"`
}

type SynchronizationFailingError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Detail   string     `json:"detail"`
}

func (SynchronizationFailingError) IsStateError()             {}
func (this SynchronizationFailingError) GetRevision() string  { return this.Revision }
func (this SynchronizationFailingError) GetLevel() ErrorLevel { return this.Level }

// Paginated teams type.
type TeamList struct {
	// The list of teams.
	Nodes []*Team `json:"nodes"`
	// Pagination information.
	PageInfo PageInfo `json:"pageInfo"`
}

// Team member input.
type TeamMemberInput struct {
	// The ID of user.
	UserID scalar.Ident `json:"userId"`
	// The role that the user will receive.
	Role TeamRole `json:"role"`
	// Reconcilers to opt the team member out of.
	ReconcilerOptOuts []string `json:"reconcilerOptOuts,omitempty"`
}

type TeamMemberList struct {
	Nodes    []*TeamMember `json:"nodes"`
	PageInfo PageInfo      `json:"pageInfo"`
}

// Team status.
type TeamStatus struct {
	Apps         AppsStatus         `json:"apps"`
	Jobs         JobsStatus         `json:"jobs"`
	SQLInstances SQLInstancesStatus `json:"sqlInstances"`
}

// Input for filtering teams.
type TeamsFilter struct {
	Github *TeamsFilterGitHub `json:"github,omitempty"`
}

type TeamsFilterGitHub struct {
	// Filter repostiories by repo name
	RepoName string `json:"repoName"`
	// Filter repostiories by permission name
	PermissionName string `json:"permissionName"`
}

type TokenX struct {
	MountSecretsAsFilesOnly bool `json:"mountSecretsAsFilesOnly"`
}

func (TokenX) IsAuthz() {}

type Topic struct {
	Name string `json:"name"`
	ACL  []*ACL `json:"acl"`
}

// Input for updating an existing team.
type UpdateTeamInput struct {
	// Specify team purpose to update the existing value.
	Purpose *string `json:"purpose,omitempty"`
	// Specify the Slack channel to update the existing value.
	SlackChannel *string `json:"slackChannel,omitempty"`
	// A list of Slack channels for NAIS alerts.
	SlackAlertsChannels []*SlackAlertsChannelInput `json:"slackAlertsChannels,omitempty"`
}

type UserList struct {
	Nodes    []*User  `json:"nodes"`
	PageInfo PageInfo `json:"pageInfo"`
}

type Variable struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type VariableInput struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type Vulnerability struct {
	ID           scalar.Ident          `json:"id"`
	AppName      string                `json:"appName"`
	Env          string                `json:"env"`
	FindingsLink string                `json:"findingsLink"`
	Summary      *VulnerabilitySummary `json:"summary,omitempty"`
	HasBom       bool                  `json:"hasBom"`
}

type VulnerabilityFilter struct {
	// Filter by environment
	Envs []string `json:"envs,omitempty"`
	// Require the presence of a Software Bill of Materials (SBOM) in the vulnerability report.
	RequireSbom *bool `json:"requireSbom,omitempty"`
}

type VulnerabilityList struct {
	Nodes    []*Vulnerability `json:"nodes"`
	PageInfo PageInfo         `json:"pageInfo"`
}

type VulnerabilityMetric struct {
	// The date of the metric.
	Date time.Time `json:"date"`
	// The number of critical vulnerabilities.
	Critical int `json:"critical"`
	// The number of high vulnerabilities.
	High int `json:"high"`
	// The number of medium vulnerabilities.
	Medium int `json:"medium"`
	// The number of low vulnerabilities.
	Low int `json:"low"`
	// The number of unassigned vulnerabilities.
	Unassigned int `json:"unassigned"`
	// The weighted severity score calculated from the number of vulnerabilities.
	RiskScore int `json:"riskScore"`
}

type VulnerabilityMetrics struct {
	// The minimum date for the metrics available in the database.
	MinDate *scalar.Date `json:"minDate,omitempty"`
	// The maximum date for the metrics available in the database.
	MaxDate *scalar.Date `json:"maxDate,omitempty"`
	// The metrics for the team's applications.
	Data []*VulnerabilityMetric `json:"data"`
}

type VulnerabilitySummary struct {
	Total      int `json:"total"`
	RiskScore  int `json:"riskScore"`
	Critical   int `json:"critical"`
	High       int `json:"high"`
	Medium     int `json:"medium"`
	Low        int `json:"low"`
	Unassigned int `json:"unassigned"`
	BomCount   int `json:"bomCount"`
}

type ErrorLevel string

const (
	ErrorLevelTodo    ErrorLevel = "TODO"
	ErrorLevelWarning ErrorLevel = "WARNING"
	ErrorLevelError   ErrorLevel = "ERROR"
)

var AllErrorLevel = []ErrorLevel{
	ErrorLevelTodo,
	ErrorLevelWarning,
	ErrorLevelError,
}

func (e ErrorLevel) IsValid() bool {
	switch e {
	case ErrorLevelTodo, ErrorLevelWarning, ErrorLevelError:
		return true
	}
	return false
}

func (e ErrorLevel) String() string {
	return string(e)
}

func (e *ErrorLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorLevel", str)
	}
	return nil
}

func (e ErrorLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstanceState string

const (
	InstanceStateRunning InstanceState = "RUNNING"
	InstanceStateFailing InstanceState = "FAILING"
	InstanceStateUnknown InstanceState = "UNKNOWN"
)

var AllInstanceState = []InstanceState{
	InstanceStateRunning,
	InstanceStateFailing,
	InstanceStateUnknown,
}

func (e InstanceState) IsValid() bool {
	switch e {
	case InstanceStateRunning, InstanceStateFailing, InstanceStateUnknown:
		return true
	}
	return false
}

func (e InstanceState) String() string {
	return string(e)
}

func (e *InstanceState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstanceState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstanceState", str)
	}
	return nil
}

func (e InstanceState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderByField string

const (
	// Order by name
	OrderByFieldName OrderByField = "NAME"
	// Order by env
	OrderByFieldEnv OrderByField = "ENV"
	// Order by deployed time
	OrderByFieldDeployed OrderByField = "DEPLOYED"
	// Order by status
	OrderByFieldStatus OrderByField = "STATUS"
	// Order by appName.
	OrderByFieldAppName OrderByField = "APP_NAME"
	// Order by env.
	OrderByFieldEnvName OrderByField = "ENV_NAME"
	// Order by risk score
	OrderByFieldRiskScore OrderByField = "RISK_SCORE"
	// Order apps by vulnerability severity critical
	OrderByFieldSeverityCritical OrderByField = "SEVERITY_CRITICAL"
	// Order apps by vulnerability severity high
	OrderByFieldSeverityHigh OrderByField = "SEVERITY_HIGH"
	// Order apps by vulnerability severity medium
	OrderByFieldSeverityMedium OrderByField = "SEVERITY_MEDIUM"
	// Order apps by vulnerability severity low
	OrderByFieldSeverityLow OrderByField = "SEVERITY_LOW"
	// Order apps by vulnerability severity unassigned
	OrderByFieldSeverityUnassigned OrderByField = "SEVERITY_UNASSIGNED"
	// Order by PostgreSQL version
	OrderByFieldVersion OrderByField = "VERSION"
)

var AllOrderByField = []OrderByField{
	OrderByFieldName,
	OrderByFieldEnv,
	OrderByFieldDeployed,
	OrderByFieldStatus,
	OrderByFieldAppName,
	OrderByFieldEnvName,
	OrderByFieldRiskScore,
	OrderByFieldSeverityCritical,
	OrderByFieldSeverityHigh,
	OrderByFieldSeverityMedium,
	OrderByFieldSeverityLow,
	OrderByFieldSeverityUnassigned,
	OrderByFieldVersion,
}

func (e OrderByField) IsValid() bool {
	switch e {
	case OrderByFieldName, OrderByFieldEnv, OrderByFieldDeployed, OrderByFieldStatus, OrderByFieldAppName, OrderByFieldEnvName, OrderByFieldRiskScore, OrderByFieldSeverityCritical, OrderByFieldSeverityHigh, OrderByFieldSeverityMedium, OrderByFieldSeverityLow, OrderByFieldSeverityUnassigned, OrderByFieldVersion:
		return true
	}
	return false
}

func (e OrderByField) String() string {
	return string(e)
}

func (e *OrderByField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderByField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderByField", str)
	}
	return nil
}

func (e OrderByField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Repository authorizations.
type RepositoryAuthorization string

const (
	// Authorize for NAIS deployment.
	RepositoryAuthorizationDeploy RepositoryAuthorization = "DEPLOY"
)

var AllRepositoryAuthorization = []RepositoryAuthorization{
	RepositoryAuthorizationDeploy,
}

func (e RepositoryAuthorization) IsValid() bool {
	switch e {
	case RepositoryAuthorizationDeploy:
		return true
	}
	return false
}

func (e RepositoryAuthorization) String() string {
	return string(e)
}

func (e *RepositoryAuthorization) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryAuthorization(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryAuthorization", str)
	}
	return nil
}

func (e RepositoryAuthorization) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Resource type.
type ResourceType string

const (
	ResourceTypeCPU    ResourceType = "CPU"
	ResourceTypeMemory ResourceType = "MEMORY"
)

var AllResourceType = []ResourceType{
	ResourceTypeCPU,
	ResourceTypeMemory,
}

func (e ResourceType) IsValid() bool {
	switch e {
	case ResourceTypeCPU, ResourceTypeMemory:
		return true
	}
	return false
}

func (e ResourceType) String() string {
	return string(e)
}

func (e *ResourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceType", str)
	}
	return nil
}

func (e ResourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SearchType string

const (
	SearchTypeApp     SearchType = "APP"
	SearchTypeTeam    SearchType = "TEAM"
	SearchTypeNaisjob SearchType = "NAISJOB"
)

var AllSearchType = []SearchType{
	SearchTypeApp,
	SearchTypeTeam,
	SearchTypeNaisjob,
}

func (e SearchType) IsValid() bool {
	switch e {
	case SearchTypeApp, SearchTypeTeam, SearchTypeNaisjob:
		return true
	}
	return false
}

func (e SearchType) String() string {
	return string(e)
}

func (e *SearchType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchType", str)
	}
	return nil
}

func (e SearchType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortOrder string

const (
	// Ascending sort order.
	SortOrderAsc SortOrder = "ASC"
	// Descending sort order.
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type State string

const (
	StateNais    State = "NAIS"
	StateNotnais State = "NOTNAIS"
	StateFailing State = "FAILING"
	StateUnknown State = "UNKNOWN"
)

var AllState = []State{
	StateNais,
	StateNotnais,
	StateFailing,
	StateUnknown,
}

func (e State) IsValid() bool {
	switch e {
	case StateNais, StateNotnais, StateFailing, StateUnknown:
		return true
	}
	return false
}

func (e State) String() string {
	return string(e)
}

func (e *State) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = State(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid State", str)
	}
	return nil
}

func (e State) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Available team roles.
type TeamRole string

const (
	// Regular member, read only access.
	TeamRoleMember TeamRole = "MEMBER"
	// Team owner, full access to the team.
	TeamRoleOwner TeamRole = "OWNER"
)

var AllTeamRole = []TeamRole{
	TeamRoleMember,
	TeamRoleOwner,
}

func (e TeamRole) IsValid() bool {
	switch e {
	case TeamRoleMember, TeamRoleOwner:
		return true
	}
	return false
}

func (e TeamRole) String() string {
	return string(e)
}

func (e *TeamRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamRole", str)
	}
	return nil
}

func (e TeamRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// User sync run status.
type UserSyncRunStatus string

const (
	// User sync run in progress.
	UserSyncRunStatusInProgress UserSyncRunStatus = "IN_PROGRESS"
	// Successful user sync run.
	UserSyncRunStatusSuccess UserSyncRunStatus = "SUCCESS"
	// Failed user sync run.
	UserSyncRunStatusFailure UserSyncRunStatus = "FAILURE"
)

var AllUserSyncRunStatus = []UserSyncRunStatus{
	UserSyncRunStatusInProgress,
	UserSyncRunStatusSuccess,
	UserSyncRunStatusFailure,
}

func (e UserSyncRunStatus) IsValid() bool {
	switch e {
	case UserSyncRunStatusInProgress, UserSyncRunStatusSuccess, UserSyncRunStatusFailure:
		return true
	}
	return false
}

func (e UserSyncRunStatus) String() string {
	return string(e)
}

func (e *UserSyncRunStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserSyncRunStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserSyncRunStatus", str)
	}
	return nil
}

func (e UserSyncRunStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

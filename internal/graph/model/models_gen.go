// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/slug"
)

// Audit event type.
type AuditEvent interface {
	IsAuditEvent()
}

type AuditEventNode interface {
	IsAuditEventNode()
}

// Authenticated user type. Can be a user or a service account.
type AuthenticatedUser interface {
	IsAuthenticatedUser()
}

type Authz interface {
	IsAuthz()
}

type DeploymentResponse interface {
	IsDeploymentResponse()
}

type ScalingStrategy interface {
	IsScalingStrategy()
}

type StateError interface {
	IsStateError()
}

type Workload interface {
	IsWorkload()
}

type AccessPolicy struct {
	Inbound  Inbound  `json:"inbound"`
	Outbound Outbound `json:"outbound"`
}

type AnalysisComment struct {
	Comment    string    `json:"comment"`
	Timestamp  time.Time `json:"timestamp"`
	OnBehalfOf string    `json:"onBehalfOf"`
}

type AnalysisCommentList struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Nodes    []*AnalysisComment `json:"nodes"`
}

// App cost type.
type AppCost struct {
	// The name of the application.
	App string `json:"app"`
	// The sum of all cost entries for the application in euros.
	Sum float64 `json:"sum"`
	// A list of cost entries for the application.
	Cost []*CostEntry `json:"cost"`
}

type AppList struct {
	Nodes    []*App   `json:"nodes"`
	PageInfo PageInfo `json:"pageInfo"`
}

// Team status for apps.
type AppsStatus struct {
	Failing         int `json:"failing"`
	NotNais         int `json:"notNais"`
	Vulnerabilities int `json:"vulnerabilities"`
}

type AuditEventMemberAddedData struct {
	MemberEmail string   `json:"memberEmail"`
	Role        TeamRole `json:"role"`
}

type AuditEventMemberRemovedData struct {
	MemberEmail string `json:"memberEmail"`
}

type AuditEventMemberSetRoleData struct {
	MemberEmail string   `json:"memberEmail"`
	Role        TeamRole `json:"role"`
}

type AuditEventTeamAddRepositoryData struct {
	RepositoryName string `json:"repositoryName"`
}

type AuditEventTeamRemoveRepositoryData struct {
	RepositoryName string `json:"repositoryName"`
}

type AuditEventTeamSetAlertsSlackChannelData struct {
	Environment string `json:"environment"`
	ChannelName string `json:"channelName"`
}

type AuditEventTeamSetDefaultSlackChannelData struct {
	DefaultSlackChannel string `json:"defaultSlackChannel"`
}

type AuditEventTeamSetPurposeData struct {
	Purpose string `json:"purpose"`
}

type AuditEventsFilter struct {
	// Filter by the type of the resource that was affected by the action.
	ResourceType *AuditEventResourceType `json:"resourceType,omitempty"`
}

// Audit log type.
type AuditLog struct {
	// ID of the log entry.
	ID scalar.Ident `json:"id"`
	// String representation of the action performed.
	Action string `json:"action"`
	// The related correlation ID.
	CorrelationID string `json:"correlationID"`
	// The identity of the actor who performed the action. When this field is empty it means that some backend process performed the action. The value, when present, is either the name of a service account, or the email address of a user.
	Actor *string `json:"actor,omitempty"`
	// The type of the audit log target.
	TargetType string `json:"targetType"`
	// The identifier of the target.
	TargetIdentifier string `json:"targetIdentifier"`
	// Log entry message.
	Message string `json:"message"`
	// Creation time of the log entry.
	CreatedAt time.Time `json:"createdAt"`
}

type AuditLogList struct {
	Nodes    []*AuditLog `json:"nodes"`
	PageInfo PageInfo    `json:"pageInfo"`
}

type AzureAd struct {
	Application *AzureApplication `json:"application,omitempty"`
	Sidecar     *Sidecar          `json:"sidecar,omitempty"`
}

func (AzureAd) IsAuthz() {}

type AzureApplication struct {
	AllowAllUsers         bool     `json:"allowAllUsers"`
	Claims                Claims   `json:"claims"`
	ReplyURLs             []string `json:"replyURLs"`
	SinglePageApplication bool     `json:"singlePageApplication"`
	Tenant                string   `json:"tenant"`
}

type CPUScalingStrategy struct {
	Threshold int `json:"threshold"`
}

func (CPUScalingStrategy) IsScalingStrategy() {}

type Claims struct {
	Extra  []string `json:"extra"`
	Groups []*Group `json:"groups"`
}

type Consume struct {
	Name string `json:"name"`
}

type Consumer struct {
	Name  string `json:"name"`
	Orgno string `json:"orgno"`
}

// Cost entry type.
type CostEntry struct {
	// The date for the entry.
	Date scalar.Date `json:"date"`
	// The cost in euros.
	Cost float64 `json:"cost"`
}

// Cost series type.
type CostSeries struct {
	// The type of cost.
	CostType string `json:"costType"`
	// The sum of all daily costs in the series for this cost type in euros.
	Sum float64 `json:"sum"`
	// The cost data.
	Data []*CostEntry `json:"data"`
}

// Daily cost type.
type DailyCost struct {
	// The sum of all costs in the cost series in euros.
	Sum float64 `json:"sum"`
	// The cost series.
	Series []*CostSeries `json:"series"`
}

type DeleteAppResult struct {
	// Whether the app was deleted or not.
	Deleted bool    `json:"deleted"`
	Error   *string `json:"error,omitempty"`
}

type DeleteJobResult struct {
	// Whether the job was deleted or not.
	Deleted bool    `json:"deleted"`
	Error   *string `json:"error,omitempty"`
}

type Deployment struct {
	ID         scalar.Ident          `json:"id"`
	Team       Team                  `json:"team"`
	Resources  []*DeploymentResource `json:"resources"`
	Env        string                `json:"env"`
	Statuses   []*DeploymentStatus   `json:"statuses"`
	Created    time.Time             `json:"created"`
	Repository string                `json:"repository"`
}

// Deployment key type.
type DeploymentKey struct {
	// The unique identifier of the deployment key.
	ID scalar.Ident `json:"id"`
	// The actual key.
	Key string `json:"key"`
	// The date the deployment key was created.
	Created time.Time `json:"created"`
	// The date the deployment key expires.
	Expires time.Time `json:"expires"`
}

type DeploymentList struct {
	Nodes    []*Deployment `json:"nodes"`
	PageInfo PageInfo      `json:"pageInfo"`
}

func (DeploymentList) IsDeploymentResponse() {}

type DeploymentResource struct {
	ID        scalar.Ident `json:"id"`
	Group     string       `json:"group"`
	Kind      string       `json:"kind"`
	Name      string       `json:"name"`
	Version   string       `json:"version"`
	Namespace string       `json:"namespace"`
}

type DeploymentStatus struct {
	ID      scalar.Ident `json:"id"`
	Status  string       `json:"status"`
	Message *string      `json:"message,omitempty"`
	Created time.Time    `json:"created"`
}

type DeprecatedIngressError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Ingress  string     `json:"ingress"`
}

func (DeprecatedIngressError) IsStateError() {}

type DeprecatedRegistryError struct {
	Revision   string     `json:"revision"`
	Level      ErrorLevel `json:"level"`
	Registry   string     `json:"registry"`
	Repository string     `json:"repository"`
	Name       string     `json:"name"`
	Tag        string     `json:"tag"`
}

func (DeprecatedRegistryError) IsStateError() {}

// Env cost type.
type EnvCost struct {
	// The name of the environment.
	Env string `json:"env"`
	// The sum of all app costs for the environment in euros.
	Sum float64 `json:"sum"`
	// A list of app costs in the environment.
	Apps []*AppCost `json:"apps"`
}

// Env cost filter input type.
type EnvCostFilter struct {
	// Start date for the cost series, inclusive.
	From scalar.Date `json:"from"`
	// End date for cost series, inclusive.
	To scalar.Date `json:"to"`
	// The name of the team to get costs for.
	Team slug.Slug `json:"team"`
}

type Error struct {
	Message string `json:"message"`
}

func (Error) IsDeploymentResponse() {}

type Expose struct {
	AllowedIntegrations []string    `json:"allowedIntegrations"`
	AtMaxAge            int         `json:"atMaxAge"`
	Consumers           []*Consumer `json:"consumers"`
	Enabled             bool        `json:"enabled"`
	Name                string      `json:"name"`
	Product             string      `json:"product"`
}

type External struct {
	Host  *string `json:"host,omitempty"`
	IPv4  *string `json:"IPv4,omitempty"`
	Ports []*Port `json:"ports"`
}

type FailedRunError struct {
	Revision   string     `json:"revision"`
	Level      ErrorLevel `json:"level"`
	RunMessage string     `json:"runMessage"`
	RunName    string     `json:"runName"`
}

func (FailedRunError) IsStateError() {}

// GCP project type.
type GCPProject struct {
	// The environment for the project.
	Environment string `json:"environment"`
	// The display name of the project.
	ProjectName string `json:"projectName"`
	// The GCP project ID.
	ProjectID string `json:"projectId"`
}

// Input for filtering GitHub repositories.
type GitHubRepositoriesFilter struct {
	// Whether or not to include archived repositories. Defaults to false.
	IncludeArchivedRepositories *bool `json:"includeArchivedRepositories,omitempty"`
}

// Paginated GitHub repository type.
type GitHubRepositoryList struct {
	// The list of GitHub repositories.
	Nodes []*GitHubRepository `json:"nodes"`
	// Pagination information.
	PageInfo PageInfo `json:"pageInfo"`
}

// GitHub repository permission type.
type GitHubRepositoryPermission struct {
	// Name of the permission.
	Name string `json:"name"`
	// Whether or not the permission is granted for the repository.
	Granted bool `json:"granted"`
}

type Group struct {
	ID string `json:"id"`
}

type IDPorten struct {
	AccessTokenLifetime    *int             `json:"accessTokenLifetime,omitempty"`
	ClientURI              *string          `json:"clientURI,omitempty"`
	FrontchannelLogoutPath *string          `json:"frontchannelLogoutPath,omitempty"`
	IntegrationType        *string          `json:"integrationType,omitempty"`
	PostLogoutRedirectURIs []*string        `json:"postLogoutRedirectURIs,omitempty"`
	RedirectPath           *string          `json:"redirectPath,omitempty"`
	Scopes                 []*string        `json:"scopes,omitempty"`
	SessionLifetime        *int             `json:"sessionLifetime,omitempty"`
	Sidecar                *IDPortenSidecar `json:"sidecar,omitempty"`
}

func (IDPorten) IsAuthz() {}

type IDPortenSidecar struct {
	AutoLogin            *bool      `json:"autoLogin,omitempty"`
	AutoLoginIgnorePaths []*string  `json:"autoLoginIgnorePaths,omitempty"`
	Enabled              *bool      `json:"enabled,omitempty"`
	Level                *string    `json:"level,omitempty"`
	Locale               *string    `json:"locale,omitempty"`
	Resources            *Resources `json:"resources,omitempty"`
}

type ImageDetailsList struct {
	Nodes    []*ImageDetails `json:"nodes"`
	PageInfo PageInfo        `json:"pageInfo"`
}

type ImageVulnerabilitySummary struct {
	ID         scalar.Ident `json:"id"`
	Total      int          `json:"total"`
	RiskScore  int          `json:"riskScore"`
	Critical   int          `json:"critical"`
	High       int          `json:"high"`
	Medium     int          `json:"medium"`
	Low        int          `json:"low"`
	Unassigned int          `json:"unassigned"`
}

type Inbound struct {
	Rules []*Rule `json:"rules"`
}

type InboundAccessError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Rule     Rule       `json:"rule"`
}

func (InboundAccessError) IsStateError() {}

type InvalidNaisYamlError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Detail   string     `json:"detail"`
}

func (InvalidNaisYamlError) IsStateError() {}

// Team status for jobs.
type JobsStatus struct {
	Failing         int `json:"failing"`
	NotNais         int `json:"notNais"`
	Vulnerabilities int `json:"vulnerabilities"`
}

type KafkaLagScalingStrategy struct {
	Threshold     int    `json:"threshold"`
	ConsumerGroup string `json:"consumerGroup"`
	Topic         string `json:"topic"`
}

func (KafkaLagScalingStrategy) IsScalingStrategy() {}

type Limits struct {
	CPU    string `json:"cpu"`
	Memory string `json:"memory"`
}

type LogLine struct {
	Time     time.Time `json:"time"`
	Message  string    `json:"message"`
	Instance string    `json:"instance"`
}

type LogSubscriptionInput struct {
	App       *string   `json:"app,omitempty"`
	Job       *string   `json:"job,omitempty"`
	Env       string    `json:"env"`
	Team      slug.Slug `json:"team"`
	Instances []string  `json:"instances,omitempty"`
}

type Maskinporten struct {
	Scopes  MaskinportenScope `json:"scopes"`
	Enabled bool              `json:"enabled"`
}

func (Maskinporten) IsAuthz() {}

type MaskinportenScope struct {
	Consumes []*Consume `json:"consumes"`
	Exposes  []*Expose  `json:"exposes"`
}

type MissingSbomError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
}

func (MissingSbomError) IsStateError() {}

// Monthly cost type.
type MonthlyCost struct {
	// Sum for all months in the series in euros.
	Sum float64 `json:"sum"`
	// A list of monthly cost entries.
	Cost []*CostEntry `json:"cost"`
}

// Monthly cost filter input type.
type MonthlyCostFilter struct {
	// The name of the team to get costs for.
	Team slug.Slug `json:"team"`
	// The name of the application to get costs for.
	App string `json:"app"`
	// The name of the environment to get costs for.
	Env string `json:"env"`
}

// The root query for implementing GraphQL mutations.
type Mutation struct {
}

type NaisJobList struct {
	Nodes    []*NaisJob `json:"nodes"`
	PageInfo PageInfo   `json:"pageInfo"`
}

// NAIS namespace type.
type NaisNamespace struct {
	// The environment for the namespace.
	Environment string `json:"environment"`
	// The namespace.
	Namespace slug.Slug `json:"namespace"`
}

type NewInstancesFailingError struct {
	Revision         string     `json:"revision"`
	Level            ErrorLevel `json:"level"`
	FailingInstances []string   `json:"failingInstances"`
}

func (NewInstancesFailingError) IsStateError() {}

type NoRunningInstancesError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
}

func (NoRunningInstancesError) IsStateError() {}

type OrderBy struct {
	// Order direction.
	Direction SortOrder `json:"direction"`
	// The field to order by.
	Field OrderByField `json:"field"`
}

type Outbound struct {
	Rules    []*Rule     `json:"rules"`
	External []*External `json:"external"`
}

type OutboundAccessError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Rule     Rule       `json:"rule"`
}

func (OutboundAccessError) IsStateError() {}

// Pagination information.
type PageInfo struct {
	// The total amount if items accessible.
	TotalCount int `json:"totalCount"`
	// Whether or not there exists a next page in the data set.
	HasNextPage bool `json:"hasNextPage"`
	// Whether or not there exists a previous page in the data set.
	HasPreviousPage bool `json:"hasPreviousPage"`
}

type Port struct {
	Port int `json:"port"`
}

// The query root for the NAIS GraphQL API.
type Query struct {
}

// Reconciler configuration type.
type ReconcilerConfig struct {
	// Configuration key.
	Key string `json:"key"`
	// The human-friendly name of the configuration key.
	DisplayName string `json:"displayName"`
	// Configuration description.
	Description string `json:"description"`
	// Whether or not the configuration key has a value.
	Configured bool `json:"configured"`
	// Whether or not the configuration value is considered a secret. Secret values will not be exposed through the API.
	Secret bool `json:"secret"`
	// Configuration value. This will be set to null if the value is considered a secret.
	Value *string `json:"value,omitempty"`
}

// Reconciler configuration input.
type ReconcilerConfigInput struct {
	// Configuration key.
	Key string `json:"key"`
	// Configuration value.
	Value string `json:"value"`
}

type ReconcilerErrorList struct {
	Nodes    []*ReconcilerError `json:"nodes"`
	PageInfo PageInfo           `json:"pageInfo"`
}

// Paginated reconcilers type.
type ReconcilerList struct {
	// The list of reconcilers.
	Nodes []*Reconciler `json:"nodes"`
	// Pagination information.
	PageInfo PageInfo `json:"pageInfo"`
}

type Rekor struct {
	BuildTrigger             string `json:"buildTrigger"`
	BuildConfigURI           string `json:"buildConfigURI"`
	GitHubWorkflowName       string `json:"gitHubWorkflowName"`
	GitHubWorkflowRef        string `json:"gitHubWorkflowRef"`
	GitHubWorkflowSha        string `json:"gitHubWorkflowSHA"`
	LogIndex                 string `json:"logIndex"`
	OIDCIssuer               string `json:"oIDCIssuer"`
	RunInvocationURI         string `json:"runInvocationURI"`
	RunnerEnvironment        string `json:"runnerEnvironment"`
	SourceRepositoryOwnerURI string `json:"sourceRepositoryOwnerURI"`
	IntegratedTime           int    `json:"integratedTime"`
	ImageDigestSha           string `json:"imageDigestSHA"`
}

type RepositoryList struct {
	// The list of repositories.
	Nodes []string `json:"nodes"`
	// Pagination information.
	PageInfo PageInfo `json:"pageInfo"`
}

type Requests struct {
	CPU    string `json:"cpu"`
	Memory string `json:"memory"`
}

// A teams inventory of resources.
type ResourceInventory struct {
	TotalJobs                int  `json:"totalJobs"`
	TotalApps                int  `json:"totalApps"`
	TotalSQLInstances        int  `json:"totalSqlInstances"`
	TotalRedisInstances      int  `json:"totalRedisInstances"`
	TotalOpenSearchInstances int  `json:"totalOpenSearchInstances"`
	TotalKafkaTopics         int  `json:"totalKafkaTopics"`
	TotalBuckets             int  `json:"totalBuckets"`
	TotalBigQueryDatasets    int  `json:"totalBigQueryDatasets"`
	TotalBucket              int  `json:"totalBucket"`
	IsEmpty                  bool `json:"isEmpty"`
}

type RestartAppResult struct {
	Error *string `json:"error,omitempty"`
}

type Rule struct {
	Application       string `json:"application"`
	Namespace         string `json:"namespace"`
	Cluster           string `json:"cluster"`
	Mutual            bool   `json:"mutual"`
	MutualExplanation string `json:"mutualExplanation"`
	IsJob             bool   `json:"isJob"`
}

type Scaling struct {
	Min        int               `json:"min"`
	Max        int               `json:"max"`
	Strategies []ScalingStrategy `json:"strategies"`
}

type Sidecar struct {
	AutoLogin            bool      `json:"autoLogin"`
	AutoLoginIgnorePaths []string  `json:"autoLoginIgnorePaths"`
	Resources            Resources `json:"resources"`
}

// Slack alerts channel type.
type SlackAlertsChannel struct {
	// The environment for the alerts sent to the channel.
	Environment string `json:"environment"`
	// The name of the Slack channel.
	ChannelName string `json:"channelName"`
}

type SQLInstancesStatus struct {
	Total           int `json:"total"`
	Failing         int `json:"failing"`
	OtherConditions int `json:"otherConditions"`
}

type Subscription struct {
}

// Sync error type.
type SyncError struct {
	// Creation time of the error.
	CreatedAt time.Time `json:"createdAt"`
	// The name of the reconciler.
	Reconciler string `json:"reconciler"`
	// Error message.
	Error string `json:"error"`
}

type SynchronizationFailingError struct {
	Revision string     `json:"revision"`
	Level    ErrorLevel `json:"level"`
	Detail   string     `json:"detail"`
}

func (SynchronizationFailingError) IsStateError() {}

// Paginated teams type.
type TeamList struct {
	// The list of teams.
	Nodes []*Team `json:"nodes"`
	// Pagination information.
	PageInfo PageInfo `json:"pageInfo"`
}

type TeamMemberList struct {
	Nodes    []*TeamMember `json:"nodes"`
	PageInfo PageInfo      `json:"pageInfo"`
}

// Team status.
type TeamStatus struct {
	State        State              `json:"state"`
	Apps         AppsStatus         `json:"apps"`
	Jobs         JobsStatus         `json:"jobs"`
	SQLInstances SQLInstancesStatus `json:"sqlInstances"`
}

// Input for filtering teams.
type TeamsFilter struct {
	Github *TeamsFilterGitHub `json:"github,omitempty"`
}

type TeamsFilterGitHub struct {
	// Filter repositories by repo name
	RepoName string `json:"repoName"`
	// Filter repositories by permission name
	PermissionName string `json:"permissionName"`
}

type TokenX struct {
	MountSecretsAsFilesOnly bool `json:"mountSecretsAsFilesOnly"`
}

func (TokenX) IsAuthz() {}

// Slack alerts channel input.
type UpdateTeamSlackAlertsChannelInput struct {
	// The environment for the alerts sent to the channel.
	Environment string `json:"environment"`
	// The name of the Slack channel.
	ChannelName *string `json:"channelName,omitempty"`
}

// Resource utilization type.
type UsageDataPoint struct {
	// Timestamp of the value.
	Timestamp time.Time `json:"timestamp"`
	// Value of the used resource at the given timestamp.
	Value float64 `json:"value"`
}

type UserList struct {
	Nodes    []*User  `json:"nodes"`
	PageInfo PageInfo `json:"pageInfo"`
}

type UsersyncRunList struct {
	Nodes    []*UsersyncRun `json:"nodes"`
	PageInfo PageInfo       `json:"pageInfo"`
}

type Variable struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type VariableInput struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type VulnIDAlias struct {
	Name   string `json:"name"`
	Source string `json:"source"`
}

type VulnerabilityFilter struct {
	// Filter by environment
	Envs []string `json:"envs,omitempty"`
	// Require the presence of a Software Bill of Materials (SBOM) in the vulnerability report.
	RequireSbom *bool `json:"requireSbom,omitempty"`
}

type VulnerabilityList struct {
	Nodes    []*VulnerabilityNode `json:"nodes"`
	PageInfo PageInfo             `json:"pageInfo"`
}

type VulnerabilityNode struct {
	ID           scalar.Ident               `json:"id"`
	WorkloadName string                     `json:"workloadName"`
	WorkloadType string                     `json:"workloadType"`
	Env          string                     `json:"env"`
	Summary      *ImageVulnerabilitySummary `json:"summary,omitempty"`
	HasSbom      bool                       `json:"hasSbom"`
	Status       WorkloadStatus             `json:"status"`
}

type VulnerabilityStatus struct {
	State       VulnerabilityState `json:"state"`
	Title       string             `json:"title"`
	Description string             `json:"description"`
}

type VulnerabilitySummaryForTeam struct {
	RiskScore            int                         `json:"riskScore"`
	RiskScoreTrend       VulnerabilityRiskScoreTrend `json:"riskScoreTrend"`
	Critical             int                         `json:"critical"`
	High                 int                         `json:"high"`
	Medium               int                         `json:"medium"`
	Low                  int                         `json:"low"`
	BomCount             int                         `json:"bomCount"`
	Unassigned           int                         `json:"unassigned"`
	Coverage             float64                     `json:"coverage"`
	TotalWorkloads       int                         `json:"totalWorkloads"`
	VulnerabilityRanking VulnerabilityRanking        `json:"vulnerabilityRanking"`
	Status               []*VulnerabilityStatus      `json:"status"`
}

type VulnerableError struct {
	Revision string                     `json:"revision"`
	Level    ErrorLevel                 `json:"level"`
	Summary  *ImageVulnerabilitySummary `json:"summary,omitempty"`
}

func (VulnerableError) IsStateError() {}

type AuditEventAction string

const (
	AuditEventActionTeamDeletionConfirmed      AuditEventAction = "TEAM_DELETION_CONFIRMED"
	AuditEventActionTeamDeletionRequested      AuditEventAction = "TEAM_DELETION_REQUESTED"
	AuditEventActionTeamDeployKeyRotated       AuditEventAction = "TEAM_DEPLOY_KEY_ROTATED"
	AuditEventActionTeamSetPurpose             AuditEventAction = "TEAM_SET_PURPOSE"
	AuditEventActionTeamSetDefaultSLACkChannel AuditEventAction = "TEAM_SET_DEFAULT_SLACK_CHANNEL"
	AuditEventActionTeamSetAlertsSLACkChannel  AuditEventAction = "TEAM_SET_ALERTS_SLACK_CHANNEL"
	AuditEventActionTeamMemberSetRole          AuditEventAction = "TEAM_MEMBER_SET_ROLE"
	AuditEventActionAdded                      AuditEventAction = "ADDED"
	AuditEventActionCreated                    AuditEventAction = "CREATED"
	AuditEventActionDeleted                    AuditEventAction = "DELETED"
	AuditEventActionRemoved                    AuditEventAction = "REMOVED"
	AuditEventActionRestarted                  AuditEventAction = "RESTARTED"
	AuditEventActionUpdated                    AuditEventAction = "UPDATED"
	AuditEventActionSynchronized               AuditEventAction = "SYNCHRONIZED"
)

var AllAuditEventAction = []AuditEventAction{
	AuditEventActionTeamDeletionConfirmed,
	AuditEventActionTeamDeletionRequested,
	AuditEventActionTeamDeployKeyRotated,
	AuditEventActionTeamSetPurpose,
	AuditEventActionTeamSetDefaultSLACkChannel,
	AuditEventActionTeamSetAlertsSLACkChannel,
	AuditEventActionTeamMemberSetRole,
	AuditEventActionAdded,
	AuditEventActionCreated,
	AuditEventActionDeleted,
	AuditEventActionRemoved,
	AuditEventActionRestarted,
	AuditEventActionUpdated,
	AuditEventActionSynchronized,
}

func (e AuditEventAction) IsValid() bool {
	switch e {
	case AuditEventActionTeamDeletionConfirmed, AuditEventActionTeamDeletionRequested, AuditEventActionTeamDeployKeyRotated, AuditEventActionTeamSetPurpose, AuditEventActionTeamSetDefaultSLACkChannel, AuditEventActionTeamSetAlertsSLACkChannel, AuditEventActionTeamMemberSetRole, AuditEventActionAdded, AuditEventActionCreated, AuditEventActionDeleted, AuditEventActionRemoved, AuditEventActionRestarted, AuditEventActionUpdated, AuditEventActionSynchronized:
		return true
	}
	return false
}

func (e AuditEventAction) String() string {
	return string(e)
}

func (e *AuditEventAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditEventAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditEventAction", str)
	}
	return nil
}

func (e AuditEventAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuditEventResourceType string

const (
	AuditEventResourceTypeApp            AuditEventResourceType = "APP"
	AuditEventResourceTypeNaisjob        AuditEventResourceType = "NAISJOB"
	AuditEventResourceTypeSecret         AuditEventResourceType = "SECRET"
	AuditEventResourceTypeTeam           AuditEventResourceType = "TEAM"
	AuditEventResourceTypeTeamMember     AuditEventResourceType = "TEAM_MEMBER"
	AuditEventResourceTypeTeamRepository AuditEventResourceType = "TEAM_REPOSITORY"
	AuditEventResourceTypeUnleash        AuditEventResourceType = "UNLEASH"
)

var AllAuditEventResourceType = []AuditEventResourceType{
	AuditEventResourceTypeApp,
	AuditEventResourceTypeNaisjob,
	AuditEventResourceTypeSecret,
	AuditEventResourceTypeTeam,
	AuditEventResourceTypeTeamMember,
	AuditEventResourceTypeTeamRepository,
	AuditEventResourceTypeUnleash,
}

func (e AuditEventResourceType) IsValid() bool {
	switch e {
	case AuditEventResourceTypeApp, AuditEventResourceTypeNaisjob, AuditEventResourceTypeSecret, AuditEventResourceTypeTeam, AuditEventResourceTypeTeamMember, AuditEventResourceTypeTeamRepository, AuditEventResourceTypeUnleash:
		return true
	}
	return false
}

func (e AuditEventResourceType) String() string {
	return string(e)
}

func (e *AuditEventResourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditEventResourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditEventResourceType", str)
	}
	return nil
}

func (e AuditEventResourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ErrorLevel string

const (
	ErrorLevelTodo    ErrorLevel = "TODO"
	ErrorLevelWarning ErrorLevel = "WARNING"
	ErrorLevelError   ErrorLevel = "ERROR"
)

var AllErrorLevel = []ErrorLevel{
	ErrorLevelTodo,
	ErrorLevelWarning,
	ErrorLevelError,
}

func (e ErrorLevel) IsValid() bool {
	switch e {
	case ErrorLevelTodo, ErrorLevelWarning, ErrorLevelError:
		return true
	}
	return false
}

func (e ErrorLevel) String() string {
	return string(e)
}

func (e *ErrorLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorLevel", str)
	}
	return nil
}

func (e ErrorLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstanceState string

const (
	InstanceStateRunning InstanceState = "RUNNING"
	InstanceStateFailing InstanceState = "FAILING"
	InstanceStateUnknown InstanceState = "UNKNOWN"
)

var AllInstanceState = []InstanceState{
	InstanceStateRunning,
	InstanceStateFailing,
	InstanceStateUnknown,
}

func (e InstanceState) IsValid() bool {
	switch e {
	case InstanceStateRunning, InstanceStateFailing, InstanceStateUnknown:
		return true
	}
	return false
}

func (e InstanceState) String() string {
	return string(e)
}

func (e *InstanceState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstanceState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstanceState", str)
	}
	return nil
}

func (e InstanceState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderByField string

const (
	// Order by name
	OrderByFieldName OrderByField = "NAME"
	// Order by env
	OrderByFieldEnv OrderByField = "ENV"
	// Order by deployed time
	OrderByFieldDeployed OrderByField = "DEPLOYED"
	// Order by status
	OrderByFieldStatus OrderByField = "STATUS"
	// Order by severity.
	OrderByFieldSeverity OrderByField = "SEVERITY"
	// Order by packageUrl
	OrderByFieldPackageURL OrderByField = "PACKAGE_URL"
	// Order by state.
	OrderByFieldState OrderByField = "STATE"
	// Order by isSuppressed.
	OrderByFieldIsSuppressed OrderByField = "IS_SUPPRESSED"
	// Order by appName.
	OrderByFieldAppName OrderByField = "APP_NAME"
	// Order by env.
	OrderByFieldEnvName OrderByField = "ENV_NAME"
	// Order by risk score
	OrderByFieldRiskScore OrderByField = "RISK_SCORE"
	// Order apps by vulnerability severity critical
	OrderByFieldSeverityCritical OrderByField = "SEVERITY_CRITICAL"
	// Order apps by vulnerability severity high
	OrderByFieldSeverityHigh OrderByField = "SEVERITY_HIGH"
	// Order apps by vulnerability severity medium
	OrderByFieldSeverityMedium OrderByField = "SEVERITY_MEDIUM"
	// Order apps by vulnerability severity low
	OrderByFieldSeverityLow OrderByField = "SEVERITY_LOW"
	// Order apps by vulnerability severity unassigned
	OrderByFieldSeverityUnassigned OrderByField = "SEVERITY_UNASSIGNED"
)

var AllOrderByField = []OrderByField{
	OrderByFieldName,
	OrderByFieldEnv,
	OrderByFieldDeployed,
	OrderByFieldStatus,
	OrderByFieldSeverity,
	OrderByFieldPackageURL,
	OrderByFieldState,
	OrderByFieldIsSuppressed,
	OrderByFieldAppName,
	OrderByFieldEnvName,
	OrderByFieldRiskScore,
	OrderByFieldSeverityCritical,
	OrderByFieldSeverityHigh,
	OrderByFieldSeverityMedium,
	OrderByFieldSeverityLow,
	OrderByFieldSeverityUnassigned,
}

func (e OrderByField) IsValid() bool {
	switch e {
	case OrderByFieldName, OrderByFieldEnv, OrderByFieldDeployed, OrderByFieldStatus, OrderByFieldSeverity, OrderByFieldPackageURL, OrderByFieldState, OrderByFieldIsSuppressed, OrderByFieldAppName, OrderByFieldEnvName, OrderByFieldRiskScore, OrderByFieldSeverityCritical, OrderByFieldSeverityHigh, OrderByFieldSeverityMedium, OrderByFieldSeverityLow, OrderByFieldSeverityUnassigned:
		return true
	}
	return false
}

func (e OrderByField) String() string {
	return string(e)
}

func (e *OrderByField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderByField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderByField", str)
	}
	return nil
}

func (e OrderByField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortOrder string

const (
	// Ascending sort order.
	SortOrderAsc SortOrder = "ASC"
	// Descending sort order.
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type State string

const (
	StateNais    State = "NAIS"
	StateNotnais State = "NOTNAIS"
	StateFailing State = "FAILING"
	StateUnknown State = "UNKNOWN"
)

var AllState = []State{
	StateNais,
	StateNotnais,
	StateFailing,
	StateUnknown,
}

func (e State) IsValid() bool {
	switch e {
	case StateNais, StateNotnais, StateFailing, StateUnknown:
		return true
	}
	return false
}

func (e State) String() string {
	return string(e)
}

func (e *State) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = State(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid State", str)
	}
	return nil
}

func (e State) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Available team roles.
type TeamRole string

const (
	// Regular member, read only access.
	TeamRoleMember TeamRole = "MEMBER"
	// Team owner, full access to the team.
	TeamRoleOwner TeamRole = "OWNER"
)

var AllTeamRole = []TeamRole{
	TeamRoleMember,
	TeamRoleOwner,
}

func (e TeamRole) IsValid() bool {
	switch e {
	case TeamRoleMember, TeamRoleOwner:
		return true
	}
	return false
}

func (e TeamRole) String() string {
	return string(e)
}

func (e *TeamRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamRole", str)
	}
	return nil
}

func (e TeamRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Resource type.
type UsageResourceType string

const (
	UsageResourceTypeCPU    UsageResourceType = "CPU"
	UsageResourceTypeMemory UsageResourceType = "MEMORY"
)

var AllUsageResourceType = []UsageResourceType{
	UsageResourceTypeCPU,
	UsageResourceTypeMemory,
}

func (e UsageResourceType) IsValid() bool {
	switch e {
	case UsageResourceTypeCPU, UsageResourceTypeMemory:
		return true
	}
	return false
}

func (e UsageResourceType) String() string {
	return string(e)
}

func (e *UsageResourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsageResourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UsageResourceType", str)
	}
	return nil
}

func (e UsageResourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// User sync run status.
type UsersyncRunStatus string

const (
	// Successful user sync run.
	UsersyncRunStatusSuccess UsersyncRunStatus = "SUCCESS"
	// Failed user sync run.
	UsersyncRunStatusFailure UsersyncRunStatus = "FAILURE"
)

var AllUsersyncRunStatus = []UsersyncRunStatus{
	UsersyncRunStatusSuccess,
	UsersyncRunStatusFailure,
}

func (e UsersyncRunStatus) IsValid() bool {
	switch e {
	case UsersyncRunStatusSuccess, UsersyncRunStatusFailure:
		return true
	}
	return false
}

func (e UsersyncRunStatus) String() string {
	return string(e)
}

func (e *UsersyncRunStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersyncRunStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UsersyncRunStatus", str)
	}
	return nil
}

func (e UsersyncRunStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VulnerabilityRanking string

const (
	VulnerabilityRankingMostVulnerable  VulnerabilityRanking = "MOST_VULNERABLE"
	VulnerabilityRankingMiddle          VulnerabilityRanking = "MIDDLE"
	VulnerabilityRankingLeastVulnerable VulnerabilityRanking = "LEAST_VULNERABLE"
	VulnerabilityRankingUnknown         VulnerabilityRanking = "UNKNOWN"
)

var AllVulnerabilityRanking = []VulnerabilityRanking{
	VulnerabilityRankingMostVulnerable,
	VulnerabilityRankingMiddle,
	VulnerabilityRankingLeastVulnerable,
	VulnerabilityRankingUnknown,
}

func (e VulnerabilityRanking) IsValid() bool {
	switch e {
	case VulnerabilityRankingMostVulnerable, VulnerabilityRankingMiddle, VulnerabilityRankingLeastVulnerable, VulnerabilityRankingUnknown:
		return true
	}
	return false
}

func (e VulnerabilityRanking) String() string {
	return string(e)
}

func (e *VulnerabilityRanking) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnerabilityRanking(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnerabilityRanking", str)
	}
	return nil
}

func (e VulnerabilityRanking) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VulnerabilityRiskScoreTrend string

const (
	VulnerabilityRiskScoreTrendUp   VulnerabilityRiskScoreTrend = "UP"
	VulnerabilityRiskScoreTrendDown VulnerabilityRiskScoreTrend = "DOWN"
	VulnerabilityRiskScoreTrendFlat VulnerabilityRiskScoreTrend = "FLAT"
)

var AllVulnerabilityRiskScoreTrend = []VulnerabilityRiskScoreTrend{
	VulnerabilityRiskScoreTrendUp,
	VulnerabilityRiskScoreTrendDown,
	VulnerabilityRiskScoreTrendFlat,
}

func (e VulnerabilityRiskScoreTrend) IsValid() bool {
	switch e {
	case VulnerabilityRiskScoreTrendUp, VulnerabilityRiskScoreTrendDown, VulnerabilityRiskScoreTrendFlat:
		return true
	}
	return false
}

func (e VulnerabilityRiskScoreTrend) String() string {
	return string(e)
}

func (e *VulnerabilityRiskScoreTrend) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnerabilityRiskScoreTrend(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnerabilityRiskScoreTrend", str)
	}
	return nil
}

func (e VulnerabilityRiskScoreTrend) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VulnerabilityState string

const (
	VulnerabilityStateOk                         VulnerabilityState = "OK"
	VulnerabilityStateTooManyVulnerableWorkloads VulnerabilityState = "TOO_MANY_VULNERABLE_WORKLOADS"
	VulnerabilityStateCoverageTooLow             VulnerabilityState = "COVERAGE_TOO_LOW"
	VulnerabilityStateVulnerable                 VulnerabilityState = "VULNERABLE"
	VulnerabilityStateMissingSbom                VulnerabilityState = "MISSING_SBOM"
)

var AllVulnerabilityState = []VulnerabilityState{
	VulnerabilityStateOk,
	VulnerabilityStateTooManyVulnerableWorkloads,
	VulnerabilityStateCoverageTooLow,
	VulnerabilityStateVulnerable,
	VulnerabilityStateMissingSbom,
}

func (e VulnerabilityState) IsValid() bool {
	switch e {
	case VulnerabilityStateOk, VulnerabilityStateTooManyVulnerableWorkloads, VulnerabilityStateCoverageTooLow, VulnerabilityStateVulnerable, VulnerabilityStateMissingSbom:
		return true
	}
	return false
}

func (e VulnerabilityState) String() string {
	return string(e)
}

func (e *VulnerabilityState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnerabilityState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnerabilityState", str)
	}
	return nil
}

func (e VulnerabilityState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WorkloadType string

const (
	WorkloadTypeApp     WorkloadType = "APP"
	WorkloadTypeNaisjob WorkloadType = "NAISJOB"
)

var AllWorkloadType = []WorkloadType{
	WorkloadTypeApp,
	WorkloadTypeNaisjob,
}

func (e WorkloadType) IsValid() bool {
	switch e {
	case WorkloadTypeApp, WorkloadTypeNaisjob:
		return true
	}
	return false
}

func (e WorkloadType) String() string {
	return string(e)
}

func (e *WorkloadType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkloadType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkloadType", str)
	}
	return nil
}

func (e WorkloadType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

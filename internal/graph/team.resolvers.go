package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"
	"strings"

	"github.com/nais/api/internal/auth"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/scalar"
)

// ChangeDeployKey is the resolver for the changeDeployKey field.
func (r *mutationResolver) ChangeDeployKey(ctx context.Context, team string) (*model.DeploymentKey, error) {
	if !r.hasAccess(ctx, team) {
		return nil, fmt.Errorf("access denied")
	}

	deployKey, err := r.hookdClient.ChangeDeployKey(ctx, team)
	if err != nil {
		return nil, fmt.Errorf("changing deploy key in Hookd: %w", err)
	}
	return &model.DeploymentKey{
		ID:      scalar.DeployKeyIdent(team),
		Key:     deployKey.Key,
		Created: deployKey.Created,
		Expires: deployKey.Expires,
	}, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *teamResolver) ViewerIsMember(ctx context.Context, obj *model.Team) (bool, error) {
	email, err := auth.GetEmail(ctx)
	if err != nil {
		return false, fmt.Errorf("getting email from context: %w", err)
	}

	members, err := r.teamsClient.GetTeamMembers(ctx, obj.Slug)
	if err != nil {
		return false, fmt.Errorf("getting teams from Teams: %w", err)
	}

	for _, m := range members {
		if strings.EqualFold(m.User.Email, email) {
			if m.Role == "OWNER" || m.Role == "MEMBER" {
				return true, nil
			}
		}
	}

	return false, nil
}

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"

	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/scalar"
)

// SynchronizeUsers is the resolver for the synchronizeUsers field.
func (r *mutationResolver) SynchronizeUsers(ctx context.Context) (*scalar.Ident, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersyncSynchronize)
	if err != nil {
		return uuid.Nil, err
	}

	correlationID, err := uuid.NewUUID()
	if err != nil {
		return uuid.Nil, fmt.Errorf("create log correlation ID: %w", err)
	}

	targets := []auditlogger.Target{
		auditlogger.ComponentTarget(logger.ComponentNameUsersync),
	}
	fields := auditlogger.Fields{
		Action:        auditlogger.AuditActionGraphqlApiUsersSync,
		Actor:         actor,
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Trigger user sync")
	r.userSync <- correlationID

	return correlationID, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, offset *int, limit *int) (*model.UserList, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersList)
	if err != nil {
		return nil, err
	}
	p := model.NewPagination(offset, limit)
	users, total, err := r.database.GetUsers(ctx, p.Offset, p.Limit)
	if err != nil {
		return nil, err
	}

	return &model.UserList{
			Nodes:    users,
			PageInfo: model.NewPageInfo(p, total),
		},
		nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id *scalar.Ident, email *string) (*model.User, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersList)
	if err != nil {
		return nil, err
	}

	if id != nil {
		return dataloader.GetUser(ctx, id)
	}
	if email != nil {
		return r.database.GetUserByEmail(ctx, *email)
	}
	return nil, apierror.Errorf("Either id or email must be specified")
}

// UserSync is the resolver for the userSync field.
func (r *queryResolver) UserSync(ctx context.Context) ([]*model.UserSyncRun, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersyncSynchronize)
	if err != nil {
		return nil, err
	}

	return r.userSyncRuns.GetRuns(), nil
}

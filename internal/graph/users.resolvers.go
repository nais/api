package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"

	"github.com/google/uuid"
	"github.com/nais/api/internal/auditlogger"
	"github.com/nais/api/internal/auditlogger/audittype"
	"github.com/nais/api/internal/auth/authz"
	"github.com/nais/api/internal/auth/roles"
	"github.com/nais/api/internal/database"
	"github.com/nais/api/internal/database/gensql"
	"github.com/nais/api/internal/graph/apierror"
	"github.com/nais/api/internal/graph/dataloader"
	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/logger"
	"github.com/nais/api/internal/usersync"
	"k8s.io/utils/ptr"
)

// SynchronizeUsers is the resolver for the synchronizeUsers field.
func (r *mutationResolver) SynchronizeUsers(ctx context.Context) (string, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersyncSynchronize)
	if err != nil {
		return "", err
	}

	correlationID := uuid.New()

	targets := []auditlogger.Target{
		auditlogger.ComponentTarget(logger.ComponentNameUsersync),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiUsersSync,
		Actor:         actor,
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Trigger user sync")
	r.userSync <- correlationID

	return correlationID.String(), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, offset *int, limit *int) (*model.UserList, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersList)
	if err != nil {
		return nil, err
	}
	p := model.NewPagination(offset, limit)
	users, total, err := r.database.GetUsers(ctx, database.Page{
		Limit:  p.Limit,
		Offset: p.Offset,
	})
	if err != nil {
		return nil, err
	}

	ret := make([]*model.User, 0, len(users))
	for _, u := range users {
		ret = append(ret, dataloader.ToGraphUser(u))
	}

	return &model.UserList{
			Nodes:    ret,
			PageInfo: model.NewPageInfo(p, total),
		},
		nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id *scalar.Ident, email *string) (*model.User, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersList)
	if err != nil {
		return nil, err
	}

	if id != nil {
		uid, err := id.AsUUID()
		if err != nil {
			return nil, err
		}
		return dataloader.GetUser(ctx, &uid)
	}
	if email != nil {
		u, err := r.database.GetUserByEmail(ctx, *email)
		if err != nil {
			return nil, err
		}
		return dataloader.ToGraphUser(u), nil
	}
	return nil, apierror.Errorf("Either id or email must be specified")
}

// UserSync is the resolver for the userSync field.
func (r *queryResolver) UserSync(ctx context.Context) ([]*model.UserSyncRun, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersyncSynchronize)
	if err != nil {
		return nil, err
	}

	return toGraphUserSyncRuns(r.userSyncRuns.GetRuns()), nil
}

// Teams is the resolver for the teams field.
func (r *userResolver) Teams(ctx context.Context, obj *model.User, limit *int, offset *int) (*model.TeamMemberList, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationTeamsList)
	if err != nil {
		return nil, err
	}
	p := model.NewPagination(offset, limit)

	uid, err := obj.ID.AsUUID()
	if err != nil {
		return nil, err
	}

	userTeams, totalCount, err := r.database.GetUserTeams(ctx, uid, database.Page{
		Limit:  p.Limit,
		Offset: p.Offset,
	})
	if err != nil {
		return nil, err
	}

	teams := make([]*model.TeamMember, 0)
	for _, userTeam := range userTeams {
		var teamRole model.TeamRole
		switch userTeam.RoleName {
		case gensql.RoleNameTeammember:
			teamRole = model.TeamRoleMember
		case gensql.RoleNameTeamowner:
			teamRole = model.TeamRoleOwner
		default:
			continue
		}
		teams = append(teams, &model.TeamMember{
			TeamRole: teamRole,
			TeamSlug: userTeam.Team.Slug,
			UserID:   uid,
		})
	}

	return &model.TeamMemberList{
		PageInfo: model.NewPageInfo(p, totalCount),
		Nodes:    teams,
	}, nil
}

// Roles is the resolver for the roles field.
func (r *userResolver) Roles(ctx context.Context, obj *model.User) ([]*model.Role, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireRole(actor, gensql.RoleNameAdmin)
	if err != nil {
		return nil, err
	}

	uid, err := obj.ID.AsUUID()
	if err != nil {
		return nil, err
	}

	if err != nil && actor.User.GetID() != uid {
		return nil, err
	}

	userRoles, err := dataloader.GetUserRoles(ctx, uid)
	if err != nil {
		return nil, err
	}
	ret := make([]*model.Role, 0)
	for _, ur := range userRoles {
		r := &model.Role{
			Name:           string(ur.RoleName),
			TargetTeamSlug: ur.TargetTeamSlug,
		}

		if ur.TargetServiceAccountID != nil {
			r.TargetServiceAccountID = ptr.To(scalar.ServiceAccountIdent(*ur.TargetServiceAccountID))
		}

		ret = append(ret, r)
	}

	return ret, nil
}

// IsAdmin is the resolver for the isAdmin field.
func (r *userResolver) IsAdmin(ctx context.Context, obj *model.User) (*bool, error) {
	uid, err := obj.ID.AsUUID()
	if err != nil {
		return nil, err
	}

	userRoles, err := dataloader.GetUserRoles(ctx, uid)
	if err != nil {
		return nil, err
	}

	for _, ur := range userRoles {
		if ur.RoleName == gensql.RoleNameAdmin {
			return ptr.To(true), nil
		}
	}

	return ptr.To(false), nil
}

// AuditLogs is the resolver for the auditLogs field.
func (r *userSyncRunResolver) AuditLogs(ctx context.Context, obj *model.UserSyncRun, limit *int, offset *int) (*model.AuditLogList, error) {
	p := model.NewPagination(offset, limit)
	entries, total, err := r.database.GetAuditLogsForCorrelationID(ctx, obj.CorrelationID, database.Page{
		Limit:  p.Limit,
		Offset: p.Offset,
	})
	if err != nil {
		return nil, err
	}

	return &model.AuditLogList{
		Nodes:    toGraphAuditLogs(entries),
		PageInfo: model.NewPageInfo(p, total),
	}, nil
}

// Status is the resolver for the status field.
func (r *userSyncRunResolver) Status(ctx context.Context, obj *model.UserSyncRun) (model.UserSyncRunStatus, error) {
	switch obj.GQLVars.Status {
	case usersync.RunSuccess:
		return model.UserSyncRunStatusSuccess, nil
	case usersync.RunFailure:
		return model.UserSyncRunStatusFailure, nil
	default:
		return model.UserSyncRunStatusInProgress, nil
	}
}

// Error is the resolver for the error field.
func (r *userSyncRunResolver) Error(ctx context.Context, obj *model.UserSyncRun) (*string, error) {
	err := obj.GQLVars.Error
	if err != nil {
		msg := err.Error()
		return &msg, nil
	}

	return nil, nil
}

// User returns gengql.UserResolver implementation.
func (r *Resolver) User() gengql.UserResolver { return &userResolver{r} }

// UserSyncRun returns gengql.UserSyncRunResolver implementation.
func (r *Resolver) UserSyncRun() gengql.UserSyncRunResolver { return &userSyncRunResolver{r} }

type (
	userResolver        struct{ *Resolver }
	userSyncRunResolver struct{ *Resolver }
)

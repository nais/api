package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"

	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/slug"
)

// EnableReconciler is the resolver for the enableReconciler field.
func (r *mutationResolver) EnableReconciler(ctx context.Context, name string) (*model.Reconciler, error) {
	if !name.Valid() {
		return nil, apierror.Errorf("%q is not a valid name", name)
	}

	correlationID, err := uuid.NewUUID()
	if err != nil {
		return nil, fmt.Errorf("create log correlation ID: %w", err)
	}

	_, err = r.database.GetReconciler(ctx, name)
	if err != nil {
		r.log.WithError(err).Errorf("unable to get reconciler: %q", name)
		return nil, apierror.Errorf("Unable to get reconciler: %q", name)
	}

	configs, err := r.database.GetReconcilerConfig(ctx, name)
	if err != nil {
		r.log.WithError(err).Errorf("unable to get reconciler config")
		return nil, apierror.Errorf("Unable to get reconciler config")
	}

	missingOptions := make([]string, 0)
	for _, config := range configs {
		if !config.Configured {
			missingOptions = append(missingOptions, string(config.Key))
		}
	}

	if len(missingOptions) != 0 {
		r.log.WithError(err).Errorf("reconciler is not fully configured")
		return nil, apierror.Errorf("Reconciler is not fully configured, missing one or more options: %s", strings.Join(missingOptions, ", "))
	}

	reconciler, err := r.database.EnableReconciler(ctx, name)
	if err != nil {
		r.log.WithError(err).Errorf("unable to enable reconciler")
		return nil, apierror.Errorf("Unable to enable reconciler")
	}

	err = r.teamSyncHandler.UseReconciler(*reconciler)
	if err != nil {
		if _, err := r.database.DisableReconciler(ctx, name); err != nil {
			r.log.WithError(err).Errorf("reconciler was enabled, but initialization failed, and we were unable to disable the reconciler.")
			return nil, apierror.Errorf("Reconciler was enabled, but initialization failed, and we were unable to disable the reconciler.")
		}

		r.log.WithError(err).Errorf("reconciler will not be enabled because of an initialization failure. Please verify that you have entered correct configuration values.")
		return nil, apierror.Errorf("Reconciler will not be enabled because of an initialization failure. Please verify that you have entered correct configuration values.")
	}

	actor := authz.ActorFromContext(ctx)
	targets := []auditlogger.Target{
		auditlogger.ReconcilerTarget(name),
	}
	fields := auditlogger.Fields{
		Action:        auditlogger.AuditActionGraphqlApiReconcilersEnable,
		Actor:         actor,
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Enable reconciler: %q", name)

	_, err = r.teamSyncHandler.ScheduleAllTeams(ctx, correlationID)
	if err != nil {
		r.log.WithError(err).Errorf("reconcile all teams")
	}

	return reconciler, nil
}

// DisableReconciler is the resolver for the disableReconciler field.
func (r *mutationResolver) DisableReconciler(ctx context.Context, name string) (*model.Reconciler, error) {
	if !name.Valid() {
		return nil, apierror.Errorf("%q is not a valid name", name)
	}

	var reconciler *db.Reconciler
	var err error
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx db.Database) error {
		reconciler, err = dbtx.GetReconciler(ctx, name)
		if err != nil {
			return err
		}

		reconciler, err = dbtx.DisableReconciler(ctx, name)
		if err != nil {
			return err
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	actor := authz.ActorFromContext(ctx)
	targets := []auditlogger.Target{
		auditlogger.ReconcilerTarget(name),
	}
	fields := auditlogger.Fields{
		Action: auditlogger.AuditActionGraphqlApiReconcilersDisable,
		Actor:  actor,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Disable reconciler: %q", name)
	r.teamSyncHandler.RemoveReconciler(name)

	return reconciler, nil
}

// ConfigureReconciler is the resolver for the configureReconciler field.
func (r *mutationResolver) ConfigureReconciler(ctx context.Context, name string, config []*model.ReconcilerConfigInput) (*model.Reconciler, error) {
	if !name.Valid() {
		return nil, apierror.Errorf("%q is not a valid name", name)
	}

	reconcilerConfig := make(map[sqlc.ReconcilerConfigKey]string)
	for _, entry := range config {
		reconcilerConfig[entry.Key] = entry.Value
	}

	err := r.database.Transaction(ctx, func(ctx context.Context, dbtx db.Database) error {
		rows, err := dbtx.GetReconcilerConfig(ctx, name)
		if err != nil {
			return err
		}

		validOptions := make(map[sqlc.ReconcilerConfigKey]struct{})
		for _, row := range rows {
			validOptions[row.Key] = struct{}{}
		}

		for key, value := range reconcilerConfig {
			if _, exists := validOptions[key]; !exists {
				keys := make([]string, 0, len(validOptions))
				for key := range validOptions {
					keys = append(keys, string(key))
				}
				return fmt.Errorf("unknown configuration option %q for reconciler %q. Valid options: %s", key, name, strings.Join(keys, ", "))
			}

			err = dbtx.ConfigureReconciler(ctx, name, key, value)
			if err != nil {
				return err
			}
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	reconciler, err := r.database.GetReconciler(ctx, name)
	if err != nil {
		return nil, err
	}

	if reconciler.Enabled {
		err = r.teamSyncHandler.UseReconciler(*reconciler)
		if err != nil {
			r.log.WithError(err).Errorf("use reconciler: %q", reconciler.Name)
		}
	}

	actor := authz.ActorFromContext(ctx)
	targets := []auditlogger.Target{
		auditlogger.ReconcilerTarget(name),
	}
	fields := auditlogger.Fields{
		Action: auditlogger.AuditActionGraphqlApiReconcilersConfigure,
		Actor:  actor,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Configure reconciler: %q", name)

	return reconciler, nil
}

// ResetReconciler is the resolver for the resetReconciler field.
func (r *mutationResolver) ResetReconciler(ctx context.Context, name string) (*model.Reconciler, error) {
	if !name.Valid() {
		return nil, fmt.Errorf("%q is not a valid name", name)
	}

	var reconciler *db.Reconciler
	var err error
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx db.Database) error {
		reconciler, err = dbtx.ResetReconcilerConfig(ctx, name)
		if err != nil {
			return err
		}

		if !reconciler.Enabled {
			return nil
		}

		reconciler, err = dbtx.DisableReconciler(ctx, name)
		if err != nil {
			return err
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	actor := authz.ActorFromContext(ctx)
	targets := []auditlogger.Target{
		auditlogger.ReconcilerTarget(name),
	}
	fields := auditlogger.Fields{
		Action: auditlogger.AuditActionGraphqlApiReconcilersReset,
		Actor:  actor,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Reset reconciler: %q", name)

	return reconciler, nil
}

// AddReconcilerOptOut is the resolver for the addReconcilerOptOut field.
func (r *mutationResolver) AddReconcilerOptOut(ctx context.Context, teamSlug slug.Slug, userID scalar.Ident, reconciler string) (*model.TeamMember, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, teamSlug)
	if err != nil {
		return nil, err
	}

	team, err := r.database.GetTeamBySlug(ctx, teamSlug)
	if err != nil {
		return nil, apierror.ErrTeamNotExist
	}

	user, err := r.database.GetTeamMember(ctx, teamSlug, userID)
	if err != nil {
		return nil, apierror.ErrUserIsNotTeamMember
	}

	err = r.database.AddReconcilerOptOut(ctx, userID, teamSlug, reconciler)
	if err != nil {
		return nil, err
	}

	return &model.TeamMember{
		TeamSlug: team.Slug,
		UserID:   user.ID,
	}, nil
}

// RemoveReconcilerOptOut is the resolver for the removeReconcilerOptOut field.
func (r *mutationResolver) RemoveReconcilerOptOut(ctx context.Context, teamSlug slug.Slug, userID scalar.Ident, reconciler string) (*model.TeamMember, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, teamSlug)
	if err != nil {
		return nil, err
	}

	team, err := r.database.GetTeamBySlug(ctx, teamSlug)
	if err != nil {
		return nil, apierror.ErrTeamNotExist
	}

	user, err := r.database.GetTeamMember(ctx, teamSlug, userID)
	if err != nil {
		return nil, apierror.ErrUserIsNotTeamMember
	}

	err = r.database.RemoveReconcilerOptOut(ctx, userID, teamSlug, reconciler)
	if err != nil {
		return nil, err
	}

	return &model.TeamMember{
		TeamSlug: team.Slug,
		UserID:   user.ID,
	}, nil
}

// Reconcilers is the resolver for the reconcilers field.
func (r *queryResolver) Reconcilers(ctx context.Context) ([]*model.Reconciler, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationTeamsCreate)
	if err != nil {
		return nil, err
	}

	return r.database.GetReconcilers(ctx)
}

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"errors"
	"fmt"

	"github.com/google/uuid"
	pgx "github.com/jackc/pgx/v5"
	"github.com/nais/api/internal/auditlogger"
	"github.com/nais/api/internal/auditlogger/audittype"
	"github.com/nais/api/internal/auth/authz"
	"github.com/nais/api/internal/auth/roles"
	"github.com/nais/api/internal/database"
	"github.com/nais/api/internal/database/gensql"
	"github.com/nais/api/internal/graph/apierror"
	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/loader"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/model/vulnerabilities"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/thirdparty/dependencytrack"
	"github.com/nais/api/internal/thirdparty/hookd"
	"github.com/nais/api/pkg/protoapi"
	"k8s.io/utils/ptr"
)

// CreateTeam is the resolver for the createTeam field.
func (r *mutationResolver) CreateTeam(ctx context.Context, input model.CreateTeamInput) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationTeamsCreate)
	if err != nil {
		return nil, err
	}

	input = input.Sanitize()

	err = input.Validate()
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	var team *database.Team
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		team, err = dbtx.CreateTeam(ctx, input.Slug, input.Purpose, input.SlackChannel)
		if err != nil {
			return err
		}

		if actor.User.IsServiceAccount() {
			return dbtx.AssignTeamRoleToServiceAccount(ctx, actor.User.GetID(), gensql.RoleNameTeamowner, input.Slug)
		}

		return dbtx.SetTeamMemberRole(ctx, actor.User.GetID(), team.Slug, gensql.RoleNameTeamowner)
	})
	if err != nil {
		return nil, err
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(team.Slug),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamCreate,
		CorrelationID: correlationID,
		Actor:         actor,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Team created")

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return loader.ToGraphTeam(team), nil
}

// UpdateTeam is the resolver for the updateTeam field.
func (r *mutationResolver) UpdateTeam(ctx context.Context, slug slug.Slug, input model.UpdateTeamInput) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, slug)
	if err != nil {
		return nil, err
	}

	if _, err := loader.GetTeam(ctx, slug); err != nil {
		return nil, err
	}

	input = input.Sanitize()
	err = input.Validate(r.clusters.GCPClusters())
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()
	auditLogEntries := make([]auditlogger.Entry, 0)
	var team *database.Team
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		team, err = dbtx.UpdateTeam(ctx, slug, input.Purpose, input.SlackChannel)
		if err != nil {
			return err
		}

		if len(input.SlackAlertsChannels) > 0 {
			for _, slackAlertsChannel := range input.SlackAlertsChannels {
				err := dbtx.UpsertTeamEnvironment(ctx, slug, slackAlertsChannel.Environment, slackAlertsChannel.ChannelName, nil)
				if err != nil {
					return err
				}
			}
		}

		targets := []auditlogger.Target{
			auditlogger.TeamTarget(slug),
		}
		fields := auditlogger.Fields{
			Action:        audittype.AuditActionGraphqlApiTeamUpdate,
			CorrelationID: correlationID,
			Actor:         actor,
		}
		auditLogEntries = append(auditLogEntries, auditlogger.Entry{
			Targets: targets,
			Fields:  fields,
			Message: "Team configuration saved",
		})
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return loader.ToGraphTeam(team), nil
}

// RemoveUsersFromTeam is the resolver for the removeUsersFromTeam field.
func (r *mutationResolver) RemoveUsersFromTeam(ctx context.Context, slug slug.Slug, userIds []*scalar.Ident) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, slug)
	if err != nil {
		return nil, err
	}

	if _, err := loader.GetTeam(ctx, slug); err != nil {
		return nil, err
	}

	correlationID := uuid.New()
	auditLogEntries := make([]auditlogger.Entry, 0)
	var team *database.Team
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		members, err := dbtx.GetAllTeamMembers(ctx, slug)
		if err != nil {
			return fmt.Errorf("get team members of %q: %w", slug, err)
		}

		memberFromUserID := func(userId uuid.UUID) *database.User {
			for _, m := range members {
				if m.ID == userId {
					return m
				}
			}
			return nil
		}

		for _, userID := range userIds {
			uuid, err := userID.AsUUID()
			if err != nil {
				return err
			}
			member := memberFromUserID(uuid)
			if member == nil {
				return apierror.Errorf("The user %q is not a member of team %q.", uuid, slug)
			}

			err = dbtx.RemoveUserFromTeam(ctx, uuid, slug)
			if err != nil {
				return err
			}

			targets := []auditlogger.Target{
				auditlogger.TeamTarget(slug),
				auditlogger.UserTarget(member.Email),
			}
			fields := auditlogger.Fields{
				Action:        audittype.AuditActionGraphqlApiTeamRemoveMember,
				CorrelationID: correlationID,
				Actor:         actor,
			}
			auditLogEntries = append(auditLogEntries, auditlogger.Entry{
				Targets: targets,
				Fields:  fields,
				Message: fmt.Sprintf("Removed user: %q", member.Email),
			})
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, slug, correlationID)

	return loader.ToGraphTeam(team), nil
}

// RemoveUserFromTeam is the resolver for the removeUserFromTeam field.
func (r *mutationResolver) RemoveUserFromTeam(ctx context.Context, slug slug.Slug, userID scalar.Ident) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, slug)
	if err != nil {
		return nil, err
	}

	userUID, err := userID.AsUUID()
	if err != nil {
		return nil, err
	}

	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	auditLogEntries := make([]auditlogger.Entry, 0)
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		members, err := dbtx.GetAllTeamMembers(ctx, slug)
		if err != nil {
			return fmt.Errorf("get team members of %q: %w", slug, err)
		}

		memberFromUserID := func(userId uuid.UUID) *database.User {
			for _, m := range members {
				if m.ID == userId {
					return m
				}
			}
			return nil
		}

		member := memberFromUserID(userUID)
		if member == nil {
			return apierror.Errorf("The user %q is not a member of team %q.", userUID, slug)
		}

		err = dbtx.RemoveUserFromTeam(ctx, userUID, slug)
		if err != nil {
			return err
		}

		targets := []auditlogger.Target{
			auditlogger.TeamTarget(slug),
			auditlogger.UserTarget(member.Email),
		}
		fields := auditlogger.Fields{
			Action:        audittype.AuditActionGraphqlApiTeamRemoveMember,
			CorrelationID: correlationID,
			Actor:         actor,
		}
		auditLogEntries = append(auditLogEntries, auditlogger.Entry{
			Targets: targets,
			Fields:  fields,
			Message: fmt.Sprintf("Removed user: %q", member.Email),
		})
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, slug, correlationID)

	return team, nil
}

// SynchronizeTeam is the resolver for the synchronizeTeam field.
func (r *mutationResolver) SynchronizeTeam(ctx context.Context, slug slug.Slug) (*model.TeamSync, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsSynchronize, slug)
	if err != nil {
		return nil, err
	}

	if _, err := loader.GetTeam(ctx, slug); err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(slug),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamSync,
		CorrelationID: correlationID,
		Actor:         actor,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Manually scheduled for synchronization")

	r.triggerTeamUpdatedEvent(ctx, slug, correlationID)

	return &model.TeamSync{
		CorrelationID: correlationID,
	}, nil
}

// SynchronizeAllTeams is the resolver for the synchronizeAllTeams field.
func (r *mutationResolver) SynchronizeAllTeams(ctx context.Context) (*model.TeamSync, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationTeamsSynchronize)
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	limit, offset := 100, 0
	teams := make([]*database.Team, 0)
	for {
		page, _, err := r.database.GetTeams(ctx, database.Page{
			Limit:  limit,
			Offset: offset,
		})
		if err != nil {
			return nil, err
		}
		teams = append(teams, page...)
		if len(page) < limit {
			break
		}
		offset += limit
	}

	targets := make([]auditlogger.Target, 0, len(teams))
	for _, entry := range teams {
		targets = append(targets, auditlogger.TeamTarget(entry.Team.Slug))
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamSync,
		Actor:         actor,
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Manually scheduled for synchronization")
	r.triggerEvent(ctx, protoapi.EventTypes_EVENT_SYNC_ALL_TEAMS, &protoapi.EventSyncAllTeams{}, correlationID)

	return &model.TeamSync{
		CorrelationID: correlationID,
	}, nil
}

// AddTeamMembers is the resolver for the addTeamMembers field.
func (r *mutationResolver) AddTeamMembers(ctx context.Context, slug slug.Slug, userIds []*scalar.Ident) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	if err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, slug); err != nil {
		return nil, err
	}

	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	auditLogEntries := make([]auditlogger.Entry, 0)
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		for _, userID := range userIds {
			uid, err := userID.AsUUID()
			if err != nil {
				return err
			}
			user, err := dbtx.GetUserByID(ctx, uid)
			if err != nil {
				return err
			}

			if err := dbtx.SetTeamMemberRole(ctx, uid, team.Slug, gensql.RoleNameTeammember); err != nil {
				return err
			}

			targets := []auditlogger.Target{
				auditlogger.TeamTarget(team.Slug),
				auditlogger.UserTarget(user.Email),
			}
			fields := auditlogger.Fields{
				Action:        audittype.AuditActionGraphqlApiTeamAddMember,
				CorrelationID: correlationID,
				Actor:         actor,
			}
			auditLogEntries = append(auditLogEntries, auditlogger.Entry{
				Targets: targets,
				Fields:  fields,
				Message: fmt.Sprintf("Add team member: %q", user.Email),
			})
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return team, nil
}

// AddTeamOwners is the resolver for the addTeamOwners field.
func (r *mutationResolver) AddTeamOwners(ctx context.Context, slug slug.Slug, userIds []*scalar.Ident) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, slug)
	if err != nil {
		return nil, err
	}

	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	auditLogEntries := make([]auditlogger.Entry, 0)
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		for _, userID := range userIds {
			uid, err := userID.AsUUID()
			if err != nil {
				return err
			}
			user, err := dbtx.GetUserByID(ctx, uid)
			if err != nil {
				return err
			}

			err = dbtx.SetTeamMemberRole(ctx, uid, team.Slug, gensql.RoleNameTeamowner)
			if err != nil {
				return err
			}

			targets := []auditlogger.Target{
				auditlogger.TeamTarget(team.Slug),
				auditlogger.UserTarget(user.Email),
			}
			fields := auditlogger.Fields{
				Action:        audittype.AuditActionGraphqlApiTeamAddOwner,
				CorrelationID: correlationID,
				Actor:         actor,
			}
			auditLogEntries = append(auditLogEntries, auditlogger.Entry{
				Targets: targets,
				Fields:  fields,
				Message: fmt.Sprintf("Add team owner: %q", user.Email),
			})
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return team, nil
}

// AddTeamMember is the resolver for the addTeamMember field.
func (r *mutationResolver) AddTeamMember(ctx context.Context, slug slug.Slug, member model.TeamMemberInput) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, slug)
	if err != nil {
		return nil, err
	}

	mid, err := member.UserID.AsUUID()
	if err != nil {
		return nil, err
	}

	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		return nil, err
	}

	user, err := r.database.GetUserByID(ctx, mid)
	if err != nil {
		return nil, apierror.ErrUserNotExists
	}

	correlationID := uuid.New()

	auditLogEntries := make([]auditlogger.Entry, 0)
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		teamMember, _ := dbtx.GetTeamMember(ctx, slug, mid)
		if teamMember != nil {
			return apierror.Errorf("User is already a member of the team.")
		}

		role, err := gensqlRoleFromTeamRole(member.Role)
		if err != nil {
			return err
		}

		err = dbtx.SetTeamMemberRole(ctx, mid, team.Slug, role)
		if err != nil {
			return err
		}

		for _, reconcilerName := range member.ReconcilerOptOuts {
			err = dbtx.AddReconcilerOptOut(ctx, mid, team.Slug, reconcilerName)
			if err != nil {
				return err
			}
		}

		targets := []auditlogger.Target{
			auditlogger.TeamTarget(team.Slug),
			auditlogger.UserTarget(user.Email),
		}

		var action audittype.AuditAction
		var msg string

		switch role {
		case gensql.RoleNameTeamowner:
			action = audittype.AuditActionGraphqlApiTeamAddOwner
			msg = fmt.Sprintf("Add team owner: %q", user.Email)
		case gensql.RoleNameTeammember:
			action = audittype.AuditActionGraphqlApiTeamAddMember
			msg = fmt.Sprintf("Add team member: %q", user.Email)
		default:
			return fmt.Errorf("unknown role: %q", role)
		}

		fields := auditlogger.Fields{
			Action:        action,
			CorrelationID: correlationID,
			Actor:         actor,
		}
		auditLogEntries = append(auditLogEntries, auditlogger.Entry{
			Targets: targets,
			Fields:  fields,
			Message: msg,
		})
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return team, nil
}

// SetTeamMemberRole is the resolver for the setTeamMemberRole field.
func (r *mutationResolver) SetTeamMemberRole(ctx context.Context, slug slug.Slug, userID scalar.Ident, role model.TeamRole) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, slug)
	if err != nil {
		return nil, err
	}

	uid, err := userID.AsUUID()
	if err != nil {
		return nil, err
	}

	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	members, err := r.database.GetAllTeamMembers(ctx, team.Slug)
	if err != nil {
		return nil, fmt.Errorf("get team members: %w", err)
	}

	var member *database.User = nil
	for _, m := range members {
		if m.ID == uid {
			member = m
			break
		}
	}
	if member == nil {
		return nil, fmt.Errorf("user %q not in team %q", uid, slug)
	}

	desiredRole, err := gensqlRoleFromTeamRole(role)
	if err != nil {
		return nil, err
	}

	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		err = dbtx.RemoveUserFromTeam(ctx, uid, team.Slug)
		if err != nil {
			return err
		}

		return dbtx.SetTeamMemberRole(ctx, uid, team.Slug, desiredRole)
	})
	if err != nil {
		return nil, err
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(team.Slug),
		auditlogger.UserTarget(member.Email),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamSetMemberRole,
		CorrelationID: correlationID,
		Actor:         actor,
	}

	r.auditLogger.Logf(ctx, targets, fields, "Assign %q to %s", desiredRole, member.Email)

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return team, nil
}

// RequestTeamDeletion is the resolver for the requestTeamDeletion field.
func (r *mutationResolver) RequestTeamDeletion(ctx context.Context, slug slug.Slug) (*model.TeamDeleteKey, error) {
	actor := authz.ActorFromContext(ctx)
	if actor.User.IsServiceAccount() {
		return nil, apierror.Errorf("Service accounts are not allowed to request a team deletion.")
	}

	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, slug)
	if err != nil {
		return nil, err
	}

	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, apierror.ErrTeamNotExist
		}
		return nil, err
	}

	correlationID := uuid.New()

	deleteKey, err := r.database.CreateTeamDeleteKey(ctx, slug, actor.User.GetID())
	if err != nil {
		return nil, fmt.Errorf("create team delete key: %w", err)
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(team.Slug),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamsRequestDelete,
		Actor:         actor,
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Request team deletion")

	return toGraphTeamDeleteKey(deleteKey), nil
}

// ConfirmTeamDeletion is the resolver for the confirmTeamDeletion field.
func (r *mutationResolver) ConfirmTeamDeletion(ctx context.Context, key string) (bool, error) {
	uid, err := uuid.Parse(key)
	if err != nil {
		return false, apierror.Errorf("Invalid deletion key: %q", key)
	}

	deleteKey, err := r.database.GetTeamDeleteKey(ctx, uid)
	if err != nil {
		return false, apierror.Errorf("Unknown deletion key: %q", key)
	}

	actor := authz.ActorFromContext(ctx)
	if actor.User.IsServiceAccount() {
		return false, apierror.Errorf("Service accounts are not allowed to confirm a team deletion.")
	}
	err = authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, deleteKey.TeamSlug)
	if err != nil {
		return false, err
	}

	if actor.User.GetID() == deleteKey.CreatedBy {
		return false, apierror.Errorf("You cannot confirm your own delete key.")
	}

	if !deleteKey.ConfirmedAt.Valid {
		return false, apierror.Errorf("Key has already been confirmed, team is currently being deleted.")
	}

	if deleteKey.HasExpired() {
		return false, apierror.Errorf("Team delete key has expired, you need to request a new key.")
	}

	correlationID := uuid.New()

	err = r.database.ConfirmTeamDeleteKey(ctx, uid)
	if err != nil {
		return false, fmt.Errorf("confirm team delete key: %w", err)
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(deleteKey.TeamSlug),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamsDelete,
		Actor:         actor,
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Delete team")

	r.triggerTeamDeletedEvent(ctx, deleteKey.TeamSlug, correlationID)

	return true, nil
}

// ChangeDeployKey is the resolver for the changeDeployKey field.
func (r *mutationResolver) ChangeDeployKey(ctx context.Context, team slug.Slug) (*model.DeploymentKey, error) {
	actor := authz.ActorFromContext(ctx)
	if _, err := r.database.GetTeamMember(ctx, team, actor.User.GetID()); errors.Is(err, pgx.ErrNoRows) {
		return nil, apierror.ErrUserIsNotTeamMember
	} else if err != nil {
		return nil, err
	}

	deployKey, err := r.hookdClient.ChangeDeployKey(ctx, team.String())
	if err != nil {
		return nil, fmt.Errorf("changing deploy key in Hookd: %w", err)
	}
	return &model.DeploymentKey{
		ID:      scalar.DeployKeyIdent(team.String()),
		Key:     deployKey.Key,
		Created: deployKey.Created,
		Expires: deployKey.Expires,
	}, nil
}

// Teams is the resolver for the teams field.
func (r *queryResolver) Teams(ctx context.Context, offset *int, limit *int, filter *model.TeamsFilter) (*model.TeamList, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationTeamsList)
	if err != nil {
		return nil, err
	}

	var teams []*database.Team
	var total int

	p := model.NewPagination(offset, limit)

	if filter != nil {
		if filter.Github != nil {
			teams, total, err = r.database.GetTeamsWithPermissionInGitHubRepo(ctx, filter.Github.RepoName, filter.Github.PermissionName, database.Page{
				Limit:  p.Limit,
				Offset: p.Offset,
			})
		}
	} else {
		teams, total, err = r.database.GetTeams(ctx, database.Page{
			Limit:  p.Limit,
			Offset: p.Offset,
		})
	}
	if err != nil {
		return nil, err
	}

	return &model.TeamList{
		Nodes:    toGraphTeams(teams),
		PageInfo: model.NewPageInfo(p, total),
	}, nil
}

// Team is the resolver for the team field.
func (r *queryResolver) Team(ctx context.Context, slug slug.Slug) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsRead, slug)
	if err != nil {
		return nil, err
	}

	return loader.GetTeam(ctx, slug)
}

// TeamDeleteKey is the resolver for the teamDeleteKey field.
func (r *queryResolver) TeamDeleteKey(ctx context.Context, key string) (*model.TeamDeleteKey, error) {
	kid, err := uuid.Parse(key)
	if err != nil {
		return nil, apierror.Errorf("Invalid deletion key: %q", key)
	}

	deleteKey, err := r.database.GetTeamDeleteKey(ctx, kid)
	if err != nil {
		return nil, apierror.Errorf("Unknown deletion key: %q", key)
	}

	actor := authz.ActorFromContext(ctx)
	if actor.User.IsServiceAccount() {
		return nil, apierror.Errorf("Service accounts are not allowed to get team delete keys.")
	}
	err = authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsUpdate, deleteKey.TeamSlug)
	if err != nil {
		return nil, err
	}

	return toGraphTeamDeleteKey(deleteKey), nil
}

// ID is the resolver for the id field.
func (r *teamResolver) ID(ctx context.Context, obj *model.Team) (*scalar.Ident, error) {
	return ptr.To(scalar.TeamIdent(obj.Slug)), nil
}

// AuditLogs is the resolver for the auditLogs field.
func (r *teamResolver) AuditLogs(ctx context.Context, obj *model.Team, offset *int, limit *int) (*model.AuditLogList, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationAuditLogsRead, obj.Slug)
	if err != nil {
		return nil, err
	}

	p := model.NewPagination(offset, limit)
	entries, total, err := r.database.GetAuditLogsForTeam(ctx, obj.Slug, database.Page{
		Limit:  p.Limit,
		Offset: p.Offset,
	})
	if err != nil {
		return nil, err
	}

	return &model.AuditLogList{
		Nodes:    toGraphAuditLogs(entries),
		PageInfo: model.NewPageInfo(p, total),
	}, nil
}

// Members is the resolver for the members field.
func (r *teamResolver) Members(ctx context.Context, obj *model.Team, offset *int, limit *int) (*model.TeamMemberList, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersList)
	if err != nil {
		return nil, err
	}

	p := model.NewPagination(offset, limit)

	users, total, err := r.database.GetTeamMembers(ctx, obj.Slug, database.Page{
		Limit:  p.Limit,
		Offset: p.Offset,
	})
	if err != nil {
		return nil, err
	}

	members := make([]*model.TeamMember, len(users))
	for idx, user := range users {
		members[idx] = &model.TeamMember{
			UserID:   user.ID,
			TeamSlug: obj.Slug,
		}
	}

	return &model.TeamMemberList{
		Nodes:    members,
		PageInfo: model.NewPageInfo(p, total),
	}, nil
}

// Member is the resolver for the member field.
func (r *teamResolver) Member(ctx context.Context, obj *model.Team, userID scalar.Ident) (*model.TeamMember, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersList)
	if err != nil {
		return nil, err
	}

	uid, err := userID.AsUUID()
	if err != nil {
		return nil, err
	}

	user, err := r.database.GetUserByID(ctx, uid)
	if err != nil {
		return nil, apierror.ErrUserNotExists
	}

	return &model.TeamMember{
		UserID:   user.ID,
		TeamSlug: obj.Slug,
	}, nil
}

// SyncErrors is the resolver for the syncErrors field.
func (r *teamResolver) SyncErrors(ctx context.Context, obj *model.Team) ([]*model.SyncError, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsRead, obj.Slug)
	if err != nil {
		return nil, err
	}

	rows, err := r.database.GetTeamReconcilerErrors(ctx, obj.Slug)
	if err != nil {
		return nil, err
	}

	syncErrors := make([]*model.SyncError, 0)
	for _, row := range rows {
		syncErrors = append(syncErrors, &model.SyncError{
			CreatedAt:  row.CreatedAt.Time,
			Reconciler: string(row.Reconciler),
			Error:      row.ErrorMessage,
		})
	}

	return syncErrors, nil
}

// GithubRepositories is the resolver for the githubRepositories field.
func (r *teamResolver) GithubRepositories(ctx context.Context, obj *model.Team, offset *int, limit *int) (*model.GitHubRepositoryList, error) {
	page := model.NewPagination(offset, limit)
	res, total, err := r.database.GetReconcilerResourcesByKey(ctx, "github:team", obj.Slug, "repo", page.Page())
	if err != nil {
		return nil, err
	}

	repos := make([]*model.GitHubRepository, 0, len(res))
	for _, r := range res {
		repo, err := toGraphGitHubRepository(r)
		if err != nil {
			return nil, err
		}
		repos = append(repos, repo)
	}

	return &model.GitHubRepositoryList{
		Nodes:    repos,
		PageInfo: model.NewPageInfo(page, total),
	}, nil
}

// DeletionInProgress is the resolver for the deletionInProgress field.
func (r *teamResolver) DeletionInProgress(ctx context.Context, obj *model.Team) (bool, error) {
	_, err := r.database.GetActiveTeamBySlug(ctx, obj.Slug)
	if errors.Is(err, pgx.ErrNoRows) {
		return true, nil
	}

	return false, err
}

// ViewerIsOwner is the resolver for the viewerIsOwner field.
func (r *teamResolver) ViewerIsOwner(ctx context.Context, obj *model.Team) (bool, error) {
	actor := authz.ActorFromContext(ctx)
	return r.database.UserIsTeamOwner(ctx, actor.User.GetID(), obj.Slug)
}

// ViewerIsMember is the resolver for the viewerIsMember field.
func (r *teamResolver) ViewerIsMember(ctx context.Context, obj *model.Team) (bool, error) {
	actor := authz.ActorFromContext(ctx)
	u, err := r.database.GetTeamMember(ctx, obj.Slug, actor.User.GetID())
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return false, nil
		}
		return false, err
	}
	return u != nil, nil
}

// Status is the resolver for the status field.
func (r *teamResolver) Status(ctx context.Context, obj *model.Team) (*model.TeamStatus, error) {
	apps, err := r.k8sClient.Apps(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting apps from Kubernetes: %w", err)
	}

	jobs, err := r.k8sClient.NaisJobs(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting naisjobs from Kubernetes: %w", err)
	}

	failingApps := 0
	for _, app := range apps {
		if app.AppState.State == model.StateFailing {
			failingApps++
		}
	}
	failingJobs := 0
	for _, job := range jobs {
		if job.JobState.State == model.StateFailing {
			failingJobs++
		}
	}

	return &model.TeamStatus{
		Apps: model.AppsStatus{
			Total:   len(apps),
			Failing: failingApps,
		},
		Jobs: model.JobsStatus{
			Total:   len(jobs),
			Failing: failingJobs,
		},
	}, nil
}

// Apps is the resolver for the apps field.
func (r *teamResolver) Apps(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.AppList, error) {
	apps, err := r.k8sClient.Apps(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting apps from Kubernetes: %w", err)
	}
	if orderBy != nil {
		switch orderBy.Field {
		case "NAME":
			model.SortWith(apps, func(a, b *model.App) bool {
				return model.Compare(a.Name, b.Name, orderBy.Direction)
			})
		case "ENV":
			model.SortWith(apps, func(a, b *model.App) bool {
				return model.Compare(a.Env.Name, b.Env.Name, orderBy.Direction)
			})
		case "DEPLOYED":
			model.SortWith(apps, func(a, b *model.App) bool {
				if a.DeployInfo.Timestamp == nil {
					return false
				}
				if b.DeployInfo.Timestamp == nil {
					return true
				}
				return model.Compare(b.DeployInfo.Timestamp.UnixMilli(), a.DeployInfo.Timestamp.UnixMilli(), orderBy.Direction)
			})
		case "STATUS":
			model.SortWith(apps, func(a, b *model.App) bool {
				sortOrder := []model.State{model.StateFailing, model.StateNotnais, model.StateUnknown, model.StateNais}
				aIndex := -1
				bIndex := -1
				for i, s := range sortOrder {
					if a.AppState.State == s {
						aIndex = i
					}
					if b.AppState.State == s {
						bIndex = i
					}
				}
				if aIndex == -1 {
					return false
				}
				if bIndex == -1 {
					return true
				}
				if orderBy.Direction == model.SortOrderAsc {
					return aIndex < bIndex
				}
				return aIndex > bIndex
			})
		}
	}
	pagination := model.NewPagination(offset, limit)
	apps, pageInfo := model.PaginatedSlice(apps, pagination)
	for _, app := range apps {
		app.GQLVars = model.AppGQLVars{Team: obj.Slug}
	}

	return &model.AppList{
		Nodes:    apps,
		PageInfo: pageInfo,
	}, nil
}

// DeployKey is the resolver for the deployKey field.
func (r *teamResolver) DeployKey(ctx context.Context, obj *model.Team) (*model.DeploymentKey, error) {
	actor := authz.ActorFromContext(ctx)
	if _, err := r.database.GetTeamMember(ctx, obj.Slug, actor.User.GetID()); errors.Is(err, pgx.ErrNoRows) {
		return nil, apierror.ErrUserIsNotTeamMember
	} else if err != nil {
		return nil, err
	}

	key, err := r.hookdClient.DeployKey(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting deploy key from Hookd: %w", err)
	}

	return &model.DeploymentKey{
		ID:      scalar.DeployKeyIdent(obj.Slug.String()),
		Key:     key.Key,
		Created: key.Created,
		Expires: key.Expires,
	}, nil
}

// Naisjobs is the resolver for the naisjobs field.
func (r *teamResolver) Naisjobs(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.NaisJobList, error) {
	naisjobs, err := r.k8sClient.NaisJobs(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting naisjobs from Kubernetes: %w", err)
	}

	if orderBy != nil {
		switch orderBy.Field {
		case "NAME":
			model.SortWith(naisjobs, func(a, b *model.NaisJob) bool {
				return model.Compare(a.Name, b.Name, orderBy.Direction)
			})
		case "ENV":
			model.SortWith(naisjobs, func(a, b *model.NaisJob) bool {
				return model.Compare(a.Env.Name, b.Env.Name, orderBy.Direction)
			})
		case "DEPLOYED":
			model.SortWith(naisjobs, func(a, b *model.NaisJob) bool {
				if a.DeployInfo.Timestamp == nil {
					return false
				}
				if b.DeployInfo.Timestamp == nil {
					return true
				}
				return model.Compare(b.DeployInfo.Timestamp.UnixMilli(), a.DeployInfo.Timestamp.UnixMilli(), orderBy.Direction)
			})
		case "STATUS":
			model.SortWith(naisjobs, func(a, b *model.NaisJob) bool {
				sortOrder := []model.State{model.StateFailing, model.StateNotnais, model.StateUnknown, model.StateNais}
				aIndex := -1
				bIndex := -1
				for i, s := range sortOrder {
					if a.JobState.State == s {
						aIndex = i
					}
					if b.JobState.State == s {
						bIndex = i
					}
				}
				if aIndex == -1 {
					return false
				}
				if bIndex == -1 {
					return true
				}
				if orderBy.Direction == model.SortOrderAsc {
					return aIndex < bIndex
				}
				return aIndex > bIndex
			})
		}
	}

	pagination := model.NewPagination(offset, limit)
	jobs, pageInfo := model.PaginatedSlice(naisjobs, pagination)
	for _, job := range jobs {
		job.GQLVars = model.NaisJobGQLVars{Team: obj.Slug}
	}

	return &model.NaisJobList{
		Nodes:    jobs,
		PageInfo: pageInfo,
	}, nil
}

// Deployments is the resolver for the deployments field.
func (r *teamResolver) Deployments(ctx context.Context, obj *model.Team, offset *int, limit *int) (*model.DeploymentList, error) {
	pagination := model.NewPagination(offset, limit)

	deploys, err := r.hookdClient.Deployments(ctx, hookd.WithTeam(obj.Slug.String()), hookd.WithLimit(pagination.Limit))
	if err != nil {
		return nil, fmt.Errorf("getting deploys from Hookd: %w", err)
	}

	return &model.DeploymentList{
		Nodes: deployToModel(deploys),
		PageInfo: model.PageInfo{
			HasNextPage:     len(deploys) >= pagination.Limit,
			HasPreviousPage: pagination.Offset > 0,
			TotalCount:      0,
		},
	}, nil
}

// Vulnerabilities is the resolver for the vulnerabilities field.
func (r *teamResolver) Vulnerabilities(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.VulnerabilityList, error) {
	apps, err := r.k8sClient.Apps(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting apps from Kubernetes: %w", err)
	}

	instances := make([]*dependencytrack.AppInstance, 0)
	for _, app := range apps {
		instances = append(instances, &dependencytrack.AppInstance{
			Env:   app.Env.Name,
			App:   app.Name,
			Image: app.Image,
			Team:  obj.Slug.String(),
		})
	}

	nodes, err := r.dependencyTrackClient.GetVulnerabilities(ctx, instances)
	if err != nil {
		return nil, fmt.Errorf("getting vulnerabilities from DependencyTrack: %w", err)
	}

	if orderBy != nil {
		vulnerabilities.Sort(nodes, orderBy.Field, orderBy.Direction)
	}

	pagination := model.NewPagination(offset, limit)
	v, pi := model.PaginatedSlice(nodes, pagination)

	return &model.VulnerabilityList{
		Nodes:    v,
		PageInfo: pi,
	}, nil
}

// VulnerabilitiesSummary is the resolver for the vulnerabilitiesSummary field.
func (r *teamResolver) VulnerabilitiesSummary(ctx context.Context, obj *model.Team) (*model.VulnerabilitySummary, error) {
	apps, err := r.k8sClient.Apps(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting apps from Kubernetes: %w", err)
	}

	instances := make([]*dependencytrack.AppInstance, 0)
	for _, app := range apps {
		instances = append(instances, &dependencytrack.AppInstance{
			Env:   app.Env.Name,
			App:   app.Name,
			Image: app.Image,
			Team:  obj.Slug.String(),
		})
	}

	nodes, err := r.dependencyTrackClient.GetVulnerabilities(ctx, instances)
	if err != nil {
		return nil, fmt.Errorf("getting vulnerabilities from DependencyTrack: %w", err)
	}

	retVal := &model.VulnerabilitySummary{}
	for _, n := range nodes {
		if n.Summary == nil {
			continue
		}
		if n.Summary.Critical > 0 {
			retVal.Critical += n.Summary.Critical
		}
		if n.Summary.High > 0 {
			retVal.High += n.Summary.High
		}
		if n.Summary.Medium > 0 {
			retVal.Medium += n.Summary.Medium
		}
		if n.Summary.Low > 0 {
			retVal.Low += n.Summary.Low
		}
		if n.Summary.Unassigned > 0 {
			retVal.Unassigned += n.Summary.Unassigned
		}
		if n.Summary.RiskScore > 0 {
			retVal.RiskScore += n.Summary.RiskScore
		}
		if n.Summary.Total > 0 {
			retVal.Total += n.Summary.Total
		}
	}
	return retVal, nil
}

// Environments is the resolver for the environments field.
func (r *teamResolver) Environments(ctx context.Context, obj *model.Team) ([]*model.Env, error) {
	// Env is a bit special, given that it will be created from k8s etc.
	// All fields, except name and team, are resolved.

	dbEnvs, _, err := r.database.GetTeamEnvironments(ctx, obj.Slug, database.Page{Limit: 50})
	if err != nil {
		return nil, err
	}

	names := r.clusters.Names()
	ret := make([]*model.Env, len(names))
	for i, env := range dbEnvs {
		ret[i] = &model.Env{Name: env.Environment, Team: obj.Slug.String()}
	}

	return ret, nil
}

// Team is the resolver for the team field.
func (r *teamMemberResolver) Team(ctx context.Context, obj *model.TeamMember) (*model.Team, error) {
	return loader.GetTeam(ctx, obj.TeamSlug)
}

// User is the resolver for the user field.
func (r *teamMemberResolver) User(ctx context.Context, obj *model.TeamMember) (*model.User, error) {
	return loader.GetUser(ctx, obj.UserID)
}

// Role is the resolver for the role field.
func (r *teamMemberResolver) Role(ctx context.Context, obj *model.TeamMember) (model.TeamRole, error) {
	if obj.TeamRole != "" {
		return obj.TeamRole, nil
	}
	isOwner, err := r.database.UserIsTeamOwner(ctx, obj.UserID, obj.TeamSlug)
	if err != nil {
		return "", err
	}

	role := model.TeamRoleMember
	if isOwner {
		role = model.TeamRoleOwner
	}

	return role, nil
}

// Reconcilers is the resolver for the reconcilers field.
func (r *teamMemberResolver) Reconcilers(ctx context.Context, obj *model.TeamMember) ([]*model.TeamMemberReconciler, error) {
	rows, err := r.database.GetTeamMemberOptOuts(ctx, obj.UserID, obj.TeamSlug)
	if err != nil {
		return nil, err
	}
	return toGraphTeamMemberReconcilers(rows), nil
}

// Reconciler is the resolver for the reconciler field.
func (r *teamMemberReconcilerResolver) Reconciler(ctx context.Context, obj *model.TeamMemberReconciler) (*model.Reconciler, error) {
	reconciler, err := r.database.GetReconciler(ctx, obj.GQLVars.Name)
	if err != nil {
		return nil, err
	}

	return toGraphReconciler(reconciler), nil
}

// Team returns gengql.TeamResolver implementation.
func (r *Resolver) Team() gengql.TeamResolver { return &teamResolver{r} }

// TeamMember returns gengql.TeamMemberResolver implementation.
func (r *Resolver) TeamMember() gengql.TeamMemberResolver { return &teamMemberResolver{r} }

// TeamMemberReconciler returns gengql.TeamMemberReconcilerResolver implementation.
func (r *Resolver) TeamMemberReconciler() gengql.TeamMemberReconcilerResolver {
	return &teamMemberReconcilerResolver{r}
}

type (
	teamResolver                 struct{ *Resolver }
	teamMemberResolver           struct{ *Resolver }
	teamMemberReconcilerResolver struct{ *Resolver }
)

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/google/uuid"
	pgx "github.com/jackc/pgx/v5"
	"github.com/nais/api/internal/auditlogger"
	"github.com/nais/api/internal/auditlogger/audittype"
	"github.com/nais/api/internal/auth/authz"
	"github.com/nais/api/internal/auth/roles"
	"github.com/nais/api/internal/database"
	"github.com/nais/api/internal/database/gensql"
	"github.com/nais/api/internal/graph/apierror"
	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/loader"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/model/vulnerabilities"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/k8s"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/thirdparty/dependencytrack"
	"github.com/nais/api/internal/thirdparty/hookd"
	"github.com/nais/api/pkg/protoapi"
	"github.com/sourcegraph/conc/pool"
	"k8s.io/utils/ptr"
)

// CreateTeam is the resolver for the createTeam field.
func (r *mutationResolver) CreateTeam(ctx context.Context, input model.CreateTeamInput) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationTeamsCreate)
	if err != nil {
		return nil, err
	}

	input = input.Sanitize()

	err = input.Validate()
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	var team *database.Team
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		team, err = dbtx.CreateTeam(ctx, input.Slug, input.Purpose, input.SlackChannel)
		if err != nil {
			return err
		}

		if actor.User.IsServiceAccount() {
			return dbtx.AssignTeamRoleToServiceAccount(ctx, actor.User.GetID(), gensql.RoleNameTeamowner, input.Slug)
		}

		return dbtx.SetTeamMemberRole(ctx, actor.User.GetID(), team.Slug, gensql.RoleNameTeamowner)
	})
	if err != nil {
		return nil, err
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(team.Slug),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamCreate,
		CorrelationID: correlationID,
		Actor:         actor,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Team created")

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return loader.ToGraphTeam(team), nil
}

// UpdateTeam is the resolver for the updateTeam field.
func (r *mutationResolver) UpdateTeam(ctx context.Context, slug slug.Slug, input model.UpdateTeamInput) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsMetadataUpdate, slug)
	if err != nil {
		return nil, err
	}

	if _, err := loader.GetTeam(ctx, slug); err != nil {
		return nil, err
	}

	input = input.Sanitize()
	err = input.Validate(r.clusters.Names())
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()
	auditLogEntries := make([]auditlogger.Entry, 0)
	var team *database.Team
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		team, err = dbtx.UpdateTeam(ctx, slug, input.Purpose, input.SlackChannel)
		if err != nil {
			return err
		}

		if len(input.SlackAlertsChannels) > 0 {
			for _, slackAlertsChannel := range input.SlackAlertsChannels {
				err := dbtx.UpsertTeamEnvironment(ctx, slug, slackAlertsChannel.Environment, slackAlertsChannel.ChannelName, nil)
				if err != nil {
					return err
				}
			}
		}

		targets := []auditlogger.Target{
			auditlogger.TeamTarget(slug),
		}
		fields := auditlogger.Fields{
			Action:        audittype.AuditActionGraphqlApiTeamUpdate,
			CorrelationID: correlationID,
			Actor:         actor,
		}
		auditLogEntries = append(auditLogEntries, auditlogger.Entry{
			Targets: targets,
			Fields:  fields,
			Message: "Team configuration saved",
		})
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return loader.ToGraphTeam(team), nil
}

// RemoveUsersFromTeam is the resolver for the removeUsersFromTeam field.
func (r *mutationResolver) RemoveUsersFromTeam(ctx context.Context, slug slug.Slug, userIds []*scalar.Ident) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsMembersAdmin, slug)
	if err != nil {
		return nil, err
	}

	if _, err := loader.GetTeam(ctx, slug); err != nil {
		return nil, err
	}

	correlationID := uuid.New()
	auditLogEntries := make([]auditlogger.Entry, 0)
	var team *database.Team
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		members, err := dbtx.GetAllTeamMembers(ctx, slug)
		if err != nil {
			return fmt.Errorf("get team members of %q: %w", slug, err)
		}

		memberFromUserID := func(userId uuid.UUID) *database.User {
			for _, m := range members {
				if m.ID == userId {
					return m
				}
			}
			return nil
		}

		for _, userID := range userIds {
			uuid, err := userID.AsUUID()
			if err != nil {
				return err
			}
			member := memberFromUserID(uuid)
			if member == nil {
				return apierror.Errorf("The user %q is not a member of team %q.", uuid, slug)
			}

			err = dbtx.RemoveUserFromTeam(ctx, uuid, slug)
			if err != nil {
				return err
			}

			targets := []auditlogger.Target{
				auditlogger.TeamTarget(slug),
				auditlogger.UserTarget(member.Email),
			}
			fields := auditlogger.Fields{
				Action:        audittype.AuditActionGraphqlApiTeamRemoveMember,
				CorrelationID: correlationID,
				Actor:         actor,
			}
			auditLogEntries = append(auditLogEntries, auditlogger.Entry{
				Targets: targets,
				Fields:  fields,
				Message: fmt.Sprintf("Removed user: %q", member.Email),
			})
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, slug, correlationID)

	return loader.ToGraphTeam(team), nil
}

// RemoveUserFromTeam is the resolver for the removeUserFromTeam field.
func (r *mutationResolver) RemoveUserFromTeam(ctx context.Context, slug slug.Slug, userID scalar.Ident) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsMembersAdmin, slug)
	if err != nil {
		return nil, err
	}

	userUID, err := userID.AsUUID()
	if err != nil {
		return nil, err
	}

	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	auditLogEntries := make([]auditlogger.Entry, 0)
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		members, err := dbtx.GetAllTeamMembers(ctx, slug)
		if err != nil {
			return fmt.Errorf("get team members of %q: %w", slug, err)
		}

		memberFromUserID := func(userId uuid.UUID) *database.User {
			for _, m := range members {
				if m.ID == userId {
					return m
				}
			}
			return nil
		}

		member := memberFromUserID(userUID)
		if member == nil {
			return apierror.Errorf("The user %q is not a member of team %q.", userUID, slug)
		}

		err = dbtx.RemoveUserFromTeam(ctx, userUID, slug)
		if err != nil {
			return err
		}

		targets := []auditlogger.Target{
			auditlogger.TeamTarget(slug),
			auditlogger.UserTarget(member.Email),
		}
		fields := auditlogger.Fields{
			Action:        audittype.AuditActionGraphqlApiTeamRemoveMember,
			CorrelationID: correlationID,
			Actor:         actor,
		}
		auditLogEntries = append(auditLogEntries, auditlogger.Entry{
			Targets: targets,
			Fields:  fields,
			Message: fmt.Sprintf("Removed user: %q", member.Email),
		})
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, slug, correlationID)

	return team, nil
}

// SynchronizeTeam is the resolver for the synchronizeTeam field.
func (r *mutationResolver) SynchronizeTeam(ctx context.Context, slug slug.Slug) (*model.TeamSync, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsSynchronize, slug)
	if err != nil {
		return nil, err
	}

	if _, err := loader.GetTeam(ctx, slug); err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(slug),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamSync,
		CorrelationID: correlationID,
		Actor:         actor,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Manually scheduled for synchronization")

	r.triggerTeamUpdatedEvent(ctx, slug, correlationID)

	return &model.TeamSync{
		CorrelationID: correlationID,
	}, nil
}

// SynchronizeAllTeams is the resolver for the synchronizeAllTeams field.
func (r *mutationResolver) SynchronizeAllTeams(ctx context.Context) (*model.TeamSync, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationTeamsSynchronize)
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	limit, offset := 100, 0
	teams := make([]*database.Team, 0)
	for {
		page, _, err := r.database.GetTeams(ctx, database.Page{
			Limit:  limit,
			Offset: offset,
		})
		if err != nil {
			return nil, err
		}
		teams = append(teams, page...)
		if len(page) < limit {
			break
		}
		offset += limit
	}

	targets := make([]auditlogger.Target, 0, len(teams))
	for _, entry := range teams {
		targets = append(targets, auditlogger.TeamTarget(entry.Slug))
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamSync,
		Actor:         actor,
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Manually scheduled for synchronization")
	r.triggerEvent(ctx, protoapi.EventTypes_EVENT_SYNC_ALL_TEAMS, &protoapi.EventSyncAllTeams{}, correlationID)

	return &model.TeamSync{
		CorrelationID: correlationID,
	}, nil
}

// AddTeamMembers is the resolver for the addTeamMembers field.
func (r *mutationResolver) AddTeamMembers(ctx context.Context, slug slug.Slug, userIds []*scalar.Ident) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	if err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsMembersAdmin, slug); err != nil {
		return nil, err
	}

	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	auditLogEntries := make([]auditlogger.Entry, 0)
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		for _, userID := range userIds {
			uid, err := userID.AsUUID()
			if err != nil {
				return err
			}
			user, err := dbtx.GetUserByID(ctx, uid)
			if err != nil {
				return err
			}

			if err := dbtx.SetTeamMemberRole(ctx, uid, team.Slug, gensql.RoleNameTeammember); err != nil {
				return err
			}

			targets := []auditlogger.Target{
				auditlogger.TeamTarget(team.Slug),
				auditlogger.UserTarget(user.Email),
			}
			fields := auditlogger.Fields{
				Action:        audittype.AuditActionGraphqlApiTeamAddMember,
				CorrelationID: correlationID,
				Actor:         actor,
			}
			auditLogEntries = append(auditLogEntries, auditlogger.Entry{
				Targets: targets,
				Fields:  fields,
				Message: fmt.Sprintf("Add team member: %q", user.Email),
			})
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return team, nil
}

// AddTeamOwners is the resolver for the addTeamOwners field.
func (r *mutationResolver) AddTeamOwners(ctx context.Context, slug slug.Slug, userIds []*scalar.Ident) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsMembersAdmin, slug)
	if err != nil {
		return nil, err
	}

	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	auditLogEntries := make([]auditlogger.Entry, 0)
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		for _, userID := range userIds {
			uid, err := userID.AsUUID()
			if err != nil {
				return err
			}
			user, err := dbtx.GetUserByID(ctx, uid)
			if err != nil {
				return err
			}

			err = dbtx.SetTeamMemberRole(ctx, uid, team.Slug, gensql.RoleNameTeamowner)
			if err != nil {
				return err
			}

			targets := []auditlogger.Target{
				auditlogger.TeamTarget(team.Slug),
				auditlogger.UserTarget(user.Email),
			}
			fields := auditlogger.Fields{
				Action:        audittype.AuditActionGraphqlApiTeamAddOwner,
				CorrelationID: correlationID,
				Actor:         actor,
			}
			auditLogEntries = append(auditLogEntries, auditlogger.Entry{
				Targets: targets,
				Fields:  fields,
				Message: fmt.Sprintf("Add team owner: %q", user.Email),
			})
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return team, nil
}

// AddTeamMember is the resolver for the addTeamMember field.
func (r *mutationResolver) AddTeamMember(ctx context.Context, slug slug.Slug, member model.TeamMemberInput) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsMembersAdmin, slug)
	if err != nil {
		return nil, err
	}
	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		return nil, err
	}

	uid, err := member.UserID.AsUUID()
	if err != nil {
		return nil, err
	}

	user, err := r.database.GetUserByID(ctx, uid)
	if err != nil {
		return nil, apierror.ErrUserNotExists
	}

	correlationID := uuid.New()

	auditLogEntries := make([]auditlogger.Entry, 0)
	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		teamMember, _ := dbtx.GetTeamMember(ctx, slug, user.ID)
		if teamMember != nil {
			return apierror.Errorf("User is already a member of the team.")
		}

		role, err := gensqlRoleFromTeamRole(member.Role)
		if err != nil {
			return err
		}

		err = dbtx.SetTeamMemberRole(ctx, user.ID, team.Slug, role)
		if err != nil {
			return err
		}

		for _, reconcilerName := range member.ReconcilerOptOuts {
			err = dbtx.AddReconcilerOptOut(ctx, user.ID, team.Slug, reconcilerName)
			if err != nil {
				return err
			}
		}

		targets := []auditlogger.Target{
			auditlogger.TeamTarget(team.Slug),
			auditlogger.UserTarget(user.Email),
		}

		var action audittype.AuditAction
		var msg string

		switch role {
		case gensql.RoleNameTeamowner:
			action = audittype.AuditActionGraphqlApiTeamAddOwner
			msg = fmt.Sprintf("Add team owner: %q", user.Email)
		case gensql.RoleNameTeammember:
			action = audittype.AuditActionGraphqlApiTeamAddMember
			msg = fmt.Sprintf("Add team member: %q", user.Email)
		default:
			return fmt.Errorf("unknown role: %q", role)
		}

		fields := auditlogger.Fields{
			Action:        action,
			CorrelationID: correlationID,
			Actor:         actor,
		}
		auditLogEntries = append(auditLogEntries, auditlogger.Entry{
			Targets: targets,
			Fields:  fields,
			Message: msg,
		})
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, entry := range auditLogEntries {
		r.auditLogger.Logf(ctx, entry.Targets, entry.Fields, entry.Message)
	}

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return team, nil
}

// SetTeamMemberRole is the resolver for the setTeamMemberRole field.
func (r *mutationResolver) SetTeamMemberRole(ctx context.Context, slug slug.Slug, userID scalar.Ident, role model.TeamRole) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationUsersUpdate, slug)
	if err != nil {
		return nil, err
	}

	uid, err := userID.AsUUID()
	if err != nil {
		return nil, err
	}

	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		return nil, err
	}

	correlationID := uuid.New()

	members, err := r.database.GetAllTeamMembers(ctx, team.Slug)
	if err != nil {
		return nil, fmt.Errorf("get team members: %w", err)
	}

	var member *database.User = nil
	for _, m := range members {
		if m.ID == uid {
			member = m
			break
		}
	}
	if member == nil {
		return nil, fmt.Errorf("user %q not in team %q", uid, slug)
	}

	desiredRole, err := gensqlRoleFromTeamRole(role)
	if err != nil {
		return nil, err
	}

	err = r.database.Transaction(ctx, func(ctx context.Context, dbtx database.Database) error {
		err = dbtx.RemoveUserFromTeam(ctx, uid, team.Slug)
		if err != nil {
			return err
		}

		return dbtx.SetTeamMemberRole(ctx, uid, team.Slug, desiredRole)
	})
	if err != nil {
		return nil, err
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(team.Slug),
		auditlogger.UserTarget(member.Email),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamSetMemberRole,
		CorrelationID: correlationID,
		Actor:         actor,
	}

	r.auditLogger.Logf(ctx, targets, fields, "Assign %q to %s", desiredRole, member.Email)

	r.triggerTeamUpdatedEvent(ctx, team.Slug, correlationID)

	return team, nil
}

// RequestTeamDeletion is the resolver for the requestTeamDeletion field.
func (r *mutationResolver) RequestTeamDeletion(ctx context.Context, slug slug.Slug) (*model.TeamDeleteKey, error) {
	actor := authz.ActorFromContext(ctx)

	err := authz.RequireTeamRole(actor, slug, gensql.RoleNameTeamowner)
	if err != nil {
		return nil, err
	}

	team, err := loader.GetTeam(ctx, slug)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, apierror.ErrTeamNotExist
		}
		return nil, err
	}

	correlationID := uuid.New()

	deleteKey, err := r.database.CreateTeamDeleteKey(ctx, slug, actor.User.GetID())
	if err != nil {
		return nil, fmt.Errorf("create team delete key: %w", err)
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(team.Slug),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamsRequestDelete,
		Actor:         actor,
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Request team deletion")

	return toGraphTeamDeleteKey(deleteKey), nil
}

// ConfirmTeamDeletion is the resolver for the confirmTeamDeletion field.
func (r *mutationResolver) ConfirmTeamDeletion(ctx context.Context, key string) (bool, error) {
	uid, err := uuid.Parse(key)
	if err != nil {
		return false, apierror.Errorf("Invalid deletion key: %q", key)
	}

	deleteKey, err := r.database.GetTeamDeleteKey(ctx, uid)
	if err != nil {
		return false, apierror.Errorf("Unknown deletion key: %q", key)
	}

	actor := authz.ActorFromContext(ctx)
	err = authz.RequireTeamRole(actor, deleteKey.TeamSlug, gensql.RoleNameTeamowner)
	if err != nil {
		return false, err
	}

	if actor.User.GetID() == deleteKey.CreatedBy {
		return false, apierror.Errorf("You cannot confirm your own delete key.")
	}

	if deleteKey.ConfirmedAt.Valid {
		return false, apierror.Errorf("Key has already been confirmed, team is currently being deleted.")
	}

	if deleteKey.HasExpired() {
		return false, apierror.Errorf("Team delete key has expired, you need to request a new key.")
	}

	correlationID := uuid.New()

	err = r.database.ConfirmTeamDeleteKey(ctx, uid)
	if err != nil {
		return false, fmt.Errorf("confirm team delete key: %w", err)
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(deleteKey.TeamSlug),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiTeamsDelete,
		Actor:         actor,
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Delete team")

	r.triggerTeamDeletedEvent(ctx, deleteKey.TeamSlug, correlationID)

	return true, nil
}

// ChangeDeployKey is the resolver for the changeDeployKey field.
func (r *mutationResolver) ChangeDeployKey(ctx context.Context, team slug.Slug) (*model.DeploymentKey, error) {
	actor := authz.ActorFromContext(ctx)
	if _, err := r.database.GetTeamMember(ctx, team, actor.User.GetID()); errors.Is(err, pgx.ErrNoRows) {
		return nil, apierror.ErrUserIsNotTeamMember
	} else if err != nil {
		return nil, err
	}

	deployKey, err := r.hookdClient.ChangeDeployKey(ctx, team.String())
	if err != nil {
		return nil, fmt.Errorf("changing deploy key in Hookd: %w", err)
	}
	return &model.DeploymentKey{
		ID:      scalar.DeployKeyIdent(team.String()),
		Key:     deployKey.Key,
		Created: deployKey.Created,
		Expires: deployKey.Expires,
	}, nil
}

// Teams is the resolver for the teams field.
func (r *queryResolver) Teams(ctx context.Context, offset *int, limit *int, filter *model.TeamsFilter) (*model.TeamList, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationTeamsList)
	if err != nil {
		return nil, err
	}

	var teams []*database.Team

	p := model.NewPagination(offset, limit)
	var pageInfo model.PageInfo

	if filter != nil && filter.Github != nil {
		teams, err = r.database.GetAllTeamsWithPermissionInGitHubRepo(ctx, filter.Github.RepoName, filter.Github.PermissionName)
		if err != nil {
			return nil, err
		}

		teams, pageInfo = model.PaginatedSlice(teams, p)
	} else {
		var total int
		teams, total, err = r.database.GetTeams(ctx, database.Page{
			Limit:  p.Limit,
			Offset: p.Offset,
		})
		if err != nil {
			return nil, err
		}

		pageInfo = model.NewPageInfo(p, total)
	}

	return &model.TeamList{
		Nodes:    toGraphTeams(teams),
		PageInfo: pageInfo,
	}, nil
}

// Team is the resolver for the team field.
func (r *queryResolver) Team(ctx context.Context, slug slug.Slug) (*model.Team, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsRead, slug)
	if err != nil {
		return nil, err
	}

	return loader.GetTeam(ctx, slug)
}

// TeamDeleteKey is the resolver for the teamDeleteKey field.
func (r *queryResolver) TeamDeleteKey(ctx context.Context, key string) (*model.TeamDeleteKey, error) {
	kid, err := uuid.Parse(key)
	if err != nil {
		return nil, apierror.Errorf("Invalid deletion key: %q", key)
	}

	deleteKey, err := r.database.GetTeamDeleteKey(ctx, kid)
	if err != nil {
		return nil, apierror.Errorf("Unknown deletion key: %q", key)
	}

	actor := authz.ActorFromContext(ctx)
	err = authz.RequireTeamRole(actor, deleteKey.TeamSlug, gensql.RoleNameTeamowner)
	if err != nil {
		return nil, err
	}

	return toGraphTeamDeleteKey(deleteKey), nil
}

// ID is the resolver for the id field.
func (r *teamResolver) ID(ctx context.Context, obj *model.Team) (*scalar.Ident, error) {
	return ptr.To(scalar.TeamIdent(obj.Slug)), nil
}

// AuditLogs is the resolver for the auditLogs field.
func (r *teamResolver) AuditLogs(ctx context.Context, obj *model.Team, offset *int, limit *int) (*model.AuditLogList, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationAuditLogsRead, obj.Slug)
	if err != nil {
		return nil, err
	}

	p := model.NewPagination(offset, limit)
	entries, total, err := r.database.GetAuditLogsForTeam(ctx, obj.Slug, database.Page{
		Limit:  p.Limit,
		Offset: p.Offset,
	})
	if err != nil {
		return nil, err
	}

	return &model.AuditLogList{
		Nodes:    toGraphAuditLogs(entries),
		PageInfo: model.NewPageInfo(p, total),
	}, nil
}

// Members is the resolver for the members field.
func (r *teamResolver) Members(ctx context.Context, obj *model.Team, offset *int, limit *int) (*model.TeamMemberList, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersList)
	if err != nil {
		return nil, err
	}

	p := model.NewPagination(offset, limit)

	users, total, err := r.database.GetTeamMembers(ctx, obj.Slug, database.Page{
		Limit:  p.Limit,
		Offset: p.Offset,
	})
	if err != nil {
		return nil, err
	}

	members := make([]*model.TeamMember, len(users))
	for idx, user := range users {
		members[idx] = &model.TeamMember{
			UserID:   scalar.UserIdent(user.ID),
			TeamSlug: obj.Slug,
		}
	}

	return &model.TeamMemberList{
		Nodes:    members,
		PageInfo: model.NewPageInfo(p, total),
	}, nil
}

// Member is the resolver for the member field.
func (r *teamResolver) Member(ctx context.Context, obj *model.Team, userID scalar.Ident) (*model.TeamMember, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireGlobalAuthorization(actor, roles.AuthorizationUsersList)
	if err != nil {
		return nil, err
	}

	uid, err := userID.AsUUID()
	if err != nil {
		return nil, err
	}

	user, err := r.database.GetUserByID(ctx, uid)
	if err != nil {
		return nil, apierror.ErrUserNotExists
	}

	return &model.TeamMember{
		UserID:   scalar.UserIdent(user.ID),
		TeamSlug: obj.Slug,
	}, nil
}

// SyncErrors is the resolver for the syncErrors field.
func (r *teamResolver) SyncErrors(ctx context.Context, obj *model.Team) ([]*model.SyncError, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationTeamsRead, obj.Slug)
	if err != nil {
		return nil, err
	}

	rows, err := r.database.GetTeamReconcilerErrors(ctx, obj.Slug)
	if err != nil {
		return nil, err
	}

	syncErrors := make([]*model.SyncError, 0)
	for _, row := range rows {
		syncErrors = append(syncErrors, &model.SyncError{
			CreatedAt:  row.CreatedAt.Time,
			Reconciler: row.Reconciler,
			Error:      row.ErrorMessage,
		})
	}

	return syncErrors, nil
}

// GithubRepositories is the resolver for the githubRepositories field.
func (r *teamResolver) GithubRepositories(ctx context.Context, obj *model.Team, offset *int, limit *int, filter *model.GitHubRepositoriesFilter) (*model.GitHubRepositoryList, error) {
	page := model.NewPagination(offset, limit)

	state, err := r.database.GetReconcilerStateForTeam(ctx, "github:team", obj.Slug)
	if err != nil {
		return &model.GitHubRepositoryList{
			Nodes: []*model.GitHubRepository{},
		}, nil
	}

	repos, err := toGraphGitHubRepositories(obj.Slug, state, filter)
	if err != nil {
		return nil, err
	}

	nodes, pageInfo := model.PaginatedSlice(repos, page)
	return &model.GitHubRepositoryList{
		Nodes:    nodes,
		PageInfo: pageInfo,
	}, nil
}

// DeletionInProgress is the resolver for the deletionInProgress field.
func (r *teamResolver) DeletionInProgress(ctx context.Context, obj *model.Team) (bool, error) {
	_, err := r.database.GetActiveTeamBySlug(ctx, obj.Slug)
	if errors.Is(err, pgx.ErrNoRows) {
		return true, nil
	}

	return false, err
}

// ViewerIsOwner is the resolver for the viewerIsOwner field.
func (r *teamResolver) ViewerIsOwner(ctx context.Context, obj *model.Team) (bool, error) {
	actor := authz.ActorFromContext(ctx)
	return r.database.UserIsTeamOwner(ctx, actor.User.GetID(), obj.Slug)
}

// ViewerIsMember is the resolver for the viewerIsMember field.
func (r *teamResolver) ViewerIsMember(ctx context.Context, obj *model.Team) (bool, error) {
	actor := authz.ActorFromContext(ctx)
	u, err := r.database.GetTeamMember(ctx, obj.Slug, actor.User.GetID())
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return false, nil
		}
		return false, err
	}
	return u != nil, nil
}

// Status is the resolver for the status field.
func (r *teamResolver) Status(ctx context.Context, obj *model.Team) (*model.TeamStatus, error) {
	wg := pool.NewWithResults[any]().WithErrors().WithFirstError()

	wg.Go(func() (any, error) {
		apps, err := r.k8sClient.Apps(ctx, obj.Slug.String())
		if err != nil {
			return nil, fmt.Errorf("getting apps from Kubernetes: %w", err)
		}
		failingApps := 0
		for _, app := range apps {
			if app.Status.State == model.StateFailing {
				failingApps++
			}
		}
		return model.AppsStatus{
			Total:   len(apps),
			Failing: failingApps,
		}, nil
	})

	wg.Go(func() (any, error) {
		jobs, err := r.k8sClient.NaisJobs(ctx, obj.Slug.String())
		if err != nil {
			return nil, fmt.Errorf("getting naisjobs from Kubernetes: %w", err)
		}
		failingJobs := 0
		for _, job := range jobs {
			if job.Status.State == model.StateFailing {
				failingJobs++
			}
		}
		return model.JobsStatus{
			Total:   len(jobs),
			Failing: failingJobs,
		}, nil
	})

	wg.Go(func() (any, error) {
		teamEnvs, _, err := r.database.GetTeamEnvironments(ctx, obj.Slug, database.Page{Limit: 50})
		if err != nil {
			return nil, err
		}
		sqlInstances, _, err := r.sqlInstanceClient.SqlInstances(ctx, obj.Slug, teamEnvs)
		failingSqlInstances := 0
		otherConditions := 0
		if err != nil {
			return nil, fmt.Errorf("getting SQL instances from Kubernetes: %w", err)
		}
		for _, sqlInstance := range sqlInstances {
			notReady := sqlInstance.IsNotReady()
			healthy := sqlInstance.IsHealthy()
			if sqlInstance.State != model.SQLInstanceStateRunnable {
				failingSqlInstances++
				continue
			}

			if notReady {
				failingSqlInstances++
			}

			if !notReady && !healthy {
				otherConditions++
			}
		}
		return model.SQLInstancesStatus{
			Total:           len(sqlInstances),
			Failing:         failingSqlInstances,
			OtherConditions: otherConditions,
		}, nil
	})

	res, err := wg.Wait()
	if err != nil {
		return nil, err
	}

	ret := &model.TeamStatus{}

	for _, r := range res {
		switch v := r.(type) {
		case model.AppsStatus:
			ret.Apps = v
		case model.JobsStatus:
			ret.Jobs = v
		case model.SQLInstancesStatus:
			ret.SQLInstances = v
		}
	}

	return ret, nil
}

// SQLInstance is the resolver for the sqlInstance field.
func (r *teamResolver) SQLInstance(ctx context.Context, obj *model.Team, name string, env string) (*model.SQLInstance, error) {
	return r.sqlInstanceClient.SqlInstance(ctx, env, obj.Slug, name)
}

// SQLInstances is the resolver for the sqlInstances field.
func (r *teamResolver) SQLInstances(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.SQLInstancesList, error) {
	dbEnvs, _, err := r.database.GetTeamEnvironments(ctx, obj.Slug, database.Page{Limit: 50})
	if err != nil {
		return nil, err
	}

	sqlInstances, metrics, err := r.sqlInstanceClient.SqlInstances(ctx, obj.Slug, dbEnvs)
	if err != nil {
		return nil, fmt.Errorf("getting SQL instances from Kubernetes: %w", err)
	}

	if orderBy != nil {
		switch orderBy.Field {
		case model.OrderByFieldName:
			model.SortWith(sqlInstances, func(a, b *model.SQLInstance) bool {
				return model.Compare(a.Name, b.Name, orderBy.Direction)
			})
		case model.OrderByFieldEnv:
			model.SortWith(sqlInstances, func(a, b *model.SQLInstance) bool {
				return model.Compare(a.Env.Name, b.Env.Name, orderBy.Direction)
			})
		case model.OrderByFieldStatus:
			model.SortWith(sqlInstances, func(a, b *model.SQLInstance) bool {
				return model.Compare(strconv.FormatBool(a.IsHealthy()), strconv.FormatBool(b.IsHealthy()), orderBy.Direction)
			})
		case model.OrderByFieldVersion:
			model.SortWith(sqlInstances, func(a, b *model.SQLInstance) bool {
				return model.Compare(a.Type, b.Type, orderBy.Direction)
			})
		case model.OrderByFieldCost:
			model.SortWith(sqlInstances, func(a, b *model.SQLInstance) bool {
				return model.Compare(a.Metrics.Cost, b.Metrics.Cost, orderBy.Direction)
			})
		case model.OrderByFieldCPU:
			model.SortWith(sqlInstances, func(a, b *model.SQLInstance) bool {
				return model.Compare(a.Metrics.CPU.Utilization, b.Metrics.CPU.Utilization, orderBy.Direction)
			})
		case model.OrderByFieldMemory:
			model.SortWith(sqlInstances, func(a, b *model.SQLInstance) bool {
				return model.Compare(a.Metrics.Memory.Utilization, b.Metrics.Memory.Utilization, orderBy.Direction)
			})
		case model.OrderByFieldDisk:
			model.SortWith(sqlInstances, func(a, b *model.SQLInstance) bool {
				return model.Compare(a.Metrics.Disk.Utilization, b.Metrics.Disk.Utilization, orderBy.Direction)
			})
		}
	}
	pagination := model.NewPagination(offset, limit)
	sqlInstances, pageInfo := model.PaginatedSlice(sqlInstances, pagination)

	return &model.SQLInstancesList{
		Nodes:    sqlInstances,
		PageInfo: pageInfo,
		Metrics:  metrics,
	}, nil
}

// Buckets is the resolver for the buckets field.
func (r *teamResolver) Buckets(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.BucketsList, error) {
	buckets, err := r.bucketClient.Buckets(obj.Slug)
	if err != nil {
		return nil, err
	}

	if orderBy != nil {
		switch orderBy.Field {
		case model.OrderByFieldName:
			model.SortWith(buckets, func(a, b *model.Bucket) bool {
				return model.Compare(a.Name, b.Name, orderBy.Direction)
			})
		case model.OrderByFieldEnv:
			model.SortWith(buckets, func(a, b *model.Bucket) bool {
				return model.Compare(a.Env.Name, b.Env.Name, orderBy.Direction)
			})
		}
	}

	pagination := model.NewPagination(offset, limit)
	buckets, pageInfo := model.PaginatedSlice(buckets, pagination)

	return &model.BucketsList{
		Nodes:    buckets,
		PageInfo: pageInfo,
	}, nil
}

// Redis is the resolver for the redis field.
func (r *teamResolver) Redis(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.RedisList, error) {
	redis, err := r.redisClient.Redis(obj.Slug)
	if err != nil {
		return nil, err
	}

	if orderBy != nil {
		switch orderBy.Field {
		case model.OrderByFieldName:
			model.SortWith(redis, func(a, b *model.Redis) bool {
				return model.Compare(a.Name, b.Name, orderBy.Direction)
			})
		case model.OrderByFieldEnv:
			model.SortWith(redis, func(a, b *model.Redis) bool {
				return model.Compare(a.Env.Name, b.Env.Name, orderBy.Direction)
			})
		}
	}

	pagination := model.NewPagination(offset, limit)
	redis, pageInfo := model.PaginatedSlice(redis, pagination)

	return &model.RedisList{
		Nodes:    redis,
		PageInfo: pageInfo,
	}, nil
}

// OpenSearch is the resolver for the openSearch field.
func (r *teamResolver) OpenSearch(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.OpenSearchList, error) {
	openSearch, err := r.openSearchClient.OpenSearch(obj.Slug)
	if err != nil {
		return nil, err
	}

	if orderBy != nil {
		switch orderBy.Field {
		case model.OrderByFieldName:
			model.SortWith(openSearch, func(a, b *model.OpenSearch) bool {
				return model.Compare(a.Name, b.Name, orderBy.Direction)
			})
		case model.OrderByFieldEnv:
			model.SortWith(openSearch, func(a, b *model.OpenSearch) bool {
				return model.Compare(a.Env.Name, b.Env.Name, orderBy.Direction)
			})
		}
	}

	pagination := model.NewPagination(offset, limit)
	openSearch, pageInfo := model.PaginatedSlice(openSearch, pagination)

	return &model.OpenSearchList{
		Nodes:    openSearch,
		PageInfo: pageInfo,
	}, nil
}

// KafkaTopic is the resolver for the kafkaTopic field.
func (r *teamResolver) KafkaTopic(ctx context.Context, obj *model.Team, name string, env string) (*model.KafkaTopic, error) {
	return r.kafkaClient.Topic(env, obj.Slug, name)
}

// KafkaTopics is the resolver for the kafkaTopics field.
func (r *teamResolver) KafkaTopics(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.KafkaTopicList, error) {
	kts, err := r.kafkaClient.Topics(obj.Slug)
	if err != nil {
		return nil, err
	}

	if orderBy != nil {
		switch orderBy.Field {
		case model.OrderByFieldName:
			model.SortWith(kts, func(a, b *model.KafkaTopic) bool {
				return model.Compare(a.Name, b.Name, orderBy.Direction)
			})
		case model.OrderByFieldEnv:
			model.SortWith(kts, func(a, b *model.KafkaTopic) bool {
				return model.Compare(a.Env.Name, b.Env.Name, orderBy.Direction)
			})
		}
	}

	pagination := model.NewPagination(offset, limit)
	kts, pageInfo := model.PaginatedSlice(kts, pagination)

	return &model.KafkaTopicList{
		Nodes:    kts,
		PageInfo: pageInfo,
	}, nil
}

// BigQuery is the resolver for the bigQuery field.
func (r *teamResolver) BigQuery(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.BigQueryDatasetList, error) {
	bqs, err := r.bigQueryDatasetClient.BigQueryDatasets(obj.Slug)
	if err != nil {
		return nil, err
	}

	if orderBy != nil {
		switch orderBy.Field {
		case model.OrderByFieldName:
			model.SortWith(bqs, func(a, b *model.BigQueryDataset) bool {
				return model.Compare(a.Name, b.Name, orderBy.Direction)
			})
		case model.OrderByFieldEnv:
			model.SortWith(bqs, func(a, b *model.BigQueryDataset) bool {
				return model.Compare(a.Env.Name, b.Env.Name, orderBy.Direction)
			})
		}
	}

	pagination := model.NewPagination(offset, limit)
	bqs, pageInfo := model.PaginatedSlice(bqs, pagination)

	return &model.BigQueryDatasetList{
		Nodes:    bqs,
		PageInfo: pageInfo,
	}, nil
}

// Apps is the resolver for the apps field.
func (r *teamResolver) Apps(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.AppList, error) {
	apps, err := r.k8sClient.Apps(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting apps from Kubernetes: %w", err)
	}

	for _, app := range apps {
		if app.GQLVars.Spec.ImageName == "" {
			fmt.Println("app.GQLVars.Spec.ImageName is empty")
		}
		image, err := r.dependencyTrackClient.GetMetadataForImage(ctx, app.GQLVars.Spec.ImageName)
		if err != nil {
			return nil, fmt.Errorf("getting metadata for image %q: %w", app.GQLVars.Spec.ImageName, err)
		}
		app.Image = *image
	}
	if orderBy != nil {
		switch orderBy.Field {
		case model.OrderByFieldName:
			model.SortWith(apps, func(a, b *model.App) bool {
				return model.Compare(a.Name, b.Name, orderBy.Direction)
			})
		case model.OrderByFieldEnv:
			model.SortWith(apps, func(a, b *model.App) bool {
				return model.Compare(a.Env.Name, b.Env.Name, orderBy.Direction)
			})
		case model.OrderByFieldDeployed:
			model.SortWith(apps, func(a, b *model.App) bool {
				if a.DeployInfo.Timestamp == nil {
					return false
				}
				if b.DeployInfo.Timestamp == nil {
					return true
				}
				return model.Compare(b.DeployInfo.Timestamp.UnixMilli(), a.DeployInfo.Timestamp.UnixMilli(), orderBy.Direction)
			})
		case model.OrderByFieldStatus:
			model.SortWith(apps, func(a, b *model.App) bool {
				sortOrder := []model.State{model.StateFailing, model.StateNotnais, model.StateUnknown, model.StateNais}
				aIndex := -1
				bIndex := -1
				for i, s := range sortOrder {
					if a.Status.State == s {
						aIndex = i
					}
					if b.Status.State == s {
						bIndex = i
					}
				}
				if aIndex == -1 {
					return false
				}
				if bIndex == -1 {
					return true
				}
				if orderBy.Direction == model.SortOrderAsc {
					return aIndex < bIndex
				}
				return aIndex > bIndex
			})
		case model.OrderByFieldSeverityCritical:
			model.SortWith(apps, func(a, b *model.App) bool {
				return model.Compare(a.Image.Summary.Critical, b.Image.Summary.Critical, orderBy.Direction)
			})
		case model.OrderByFieldRiskScore:
			model.SortWith(apps, func(a, b *model.App) bool {
				return model.Compare(a.Image.Summary.RiskScore, b.Image.Summary.RiskScore, orderBy.Direction)
			})

		}
	}
	pagination := model.NewPagination(offset, limit)
	apps, pageInfo := model.PaginatedSlice(apps, pagination)
	for _, app := range apps {
		app.GQLVars = model.WorkloadBaseGQLVars{Team: obj.Slug}
	}

	return &model.AppList{
		Nodes:    apps,
		PageInfo: pageInfo,
	}, nil
}

// DeployKey is the resolver for the deployKey field.
func (r *teamResolver) DeployKey(ctx context.Context, obj *model.Team) (*model.DeploymentKey, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamAuthorization(actor, roles.AuthorizationDeployKeyView, obj.Slug)
	if err != nil {
		if actor.User.IsServiceAccount() {
			return nil, apierror.ErrUserIsNotTeamMember
		}
		return nil, err
	}

	key, err := r.hookdClient.DeployKey(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting deploy key from Hookd: %w", err)
	}

	return &model.DeploymentKey{
		ID:      scalar.DeployKeyIdent(obj.Slug.String()),
		Key:     key.Key,
		Created: key.Created,
		Expires: key.Expires,
	}, nil
}

// Naisjobs is the resolver for the naisjobs field.
func (r *teamResolver) Naisjobs(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.NaisJobList, error) {
	naisjobs, err := r.k8sClient.NaisJobs(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting naisjobs from Kubernetes: %w", err)
	}
	for _, job := range naisjobs {
		image, err := r.dependencyTrackClient.GetMetadataForImage(ctx, job.GQLVars.Spec.ImageName)
		if err != nil {
			return nil, fmt.Errorf("getting metadata for image %q: %w", job.GQLVars.Spec.ImageName, err)
		}
		job.Image = *image
	}

	if orderBy != nil {
		switch orderBy.Field {
		case model.OrderByFieldName:
			model.SortWith(naisjobs, func(a, b *model.NaisJob) bool {
				return model.Compare(a.Name, b.Name, orderBy.Direction)
			})
		case model.OrderByFieldEnv:
			model.SortWith(naisjobs, func(a, b *model.NaisJob) bool {
				return model.Compare(a.Env.Name, b.Env.Name, orderBy.Direction)
			})
		case model.OrderByFieldDeployed:
			model.SortWith(naisjobs, func(a, b *model.NaisJob) bool {
				if a.DeployInfo.Timestamp == nil {
					return false
				}
				if b.DeployInfo.Timestamp == nil {
					return true
				}
				return model.Compare(b.DeployInfo.Timestamp.UnixMilli(), a.DeployInfo.Timestamp.UnixMilli(), orderBy.Direction)
			})
		case model.OrderByFieldStatus:
			model.SortWith(naisjobs, func(a, b *model.NaisJob) bool {
				sortOrder := []model.State{model.StateFailing, model.StateNotnais, model.StateUnknown, model.StateNais}
				aIndex := -1
				bIndex := -1
				for i, s := range sortOrder {
					if a.Status.State == s {
						aIndex = i
					}
					if b.Status.State == s {
						bIndex = i
					}
				}
				if aIndex == -1 {
					return false
				}
				if bIndex == -1 {
					return true
				}
				if orderBy.Direction == model.SortOrderAsc {
					return aIndex < bIndex
				}
				return aIndex > bIndex
			})
		case model.OrderByFieldSeverityCritical:
			model.SortWith(naisjobs, func(a, b *model.NaisJob) bool {
				return model.Compare(a.Image.Summary.Critical, b.Image.Summary.Critical, orderBy.Direction)
			})
		case model.OrderByFieldRiskScore:
			model.SortWith(naisjobs, func(a, b *model.NaisJob) bool {
				return model.Compare(a.Image.Summary.RiskScore, b.Image.Summary.RiskScore, orderBy.Direction)
			})
		}
	}

	pagination := model.NewPagination(offset, limit)
	jobs, pageInfo := model.PaginatedSlice(naisjobs, pagination)
	for _, job := range jobs {
		job.GQLVars = model.WorkloadBaseGQLVars{Team: obj.Slug}
	}

	return &model.NaisJobList{
		Nodes:    jobs,
		PageInfo: pageInfo,
	}, nil
}

// Deployments is the resolver for the deployments field.
func (r *teamResolver) Deployments(ctx context.Context, obj *model.Team, offset *int, limit *int) (*model.DeploymentList, error) {
	pagination := model.NewPagination(offset, limit)

	deploys, err := r.hookdClient.Deployments(ctx, hookd.WithTeam(obj.Slug.String()), hookd.WithLimit(pagination.Limit))
	if err != nil {
		return nil, fmt.Errorf("getting deploys from Hookd: %w", err)
	}

	return &model.DeploymentList{
		Nodes: deployToModel(deploys),
		PageInfo: model.PageInfo{
			HasNextPage:     len(deploys) >= pagination.Limit,
			HasPreviousPage: pagination.Offset > 0,
			TotalCount:      0,
		},
	}, nil
}

// Images is the resolver for the images field.
func (r *teamResolver) Images(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy) (*model.ImageList, error) {
	images, err := r.dependencyTrackClient.GetMetadataForTeam(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting images from DependencyTrack: %w", err)
	}

	if orderBy != nil {
		switch orderBy.Field {
		case "NAME":
			model.SortWith(images, func(a, b *model.Image) bool {
				return model.Compare(a.Name, b.Name, orderBy.Direction)
			})
		case "SEVERITY_CRITICAL":
			model.SortWith(images, func(a, b *model.Image) bool {
				return model.Compare(a.Summary.Critical, b.Summary.Critical, orderBy.Direction)
			})
		case "RISK_SCORE":
			model.SortWith(images, func(a, b *model.Image) bool {
				return model.Compare(a.Summary.RiskScore, b.Summary.RiskScore, orderBy.Direction)
			})

		}
	}

	pagination := model.NewPagination(offset, limit)
	images, pageInfo := model.PaginatedSlice(images, pagination)

	return &model.ImageList{
		Nodes:    images,
		PageInfo: pageInfo,
	}, nil
}

// Vulnerabilities is the resolver for the vulnerabilities field.
func (r *teamResolver) Vulnerabilities(ctx context.Context, obj *model.Team, offset *int, limit *int, orderBy *model.OrderBy, filter *model.VulnerabilityFilter) (*model.VulnerabilityList, error) {
	var envFilter []k8s.EnvFilter
	if filter != nil && len(filter.Envs) > 0 {
		envFilter = append(envFilter, k8s.WithEnvs(filter.Envs...))
	}

	apps, err := r.k8sClient.Apps(ctx, obj.Slug.String(), envFilter...)
	if err != nil {
		return nil, fmt.Errorf("getting apps from Kubernetes: %w", err)
	}

	instances := make([]*dependencytrack.AppInstance, 0)
	for _, app := range apps {
		instances = append(instances, &dependencytrack.AppInstance{
			Env:   app.Env.Name,
			App:   app.Name,
			Image: app.GQLVars.Spec.ImageName,
			Team:  obj.Slug.String(),
		})
	}

	requireSbom := make([]dependencytrack.Filter, 0)
	if filter != nil && filter.RequireSbom != nil && *filter.RequireSbom {
		requireSbom = append(requireSbom, dependencytrack.RequireSbom())
	}

	nodes, err := r.dependencyTrackClient.GetVulnerabilities(ctx, instances, requireSbom...)
	if err != nil {
		return nil, fmt.Errorf("getting vulnerabilities from DependencyTrack: %w", err)
	}

	if orderBy != nil {
		vulnerabilities.Sort(nodes, orderBy.Field, orderBy.Direction)
	}

	pagination := model.NewPagination(offset, limit)
	v, pi := model.PaginatedSlice(nodes, pagination)

	return &model.VulnerabilityList{
		Nodes:    v,
		PageInfo: pi,
	}, nil
}

// VulnerabilitiesSummary is the resolver for the vulnerabilitiesSummary field.
func (r *teamResolver) VulnerabilitiesSummary(ctx context.Context, obj *model.Team) (*model.VulnerabilitySummaryForTeam, error) {
	images, err := r.dependencyTrackClient.GetMetadataForTeam(ctx, obj.Slug.String())
	if err != nil {
		return nil, fmt.Errorf("getting metadata for team %q: %w", obj.Slug.String(), err)
	}

	retVal := &model.VulnerabilitySummaryForTeam{}
	for _, image := range images {
		// do not count plattform images used in init containers and sidecars
		if strings.Contains(image.Name, "/nais-io/") {
			continue
		}
		if image.Summary.Critical > 0 {
			retVal.Critical += image.Summary.Critical
		}
		if image.Summary.High > 0 {
			retVal.High += image.Summary.High
		}
		if image.Summary.Medium > 0 {
			retVal.Medium += image.Summary.Medium
		}
		if image.Summary.Low > 0 {
			retVal.Low += image.Summary.Low
		}
		if image.Summary.Unassigned > 0 {
			retVal.Unassigned += image.Summary.Unassigned
		}
		if image.Summary.RiskScore > 0 {
			retVal.RiskScore += image.Summary.RiskScore
		}
		if image.Summary.Total > 0 {
			retVal.Total += image.Summary.Total
		}
		if image.HasSbom {
			retVal.BomCount += 1
		}
	}

	return retVal, nil
}

// VulnerabilityMetrics is the resolver for the vulnerabilityMetrics field.
func (r *teamResolver) VulnerabilityMetrics(ctx context.Context, obj *model.Team, from scalar.Date, to scalar.Date, environment *string) (*model.VulnerabilityMetrics, error) {
	var metrics []*model.VulnerabilityMetric

	if err := ValidateDateInterval(from, to); err != nil {
		return nil, err
	}

	fromDate, err := from.PgDate()
	if err != nil {
		return nil, err
	}

	toDate, err := to.PgDate()
	if err != nil {
		return nil, err
	}

	if environment != nil {
		rows, err := r.database.VulnerabilityMetricsDateRangeForTeamAndEnvironment(ctx, fromDate, toDate, obj.Slug, *environment)
		if err != nil {
			return nil, err
		}
		for _, row := range rows {
			metrics = append(metrics, &model.VulnerabilityMetric{
				Date:       row.Date.Time,
				Critical:   int(row.Critical),
				High:       int(row.High),
				Medium:     int(row.Medium),
				Low:        int(row.Low),
				Unassigned: int(row.Unassigned),
				RiskScore:  int(row.RiskScore),
				Count:      int(row.Count),
			})
		}
	} else {
		rows, err := r.database.DailyVulnerabilityForTeam(ctx, fromDate, toDate, obj.Slug)
		if err != nil {
			return nil, err
		}

		for _, row := range rows {
			metrics = append(metrics, &model.VulnerabilityMetric{
				Date:       row.Date.Time,
				Critical:   int(row.Critical),
				High:       int(row.High),
				Medium:     int(row.Medium),
				Low:        int(row.Low),
				Unassigned: int(row.Unassigned),
				RiskScore:  int(row.RiskScore),
				Count:      int(row.Count),
			})
		}
	}

	if len(metrics) == 0 {
		return &model.VulnerabilityMetrics{}, nil
	}

	dateRange, err := r.database.VulnerabilityMetricsDateRangeForTeam(ctx, obj.Slug)
	if err != nil {
		return nil, err
	}

	return &model.VulnerabilityMetrics{
		MinDate: ptr.To(scalar.NewDate(dateRange.FromDate.Time)),
		MaxDate: ptr.To(scalar.NewDate(dateRange.ToDate.Time)),
		Data:    metrics,
	}, nil
}

// Secrets is the resolver for the secrets field.
func (r *teamResolver) Secrets(ctx context.Context, obj *model.Team) ([]*model.Secret, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamMembership(actor, obj.Slug)
	if err != nil {
		return nil, err
	}
	return r.k8sClient.Secrets(ctx, obj.Slug)
}

// Secret is the resolver for the secret field.
func (r *teamResolver) Secret(ctx context.Context, obj *model.Team, name string, env string) (*model.Secret, error) {
	actor := authz.ActorFromContext(ctx)
	err := authz.RequireTeamMembership(actor, obj.Slug)
	if err != nil {
		return nil, err
	}
	return r.k8sClient.Secret(ctx, name, obj.Slug, env)
}

// Environments is the resolver for the environments field.
func (r *teamResolver) Environments(ctx context.Context, obj *model.Team) ([]*model.Env, error) {
	// Env is a bit special, given that it will be created from k8s etc.
	// All fields, except name and team, are resolved.

	dbEnvs, _, err := r.database.GetTeamEnvironments(ctx, obj.Slug, database.Page{Limit: 50})
	if err != nil {
		return nil, err
	}

	ret := make([]*model.Env, len(dbEnvs))
	for i, env := range dbEnvs {
		ret[i] = &model.Env{Name: env.Environment, Team: obj.Slug.String()}
	}

	return ret, nil
}

// Unleash is the resolver for the unleash field.
func (r *teamResolver) Unleash(ctx context.Context, obj *model.Team) (*model.Unleash, error) {
	return r.unleashMgr.Unleash(obj.Slug.String())
}

// CreatedBy is the resolver for the createdBy field.
func (r *teamDeleteKeyResolver) CreatedBy(ctx context.Context, obj *model.TeamDeleteKey) (*model.User, error) {
	return loader.GetUser(ctx, obj.GQLVars.UserID)
}

// Team is the resolver for the team field.
func (r *teamDeleteKeyResolver) Team(ctx context.Context, obj *model.TeamDeleteKey) (*model.Team, error) {
	return loader.GetTeam(ctx, obj.GQLVars.TeamSlug)
}

// Team is the resolver for the team field.
func (r *teamMemberResolver) Team(ctx context.Context, obj *model.TeamMember) (*model.Team, error) {
	return loader.GetTeam(ctx, obj.TeamSlug)
}

// User is the resolver for the user field.
func (r *teamMemberResolver) User(ctx context.Context, obj *model.TeamMember) (*model.User, error) {
	uid, err := obj.UserID.AsUUID()
	if err != nil {
		return nil, err
	}
	return loader.GetUser(ctx, uid)
}

// Role is the resolver for the role field.
func (r *teamMemberResolver) Role(ctx context.Context, obj *model.TeamMember) (model.TeamRole, error) {
	if obj.TeamRole != "" {
		return obj.TeamRole, nil
	}
	uid, err := obj.UserID.AsUUID()
	if err != nil {
		return "", err
	}

	isOwner, err := r.database.UserIsTeamOwner(ctx, uid, obj.TeamSlug)
	if err != nil {
		return "", err
	}

	role := model.TeamRoleMember
	if isOwner {
		role = model.TeamRoleOwner
	}

	return role, nil
}

// Reconcilers is the resolver for the reconcilers field.
func (r *teamMemberResolver) Reconcilers(ctx context.Context, obj *model.TeamMember) ([]*model.TeamMemberReconciler, error) {
	uid, err := obj.UserID.AsUUID()
	if err != nil {
		return nil, err
	}

	rows, err := r.database.GetTeamMemberOptOuts(ctx, uid, obj.TeamSlug)
	if err != nil {
		return nil, err
	}
	return toGraphTeamMemberReconcilers(rows), nil
}

// Reconciler is the resolver for the reconciler field.
func (r *teamMemberReconcilerResolver) Reconciler(ctx context.Context, obj *model.TeamMemberReconciler) (*model.Reconciler, error) {
	reconciler, err := r.database.GetReconciler(ctx, obj.GQLVars.Name)
	if err != nil {
		return nil, err
	}

	return toGraphReconciler(reconciler), nil
}

// Team returns gengql.TeamResolver implementation.
func (r *Resolver) Team() gengql.TeamResolver { return &teamResolver{r} }

// TeamDeleteKey returns gengql.TeamDeleteKeyResolver implementation.
func (r *Resolver) TeamDeleteKey() gengql.TeamDeleteKeyResolver { return &teamDeleteKeyResolver{r} }

// TeamMember returns gengql.TeamMemberResolver implementation.
func (r *Resolver) TeamMember() gengql.TeamMemberResolver { return &teamMemberResolver{r} }

// TeamMemberReconciler returns gengql.TeamMemberReconcilerResolver implementation.
func (r *Resolver) TeamMemberReconciler() gengql.TeamMemberReconcilerResolver {
	return &teamMemberReconcilerResolver{r}
}

type (
	teamResolver                 struct{ *Resolver }
	teamDeleteKeyResolver        struct{ *Resolver }
	teamMemberResolver           struct{ *Resolver }
	teamMemberReconcilerResolver struct{ *Resolver }
)

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"errors"
	"fmt"

	pgx "github.com/jackc/pgx/v5"
	"github.com/nais/api/internal/auth/authz"
	"github.com/nais/api/internal/database/gensql"
	"github.com/nais/api/internal/graph/apierror"
	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/slug"
)

// Authorizations is the resolver for the authorizations field.
func (r *gitHubRepositoryResolver) Authorizations(ctx context.Context, obj *model.GitHubRepository) ([]model.RepositoryAuthorization, error) {
	authz, err := r.database.GetRepositoryAuthorizations(ctx, obj.GQLVars.TeamSlug, obj.Name)
	if err != nil {
		return nil, err
	}

	var ret []model.RepositoryAuthorization
	for _, a := range authz {
		switch a {
		default:
			return nil, fmt.Errorf("invalid authorization: %q", string(a))
		case gensql.RepositoryAuthorizationEnumDeploy:
			ret = append(ret, model.RepositoryAuthorizationDeploy)
		}
	}

	return ret, nil
}

// AuthorizeRepository is the resolver for the authorizeRepository field.
func (r *mutationResolver) AuthorizeRepository(ctx context.Context, authorization model.RepositoryAuthorization, teamSlug slug.Slug, repoName string) (*model.GitHubRepository, error) {
	actor := authz.ActorFromContext(ctx)
	if _, err := r.database.GetTeamMember(ctx, teamSlug, actor.User.GetID()); errors.Is(err, pgx.ErrNoRows) {
		return nil, apierror.ErrUserIsNotTeamMember
	} else if err != nil {
		return nil, err
	}

	var repoAuthorization gensql.RepositoryAuthorizationEnum
	switch authorization {
	default:
		return nil, fmt.Errorf("invalid authorization: %q", string(authorization))
	case model.RepositoryAuthorizationDeploy:
		repoAuthorization = gensql.RepositoryAuthorizationEnumDeploy
	}

	if err := r.database.CreateRepositoryAuthorization(ctx, teamSlug, repoName, repoAuthorization); err != nil {
		return nil, err
	}

	ret, err := r.database.GetReconcilerResourcesByKeyAndValue(ctx, "github:team", teamSlug, "repo", []byte(repoName))
	if err != nil {
		return nil, err
	}

	return toGraphGitHubRepository(ret)
}

// DeauthorizeRepository is the resolver for the deauthorizeRepository field.
func (r *mutationResolver) DeauthorizeRepository(ctx context.Context, authorization model.RepositoryAuthorization, teamSlug slug.Slug, repoName string) (*model.GitHubRepository, error) {
	actor := authz.ActorFromContext(ctx)
	if _, err := r.database.GetTeamMember(ctx, teamSlug, actor.User.GetID()); errors.Is(err, pgx.ErrNoRows) {
		return nil, apierror.ErrUserIsNotTeamMember
	} else if err != nil {
		return nil, err
	}

	var repoAuthorization gensql.RepositoryAuthorizationEnum
	switch authorization {
	default:
		return nil, fmt.Errorf("invalid authorization: %q", string(authorization))
	case model.RepositoryAuthorizationDeploy:
		repoAuthorization = gensql.RepositoryAuthorizationEnumDeploy
	}

	if err := r.database.RemoveRepositoryAuthorization(ctx, teamSlug, repoName, repoAuthorization); err != nil {
		return nil, err
	}

	ret, err := r.database.GetReconcilerResourcesByKeyAndValue(ctx, "github:team", teamSlug, "repo", []byte(repoName))
	if err != nil {
		return nil, err
	}

	return toGraphGitHubRepository(ret)
}

// GitHubRepository returns gengql.GitHubRepositoryResolver implementation.
func (r *Resolver) GitHubRepository() gengql.GitHubRepositoryResolver {
	return &gitHubRepositoryResolver{r}
}

// Mutation returns gengql.MutationResolver implementation.
func (r *Resolver) Mutation() gengql.MutationResolver { return &mutationResolver{r} }

type (
	gitHubRepositoryResolver struct{ *Resolver }
	mutationResolver         struct{ *Resolver }
)

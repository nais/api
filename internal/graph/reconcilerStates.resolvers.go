package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"
	"slices"
	"strings"

	"github.com/google/uuid"
	"github.com/nais/api/internal/auditlogger"
	"github.com/nais/api/internal/auditlogger/audittype"
	"github.com/nais/api/internal/auth/authz"
	sqlc "github.com/nais/api/internal/database/gensql"
	"github.com/nais/api/internal/graph/apierror"
	"github.com/nais/api/internal/graph/gengql"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/scalar"
	"github.com/nais/api/internal/slug"
)

// SetGitHubTeamSlug is the resolver for the setGitHubTeamSlug field.
func (r *mutationResolver) SetGitHubTeamSlug(ctx context.Context, teamSlug slug.Slug, gitHubTeamSlug slug.Slug) (*model.Team, error) {
	team, err := r.database.GetTeamBySlug(ctx, teamSlug)
	if err != nil {
		return nil, apierror.ErrTeamNotExist
	}

	correlationID, err := uuid.NewUUID()
	if err != nil {
		return nil, fmt.Errorf("create log correlation ID: %w", err)
	}

	err = r.database.SetReconcilerStateForTeam(ctx, sqlc.ReconcilerNameGithubTeam, teamSlug, GitHubState{
		Slug: &gitHubTeamSlug,
	})
	if err != nil {
		return nil, apierror.Errorf("Unable to save the GitHub state.")
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(slug.Slug(team.Slug)),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiReconcilersUpdateTeamState,
		Actor:         authz.ActorFromContext(ctx),
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Update GitHub state, set team slug: %q", gitHubTeamSlug)

	r.reconcileTeam(ctx, correlationID, slug.Slug(team.Slug))

	return toGraphTeam(team), nil
}

// SetGoogleWorkspaceGroupEmail is the resolver for the setGoogleWorkspaceGroupEmail field.
func (r *mutationResolver) SetGoogleWorkspaceGroupEmail(ctx context.Context, teamSlug slug.Slug, googleWorkspaceGroupEmail string) (*model.Team, error) {
	team, err := r.database.GetTeamBySlug(ctx, teamSlug)
	if err != nil {
		return nil, apierror.ErrTeamNotExist
	}

	if !strings.HasSuffix(googleWorkspaceGroupEmail, "@"+r.tenantDomain) {
		return nil, apierror.Errorf("Incorrect domain in email address %q. The required domain is %q.", googleWorkspaceGroupEmail, r.tenantDomain)
	}

	correlationID, err := uuid.NewUUID()
	if err != nil {
		return nil, fmt.Errorf("create log correlation ID: %w", err)
	}

	err = r.database.SetReconcilerStateForTeam(ctx, sqlc.ReconcilerNameGoogleWorkspaceAdmin, teamSlug, GoogleWorkspaceState{
		GroupEmail: &googleWorkspaceGroupEmail,
	})
	if err != nil {
		return nil, apierror.Errorf("Unable to save the Google Workspace state.")
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(slug.Slug(team.Slug)),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiReconcilersUpdateTeamState,
		Actor:         authz.ActorFromContext(ctx),
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Update Google Workspace state, set group email: %q", googleWorkspaceGroupEmail)

	r.reconcileTeam(ctx, correlationID, slug.Slug(team.Slug))

	return toGraphTeam(team), nil
}

// SetAzureADGroupID is the resolver for the setAzureADGroupId field.
func (r *mutationResolver) SetAzureADGroupID(ctx context.Context, teamSlug slug.Slug, azureADGroupID scalar.Ident) (*model.Team, error) {
	team, err := r.database.GetTeamBySlug(ctx, teamSlug)
	if err != nil {
		return nil, apierror.ErrTeamNotExist
	}

	correlationID, err := uuid.NewUUID()
	if err != nil {
		return nil, fmt.Errorf("create log correlation ID: %w", err)
	}

	uuid, err := azureADGroupID.AsUUID()
	if err != nil {
		return nil, apierror.Errorf("Unable to parse Azure AD group ID: %w", err)
	}

	err = r.database.SetReconcilerStateForTeam(ctx, sqlc.ReconcilerNameAzureGroup, teamSlug, AzureState{
		GroupID: uuid,
	})
	if err != nil {
		return nil, apierror.Errorf("Unable to save the Azure AD state.")
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(slug.Slug(team.Slug)),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiReconcilersUpdateTeamState,
		Actor:         authz.ActorFromContext(ctx),
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Update Azure AD state, set group ID: %q", azureADGroupID)

	r.reconcileTeam(ctx, correlationID, slug.Slug(team.Slug))

	return toGraphTeam(team), nil
}

// SetGcpProjectID is the resolver for the setGcpProjectId field.
func (r *mutationResolver) SetGcpProjectID(ctx context.Context, teamSlug slug.Slug, gcpEnvironment string, gcpProjectID string) (*model.Team, error) {
	if len(r.gcpEnvironments) == 0 {
		return nil, apierror.Errorf("GCP cluster info has not been configured.")
	}

	team, err := r.database.GetTeamBySlug(ctx, teamSlug)
	if err != nil {
		return nil, apierror.ErrTeamNotExist
	}

	if !slices.Contains(r.gcpEnvironments, gcpEnvironment) {
		return nil, apierror.Errorf("Unknown GCP environment %q. Supported environments are: %s", gcpEnvironment, strings.Join(r.gcpEnvironments, ", "))
	}

	correlationID, err := uuid.NewUUID()
	if err != nil {
		return nil, fmt.Errorf("create log correlation ID: %w", err)
	}

	state := &GoogleGcpProjectState{
		Projects: make(map[string]GoogleGcpEnvironmentProject),
	}
	err = r.database.LoadReconcilerStateForTeam(ctx, sqlc.ReconcilerNameGoogleGcpProject, teamSlug, state)
	if err != nil {
		return nil, apierror.Errorf("Unable to load the existing GCP project state.")
	}
	if state.Projects == nil {
		state.Projects = make(map[string]GoogleGcpEnvironmentProject)
	}

	state.Projects[gcpEnvironment] = GoogleGcpEnvironmentProject{ProjectID: gcpProjectID}
	err = r.database.SetReconcilerStateForTeam(ctx, sqlc.ReconcilerNameGoogleGcpProject, teamSlug, state)
	if err != nil {
		return nil, apierror.Errorf("Unable to save the GCP project state.")
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(slug.Slug(team.Slug)),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiReconcilersUpdateTeamState,
		Actor:         authz.ActorFromContext(ctx),
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Update GCP project state, set project ID %q in environment %q", gcpProjectID, gcpEnvironment)

	r.reconcileTeam(ctx, correlationID, slug.Slug(team.Slug))

	return toGraphTeam(team), nil
}

// SetNaisNamespace is the resolver for the setNaisNamespace field.
func (r *mutationResolver) SetNaisNamespace(ctx context.Context, teamSlug slug.Slug, gcpEnvironment string, naisNamespace slug.Slug) (*model.Team, error) {
	if len(r.gcpEnvironments) == 0 {
		return nil, apierror.Errorf("GCP cluster info has not been configured.")
	}

	team, err := r.database.GetTeamBySlug(ctx, teamSlug)
	if err != nil {
		return nil, apierror.ErrTeamNotExist
	}

	if !slices.Contains(r.gcpEnvironments, gcpEnvironment) {
		return nil, apierror.Errorf("Unknown GCP environment %q. Supported environments are: %s", gcpEnvironment, strings.Join(r.gcpEnvironments, ", "))
	}

	correlationID, err := uuid.NewUUID()
	if err != nil {
		return nil, fmt.Errorf("create log correlation ID: %w", err)
	}

	state := &NaisNamespaceState{
		Namespaces: make(map[string]slug.Slug),
	}
	err = r.database.LoadReconcilerStateForTeam(ctx, sqlc.ReconcilerNameNaisNamespace, teamSlug, state)
	if err != nil {
		return nil, apierror.Errorf("Unable to load the existing NAIS namespace state.")
	}
	if state.Namespaces == nil {
		state.Namespaces = make(map[string]slug.Slug)
	}

	state.Namespaces[gcpEnvironment] = naisNamespace
	err = r.database.SetReconcilerStateForTeam(ctx, sqlc.ReconcilerNameNaisNamespace, teamSlug, state)
	if err != nil {
		return nil, apierror.Errorf("Unable to save the NAIS namespace state.")
	}

	targets := []auditlogger.Target{
		auditlogger.TeamTarget(slug.Slug(team.Slug)),
	}
	fields := auditlogger.Fields{
		Action:        audittype.AuditActionGraphqlApiReconcilersUpdateTeamState,
		Actor:         authz.ActorFromContext(ctx),
		CorrelationID: correlationID,
	}
	r.auditLogger.Logf(ctx, targets, fields, "Update NAIS namespace state, set namespace %q in environment %q", naisNamespace, gcpEnvironment)

	r.reconcileTeam(ctx, correlationID, slug.Slug(team.Slug))

	return toGraphTeam(team), nil
}

// Mutation returns gengql.MutationResolver implementation.
func (r *Resolver) Mutation() gengql.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }

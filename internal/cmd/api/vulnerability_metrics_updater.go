package api

import (
	"context"
	"time"

	"github.com/nais/api/internal/database"
	"github.com/nais/api/internal/k8s"
	"github.com/nais/api/internal/vulnerability"
	"github.com/sirupsen/logrus"
)

const (
	vulnerabilityUpdateSchedule = time.Hour
)

func vulnerabilityMetricUpdater(ctx context.Context, cfg *Config, db database.Database, k8sClient *k8s.Client, dTrackClient vulnerability.DependencytrackClient, log logrus.FieldLogger) error {
	if !cfg.DependencyTrack.VulnerabilityMetricsImportEnabled {
		log.Warningf(`vulnerability metrics import is not enabled. Enable by setting the "VULNERABILITY_METRICS_IMPORT_ENABLED" environment variable to "true"`)
		return nil
	}

	vulnerabilityMetricUpdater := vulnerability.NewMetricUpdater(k8sClient, dTrackClient, db, log)
	if err := runVulnerabilityUpdater(ctx, vulnerabilityMetricUpdater, log.WithField("task", "vulnerability_updater")); err != nil {
		log.WithError(err).Errorf("error in vulnerability updater")
	}
	return nil
}

func runVulnerabilityUpdater(ctx context.Context, updater *vulnerability.Updater, log logrus.FieldLogger) error {
	ticker := time.NewTicker(time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-ticker.C:
			ticker.Reset(vulnerabilityUpdateSchedule * 24) // schedule next run, same time next day
			start := time.Now()
			log.Infof("start scheduled vulnerability update run")
			rows, err := updater.UpdateVulnerabilityMetrics(ctx)
			if err != nil {
				log = log.WithError(err)
			}
			log.
				WithFields(logrus.Fields{
					"rows_upserted": rows,
					"duration":      time.Since(start),
				}).
				Infof("finished scheduled vulnerability metrics update run")
		}
	}
}

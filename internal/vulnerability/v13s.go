package vulnerability

import (
	"context"
	"crypto/tls"
	"github.com/nais/v13s/pkg/api/auth"
	"github.com/nais/v13s/pkg/api/vulnerabilities"
	"github.com/sirupsen/logrus"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
	"strings"
)

const (
	VulnerabilitiesApiAudience = "v13s"
)

var _ Manager = (*vulnerabilitiesManager)(nil)

type Manager interface {
	GetMetadataForImage(ctx context.Context, image string) (*ImageDetails, error)
	GetFindingsForImageByProjectID(ctx context.Context, projectID string, suppressed bool) ([]*ImageVulnerability, error)
	GetMetadataForTeam(ctx context.Context, team string) ([]*ImageDetails, error)
	UpdateFinding(ctx context.Context, analysisState, comment, componentID, projectID, vulnerabilityID, suppressedBy string, suppress bool) error
	GetAnalysisTrailForImage(ctx context.Context, projectID, componentID, vulnerabilityID string) (*ImageVulnerabilityAnalysisTrail, error)
}

type vulnerabilitiesManager struct {
	client vulnerabilities.Client
}

func (v *vulnerabilitiesManager) GetMetadataForImage(ctx context.Context, image string) (*ImageDetails, error) {
	//TODO implement me
	panic("implement me")
}

func (v *vulnerabilitiesManager) GetFindingsForImageByProjectID(ctx context.Context, projectID string, suppressed bool) ([]*ImageVulnerability, error) {
	//TODO implement me
	panic("implement me")
}

func (v *vulnerabilitiesManager) GetMetadataForTeam(ctx context.Context, team string) ([]*ImageDetails, error) {
	res, err := v.client.ListVulnerabilitySummaries(ctx,
		vulnerabilities.NamespaceFilter(team),
	)

	if err != nil {
		return nil, err
	}

	details := make([]*ImageDetails, 0)
	for _, d := range res.WorkloadSummaries {
		var summary *ImageVulnerabilitySummary
		hasSbom := false
		if d.VulnerabilitySummary != nil {
			hasSbom = true
			summary = &ImageVulnerabilitySummary{
				Total:      0,
				RiskScore:  int(d.VulnerabilitySummary.RiskScore),
				Low:        int(d.VulnerabilitySummary.Low),
				Medium:     int(d.VulnerabilitySummary.Medium),
				High:       int(d.VulnerabilitySummary.High),
				Critical:   int(d.VulnerabilitySummary.Critical),
				Unassigned: int(d.VulnerabilitySummary.Unassigned),
			}
		}

		ref := make([]*WorkloadReference, 0)

		// TODO: url workloadRef projectId
		details = append(details, &ImageDetails{
			ProjectID:          "yalla",
			Name:               d.Workload.ImageName,
			Version:            d.Workload.ImageTag,
			Summary:            summary,
			HasSBOM:            hasSbom,
			ProjectURL:         "url",
			WorkloadReferences: ref,
		})
	}

	return details, nil
}

func (v *vulnerabilitiesManager) UpdateFinding(ctx context.Context, analysisState, comment, componentID, projectID, vulnerabilityID, suppressedBy string, suppress bool) error {
	//TODO implement me
	panic("implement me")
}

func (v *vulnerabilitiesManager) GetAnalysisTrailForImage(ctx context.Context, projectID, componentID, vulnerabilityID string) (*ImageVulnerabilityAnalysisTrail, error) {
	//TODO implement me
	panic("implement me")
}

func NewVulnerabilitiesManager(ctx context.Context, url, serviceAccount string, field *logrus.Entry) (*vulnerabilitiesManager, error) {
	dialOptions := make([]grpc.DialOption, 0)
	if strings.Contains(url, "localhost") || strings.Contains(url, "127.0.0.1") {
		dialOptions = append(dialOptions, grpc.WithTransportCredentials(insecure.NewCredentials()))
	} else {
		tlsOpts := &tls.Config{}
		cred := credentials.NewTLS(tlsOpts)
		dialOptions = append(dialOptions, grpc.WithTransportCredentials(cred))
	}
	creds, err := auth.PerRPCGoogleIDToken(ctx, serviceAccount, VulnerabilitiesApiAudience)
	if err != nil {
		return nil, err
	}
	dialOptions = append(dialOptions, grpc.WithPerRPCCredentials(creds))

	c, err := vulnerabilities.NewClient(
		url,
		dialOptions...,
	)
	if err != nil {
		return nil, err
	}

	return &vulnerabilitiesManager{
		client: c,
	}, nil
}

func (v *vulnerabilitiesManager) Close() error {
	return v.client.Close()
}

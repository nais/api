package vulnerability

import (
	"context"
	"crypto/tls"
	"fmt"
	"github.com/google/uuid"
	"github.com/nais/v13s/pkg/api/auth"
	"github.com/nais/v13s/pkg/api/vulnerabilities"
	"github.com/sirupsen/logrus"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
	"strings"
)

const (
	VulnerabilitiesApiAudience = "v13s"
)

var _ Manager = (*vulnerabilitiesManager)(nil)

type Manager interface {
	GetVulnerabilitySummary(ctx context.Context, opts ...vulnerabilities.Option) (*vulnerabilities.GetVulnerabilitySummaryResponse, error)
	GetMetadataForImage(ctx context.Context, image string) (*ImageDetails, error)
	GetFindingsForImageByProjectID(ctx context.Context, projectID string, suppressed bool) ([]*ImageVulnerability, error)
	ListVulnerabilitiesForImage(ctx context.Context, imageName, imageTag string, includeSuppressed bool) (*vulnerabilities.ListVulnerabilitiesForImageResponse, error)
	UpdateFinding(ctx context.Context, analysisState, comment, componentID, projectID, vulnerabilityID, suppressedBy string, suppress bool) error
	GetAnalysisTrailForImage(ctx context.Context, projectID, componentID, vulnerabilityID string) (*ImageVulnerabilityAnalysisTrail, error)
}

type vulnerabilitiesManager struct {
	client vulnerabilities.Client
}

func (v *vulnerabilitiesManager) GetVulnerabilitySummary(ctx context.Context, opts ...vulnerabilities.Option) (*vulnerabilities.GetVulnerabilitySummaryResponse, error) {
	return v.client.GetVulnerabilitySummary(ctx, opts...)
}

func (v *vulnerabilitiesManager) GetMetadataForImage(ctx context.Context, image string) (*ImageDetails, error) {
	parts := strings.Split(image, ":")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid image format: %s", image)
	}
	resp, err := v.client.GetVulnerabilitySummaryForImage(ctx, parts[0], parts[1])
	if err != nil {
		return nil, err
	}
	details := &ImageDetails{
		Name:               parts[0],
		Version:            parts[1],
		WorkloadReferences: make([]*WorkloadReference, 0),
	}

	for _, w := range resp.GetWorkloadRef() {
		details.WorkloadReferences = append(details.WorkloadReferences, &WorkloadReference{
			Environment:  w.Cluster,
			Team:         w.Namespace,
			Name:         w.Name,
			WorkloadType: w.Type,
		})
	}

	summary := resp.GetVulnerabilitySummary()
	if summary.HasSbom {
		details.HasSBOM = true
		details.ProjectID = uuid.New().String() + "-todo"
		details.ProjectURL = "todo"
		details.Summary = &ImageVulnerabilitySummary{
			Total:      int(summary.Critical + summary.High + summary.Medium + summary.Low + summary.Unassigned),
			RiskScore:  int(summary.RiskScore),
			Low:        int(summary.Low),
			Medium:     int(summary.Medium),
			High:       int(summary.High),
			Critical:   int(summary.Critical),
			Unassigned: int(summary.Unassigned),
		}
	}
	return details, nil
}

func (v *vulnerabilitiesManager) GetFindingsForImageByProjectID(ctx context.Context, projectID string, suppressed bool) ([]*ImageVulnerability, error) {
	return []*ImageVulnerability{}, nil
}

func (v *vulnerabilitiesManager) ListVulnerabilitiesForImage(ctx context.Context, imageName, imageTag string, includeSuppressed bool) (*vulnerabilities.ListVulnerabilitiesForImageResponse, error) {
	return v.client.ListVulnerabilitiesForImage(ctx, imageName, imageTag, includeSuppressed)
}

func (v *vulnerabilitiesManager) GetMetadataForTeam(ctx context.Context, team string) ([]*ImageDetails, error) {
	/*res, err := v.client.ListVulnerabilitySummaries(ctx,
		vulnerabilities.NamespaceFilter(team),
	)

	if err != nil {
		return nil, err
	}

	details := make([]*ImageDetails, 0)
	for _, d := range res.WorkloadSummaries {
		var summary *ImageVulnerabilitySummary
		hasSbom := false
		if d.VulnerabilitySummary != nil {
			hasSbom = true
			summary = &ImageVulnerabilitySummary{
				Total:      0,
				RiskScore:  int(d.VulnerabilitySummary.RiskScore),
				Low:        int(d.VulnerabilitySummary.Low),
				Medium:     int(d.VulnerabilitySummary.Medium),
				High:       int(d.VulnerabilitySummary.High),
				Critical:   int(d.VulnerabilitySummary.Critical),
				Unassigned: int(d.VulnerabilitySummary.Unassigned),
			}
		}

		ref := make([]*WorkloadReference, 0)

		// TODO: url workloadRef projectId
		details = append(details, &ImageDetails{
			ProjectID:          "yalla",
			Name:               d.Workload.ImageName,
			Version:            d.Workload.ImageTag,
			Summary:            summary,
			HasSBOM:            hasSbom,
			ProjectURL:         "url",
			WorkloadReferences: ref,
		})
	}

	return details, nil*/
	panic("implement me")
}

func (v *vulnerabilitiesManager) UpdateFinding(ctx context.Context, analysisState, comment, componentID, projectID, vulnerabilityID, suppressedBy string, suppress bool) error {
	//TODO implement me
	panic("implement me")
}

func (v *vulnerabilitiesManager) GetAnalysisTrailForImage(ctx context.Context, projectID, componentID, vulnerabilityID string) (*ImageVulnerabilityAnalysisTrail, error) {
	//TODO implement me
	panic("implement me")
}

func NewVulnerabilitiesManager(ctx context.Context, url, serviceAccount string, field *logrus.Entry) (*vulnerabilitiesManager, error) {
	dialOptions := make([]grpc.DialOption, 0)
	if strings.Contains(url, "localhost") || strings.Contains(url, "127.0.0.1") {
		dialOptions = append(dialOptions, grpc.WithTransportCredentials(insecure.NewCredentials()))
	} else {
		tlsOpts := &tls.Config{}
		cred := credentials.NewTLS(tlsOpts)
		dialOptions = append(dialOptions, grpc.WithTransportCredentials(cred))
	}
	creds, err := auth.PerRPCGoogleIDToken(ctx, serviceAccount, VulnerabilitiesApiAudience)
	if err != nil {
		return nil, err
	}
	dialOptions = append(dialOptions, grpc.WithPerRPCCredentials(creds))

	c, err := vulnerabilities.NewClient(
		url,
		dialOptions...,
	)
	if err != nil {
		return nil, err
	}

	return &vulnerabilitiesManager{
		client: c,
	}, nil
}

func (v *vulnerabilitiesManager) Close() error {
	return v.client.Close()
}

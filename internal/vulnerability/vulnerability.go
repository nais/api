package vulnerability

import (
	"context"
	"crypto/tls"
	"strings"

	"github.com/nais/api/internal/vulnerability/fake"
	"github.com/nais/v13s/pkg/api/auth"
	"github.com/nais/v13s/pkg/api/vulnerabilities"
	"github.com/sirupsen/logrus"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
)

const (
	VulnerabilitiesApiAudience = "v13s"
	FakeVulnerabilitiesApiUrl  = "fake"
)

type Manager struct {
	client vulnerabilities.Client
	log    *logrus.Entry
}

func NewManager(ctx context.Context, url, serviceAccount string, log *logrus.Entry) (*Manager, error) {
	if strings.Contains(url, FakeVulnerabilitiesApiUrl) {
		return NewFakeManager(ctx, log)
	}

	dialOptions := make([]grpc.DialOption, 0)
	if strings.Contains(url, "localhost") || strings.Contains(url, "127.0.0.1") {
		dialOptions = append(dialOptions, grpc.WithTransportCredentials(insecure.NewCredentials()))
	} else {
		//dialOptions = append(dialOptions, grpc.WithTransportCredentials(insecure.NewCredentials()))
		//creds, err := auth.PerRPCGoogleIDToken(ctx, serviceAccount, VulnerabilitiesApiAudience)
		// do not commit this
		tlsOpts := &tls.Config{}
		cred := credentials.NewTLS(tlsOpts)
		dialOptions = append(dialOptions, grpc.WithTransportCredentials(cred))
		creds, err := auth.PerRPCGoogleIDToken(ctx, serviceAccount, "v13s")
		if err != nil {
			return nil, err
		}
		dialOptions = append(dialOptions, grpc.WithPerRPCCredentials(creds))
	}

	c, err := vulnerabilities.NewClient(
		url,
		dialOptions...,
	)
	if err != nil {
		return nil, err
	}

	return &Manager{
		client: c,
		log:    log,
	}, nil
}

func NewFakeManager(_ context.Context, log *logrus.Entry) (*Manager, error) {
	return &Manager{
		client: fake.NewFakeVulnerabilitiesClient(),
		log:    log,
	}, nil
}

func (m *Manager) Close() error {
	return m.client.Close()
}

package vulnerability

import (
	"context"
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/api/internal/database"
	"github.com/nais/api/internal/database/gensql"
	"github.com/nais/api/internal/k8s"
	"github.com/nais/api/internal/k8s/fake"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/thirdparty/dependencytrack"
	dpFake "github.com/nais/api/internal/thirdparty/dependencytrack/fake"
	logrustest "github.com/sirupsen/logrus/hooks/test"
	"github.com/stretchr/testify/mock"
)

func TestUpdater_UpdateVulnerabilityMetrics(t *testing.T) {
	log, _ := logrustest.NewNullLogger()
	ctx := context.Background()
	dpMock := dpFake.New(log)
	db := database.NewMockDatabase(t)
	k8sClient, err := setupFakeK8s(ctx, db)
	if err != nil {
		t.Errorf("fake client setup, expected no error, got %v", err)
	}
	updater := NewMetricUpdater(k8sClient, dpMock, db, log)

	// Only to test the flow of the function is behaving as anticipated
	db.EXPECT().GetActiveTeams(mock.Anything).Return(
		[]*database.Team{
			{
				Team: &gensql.Team{
					Slug: "nais",
				},
			},
		}, nil)

	db.EXPECT().VulnerabilityMetricsMaxDate(mock.Anything, "dev", "nais-deploy-canary", slug.Slug("nais")).Return(
		pgtype.Date{}, nil)

	// Don't know the generated UUID, so mock.Anything is good for testing
	db.EXPECT().CreateDependencytrackProject(mock.Anything, mock.Anything).Return(nil)
	// We cant mock the upsert result
	db.EXPECT().VulnerabilityMetricsUpsert(mock.Anything, mock.Anything).Return(nil)

	res, err := updater.UpdateVulnerabilityMetrics(ctx)
	if err != nil {
		t.Errorf("expected no error, got %v", err)
	}
	if res != 0 {
		t.Errorf("expected 0 result, got %d", res)
	}
}

func Test_GetHistoricalVulnerabilityMetricsParams(t *testing.T) {
	log, _ := logrustest.NewNullLogger()
	dpMock := dpFake.New(log)
	db := database.NewMockDatabase(t)
	updater := NewMetricUpdater(nil, dpMock, db, log)

	// This test simulates the case when the project is not in the database
	// we fetch the current metrics and register it from the first occurrence to the last occurrence in dependencytrack
	id := uuid.New()
	initialHistoricalProjectsMetrics := &dependencytrack.ProjectMetric{
		ProjectID: id,
		VulnerabilityMetrics: []*dependencytrack.VulnerabilityMetrics{
			{
				Total:      1,
				Critical:   1,
				High:       2,
				Medium:     3,
				Low:        4,
				Unassigned: 5,
				RiskScore:  6,
				// the first occurrence of the vulnerability
				FirstOccurrence: 1704879809629,
				// the last occurrence of the vulnerability
				LastOccurrence: 1705412920226,
			},
			{
				Total:           2,
				Critical:        3,
				High:            2,
				Medium:          3,
				Low:             4,
				Unassigned:      5,
				RiskScore:       6,
				FirstOccurrence: 1705413522933,
				LastOccurrence:  1707463343762,
			},
		},
	}

	initialResult := updater.vulnerabilityMetricsParams(initialHistoricalProjectsMetrics, time.Time{}, time.Now())
	if len(initialResult) != 29 {
		t.Errorf("expected 29 results, got %d", len(initialResult))
	}

	// This test simulates the case when the project is already in the database
	// we fetch the current metrics and register it from the max date in the database to the current date
	projects1 := &dependencytrack.ProjectMetric{
		ProjectID: id,
		VulnerabilityMetrics: []*dependencytrack.VulnerabilityMetrics{
			{
				Total:           2,
				Critical:        3,
				High:            2,
				Medium:          3,
				Low:             4,
				Unassigned:      5,
				RiskScore:       6,
				FirstOccurrence: 1705413522933,
				LastOccurrence:  1707463343762,
			},
		},
	}

	// 3 days difference
	staticDbDate := time.Date(2024, 2, 7, 0, 0, 0, 0, time.UTC)
	staticCurrentDate := time.Date(2024, 2, 10, 0, 0, 0, 0, time.UTC)
	updatedResult := updater.vulnerabilityMetricsParams(projects1, staticDbDate, staticCurrentDate)
	for _, r := range updatedResult {
		fmt.Printf("%+v\n", r)
	}

	if len(updatedResult) != 3 {
		t.Errorf("expected 3 results, got %d", len(updatedResult))
	}

	if len(initialResult)+len(updatedResult) != 32 {
		t.Errorf("expected 32 results, got %d", len(initialResult)+len(updatedResult))
	}
}

func TestUpdater_UpsertBatchParamsNotExistsInDatabase(t *testing.T) {
	log, _ := logrustest.NewNullLogger()
	ctx := context.Background()
	dpMock := dpFake.New(log)
	db := database.NewMockDatabase(t)
	updater := NewMetricUpdater(nil, dpMock, db, log)

	db.EXPECT().VulnerabilityMetricsMaxDate(mock.Anything, "dev", "test-app", slug.Slug("nais")).Return(pgtype.Date{}, nil)
	db.EXPECT().CreateDependencytrackProject(mock.Anything, mock.Anything).Return(nil)
	result, err := updater.UpsertBatchParams(ctx, "nais", []*dependencytrack.AppInstance{
		{
			Env:   "dev",
			Team:  "nais",
			App:   "test-app",
			Image: "test-image",
		},
	}, time.Now())
	if err != nil {
		t.Errorf("expected no error, got %v", err)
	}
	if len(result) != 23 {
		// we know the result is 23 because of the fake dependencytrack client
		// and the unix a static date
		// FirstOccurrence: 1705413522933 = Tuesday 16. January 2024 13:58:42.933
		// LastOccurrence:  1707463343762 = Friday 9. February 2024 07:22:23.762
		t.Errorf("expected 23 results, got %d", len(result))
	}
}

func TestUpdater_UpsertBatchParamsExistsInDatabase(t *testing.T) {
	log, _ := logrustest.NewNullLogger()
	ctx := context.Background()
	dpMock := dpFake.New(log)
	db := database.NewMockDatabase(t)
	updater := NewMetricUpdater(nil, dpMock, db, log)

	db.EXPECT().VulnerabilityMetricsMaxDate(mock.Anything, "dev", "test-app", slug.Slug("nais")).Return(pgtype.Date{Time: time.Date(2024, 2, 7, 0, 0, 0, 0, time.UTC)}, nil)
	db.EXPECT().CreateDependencytrackProject(mock.Anything, mock.Anything).Return(nil)
	result, err := updater.UpsertBatchParams(ctx, "nais", []*dependencytrack.AppInstance{
		{
			Env:   "dev",
			Team:  "nais",
			App:   "test-app",
			Image: "test-image",
		},
	}, time.Date(2024, 2, 10, 0, 0, 0, 0, time.UTC))
	if err != nil {
		t.Errorf("expected no error, got %v", err)
	}
	if len(result) != 3 {
		t.Errorf("expected 3 results, got %d", len(result))
	}
}

func TestUpdater_GetApps(t *testing.T) {
	log, _ := logrustest.NewNullLogger()
	ctx := context.Background()
	dpMock := dpFake.New(log)
	db := database.NewMockDatabase(t)
	k8sClient, err := setupFakeK8s(ctx, db)
	if err != nil {
		t.Errorf("fake client setup, expected no error, got %v", err)
	}
	updater := NewMetricUpdater(k8sClient, dpMock, db, log)

	res, err := updater.getAllAppsFor(ctx, "nais")
	if err != nil {
		t.Errorf("expected no error, got %v", err)
	}
	if len(res) != 1 {
		t.Errorf("expected 1 result, got %d", len(res))
	}
}

func setupFakeK8s(ctx context.Context, db database.Database) (*k8s.Client, error) {
	log, _ := logrustest.NewNullLogger()
	k8sOpts := []k8s.Opt{k8s.WithClientsCreator(fake.Clients(os.DirFS("testdata/k8s")))}
	k8sClient, err := k8s.New(
		"test",
		k8s.Config{
			Clusters: []string{"dev"},
		},
		db,
		true,
		log.WithField("client", "k8s"),
		k8sOpts...,
	)
	if err != nil {
		return nil, err
	}

	// k8s informers
	if err := k8sClient.Informers().Start(ctx, log); err != nil {
		return nil, err
	}
	return k8sClient, nil
}

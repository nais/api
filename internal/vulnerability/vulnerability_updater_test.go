package vulnerability

import (
	"context"
	"github.com/nais/api/internal/database"
	"github.com/nais/api/internal/k8s"
	"github.com/nais/api/internal/k8s/fake"
	"github.com/nais/api/internal/thirdparty/dependencytrack"
	dpFake "github.com/nais/api/internal/thirdparty/dependencytrack/fake"
	logrustest "github.com/sirupsen/logrus/hooks/test"
	"github.com/stretchr/testify/mock"
	"os"
	"testing"
)

func TestUpdater_UpsertBatchParams(t *testing.T) {
	log, _ := logrustest.NewNullLogger()
	ctx := context.Background()
	dpMock := dpFake.New()
	db := database.NewMockDatabase(t)

	db.EXPECT().CreateDependencytrackProject(mock.Anything, mock.Anything).Return(nil)

	updater := NewMetricUpdater(nil, dpMock, db, log)
	result, err := updater.UpsertBatchParams(ctx, "nais", []*dependencytrack.AppInstance{
		{
			Env:   "dev",
			Team:  "nais",
			App:   "test-app",
			Image: "test-image",
		},
	})
	if err != nil {
		t.Errorf("expected no error, got %v", err)
	}
	if len(result) != 1 {
		t.Errorf("expected 1 result, got %d", len(result))
	}
}

func TestUpdater_GetApps(t *testing.T) {
	log, _ := logrustest.NewNullLogger()
	ctx := context.Background()
	dpMock := dpFake.New()
	db := database.NewMockDatabase(t)

	k8sClient, err := setupFakeK8s(ctx, db)

	updater := NewMetricUpdater(k8sClient, dpMock, db, log)
	res, err := updater.getApps(ctx, "nais")
	if err != nil {
		t.Errorf("expected no error, got %v", err)
	}
	if len(res) != 1 {
		t.Errorf("expected 1 result, got %d", len(res))
	}
}

func setupFakeK8s(ctx context.Context, db database.Database) (*k8s.Client, error) {
	log, _ := logrustest.NewNullLogger()
	k8sOpts := []k8s.Opt{k8s.WithClientsCreator(fake.Clients(os.DirFS("data/k8s")))}
	k8sClient, err := k8s.New(
		"test",
		k8s.Config{
			Clusters: []string{"dev"},
		},
		db,
		log.WithField("client", "k8s"),
		k8sOpts...,
	)
	if err != nil {
		return nil, err
	}

	// k8s informers
	if err := k8sClient.Informers().Start(ctx, log); err != nil {
		return nil, err
	}
	return k8sClient, nil
}

package vulnerability

import (
	"time"

	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/workload"
	"github.com/nais/v13s/pkg/api/vulnerabilities"
)

func toImageVulnerability(v *vulnerabilities.Vulnerability) *ImageVulnerability {
	description := v.Cve.Description
	if description == "" {
		description = v.Cve.Title
	}

	var severitySince *time.Time
	if v.SeveritySince != nil {
		t := v.SeveritySince.AsTime()
		severitySince = &t
	}

	imageVulnerability := &ImageVulnerability{
		vulnerabilityID:          v.Id,
		Identifier:               v.Cve.Id,
		Severity:                 ImageVulnerabilitySeverity(v.Cve.Severity.String()),
		CvssScore:                v.CvssScore,
		Description:              description,
		Package:                  v.Package,
		SeveritySince:            severitySince,
		VulnerabilityDetailsLink: v.Cve.Link,
	}

	if v.GetSuppression() != nil {
		var imageVulnerabilityState ImageVulnerabilitySuppressionState
		switch v.GetSuppression().GetSuppressedReason() {
		case vulnerabilities.SuppressState_FALSE_POSITIVE:
			imageVulnerabilityState = ImageVulnerabilitySuppressionStateFalsePositive
		case vulnerabilities.SuppressState_IN_TRIAGE:
			imageVulnerabilityState = ImageVulnerabilitySuppressionStateInTriage
		case vulnerabilities.SuppressState_NOT_AFFECTED:
			imageVulnerabilityState = ImageVulnerabilitySuppressionStateNotAffected
		case vulnerabilities.SuppressState_RESOLVED:
			imageVulnerabilityState = ImageVulnerabilitySuppressionStateResolved
		case vulnerabilities.SuppressState_NOT_SET:
			return imageVulnerability
		}

		imageVulnerability.Suppression = &ImageVulnerabilitySuppression{
			State:  imageVulnerabilityState,
			Reason: v.Suppression.SuppressedDetails,
		}
	}
	return imageVulnerability
}

func toWorkloadVulnerabilitySummary(w *vulnerabilities.WorkloadSummary) *WorkloadVulnerabilitySummary {
	wType := workload.TypeApplication
	if w.GetWorkload().GetType() == "job" {
		wType = workload.TypeJob
	}

	var lastUpdated *time.Time
	if ts := w.GetVulnerabilitySummary().GetLastUpdated(); ts != nil {
		t := ts.AsTime()
		lastUpdated = &t
	}

	return &WorkloadVulnerabilitySummary{
		Summary: &ImageVulnerabilitySummary{
			Critical:    int(w.GetVulnerabilitySummary().Critical),
			High:        int(w.GetVulnerabilitySummary().High),
			Medium:      int(w.GetVulnerabilitySummary().Medium),
			Low:         int(w.GetVulnerabilitySummary().Low),
			Unassigned:  int(w.GetVulnerabilitySummary().Unassigned),
			Total:       int(w.GetVulnerabilitySummary().Total),
			RiskScore:   int(w.GetVulnerabilitySummary().RiskScore),
			LastUpdated: lastUpdated,
		},
		HasSbom:         w.GetVulnerabilitySummary().GetHasSbom(),
		TeamSlug:        slug.Slug(w.GetWorkload().GetNamespace()),
		EnvironmentName: w.GetWorkload().GetCluster(),
		WorkloadReference: &workload.Reference{
			Name: w.GetWorkload().GetName(),
			Type: wType,
		},
	}
}

func toCVE(cve *vulnerabilities.Cve) *CVE {
	return &CVE{
		Identifier:  cve.Id,
		Title:       cve.Title,
		Description: cve.Description,
		DetailsLink: cve.Link,
		CVSSScore:   cve.CvssScore,
		Severity:    ImageVulnerabilitySeverity(cve.Severity.String()),
	}
}

func mapVulnerabilitySeverity(severity ImageVulnerabilitySeverity) vulnerabilities.Severity {
	switch severity {
	case ImageVulnerabilitySeverityCritical:
		return vulnerabilities.Severity_CRITICAL
	case ImageVulnerabilitySeverityHigh:
		return vulnerabilities.Severity_HIGH
	case ImageVulnerabilitySeverityMedium:
		return vulnerabilities.Severity_MEDIUM
	case ImageVulnerabilitySeverityLow:
		return vulnerabilities.Severity_LOW
	case ImageVulnerabilitySeverityUnassigned:
		return vulnerabilities.Severity_UNASSIGNED
	default:
		return vulnerabilities.Severity_UNASSIGNED
	}
}

package vulnerability

import (
	"context"
	"fmt"
	"math"
	"sort"
	"strings"
	"time"

	"github.com/nais/api/internal/activitylog"
	"github.com/nais/api/internal/auth/authz"
	"github.com/nais/api/internal/environmentmapper"
	"github.com/nais/api/internal/graph/apierror"
	"github.com/nais/api/internal/graph/ident"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/workload"
	"github.com/nais/api/internal/workload/application"
	"github.com/nais/api/internal/workload/job"
	"github.com/nais/v13s/pkg/api/vulnerabilities"
)

// TODO: check references to workload as a hack until v13s api has proper data
func ListWorkloadReferences(ctx context.Context, image string, page *pagination.Pagination) (*pagination.Connection[*ContainerImageWorkloadReference], error) {
	metadata, err := fromContext(ctx).imageLoader.Load(ctx, image)
	if err != nil {
		return nil, err
	}

	all := metadata.WorkloadReferences

	refs := make([]*WorkloadReference, 0)
	for _, ref := range all {
		if ref.WorkloadType == "app" {
			_, err = application.Get(ctx, slug.Slug(ref.Team), ref.Environment, ref.Name)
			if err != nil {
				continue
			}
			refs = append(refs, ref)
		}

		if ref.WorkloadType == "job" {
			_, err = job.Get(ctx, slug.Slug(ref.Team), ref.Environment, ref.Name)
			if err != nil {
				continue
			}
			refs = append(refs, ref)
		}
	}

	slice := pagination.Slice(refs, page)
	return pagination.NewConvertConnection(slice, page, len(refs), toGraphWorkloadReference), nil
}

func ListVulnerabilitySummaries(ctx context.Context, s slug.Slug, filter *TeamVulnerabilitySummaryFilter, page *pagination.Pagination, orderBy *VulnerabilitySummaryOrder) (*WorkloadVulnerabilitySummaryConnection, error) {
	opts := make([]vulnerabilities.Option, 0)
	if filter != nil && len(filter.Environments) == 1 {
		opts = append(opts, vulnerabilities.ClusterFilter(filter.Environments[0]))
	}
	opts = append(opts, vulnerabilities.NamespaceFilter(s.String()))
	opts = append(opts, vulnerabilities.Offset(page.Offset()))
	opts = append(opts, vulnerabilities.Limit(page.Limit()))

	if orderBy != nil {
		direction := vulnerabilities.Direction_ASC
		if orderBy.Direction == model.OrderDirectionDesc {
			direction = vulnerabilities.Direction_DESC
		}

		o, ok := SortFilterWorkloadSummaries[orderBy.Field]
		if !ok {
			return nil, apierror.Errorf("unsupported order field '%s'", orderBy.Field)
		}

		opts = append(opts, vulnerabilities.Order(o, direction))
	}

	resp, err := fromContext(ctx).vulnMgr.client.ListVulnerabilitySummaries(ctx, opts...)
	if err != nil {
		return nil, apierror.Errorf("list vulnerability summaries: %v", err)
	}

	summaries := make([]*WorkloadVulnerabilitySummary, 0)
	for _, sum := range resp.GetNodes() {
		summaries = append(summaries, toWorkloadVulnerabilitySummary(sum))
	}
	return pagination.NewConnection(summaries, page, resp.PageInfo.TotalCount), nil
}

func ListImageVulnerabilities(ctx context.Context, ref string, page *pagination.Pagination, order *ImageVulnerabilityOrder) (*ImageVulnerabilityConnection, error) {
	parts := strings.Split(ref, ":")
	if len(parts) != 2 {
		return nil, apierror.Errorf("invalid image ref")
	}

	if order == nil {
		order = &ImageVulnerabilityOrder{
			Field:     "SEVERITY",
			Direction: model.OrderDirectionAsc,
		}
	}

	direction := vulnerabilities.Direction_ASC
	if order.Direction == model.OrderDirectionDesc {
		direction = vulnerabilities.Direction_DESC
	}

	o, ok := SortFilterImageVulnerabilities[order.Field]
	if !ok {
		return nil, apierror.Errorf("unsupported order field '%s'", order.Field)
	}

	resp, err := fromContext(ctx).vulnMgr.client.ListVulnerabilitiesForImage(
		ctx,
		parts[0],
		parts[1],
		vulnerabilities.IncludeSuppressed(),
		vulnerabilities.Offset(page.Offset()),
		vulnerabilities.Limit(page.Limit()),
		vulnerabilities.Order(o, direction),
	)
	if err != nil {
		return nil, err
	}

	vulns := make([]*ImageVulnerability, 0)
	for _, v := range resp.Nodes {
		vulns = append(vulns, toImageVulnerability(v))
	}

	return pagination.NewConnection(vulns, page, resp.PageInfo.TotalCount), nil
}

func GetImageMetadata(ctx context.Context, imageRef string) (*ImageDetails, error) {
	return fromContext(ctx).imageLoader.Load(ctx, imageRef)
}

func GetTeamRanking(ctx context.Context, teamSlug slug.Slug) (TeamVulnerabilityRanking, error) {
	panic("not implemented")
}

func GetTeamRiskScoreTrend(ctx context.Context, teamSlug slug.Slug) (TeamVulnerabilityRiskScoreTrend, error) {
	// fetch last 30 days of history
	since := time.Now().AddDate(0, 0, -30)
	opts := []vulnerabilities.Option{
		vulnerabilities.Since(since),
		vulnerabilities.NamespaceFilter(teamSlug.String()),
	}

	resp, err := fromContext(ctx).vulnMgr.client.GetVulnerabilitySummaryTimeSeries(ctx, opts...)
	if err != nil {
		return "", fmt.Errorf("fetching vulnerability summary time series: %w", err)
	}

	if len(resp.Points) < 2 {
		return TeamVulnerabilityRiskScoreTrendFlat, nil
	}

	// extract xs (days since start) and ys (risk scores)
	xs := make([]float64, 0, len(resp.Points))
	ys := make([]float64, 0, len(resp.Points))
	start := resp.Points[0].BucketTime.AsTime()

	for _, pt := range resp.Points {
		if pt == nil || pt.BucketTime == nil {
			continue
		}
		// convert bucket time to days since start
		days := pt.BucketTime.AsTime().Sub(start).Hours() / 24.0
		xs = append(xs, days)
		ys = append(ys, float64(pt.RiskScore))
	}

	if len(xs) < 2 {
		return TeamVulnerabilityRiskScoreTrendFlat, nil
	}

	slope := olsSlope(xs, ys)

	// tolerance band to avoid flicker on small movements
	m := mean(ys)

	// Domain-aware band:
	// - 5 pts/day ~ half a critical/day
	// - 0.3% of mean/day to scale gently with very large series
	absBand := 5.0
	relBand := 0.003 * math.Max(m, 1.0)
	band := math.Max(absBand, relBand)

	switch {
	case slope > band:
		return TeamVulnerabilityRiskScoreTrendUp, nil
	case slope < -band:
		return TeamVulnerabilityRiskScoreTrendDown, nil
	default:
		return TeamVulnerabilityRiskScoreTrendFlat, nil
	}
}

func olsSlope(x, y []float64) float64 {
	// ordinary least squares slope
	n := float64(len(x))
	var sumX, sumY, sumXX, sumXY float64
	for i := range x {
		sumX += x[i]
		sumY += y[i]
		sumXX += x[i] * x[i]
		sumXY += x[i] * y[i]
	}
	den := n*sumXX - sumX*sumX
	if den == 0 {
		return 0
	}
	return (n*sumXY - sumX*sumY) / den
}

func mean(vals []float64) float64 {
	if len(vals) == 0 {
		return 0
	}
	var s float64
	for _, v := range vals {
		s += v
	}
	return s / float64(len(vals))
}

func UpdateImageVulnerability(ctx context.Context, input UpdateImageVulnerabilityInput) (*UpdateImageVulnerabilityPayload, error) {
	usr := authz.ActorFromContext(ctx).User

	state := vulnerabilities.SuppressState_NOT_AFFECTED
	switch input.AnalysisState {
	case ImageVulnerabilityAnalysisStateResolved:
		state = vulnerabilities.SuppressState_RESOLVED
	case ImageVulnerabilityAnalysisStateInTriage:
		state = vulnerabilities.SuppressState_IN_TRIAGE
	case ImageVulnerabilityAnalysisStateFalsePositive:
		state = vulnerabilities.SuppressState_FALSE_POSITIVE
	}

	err := fromContext(ctx).vulnMgr.client.SuppressVulnerability(ctx, input.VulnerabilityID.ID, input.Comment, usr.Identity(), state, input.Suppress)
	if err != nil {
		return nil, err
	}

	err = activitylog.Create(ctx, activitylog.CreateInput{
		Action:       activitylog.ActivityLogEntryActionUpdated,
		Actor:        usr,
		ResourceType: activityLogEntryResourceTypeVulnerability,
		ResourceName: input.VulnerabilityID.String(),
	})
	if err != nil {
		return nil, err
	}

	return &UpdateImageVulnerabilityPayload{
		Vulnerability: &ImageVulnerability{
			AnalysisTrail: &ImageVulnerabilityAnalysisTrail{
				State:      input.AnalysisState,
				Suppressed: input.Suppress,
				AllComments: []*ImageVulnerabilityAnalysisComment{
					{
						Comment:    input.Comment,
						State:      input.AnalysisState,
						Suppressed: input.Suppress,
						OnBehalfOf: usr.Identity(),
						Timestamp:  time.Now(),
					},
				},
			},
			vulnerabilityID: input.VulnerabilityID.ID,
		},
	}, nil
}

func GetImageVulnerabilitySummary(ctx context.Context, ref string) (*ImageVulnerabilitySummary, error) {
	parts := strings.Split(ref, ":")
	if len(parts) != 2 {
		return nil, apierror.Errorf("invalid image ref")
	}
	resp, err := fromContext(ctx).vulnMgr.client.GetVulnerabilitySummaryForImage(ctx, parts[0], parts[1])
	if err != nil {
		return nil, apierror.Errorf("get vulnerability summary: %v", err)
	}
	sum := resp.GetVulnerabilitySummary()

	var lastUpdated *time.Time
	if ts := sum.GetLastUpdated(); ts != nil {
		t := ts.AsTime()
		lastUpdated = &t
	}

	return &ImageVulnerabilitySummary{
		Critical:    int(sum.GetCritical()),
		High:        int(sum.GetHigh()),
		Medium:      int(sum.GetMedium()),
		Low:         int(sum.GetLow()),
		Unassigned:  int(sum.GetUnassigned()),
		Total:       int(sum.GetTotal()),
		RiskScore:   int(sum.GetRiskScore()),
		LastUpdated: lastUpdated,
	}, nil
}

func GetWorkloadVulnerabilityHistoryForTeam(ctx context.Context, slug slug.Slug, from time.Time) (*ImageVulnerabilityHistory, error) {
	if from.Before(time.Now().AddDate(-1, 0, 0)) {
		return nil, apierror.Errorf("`from` cannot be older than 1 year")
	}
	if from.After(time.Now()) {
		return nil, apierror.Errorf("`from` cannot be in the future")
	}

	since := normalizeFromDate(from)

	opts := []vulnerabilities.Option{}
	opts = append(opts, vulnerabilities.Since(since))
	opts = append(opts, vulnerabilities.NamespaceFilter(slug.String()))

	return getVulnerabilityHistory(ctx, opts)
}

func GetTenantVulnerabilitySummary(ctx context.Context) (*TenantVulnerabilitySummary, error) {
	resp, err := fromContext(ctx).vulnMgr.client.GetVulnerabilitySummary(ctx)
	if err != nil {
		return nil, apierror.Errorf("get tenant vulnerability summary: %v", err)
	}

	summary := resp.GetVulnerabilitySummary()
	if summary == nil {
		return nil, apierror.Errorf("tenant vulnerability summary not found")
	}

	var lastUpdated *time.Time
	if ts := resp.VulnerabilitySummary.GetLastUpdated(); ts != nil {
		t := ts.AsTime()
		lastUpdated = &t
	}

	return &TenantVulnerabilitySummary{
		Critical:    int(summary.GetCritical()),
		High:        int(summary.GetHigh()),
		Medium:      int(summary.GetMedium()),
		Low:         int(summary.GetLow()),
		Unassigned:  int(summary.GetUnassigned()),
		RiskScore:   int(summary.GetRiskScore()),
		Coverage:    float64(resp.GetCoverage()),
		SbomCount:   int(resp.GetSbomCount()),
		LastUpdated: lastUpdated,
	}, nil
}

func GetWorkloadVulnerabilityHistoryForTenant(ctx context.Context, from time.Time) (*ImageVulnerabilityHistory, error) {
	if from.Before(time.Now().AddDate(-1, 0, 0)) {
		return nil, apierror.Errorf("`from` cannot be older than 1 year")
	}
	if from.After(time.Now()) {
		return nil, apierror.Errorf("`from` cannot be in the future")
	}

	since := normalizeFromDate(from)

	opts := []vulnerabilities.Option{}
	opts = append(opts, vulnerabilities.Since(since))

	return getVulnerabilityHistory(ctx, opts)
}

func GetWorkloadVulnerabilityHistoryForWorkload(ctx context.Context, obj workload.Workload, from time.Time) (*ImageVulnerabilityHistory, error) {
	var workloadType string
	switch obj.GetType() {
	case workload.TypeApplication:
		workloadType = "app"
	case workload.TypeJob:
		workloadType = "job"
	default:
		return nil, apierror.Errorf("invalid workload type")
	}

	if from.Before(time.Now().AddDate(-1, 0, 0)) {
		return nil, apierror.Errorf("`from` cannot be older than 1 year")
	}
	if from.After(time.Now()) {
		return nil, apierror.Errorf("`from` cannot be in the future")
	}

	since := normalizeFromDate(from)

	opts := []vulnerabilities.Option{}
	opts = append(opts, vulnerabilities.Since(since))
	opts = append(opts, vulnerabilities.ClusterFilter(environmentmapper.ClusterName(obj.GetEnvironmentName())))
	opts = append(opts, vulnerabilities.NamespaceFilter(obj.GetTeamSlug().String()))
	opts = append(opts, vulnerabilities.WorkloadFilter(obj.GetName()))
	opts = append(opts, vulnerabilities.WorkloadTypeFilter(workloadType))

	return getVulnerabilityHistory(ctx, opts)
}

// TODO: this is a hack to get the correct date for the vulnerability history. Probably timezone related.
func normalizeFromDate(from time.Time) time.Time {
	return time.Date(from.Year(), from.Month(), from.Day(), 2, 0, 0, 0, time.UTC)
}

func getVulnerabilityHistory(ctx context.Context, opts []vulnerabilities.Option) (*ImageVulnerabilityHistory, error) {
	resp, err := fromContext(ctx).vulnMgr.client.GetVulnerabilitySummaryTimeSeries(ctx, opts...)
	if err != nil {
		return nil, apierror.Errorf("get vulnerability history: %v", err)
	}

	samples := make([]*ImageVulnerabilitySample, 0)

	for _, point := range resp.GetPoints() {
		samples = append(samples, &ImageVulnerabilitySample{
			Summary: &ImageVulnerabilitySummary{
				Critical:   int(point.GetCritical()),
				High:       int(point.GetHigh()),
				Medium:     int(point.GetMedium()),
				Low:        int(point.GetLow()),
				Unassigned: int(point.GetUnassigned()),
				Total:      int(point.GetTotal()),
				RiskScore:  int(point.GetRiskScore()),
			},
			Date: point.GetBucketTime().AsTime(),
		})
	}

	sort.Slice(samples, func(i, j int) bool {
		return samples[i].Date.After(samples[j].Date)
	})

	return &ImageVulnerabilityHistory{
		Samples: samples,
	}, nil
}

func GetVulnerabilitySummary(ctx context.Context, s slug.Slug, filter *TeamVulnerabilitySummaryFilter) (*TeamVulnerabilitySummary, error) {
	opts := []vulnerabilities.Option{}
	opts = append(opts, vulnerabilities.NamespaceFilter(s.String()))
	if filter != nil && len(filter.Environments) > 0 {
		for _, env := range filter.Environments {
			opts = append(opts, vulnerabilities.ClusterFilter(env))
		}
	}

	resp, err := fromContext(ctx).vulnMgr.client.GetVulnerabilitySummary(ctx, opts...)
	if err != nil {
		return nil, apierror.Errorf("get vulnerability summary: %v", err)
	}

	summary := resp.GetVulnerabilitySummary()
	if summary == nil {
		return nil, apierror.Errorf("vulnerability summary not found for team %s", s)
	}

	var lastUpdated *time.Time
	if ts := summary.GetLastUpdated(); ts != nil {
		t := ts.AsTime()
		lastUpdated = &t
	}

	return &TeamVulnerabilitySummary{
		TeamSlug:    s,
		Critical:    int(summary.GetCritical()),
		High:        int(summary.GetHigh()),
		Medium:      int(summary.GetMedium()),
		Low:         int(summary.GetLow()),
		Unassigned:  int(summary.GetUnassigned()),
		RiskScore:   int(summary.GetRiskScore()),
		Coverage:    float64(resp.GetCoverage()),
		BomCount:    int(resp.GetSbomCount()),
		LastUpdated: lastUpdated,
	}, nil
}

func getVulnerabilityByIdent(ctx context.Context, id ident.Ident) (*ImageVulnerability, error) {
	resp, err := fromContext(ctx).vulnMgr.client.GetVulnerabilityById(ctx, id.ID)
	if err != nil {
		return nil, apierror.Errorf("%v", err)
	}
	return toImageVulnerability(resp.GetVulnerability()), nil
}

func getWorkloadVulnerabilitySummaryByIdent(ctx context.Context, id ident.Ident) (*WorkloadVulnerabilitySummary, error) {
	w, err := parseWorkloadVulnerabilitySummaryIdent(id)
	if err != nil {
		return nil, err
	}

	resp, err := fromContext(ctx).vulnMgr.client.ListVulnerabilitySummaries(
		ctx,
		vulnerabilities.ClusterFilter(w.Environment),
		vulnerabilities.NamespaceFilter(w.Team),
		vulnerabilities.WorkloadTypeFilter(w.WorkloadType),
		vulnerabilities.WorkloadFilter(w.Name),
	)
	if err != nil {
		return nil, apierror.Errorf("%v", err)
	}

	for _, sum := range resp.GetNodes() {
		if id.ID == newWorkloadVulnerabilitySummaryIdent(w).ID {
			return toWorkloadVulnerabilitySummary(sum), nil
		}
	}
	return nil, apierror.Errorf("workload vulnerability summary not found for %v", w)
}

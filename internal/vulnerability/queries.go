package vulnerability

import (
	"context"
	"fmt"
	"time"

	"github.com/nais/api/internal/activitylog"
	"github.com/nais/api/internal/auth/authz"
	"github.com/nais/api/internal/graph/apierror"
	"github.com/nais/api/internal/graph/ident"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/team"
	"github.com/nais/api/internal/workload/application"
	"github.com/nais/api/internal/workload/job"
)

func GetImageMetadata(ctx context.Context, imageRef string) (*ImageDetails, error) {
	return fromContext(ctx).imageLoader.Load(ctx, imageRef)
}

func GetTeamMetadata(ctx context.Context, teamSlug slug.Slug) ([]*ImageDetails, error) {
	c := fromContext(ctx).dpClient
	projects, err := c.GetMetadataForTeam(ctx, teamSlug.String())
	if err != nil {
		return nil, fmt.Errorf("getting projects by team %s: %w", teamSlug, err)
	}

	if projects == nil {
		return nil, nil
	}

	images := make([]*ImageDetails, 0)
	for _, p := range projects {
		if p == nil {
			continue
		}

		// TODO: Find a better way to filter out these images
		if p.Name == "europe-north1-docker.pkg.dev/nais-io/nais/images/wonderwall" {
			continue
		}

		if p.Name == "europe-north1-docker.pkg.dev/nais-io/nais/images/elector" {
			continue
		}

		image, err := c.GetMetadataForImage(ctx, p.Name)
		if err != nil {
			return nil, fmt.Errorf("getting metadata for image %q: %w", p.Name, err)
		}
		images = append(images, image)
	}

	return images, nil
}

func GetTeamVulnerabilityStatus(ctx context.Context, teamSlug slug.Slug) ([]*TeamVulnerabilityStatus, error) {
	metadata, err := GetTeamMetadata(ctx, teamSlug)
	if err != nil {
		return nil, err
	}

	vulnWorkloads := 0
	bomCount := 0

	retVal := make([]*TeamVulnerabilityStatus, 0)

	for _, image := range metadata {
		if image.Summary == nil {
			continue
		}
		if image.HasSBOM {
			bomCount += 1
		}
		s := getVulnerabilityState(image.Summary)
		if s == TeamVulnerabilityStateVulnerable {
			vulnWorkloads += 1
		}

	}

	apps := application.ListAllForTeam(ctx, teamSlug)
	jobs := job.ListAllForTeam(ctx, teamSlug)

	coverage := 0.0

	if len(apps) > 0 || len(jobs) > 0 {
		coverage = float64(bomCount) / float64(len(apps)+len(jobs)) * 100
	}

	if coverage < 90 {
		retVal = append(retVal, &TeamVulnerabilityStatus{
			State:       TeamVulnerabilityStateCoverageTooLow,
			Title:       "SBOM coverage",
			Description: "SBOM coverage is below 90% (number of workloads with SBOM / total number of workloads)",
		})
	}

	if vulnWorkloads > 0 {
		retVal = append(retVal, &TeamVulnerabilityStatus{
			State:       TeamVulnerabilityStateTooManyVulnerableWorkloads,
			Title:       "Too many vulnerable workloads",
			Description: "The threshold for a vulnerable workload is a riskscore above 100 or a critical vulnerability",
		})
	}

	return retVal, nil
}

func getVulnerabilityState(summary *ImageVulnerabilitySummary) TeamVulnerabilityState {
	switch {
	case summary == nil:
		return TeamVulnerabilityStateMissingSbom
	case summary.Critical > 0:
		return TeamVulnerabilityStateVulnerable
	// if the amount of high vulnerabilities is greater than 50 % of the total amount of vulnerabilities, we consider the image as vulnerable
	case summary.RiskScore > 100 && summary.High > summary.RiskScore/2:
		return TeamVulnerabilityStateVulnerable
	}

	return TeamVulnerabilityStateOk
}

func ListWorkloadReferences(ctx context.Context, image string, page *pagination.Pagination) (*pagination.Connection[*ContainerImageWorkloadReference], error) {
	metadata, err := fromContext(ctx).imageLoader.Load(ctx, image)
	if err != nil {
		return nil, err
	}

	all := metadata.WorkloadReferences
	slice := pagination.Slice(all, page)
	return pagination.NewConvertConnection(slice, page, len(all), toGraphWorkloadReference), nil
}

func GetTeamRanking(ctx context.Context, teamSlug slug.Slug) (TeamVulnerabilityRanking, error) {
	totalTeams, err := team.Count(ctx)
	if err != nil {
		return TeamVulnerabilityRankingUnknown, fmt.Errorf("counting teams: %w", err)
	}

	currentRank, err := fromContext(ctx).promClients.ranking(ctx, teamSlug.String(), time.Now())
	if err != nil {
		return "", fmt.Errorf("getting team ranking: %w", err)
	}

	// Divide teams into three parts
	upperLimit := int(totalTeams) / 3        // Upper third
	middleLimit := 2 * (int(totalTeams) / 3) // Middle third (everything before bottom third)

	// Determine vulnerability score based on rank
	switch {
	case currentRank == 0:
		return TeamVulnerabilityRankingUnknown, nil
	case currentRank <= upperLimit: // Top third
		return TeamVulnerabilityRankingMostVulnerable, nil
	case currentRank > upperLimit && currentRank <= middleLimit: // Middle third
		return TeamVulnerabilityRankingMiddle, nil
	default: // Bottom third
		return TeamVulnerabilityRankingLeastVulnerable, nil
	}
}

func GetTeamRiskScoreTrend(ctx context.Context, teamSlug slug.Slug) (TeamVulnerabilityRiskScoreTrend, error) {
	current, err := fromContext(ctx).promClients.riskScoreTotal(ctx, teamSlug.String(), time.Now())
	if err != nil {
		return "", fmt.Errorf("getting team risk score: %w", err)
	}
	previous, err := fromContext(ctx).promClients.riskScoreTotal(ctx, teamSlug.String(), time.Now().AddDate(0, 0, -30))
	if err != nil {
		return "", fmt.Errorf("getting team risk score: %w", err)
	}
	switch {
	case current > previous:
		return TeamVulnerabilityRiskScoreTrendUp, nil
	case current < previous:
		return TeamVulnerabilityRiskScoreTrendDown, nil
	default:
		return TeamVulnerabilityRiskScoreTrendFlat, nil
	}
}

func ListImageVulnerabilities(ctx context.Context, ref string, page *pagination.Pagination, order *ImageVulnerabilityOrder) (*ImageVulnerabilityConnection, error) {
	metadata, err := GetImageMetadata(ctx, ref)
	if err != nil {
		return nil, err
	}

	vulns, err := fromContext(ctx).dpClient.GetFindingsForImageByProjectID(ctx, metadata.ProjectID, true)
	if err != nil {
		return nil, err
	}

	if order == nil {
		order = &ImageVulnerabilityOrder{
			Field:     ImageVulnerabilityOrderFieldSeverity,
			Direction: model.OrderDirectionDesc,
		}
	}

	SortFilterImageVulnerabilities.Sort(ctx, vulns, order.Field, order.Direction)

	slice := pagination.Slice(vulns, page)

	return pagination.NewConnection(slice, page, len(vulns)), nil
}

func UpdateImageVulnerability(ctx context.Context, input UpdateImageVulnerabilityInput) (*UpdateImageVulnerabilityPayload, error) {
	projectID, identifier, componentID, err := parseVulnerabilityIdent(input.VulnerabilityID)
	if err != nil {
		return nil, err
	}

	usr := authz.ActorFromContext(ctx).User

	err = fromContext(ctx).dpClient.UpdateFinding(ctx, input.AnalysisState.String(), input.Comment, componentID, projectID, identifier, usr.Identity(), input.Suppress)
	if err != nil {
		return nil, err
	}

	vuln, err := getVulnerabilityByIdent(ctx, input.VulnerabilityID)
	if err != nil {
		return nil, err
	}

	err = activitylog.Create(ctx, activitylog.CreateInput{
		Action:       activitylog.AuditActionUpdated,
		Actor:        usr,
		ResourceType: auditResourceTypeVulnerability,
		ResourceName: vuln.vulnerabilityID,
	})
	if err != nil {
		return nil, err
	}

	return &UpdateImageVulnerabilityPayload{
		Vulnerability: vuln,
	}, nil
}

func GetImageAnalysisTrail(ctx context.Context, obj *ImageVulnerability) (*ImageVulnerabilityAnalysisTrail, error) {
	return fromContext(ctx).dpClient.GetAnalysisTrailForImage(ctx, obj.projectID, obj.componentID, obj.vulnerabilityID)
}

func getVulnerabilityByIdent(ctx context.Context, id ident.Ident) (*ImageVulnerability, error) {
	projectID, vulnerabilityID, componentID, err := parseVulnerabilityIdent(id)
	if err != nil {
		return nil, err
	}

	vulns, err := fromContext(ctx).dpClient.GetFindingsForImageByProjectID(ctx, projectID, true)
	if err != nil {
		return nil, err
	}

	for _, v := range vulns {
		if v.vulnerabilityID == vulnerabilityID && v.componentID == componentID {
			return v, nil
		}
	}

	return nil, apierror.Errorf("vulnerability not found")
}

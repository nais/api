package vulnerability

import (
	"context"
	"fmt"
	"math"
	"sort"
	"strings"
	"time"

	"github.com/nais/api/internal/activitylog"
	"github.com/nais/api/internal/auth/authz"
	"github.com/nais/api/internal/environmentmapper"
	"github.com/nais/api/internal/graph/apierror"
	"github.com/nais/api/internal/graph/ident"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/workload"
	"github.com/nais/api/internal/workload/application"
	"github.com/nais/api/internal/workload/job"
	"github.com/nais/v13s/pkg/api/vulnerabilities"
	"k8s.io/utils/ptr"
)

func ListWorkloadReferences(ctx context.Context, image string, page *pagination.Pagination) (*pagination.Connection[*ContainerImageWorkloadReference], error) {
	parts := strings.Split(image, ":")
	if len(parts) != 2 {
		return nil, apierror.Errorf("invalid image reference: %s", image)
	}

	resp, err := fromContext(ctx).Client.GetVulnerabilitySummaryForImage(ctx, parts[0], parts[1])
	if err != nil {
		return nil, err
	}

	workloadRefs := make([]*WorkloadReference, 0)
	for _, ref := range resp.GetWorkloadRef() {
		workloadRefs = append(workloadRefs, &WorkloadReference{
			Environment:  environmentmapper.EnvironmentName(ref.GetCluster()),
			Team:         ref.GetNamespace(),
			Name:         ref.GetName(),
			WorkloadType: ref.GetType(),
		})
	}

	refs := make([]*WorkloadReference, 0)
	for _, ref := range workloadRefs {
		if ref.WorkloadType == "app" {
			_, err = application.Get(ctx, slug.Slug(ref.Team), ref.Environment, ref.Name)
			if err != nil {
				continue
			}
			refs = append(refs, ref)
		}

		if ref.WorkloadType == "job" {
			_, err = job.Get(ctx, slug.Slug(ref.Team), ref.Environment, ref.Name)
			if err != nil {
				continue
			}
			refs = append(refs, ref)
		}
	}

	slice := pagination.Slice(refs, page)
	return pagination.NewConvertConnection(slice, page, len(refs), toGraphWorkloadReference), nil
}

func ListVulnerabilitySummaries(ctx context.Context, s slug.Slug, filter *TeamVulnerabilitySummaryFilter, page *pagination.Pagination, orderBy *VulnerabilitySummaryOrder) (*WorkloadVulnerabilitySummaryConnection, error) {
	opts := make([]vulnerabilities.Option, 0)
	if filter != nil && len(filter.Environments) == 1 {
		opts = append(opts, vulnerabilities.ClusterFilter(filter.Environments[0]))
	}
	opts = append(opts, vulnerabilities.NamespaceFilter(s.String()))
	opts = append(opts, vulnerabilities.Offset(page.Offset()))
	opts = append(opts, vulnerabilities.Limit(page.Limit()))

	if orderBy != nil {
		direction := vulnerabilities.Direction_ASC
		if orderBy.Direction == model.OrderDirectionDesc {
			direction = vulnerabilities.Direction_DESC
		}

		o, ok := SortFilterWorkloadSummaries[orderBy.Field]
		if !ok {
			return nil, apierror.Errorf("unsupported order field '%s'", orderBy.Field)
		}

		opts = append(opts, vulnerabilities.Order(o, direction))
	}

	resp, err := fromContext(ctx).Client.ListVulnerabilitySummaries(ctx, opts...)
	if err != nil {
		return nil, apierror.Errorf("list vulnerability summaries: %v", err)
	}

	summaries := make([]*WorkloadVulnerabilitySummary, 0)
	for _, sum := range resp.GetNodes() {
		summaries = append(summaries, toWorkloadVulnerabilitySummary(sum))
	}
	return pagination.NewConnection(summaries, page, resp.PageInfo.TotalCount), nil
}

func ListImageVulnerabilities(ctx context.Context, ref string, filter *ImageVulnerabilityFilter, page *pagination.Pagination, orderBy *ImageVulnerabilityOrder) (*ImageVulnerabilityConnection, error) {
	parts := strings.Split(ref, ":")
	if len(parts) != 2 {
		return nil, apierror.Errorf("invalid image ref")
	}

	if orderBy == nil {
		orderBy = &ImageVulnerabilityOrder{
			Field:     "SEVERITY",
			Direction: model.OrderDirectionAsc,
		}
	}

	direction := vulnerabilities.Direction_ASC
	if orderBy.Direction == model.OrderDirectionDesc {
		direction = vulnerabilities.Direction_DESC
	}

	o, ok := SortFilterImageVulnerabilities[orderBy.Field]
	if !ok {
		return nil, apierror.Errorf("unsupported order field '%s'", orderBy.Field)
	}

	opts := make([]vulnerabilities.Option, 0)
	opts = append(opts, vulnerabilities.IncludeSuppressed())
	opts = append(opts, vulnerabilities.Offset(page.Offset()))
	opts = append(opts, vulnerabilities.Limit(page.Limit()))
	if filter != nil && filter.Severity != "" {
		severity := mapVulnerabilitySeverity(filter.Severity)
		opts = append(opts, vulnerabilities.SeverityFilter(severity))
	}
	if filter != nil && filter.SeveritySince != nil {
		opts = append(opts, vulnerabilities.Since(*filter.SeveritySince))
	}
	opts = append(opts, vulnerabilities.Order(o, direction))

	resp, err := fromContext(ctx).Client.ListVulnerabilitiesForImage(
		ctx,
		parts[0],
		parts[1],
		opts...,
	)
	if err != nil {
		return nil, err
	}

	vulns := make([]*ImageVulnerability, 0)
	for _, v := range resp.Nodes {
		vulns = append(vulns, toImageVulnerability(v))
	}

	return pagination.NewConnection(vulns, page, resp.PageInfo.TotalCount), nil
}

func GetImageHasSBOM(ctx context.Context, imageRef string) (bool, error) {
	parts := strings.Split(imageRef, ":")
	if len(parts) != 2 {
		return false, apierror.Errorf("invalid image ref")
	}

	resp, err := fromContext(ctx).Client.GetVulnerabilitySummaryForImage(ctx, parts[0], parts[1])
	if err != nil {
		return false, apierror.Errorf("get vulnerability summary: %v", err)
	}
	return resp.GetVulnerabilitySummary().GetHasSbom(), nil
}

func GetTeamRiskScoreTrend(ctx context.Context, teamSlug slug.Slug) (TeamVulnerabilityRiskScoreTrend, error) {
	// fetch last 30 days of history
	since := time.Now().AddDate(0, 0, -30)
	opts := []vulnerabilities.Option{
		vulnerabilities.Since(since),
		vulnerabilities.NamespaceFilter(teamSlug.String()),
	}

	resp, err := fromContext(ctx).Client.GetVulnerabilitySummaryTimeSeries(ctx, opts...)
	if err != nil {
		return "", fmt.Errorf("fetching vulnerability summary time series: %w", err)
	}

	if len(resp.Points) < 2 {
		return TeamVulnerabilityRiskScoreTrendFlat, nil
	}

	// extract xs (days since start) and ys (risk scores)
	xs := make([]float64, 0, len(resp.Points))
	ys := make([]float64, 0, len(resp.Points))
	start := resp.Points[0].BucketTime.AsTime()

	for _, pt := range resp.Points {
		if pt == nil || pt.BucketTime == nil {
			continue
		}
		// convert bucket time to days since start
		days := pt.BucketTime.AsTime().Sub(start).Hours() / 24.0
		xs = append(xs, days)
		ys = append(ys, float64(pt.RiskScore))
	}

	if len(xs) < 2 {
		return TeamVulnerabilityRiskScoreTrendFlat, nil
	}

	slope := olsSlope(xs, ys)

	// tolerance band to avoid flicker on small movements
	m := mean(ys)

	// Domain-aware band:
	// - 5 pts/day ~ half a critical/day
	// - 0.3% of mean/day to scale gently with very large series
	absBand := 5.0
	relBand := 0.003 * math.Max(m, 1.0)
	band := math.Max(absBand, relBand)

	switch {
	case slope > band:
		return TeamVulnerabilityRiskScoreTrendUp, nil
	case slope < -band:
		return TeamVulnerabilityRiskScoreTrendDown, nil
	default:
		return TeamVulnerabilityRiskScoreTrendFlat, nil
	}
}

func olsSlope(x, y []float64) float64 {
	// ordinary least squares slope
	n := float64(len(x))
	var sumX, sumY, sumXX, sumXY float64
	for i := range x {
		sumX += x[i]
		sumY += y[i]
		sumXX += x[i] * x[i]
		sumXY += x[i] * y[i]
	}
	den := n*sumXX - sumX*sumX
	if den == 0 {
		return 0
	}
	return (n*sumXY - sumX*sumY) / den
}

func mean(vals []float64) float64 {
	if len(vals) == 0 {
		return 0
	}
	var s float64
	for _, v := range vals {
		s += v
	}
	return s / float64(len(vals))
}

func ListWorkloadsForVulnerabilityByID(ctx context.Context, id string) ([]*WorkloadReference, error) {
	resp, err := fromContext(ctx).Client.ListWorkloadsForVulnerabilityById(ctx, id)
	if err != nil {
		return nil, apierror.Errorf("list workloads for vulnerability: %v", err)
	}

	workloads := make([]*WorkloadReference, 0, len(resp.GetWorkloadRef()))
	for _, w := range resp.GetWorkloadRef() {
		workloads = append(workloads, &WorkloadReference{
			Name:         w.Name,
			Environment:  w.Cluster,
			Team:         w.Namespace,
			WorkloadType: w.Type,
		})
	}

	return workloads, nil
}

func UpdateImageVulnerability(ctx context.Context, input UpdateImageVulnerabilityInput) (*UpdateImageVulnerabilityPayload, error) {
	usr := authz.ActorFromContext(ctx).User

	// Get the current vulnerability state before updating
	oldVuln, err := getVulnerabilityByIdent(ctx, input.VulnerabilityID)
	if err != nil {
		return nil, fmt.Errorf("getting current vulnerability state: %w", err)
	}

	// Store old suppression state
	var oldSuppression *ImageVulnerabilitySuppression
	if oldVuln.Suppression != nil {
		oldSuppression = &ImageVulnerabilitySuppression{
			State:  oldVuln.Suppression.State,
			Reason: oldVuln.Suppression.Reason,
		}
	}

	state := vulnerabilities.SuppressState_NOT_SET
	if input.State != nil {
		switch *input.State {
		case ImageVulnerabilitySuppressionStateResolved:
			state = vulnerabilities.SuppressState_RESOLVED
		case ImageVulnerabilitySuppressionStateInTriage:
			state = vulnerabilities.SuppressState_IN_TRIAGE
		case ImageVulnerabilitySuppressionStateFalsePositive:
			state = vulnerabilities.SuppressState_FALSE_POSITIVE
		case ImageVulnerabilitySuppressionStateNotAffected:
			state = vulnerabilities.SuppressState_NOT_AFFECTED
		}
	}

	reason := input.Reason
	suppress := input.Suppress
	if state == vulnerabilities.SuppressState_NOT_SET {
		reason = ""
		suppress = false
	}

	err = fromContext(ctx).Client.SuppressVulnerability(ctx, input.VulnerabilityID.ID, reason, usr.Identity(), state, suppress)
	if err != nil {
		return nil, err
	}

	vuln, err := fromContext(ctx).Client.GetVulnerabilityById(ctx, input.VulnerabilityID.ID)
	if err != nil {
		return nil, err
	}

	// Get updated vulnerability state
	updatedVuln, err := getVulnerabilityByIdent(ctx, input.VulnerabilityID)
	if err != nil {
		return nil, fmt.Errorf("getting updated vulnerability state: %w", err)
	}

	// Determine new suppression state
	var newSuppression *ImageVulnerabilitySuppression
	if updatedVuln.Suppression != nil {
		newSuppression = &ImageVulnerabilitySuppression{
			State:  updatedVuln.Suppression.State,
			Reason: updatedVuln.Suppression.Reason,
		}
	}

	err = activitylog.Create(ctx, activitylog.CreateInput{
		Action:       activitylog.ActivityLogEntryActionUpdated,
		Actor:        usr,
		ResourceType: activityLogEntryResourceTypeVulnerability,
		ResourceName: vuln.GetVulnerability().ImageName,
		Data: VulnerabilityActivityLogEntryData{
			Identifier:          updatedVuln.Identifier,
			Severity:            updatedVuln.Severity,
			Package:             updatedVuln.Package,
			PreviousSuppression: oldSuppression,
			NewSuppression:      newSuppression,
		},
	})
	if err != nil {
		return nil, err
	}

	return &UpdateImageVulnerabilityPayload{
		Vulnerability: updatedVuln,
	}, nil
}

func GetImageVulnerabilitySummary(ctx context.Context, ref string) (*ImageVulnerabilitySummary, error) {
	parts := strings.Split(ref, ":")
	if len(parts) != 2 {
		return nil, apierror.Errorf("invalid image ref")
	}
	resp, err := fromContext(ctx).Client.GetVulnerabilitySummaryForImage(ctx, parts[0], parts[1])
	if err != nil {
		return nil, apierror.Errorf("get vulnerability summary: %v", err)
	}
	sum := resp.GetVulnerabilitySummary()

	var lastUpdated *time.Time
	if ts := sum.GetLastUpdated(); ts != nil {
		t := ts.AsTime()
		lastUpdated = &t
	}

	return &ImageVulnerabilitySummary{
		Critical:    int(sum.GetCritical()),
		High:        int(sum.GetHigh()),
		Medium:      int(sum.GetMedium()),
		Low:         int(sum.GetLow()),
		Unassigned:  int(sum.GetUnassigned()),
		Total:       int(sum.GetTotal()),
		RiskScore:   int(sum.GetRiskScore()),
		LastUpdated: lastUpdated,
	}, nil
}

func GetWorkloadVulnerabilityHistoryForTeam(ctx context.Context, slug slug.Slug, from time.Time) (*ImageVulnerabilityHistory, error) {
	if from.Before(time.Now().AddDate(-1, 0, 0)) {
		return nil, apierror.Errorf("`from` cannot be older than 1 year")
	}
	if from.After(time.Now()) {
		return nil, apierror.Errorf("`from` cannot be in the future")
	}

	since := normalizeFromDate(from)

	opts := []vulnerabilities.Option{}
	opts = append(opts, vulnerabilities.Since(since))
	opts = append(opts, vulnerabilities.NamespaceFilter(slug.String()))

	return getVulnerabilityHistory(ctx, opts)
}

func GetTenantVulnerabilitySummary(ctx context.Context) (*TenantVulnerabilitySummary, error) {
	resp, err := fromContext(ctx).Client.GetVulnerabilitySummary(ctx)
	if err != nil {
		return nil, apierror.Errorf("get tenant vulnerability summary: %v", err)
	}

	summary := resp.GetVulnerabilitySummary()
	if summary == nil {
		return nil, apierror.Errorf("tenant vulnerability summary not found")
	}

	var lastUpdated *time.Time
	if ts := resp.VulnerabilitySummary.GetLastUpdated(); ts != nil {
		t := ts.AsTime()
		lastUpdated = &t
	}

	return &TenantVulnerabilitySummary{
		Critical:    int(summary.GetCritical()),
		High:        int(summary.GetHigh()),
		Medium:      int(summary.GetMedium()),
		Low:         int(summary.GetLow()),
		Unassigned:  int(summary.GetUnassigned()),
		RiskScore:   int(summary.GetRiskScore()),
		Coverage:    float64(resp.GetCoverage()),
		SbomCount:   int(resp.GetSbomCount()),
		LastUpdated: lastUpdated,
	}, nil
}

func GetWorkloadVulnerabilityHistoryForTenant(ctx context.Context, from time.Time) (*ImageVulnerabilityHistory, error) {
	if from.Before(time.Now().AddDate(-1, 0, 0)) {
		return nil, apierror.Errorf("`from` cannot be older than 1 year")
	}
	if from.After(time.Now()) {
		return nil, apierror.Errorf("`from` cannot be in the future")
	}

	since := normalizeFromDate(from)

	opts := []vulnerabilities.Option{}
	opts = append(opts, vulnerabilities.Since(since))

	return getVulnerabilityHistory(ctx, opts)
}

func GetWorkloadVulnerabilityHistoryForWorkload(ctx context.Context, obj workload.Workload, from time.Time) (*ImageVulnerabilityHistory, error) {
	var workloadType string
	switch obj.GetType() {
	case workload.TypeApplication:
		workloadType = "app"
	case workload.TypeJob:
		workloadType = "job"
	default:
		return nil, apierror.Errorf("invalid workload type")
	}

	if from.Before(time.Now().AddDate(-1, 0, 0)) {
		return nil, apierror.Errorf("`from` cannot be older than 1 year")
	}
	if from.After(time.Now()) {
		return nil, apierror.Errorf("`from` cannot be in the future")
	}

	since := normalizeFromDate(from)

	opts := []vulnerabilities.Option{}
	opts = append(opts, vulnerabilities.Since(since))
	opts = append(opts, vulnerabilities.ClusterFilter(environmentmapper.ClusterName(obj.GetEnvironmentName())))
	opts = append(opts, vulnerabilities.NamespaceFilter(obj.GetTeamSlug().String()))
	opts = append(opts, vulnerabilities.WorkloadFilter(obj.GetName()))
	opts = append(opts, vulnerabilities.WorkloadTypeFilter(workloadType))

	return getVulnerabilityHistory(ctx, opts)
}

// TODO: this is a hack to get the correct date for the vulnerability history. Probably timezone related.
func normalizeFromDate(from time.Time) time.Time {
	return time.Date(from.Year(), from.Month(), from.Day(), 2, 0, 0, 0, time.UTC)
}

func getVulnerabilityHistory(ctx context.Context, opts []vulnerabilities.Option) (*ImageVulnerabilityHistory, error) {
	resp, err := fromContext(ctx).Client.GetVulnerabilitySummaryTimeSeries(ctx, opts...)
	if err != nil {
		return nil, apierror.Errorf("get vulnerability history: %v", err)
	}

	samples := make([]*ImageVulnerabilitySample, 0)

	for _, point := range resp.GetPoints() {
		samples = append(samples, &ImageVulnerabilitySample{
			Summary: &ImageVulnerabilitySummary{
				Critical:   int(point.GetCritical()),
				High:       int(point.GetHigh()),
				Medium:     int(point.GetMedium()),
				Low:        int(point.GetLow()),
				Unassigned: int(point.GetUnassigned()),
				Total:      int(point.GetTotal()),
				RiskScore:  int(point.GetRiskScore()),
			},
			Date: point.GetBucketTime().AsTime(),
		})
	}

	sort.Slice(samples, func(i, j int) bool {
		return samples[i].Date.After(samples[j].Date)
	})

	return &ImageVulnerabilityHistory{
		Samples: samples,
	}, nil
}

func GetVulnerabilitySummary(ctx context.Context, s slug.Slug, filter *TeamVulnerabilitySummaryFilter) (*TeamVulnerabilitySummary, error) {
	opts := []vulnerabilities.Option{}
	opts = append(opts, vulnerabilities.NamespaceFilter(s.String()))
	if filter != nil && len(filter.Environments) > 0 {
		for _, env := range filter.Environments {
			opts = append(opts, vulnerabilities.ClusterFilter(env))
		}
	}

	resp, err := fromContext(ctx).Client.GetVulnerabilitySummary(ctx, opts...)
	if err != nil {
		return nil, apierror.Errorf("get vulnerability summary: %v", err)
	}

	summary := resp.GetVulnerabilitySummary()
	if summary == nil {
		return nil, apierror.Errorf("vulnerability summary not found for team %s", s)
	}

	var lastUpdated *time.Time
	if ts := summary.GetLastUpdated(); ts != nil {
		t := ts.AsTime()
		lastUpdated = &t
	}

	return &TeamVulnerabilitySummary{
		TeamSlug:    s,
		Critical:    int(summary.GetCritical()),
		High:        int(summary.GetHigh()),
		Medium:      int(summary.GetMedium()),
		Low:         int(summary.GetLow()),
		Unassigned:  int(summary.GetUnassigned()),
		RiskScore:   int(summary.GetRiskScore()),
		Coverage:    float64(resp.GetCoverage()),
		SBOMCount:   int(resp.GetSbomCount()),
		LastUpdated: lastUpdated,
	}, nil
}

func GetVulnerabilityMeanTimeToFixHistoryForWorkload(ctx context.Context, obj workload.Workload, from time.Time) (*VulnerabilityFixHistory, error) {
	workloadType, err := getWorkloadType(obj.GetType())
	if err != nil {
		return nil, err
	}

	if from.Before(time.Now().AddDate(-1, 0, 0)) {
		return nil, apierror.Errorf("`from` cannot be older than 1 year")
	}
	if from.After(time.Now()) {
		return nil, apierror.Errorf("`from` cannot be in the future")
	}

	since := normalizeFromDate(from)
	opts := []vulnerabilities.Option{
		vulnerabilities.Since(since),
		vulnerabilities.ClusterFilter(environmentmapper.ClusterName(obj.GetEnvironmentName())),
		vulnerabilities.NamespaceFilter(obj.GetTeamSlug().String()),
		vulnerabilities.WorkloadFilter(obj.GetName()),
		vulnerabilities.WorkloadTypeFilter(workloadType),
	}

	return getVulnerabilityMeanTimeToFixHistory(ctx, opts)
}

func GetVulnerabilityMeanTimeToFixHistoryForTeam(ctx context.Context, slug slug.Slug, from time.Time) (*VulnerabilityFixHistory, error) {
	if from.Before(time.Now().AddDate(-1, 0, 0)) {
		return nil, apierror.Errorf("`from` cannot be older than 1 year")
	}
	if from.After(time.Now()) {
		return nil, apierror.Errorf("`from` cannot be in the future")
	}

	since := normalizeFromDate(from)

	opts := []vulnerabilities.Option{}
	opts = append(opts, vulnerabilities.Since(since))
	opts = append(opts, vulnerabilities.NamespaceFilter(slug.String()))

	return getVulnerabilityMeanTimeToFixHistory(ctx, opts)
}

func GetVulnerabilityMeanTimeToFixHistory(ctx context.Context, from time.Time) (*VulnerabilityFixHistory, error) {
	var opts []vulnerabilities.Option
	opts = append(opts, vulnerabilities.Since(from))
	return getVulnerabilityMeanTimeToFixHistory(ctx, opts)
}

func GetCVE(ctx context.Context, cve string) (*CVE, error) {
	vuln, err := fromContext(ctx).Client.GetCve(ctx, cve)
	if err != nil {
		return nil, apierror.Errorf("get vulnerability by CVE: %v", err)
	}

	return toCVE(vuln.GetCve()), nil
}

func ListCVEs(ctx context.Context, page *pagination.Pagination, orderBy *CVEOrder) (*CVEConnection, error) {
	opts := []vulnerabilities.Option{
		vulnerabilities.Limit(page.Limit()),
		vulnerabilities.Offset(page.Offset()),
		vulnerabilities.ExcludeNamespacesFilter("nais-system"),
		vulnerabilities.ExcludeClustersFilter("management"),
	}

	// Apply ordering if specified
	if orderBy != nil {
		direction := vulnerabilities.Direction_ASC
		if orderBy.Direction == model.OrderDirectionDesc {
			direction = vulnerabilities.Direction_DESC
		}

		var field vulnerabilities.OrderByField
		switch orderBy.Field {
		case CVEOrderFieldIdentifier:
			field = vulnerabilities.OrderByCveId
		case CVEOrderFieldSeverity:
			field = vulnerabilities.OrderBySeverity
		case CVEOrderFieldCVSSScore:
			field = vulnerabilities.OrderByCvssScore
		case CVEOrderFieldAffectedWorkloadsCount:
			field = vulnerabilities.OrderByAffectedWorkloads
		default:
			field = vulnerabilities.OrderByCvssScore
		}

		opts = append(opts, vulnerabilities.Order(field, direction))
	}

	resp, err := fromContext(ctx).Client.ListCveSummaries(ctx, opts...)
	if err != nil {
		return nil, apierror.Errorf("list CVE summaries: %v", err)
	}

	// Convert CVE summaries to CVE objects
	cves := make([]*CVE, 0, len(resp.GetNodes()))
	for _, cveSummary := range resp.GetNodes() {
		c := toCVE(cveSummary.GetCve())
		c.AffectedWorkloads = ptr.To(int(cveSummary.AffectedWorkloads))
		cves = append(cves, c)
	}

	return pagination.NewConnection(cves, page, int(resp.GetPageInfo().GetTotalCount())), nil
}

func GetWorkloadsByCVE(ctx context.Context, cve string, page *pagination.Pagination) (*WorkloadWithVulnerabilityConnection, error) {
	opts := []vulnerabilities.Option{
		vulnerabilities.Offset(page.Offset()),
		vulnerabilities.Limit(page.Limit()),
		vulnerabilities.ExcludeNamespacesFilter("nais-system"),
		vulnerabilities.ExcludeClustersFilter("management"),
	}

	opts = append(opts, vulnerabilities.Order(vulnerabilities.OrderByNamespace, vulnerabilities.Direction_ASC))

	resp, err := fromContext(ctx).Client.ListWorkloadsForVulnerability(
		ctx,
		vulnerabilities.VulnerabilityFilter{
			CveIds: []string{cve},
		},
		opts...,
	)
	if err != nil {
		return nil, apierror.Errorf("list workloads for vulnerability by CVE: %v", err)
	}

	return pagination.NewConvertConnectionWithError(resp.GetNodes(), page, resp.GetPageInfo().GetTotalCount(), func(from *vulnerabilities.WorkloadForVulnerability) (*WorkloadWithVulnerability, error) {
		var workload workload.Workload
		var err error
		w := from.GetWorkloadRef()

		switch w.GetType() {
		case "app":
			workload, err = application.Get(ctx, slug.Slug(w.GetNamespace()), environmentmapper.EnvironmentName(w.GetCluster()), w.GetName())
		case "job":
			workload, err = job.Get(ctx, slug.Slug(w.GetNamespace()), environmentmapper.EnvironmentName(w.GetCluster()), w.GetName())
		}

		if err != nil {
			return nil, apierror.Errorf("getting workload (%v) %v/%v/%v: %v", w.GetType(), environmentmapper.EnvironmentName(w.GetCluster()), w.GetNamespace(), w.GetName(), err)
		}

		return &WorkloadWithVulnerability{
			Workload:      workload,
			Vulnerability: toImageVulnerability(from.GetVulnerability()),
		}, nil
	})
}

func getCVEByIdent(ctx context.Context, id ident.Ident) (*CVE, error) {
	cveID, err := parseCVEIdent(id)
	if err != nil {
		return nil, err
	}
	return GetCVE(ctx, cveID)
}

func getVulnerabilityMeanTimeToFixHistory(ctx context.Context, opts []vulnerabilities.Option) (*VulnerabilityFixHistory, error) {
	resp, err := fromContext(ctx).Client.ListMeanTimeToFixTrendBySeverity(ctx, opts...)
	if err != nil {
		return nil, apierror.Errorf("list mean time to fix trend by severity: %v", err)
	}

	samples := make([]*VulnerabilityFixSample, 0, len(resp.GetPoints()))
	for _, point := range resp.GetPoints() {
		firstFixedAt := point.GetFirstFixedAt().AsTime()
		lastFixedAt := point.GetLastFixedAt().AsTime()
		sample := &VulnerabilityFixSample{
			Severity:       parseSeverity(point.Severity),
			Date:           point.SnapshotDate.AsTime(),
			Days:           int(point.GetMeanTimeToFixDays()),
			FixedCount:     int(point.FixedCount),
			FirstFixedAt:   &firstFixedAt,
			LastFixedAt:    &lastFixedAt,
			TotalWorkloads: int(point.WorkloadCount),
		}
		samples = append(samples, sample)
	}

	sort.Slice(samples, func(i, j int) bool {
		return samples[i].Date.After(samples[j].Date)
	})

	return &VulnerabilityFixHistory{
		Samples: samples,
	}, nil
}

func getWorkloadType(workloadType workload.Type) (string, error) {
	switch workloadType {
	case workload.TypeApplication:
		return "app", nil
	case workload.TypeJob:
		return "job", nil
	default:
		return "", apierror.Errorf("invalid workload type: %s", workloadType)
	}
}

func parseSeverity(s vulnerabilities.Severity) ImageVulnerabilitySeverity {
	switch s {
	case vulnerabilities.Severity_CRITICAL:
		return ImageVulnerabilitySeverityCritical
	case vulnerabilities.Severity_HIGH:
		return ImageVulnerabilitySeverityHigh
	case vulnerabilities.Severity_MEDIUM:
		return ImageVulnerabilitySeverityMedium
	case vulnerabilities.Severity_LOW:
		return ImageVulnerabilitySeverityLow
	default:
		return ImageVulnerabilitySeverityUnassigned
	}
}

func getVulnerabilityByIdent(ctx context.Context, id ident.Ident) (*ImageVulnerability, error) {
	resp, err := fromContext(ctx).Client.GetVulnerabilityById(ctx, id.ID)
	if err != nil {
		return nil, apierror.Errorf("%v", err)
	}
	return toImageVulnerability(resp.GetVulnerability()), nil
}

func getWorkloadVulnerabilitySummaryByIdent(ctx context.Context, id ident.Ident) (*WorkloadVulnerabilitySummary, error) {
	w, err := parseWorkloadVulnerabilitySummaryIdent(id)
	if err != nil {
		return nil, err
	}

	resp, err := fromContext(ctx).Client.ListVulnerabilitySummaries(
		ctx,
		vulnerabilities.ClusterFilter(w.Environment),
		vulnerabilities.NamespaceFilter(w.Team),
		vulnerabilities.WorkloadTypeFilter(w.WorkloadType),
		vulnerabilities.WorkloadFilter(w.Name),
	)
	if err != nil {
		return nil, apierror.Errorf("%v", err)
	}

	for _, sum := range resp.GetNodes() {
		if id.ID == newWorkloadVulnerabilitySummaryIdent(w).ID {
			return toWorkloadVulnerabilitySummary(sum), nil
		}
	}
	return nil, apierror.Errorf("workload vulnerability summary not found for %v", w)
}

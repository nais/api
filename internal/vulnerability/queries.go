package vulnerability

import (
	"context"
	"fmt"
	"time"

	"github.com/nais/api/internal/auth/authz"
	"github.com/nais/api/internal/graph/apierror"
	"github.com/nais/api/internal/graph/ident"
	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/pagination"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/team"
)

func GetImageMetadata(ctx context.Context, imageRef string) (*ImageDetails, error) {
	return fromContext(ctx).imageLoader.Load(ctx, imageRef)
}

func GetTeamMetadata(ctx context.Context, teamSlug slug.Slug) ([]*ImageDetails, error) {
	c := fromContext(ctx).dpClient
	projects, err := c.GetMetadataForTeam(ctx, teamSlug.String())
	if err != nil {
		return nil, fmt.Errorf("getting projects by team %s: %w", teamSlug, err)
	}

	if projects == nil {
		return nil, nil
	}

	images := make([]*ImageDetails, 0)
	for _, p := range projects {
		if p == nil {
			continue
		}

		// TODO: Find a better way to filter out these images
		if p.Name == "europe-north1-docker.pkg.dev/nais-io/nais/images/wonderwall" {
			continue
		}

		if p.Name == "europe-north1-docker.pkg.dev/nais-io/nais/images/elector" {
			continue
		}

		image, err := c.GetMetadataForImage(ctx, p.Name)
		if err != nil {
			return nil, fmt.Errorf("getting metadata for image %q: %w", p.Name, err)
		}
		images = append(images, image)
	}

	return images, nil
}

func ListWorkloadReferences(ctx context.Context, image string, page *pagination.Pagination) (*pagination.Connection[*ContainerImageWorkloadReference], error) {
	metadata, err := fromContext(ctx).imageLoader.Load(ctx, image)
	if err != nil {
		return nil, err
	}

	all := metadata.WorkloadReferences
	slice := pagination.Slice(all, page)
	return pagination.NewConvertConnection(slice, page, int32(len(all)), toGraphWorkloadReference), nil
}

func GetTeamRanking(ctx context.Context, teamSlug slug.Slug) (TeamVulnerabilityRanking, error) {
	totalTeams, err := team.Count(ctx)
	if err != nil {
		return TeamVulnerabilityRankingUnknown, fmt.Errorf("counting teams: %w", err)
	}

	currentRank, err := fromContext(ctx).promClients.ranking(ctx, teamSlug.String(), time.Now())
	if err != nil {
		return "", fmt.Errorf("getting team ranking: %w", err)
	}

	// Divide teams into three parts
	upperLimit := int(totalTeams) / 3        // Upper third
	middleLimit := 2 * (int(totalTeams) / 3) // Middle third (everything before bottom third)

	// Determine vulnerability score based on rank
	switch {
	case currentRank == 0:
		return TeamVulnerabilityRankingUnknown, nil
	case currentRank <= upperLimit: // Top third
		return TeamVulnerabilityRankingMostVulnerable, nil
	case currentRank > upperLimit && currentRank <= middleLimit: // Middle third
		return TeamVulnerabilityRankingMiddle, nil
	default: // Bottom third
		return TeamVulnerabilityRankingLeastVulnerable, nil
	}
}

func GetTeamRiskScoreTrend(ctx context.Context, teamSlug slug.Slug) (TeamVulnerabilityRiskScoreTrend, error) {
	current, err := fromContext(ctx).promClients.riskScoreTotal(ctx, teamSlug.String(), time.Now())
	if err != nil {
		return "", fmt.Errorf("getting team risk score: %w", err)
	}
	previous, err := fromContext(ctx).promClients.riskScoreTotal(ctx, teamSlug.String(), time.Now().AddDate(0, 0, -30))
	if err != nil {
		return "", fmt.Errorf("getting team risk score: %w", err)
	}
	switch {
	case current > previous:
		return TeamVulnerabilityRiskScoreTrendUp, nil
	case current < previous:
		return TeamVulnerabilityRiskScoreTrendDown, nil
	default:
		return TeamVulnerabilityRiskScoreTrendFlat, nil
	}
}

func ListImageVulnerabilities(ctx context.Context, ref string, page *pagination.Pagination, order *ImageVulnerabilityOrder) (*ImageVulnerabilityConnection, error) {
	metadata, err := GetImageMetadata(ctx, ref)
	if err != nil {
		return nil, err
	}

	vulns, err := fromContext(ctx).dpClient.GetFindingsForImageByProjectID(ctx, metadata.ProjectID, true)
	if err != nil {
		return nil, err
	}

	if order == nil {
		order = &ImageVulnerabilityOrder{
			Field:     ImageVulnerabilityOrderFieldSeverity,
			Direction: model.OrderDirectionDesc,
		}
	}

	SortFilterImageVulnerabilities.Sort(ctx, vulns, order.Field, order.Direction)

	slice := pagination.Slice(vulns, page)

	return pagination.NewConnection(slice, page, int32(len(vulns))), nil
}

func UpdateImageVulnerability(ctx context.Context, input UpdateImageVulnerabilityInput) (*UpdateImageVulnerabilityPayload, error) {
	projectID, identifier, componentID, err := parseVulnerabilityIdent(input.VulnerabilityID)
	if err != nil {
		return nil, err
	}

	usr := authz.ActorFromContext(ctx)

	err = fromContext(ctx).dpClient.UpdateFinding(ctx, input.AnalysisState.String(), input.Comment, componentID, projectID, identifier, usr.User.Identity(), input.Suppress)
	if err != nil {
		return nil, err
	}

	vuln, err := getVulnerabilityByIdent(ctx, input.VulnerabilityID)
	if err != nil {
		return nil, err
	}

	return &UpdateImageVulnerabilityPayload{
		Vulnerability: vuln,
	}, nil
}

func GetImageAnalysisTrail(ctx context.Context, obj *ImageVulnerability) (*ImageVulnerabilityAnalysisTrail, error) {
	return fromContext(ctx).dpClient.GetAnalysisTrailForImage(ctx, obj.projectID, obj.componentID, obj.Identifier)
}

func getVulnerabilityByIdent(ctx context.Context, id ident.Ident) (*ImageVulnerability, error) {
	projectID, identifier, componentID, err := parseVulnerabilityIdent(id)
	if err != nil {
		return nil, err
	}

	vulns, err := fromContext(ctx).dpClient.GetFindingsForImageByProjectID(ctx, projectID, true)
	if err != nil {
		return nil, err
	}

	for _, v := range vulns {
		if v.Identifier == identifier && v.componentID == componentID {
			return v, nil
		}
	}

	return nil, apierror.Errorf("vulnerability not found")
}

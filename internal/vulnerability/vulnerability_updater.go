package vulnerability

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/api/internal/database"
	"github.com/nais/api/internal/database/gensql"
	"github.com/nais/api/internal/graph"
	"github.com/nais/api/internal/k8s"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/thirdparty/dependencytrack"
	"github.com/sirupsen/logrus"
)

// DependencyTrackHistoricalDate is the date to fetch historical metrics from dependencytrack
// This resembles the date of the first occurrence of vulnerability metrics in the system
const DependencyTrackHistoricalDate = "2023-12-01"

type DependencytrackClient interface {
	graph.DependencytrackClient
	GetProjectMetrics(ctx context.Context, app *dependencytrack.AppInstance, date string) (*dependencytrack.ProjectMetric, error)
}

type Updater struct {
	dpTrackClient DependencytrackClient
	k8sClient     *k8s.Client
	db            database.Database
	log           logrus.FieldLogger
}

func NewMetricUpdater(client *k8s.Client, dpTrackClient DependencytrackClient, db database.Database, log logrus.FieldLogger) *Updater {
	return &Updater{
		dpTrackClient: dpTrackClient,
		k8sClient:     client,
		db:            db,
		log:           log,
	}
}

func projectParams(app *dependencytrack.AppInstance, teamSlug slug.Slug, uuId uuid.UUID) gensql.CreateDependencytrackProjectParams {
	return gensql.CreateDependencytrackProjectParams{
		Environment: app.Env,
		TeamSlug:    teamSlug,
		App:         app.App,
		Projectid:   uuId,
	}
}

func vulnParams(vuln *dependencytrack.VulnerabilityMetrics, date time.Time, uuId uuid.UUID) gensql.VulnerabilityMetricsUpsertParams {
	return gensql.VulnerabilityMetricsUpsertParams{
		Date:                     pgtype.Date{Time: date.UTC(), Valid: true},
		DependencytrackProjectID: uuId,
		Critical:                 int32(vuln.Critical),
		High:                     int32(vuln.High),
		Medium:                   int32(vuln.Medium),
		Low:                      int32(vuln.Low),
		Unassigned:               int32(vuln.Unassigned),
		RiskScore:                float64(vuln.RiskScore),
	}
}

func toDateTime(unixInMilli int64) time.Time {
	return time.Unix(0, unixInMilli*int64(time.Millisecond))
}

func differenceInDaysFrom(firstOccurrenceDate, lastOccurrenceDate time.Time) int64 {
	return int64(lastOccurrenceDate.Sub(firstOccurrenceDate).Hours() / 24)
}

func firstOccurrenceToLastParams(metric *dependencytrack.ProjectMetric, projectID uuid.UUID) []gensql.VulnerabilityMetricsUpsertParams {
	var vulnerabilityMetricsUpsertParams []gensql.VulnerabilityMetricsUpsertParams
	for _, vulnSum := range metric.VulnerabilityMetrics {
		firstOccurrenceDateTime := toDateTime(vulnSum.FirstOccurrence)
		lastOccurrenceDateTime := toDateTime(vulnSum.LastOccurrence)
		daysToUpsert := differenceInDaysFrom(firstOccurrenceDateTime, lastOccurrenceDateTime)
		for i := daysToUpsert + 0; i > 0; i-- {
			vulnerabilityMetricsUpsertParams = append(vulnerabilityMetricsUpsertParams, vulnParams(vulnSum, firstOccurrenceDateTime, projectID))
			firstOccurrenceDateTime = firstOccurrenceDateTime.AddDate(0, 0, 1)
		}
	}
	return vulnerabilityMetricsUpsertParams
}

func dbLastToCurrentTimeParams(metric *dependencytrack.ProjectMetric, dbLastDateTime time.Time, currentTime time.Time, projectID uuid.UUID) []gensql.VulnerabilityMetricsUpsertParams {
	var vulnerabilityMetricsUpsertParams []gensql.VulnerabilityMetricsUpsertParams
	daysToUpsert := differenceInDaysFrom(dbLastDateTime, currentTime)
	currentVulnSum := metric.VulnerabilityMetrics[len(metric.VulnerabilityMetrics)-1]
	if currentVulnSum != nil {
		for i := daysToUpsert + 0; i > 0; i-- {
			dbLastDateTime = dbLastDateTime.AddDate(0, 0, 1)
			vulnerabilityMetricsUpsertParams = append(vulnerabilityMetricsUpsertParams, vulnParams(currentVulnSum, dbLastDateTime, projectID))
		}
	}
	return vulnerabilityMetricsUpsertParams
}

func (u *Updater) vulnerabilityMetricsParams(metric *dependencytrack.ProjectMetric, dbLastDateTime time.Time, currentTime time.Time) []gensql.VulnerabilityMetricsUpsertParams {
	var vulnerabilityMetricsUpsertParams []gensql.VulnerabilityMetricsUpsertParams
	projectID := metric.ProjectID

	// If the last date is not zero, we fetch all metrics from the last occurrence to the current date
	if !dbLastDateTime.IsZero() {
		vulnerabilityMetricsUpsertParams = dbLastToCurrentTimeParams(metric, dbLastDateTime, currentTime, projectID)
		return vulnerabilityMetricsUpsertParams
	}

	// If the last date is zero, we fetch all metrics from the first occurrence to the last occurrence
	vulnerabilityMetricsUpsertParams = firstOccurrenceToLastParams(metric, projectID)
	return vulnerabilityMetricsUpsertParams
}

func setHistoricalDate(date time.Time) string {
	if date.IsZero() {
		return DependencyTrackHistoricalDate
	}
	return date.Format("2006-01-02")
}

func (u *Updater) UpsertBatchParams(ctx context.Context, teamSlug slug.Slug, appInstances []*dependencytrack.AppInstance, currentTime time.Time) ([]gensql.VulnerabilityMetricsUpsertParams, error) {
	var wg sync.WaitGroup
	now := time.Now()
	vulnerabilityMetricsUpsertParams := make([]gensql.VulnerabilityMetricsUpsertParams, 0)
	for _, app := range appInstances {
		wg.Add(1)
		// Go routine to speed up the fetching of metrics
		go func(app *dependencytrack.AppInstance) {
			defer wg.Done() // Decrease the counter when the goroutine completes.

			// Get the max date for the projects vulnerability metrics stored in the database
			projectMaxDate, err := u.db.VulnerabilityMetricsMaxDate(ctx, app.Env, app.App, teamSlug)
			if err != nil {
				u.log.Errorf("getting max date for vulnerability metrics: %v", err)
				return
			}

			// If the max date is not zero, we set the historical date to the max date
			// This is to avoid fetching metrics that are already stored in the database
			historicalDate := setHistoricalDate(projectMaxDate.Time)
			// Get the project metrics for the app from the defined date and up to most recent
			metric, err := u.dpTrackClient.GetProjectMetrics(ctx, app, historicalDate)
			if err != nil {
				u.log.Errorf("getting project metrics for app %s: %v", app.App, err)
			}

			// If no metrics are found, we skip the app
			if metric == nil {
				u.log.Debugf("no metrics found for app %s", app.App)
				return
			}

			err = u.db.CreateDependencytrackProject(ctx, projectParams(app, teamSlug, metric.ProjectID))
			if err != nil {
				u.log.Errorf("creating dependencytrack project for app %s: %v", app.App, err)
				return
			}

			vulnerabilityMetricsUpsertParams = append(
				vulnerabilityMetricsUpsertParams, u.vulnerabilityMetricsParams(metric, projectMaxDate.Time, currentTime)...)
		}(app)
	}
	wg.Wait()
	u.log.WithFields(logrus.Fields{
		"duration": time.Since(now),
	}).Debugf("DependencyTrack fetch of metrics for %d apps", len(appInstances))

	return vulnerabilityMetricsUpsertParams, nil
}

func (u *Updater) getAllAppsFor(ctx context.Context, team string) ([]*dependencytrack.AppInstance, error) {
	apps, err := u.k8sClient.Apps(ctx, team)
	if err != nil {
		return nil, err
	}

	appInstances := make([]*dependencytrack.AppInstance, 0)
	for _, app := range apps {
		appInstances = append(appInstances, &dependencytrack.AppInstance{
			Env:   app.Env.Name,
			Team:  team,
			App:   app.Name,
			Image: app.Image,
		})
	}
	return appInstances, nil
}

func (u *Updater) UpdateVulnerabilityMetrics(ctx context.Context) (int, error) {
	// Get all teams
	teams, err := u.db.GetActiveTeams(ctx)
	if err != nil {
		return 0, err
	}

	results := 0
	batchErrors := 0
	for _, team := range teams {
		log := u.log.WithField("team", team.Slug)
		appInstances, err := u.getAllAppsFor(ctx, team.Slug.String())
		if err != nil {
			return 0, fmt.Errorf("getting getAllAppsFor for team %s: %v", team.Slug, err)
		}

		log = log.WithField("num_apps", len(appInstances))
		batch, err := u.UpsertBatchParams(ctx, team.Slug, appInstances, time.Now())
		if err != nil {
			u.log.Errorf("creating upsert batch for team %s: %v", team.Slug, err)
			batchErrors++
		}
		vulnUpsert := u.db.VulnerabilityMetricsUpsert(ctx, batch)
		if vulnUpsert == nil {
			u.log.Warn("upsert metrics response is null")
			return results, nil
		}
		vulnUpsert.Exec(func(i int, err error) {
			if err != nil {
				u.log.Errorf("updating vulnerability metrics for team %s: %v", team.Slug, err)
				batchErrors++
			}
		})
		log.WithFields(logrus.Fields{
			"num_rows":   len(batch),
			"num_errors": batchErrors,
		}).Debugf("batch upsert")
		results += len(batch) - batchErrors
	}
	return results, nil
}

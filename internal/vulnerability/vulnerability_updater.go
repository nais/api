package vulnerability

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/api/internal/database"
	"github.com/nais/api/internal/database/gensql"
	"github.com/nais/api/internal/graph"
	"github.com/nais/api/internal/k8s"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/thirdparty/dependencytrack"
	"github.com/sirupsen/logrus"
	"github.com/sourcegraph/conc/pool"
)

// DependencyTrackHistoricalDate is the date to fetch historical metrics from dependencytrack
// This resembles the date of the first occurrence of vulnerability metrics in the system
const DependencyTrackHistoricalDate = "2023-12-01"

type DependencytrackClient interface {
	graph.DependencytrackClient
	GetProjectMetrics(ctx context.Context, instance *dependencytrack.WorkloadInstance, date string) (*dependencytrack.ProjectMetric, error)
}

type Updater struct {
	dpTrackClient DependencytrackClient
	k8sClient     *k8s.Client
	db            database.Database
	log           logrus.FieldLogger
}

func NewMetricUpdater(client *k8s.Client, dpTrackClient DependencytrackClient, db database.Database, log logrus.FieldLogger) *Updater {
	return &Updater{
		dpTrackClient: dpTrackClient,
		k8sClient:     client,
		db:            db,
		log:           log,
	}
}

func projectParams(instance *dependencytrack.WorkloadInstance, teamSlug slug.Slug, id uuid.UUID) gensql.CreateDependencytrackProjectParams {
	var workloadType gensql.WorkloadType
	switch instance.Kind {
	case "app":
		workloadType = gensql.WorkloadTypeApp
	case "job":
		workloadType = gensql.WorkloadTypeNaisjob
	default:
		panic(fmt.Sprintf("unknown workload type: %s", instance.Kind))
	}

	return gensql.CreateDependencytrackProjectParams{
		Environment:  instance.Env,
		TeamSlug:     teamSlug,
		Workload:     instance.Name,
		ID:           id,
		WorkloadType: workloadType,
	}
}

func vulnParams(vuln *dependencytrack.VulnerabilityMetrics, date time.Time, id uuid.UUID) gensql.VulnerabilityMetricsUpsertParams {
	return gensql.VulnerabilityMetricsUpsertParams{
		Date:                     pgtype.Date{Time: date.UTC(), Valid: true},
		DependencytrackProjectID: id,
		Critical:                 int32(vuln.Critical),
		High:                     int32(vuln.High),
		Medium:                   int32(vuln.Medium),
		Low:                      int32(vuln.Low),
		Unassigned:               int32(vuln.Unassigned),
		RiskScore:                float64(vuln.RiskScore),
	}
}

func toDateTime(unixInMilli int64) time.Time {
	return time.Unix(0, unixInMilli*int64(time.Millisecond))
}

func differenceInDaysFrom(firstOccurrenceDate, lastOccurrenceDate time.Time) int64 {
	return int64(lastOccurrenceDate.Sub(firstOccurrenceDate).Hours() / 24)
}

func firstOccurrenceToLastParams(metric *dependencytrack.ProjectMetric, projectID uuid.UUID) []gensql.VulnerabilityMetricsUpsertParams {
	var vulnerabilityMetricsUpsertParams []gensql.VulnerabilityMetricsUpsertParams
	for _, vulnSum := range metric.VulnerabilityMetrics {
		firstOccurrenceDateTime := toDateTime(vulnSum.FirstOccurrence)
		lastOccurrenceDateTime := toDateTime(vulnSum.LastOccurrence)
		daysToUpsert := differenceInDaysFrom(firstOccurrenceDateTime, lastOccurrenceDateTime)
		for i := daysToUpsert + 0; i > 0; i-- {
			vulnerabilityMetricsUpsertParams = append(vulnerabilityMetricsUpsertParams, vulnParams(vulnSum, firstOccurrenceDateTime, projectID))
			firstOccurrenceDateTime = firstOccurrenceDateTime.AddDate(0, 0, 1)
		}
	}
	return vulnerabilityMetricsUpsertParams
}

func dbLastToCurrentTimeParams(metric *dependencytrack.ProjectMetric, dbLastDateTime time.Time, currentTime time.Time, projectID uuid.UUID) []gensql.VulnerabilityMetricsUpsertParams {
	var vulnerabilityMetricsUpsertParams []gensql.VulnerabilityMetricsUpsertParams
	daysToUpsert := differenceInDaysFrom(dbLastDateTime, currentTime)

	if len(metric.VulnerabilityMetrics) == 0 {
		return vulnerabilityMetricsUpsertParams
	}

	currentVulnSum := metric.VulnerabilityMetrics[len(metric.VulnerabilityMetrics)-1]
	if currentVulnSum != nil {
		for i := daysToUpsert + 0; i > 0; i-- {
			dbLastDateTime = dbLastDateTime.AddDate(0, 0, 1)
			vulnerabilityMetricsUpsertParams = append(vulnerabilityMetricsUpsertParams, vulnParams(currentVulnSum, dbLastDateTime, projectID))
		}
	}
	return vulnerabilityMetricsUpsertParams
}

func (u *Updater) vulnerabilityMetricsParams(metric *dependencytrack.ProjectMetric, dbLastDateTime time.Time, currentTime time.Time) []gensql.VulnerabilityMetricsUpsertParams {
	var vulnerabilityMetricsUpsertParams []gensql.VulnerabilityMetricsUpsertParams
	projectID := metric.ProjectID

	// If the last date is not zero, we fetch all metrics from the last occurrence to the current date
	if !dbLastDateTime.IsZero() {
		vulnerabilityMetricsUpsertParams = dbLastToCurrentTimeParams(metric, dbLastDateTime, currentTime, projectID)
		return vulnerabilityMetricsUpsertParams
	}

	// If the last date is zero, we fetch all metrics from the first occurrence to the last occurrence
	vulnerabilityMetricsUpsertParams = firstOccurrenceToLastParams(metric, projectID)
	return vulnerabilityMetricsUpsertParams
}

func setHistoricalDate(date time.Time) string {
	if date.IsZero() {
		return DependencyTrackHistoricalDate
	}
	return date.Format("2006-01-02")
}

func (u *Updater) UpsertBatchParams(ctx context.Context, teamSlug slug.Slug, instances []*dependencytrack.WorkloadInstance, currentTime time.Time) ([]gensql.VulnerabilityMetricsUpsertParams, error) {
	vulnerabilityMetricsUpsertParams := make([]gensql.VulnerabilityMetricsUpsertParams, 0)
	p := pool.New().WithMaxGoroutines(10)
	for _, instance := range instances {
		// Go routine to speed up the fetching of metrics
		p.Go(func() {
			params := u.handle(ctx, instance, teamSlug, currentTime)
			vulnerabilityMetricsUpsertParams = append(vulnerabilityMetricsUpsertParams, params...)
		})
	}
	p.Wait()
	u.log.WithFields(logrus.Fields{
		"duration": time.Since(currentTime),
	}).Debugf("DependencyTrack fetch of metrics for %d instances", len(instances))

	return vulnerabilityMetricsUpsertParams, nil
}

func (u *Updater) handle(ctx context.Context, instance *dependencytrack.WorkloadInstance, teamSlug slug.Slug, now time.Time) []gensql.VulnerabilityMetricsUpsertParams {
	var workloadType gensql.WorkloadType
	switch instance.Kind {
	case "app":
		workloadType = gensql.WorkloadTypeApp
	case "job":
		workloadType = gensql.WorkloadTypeNaisjob
	default:
		panic(fmt.Sprintf("unknown workload type: %s", instance.Kind))
	}

	// Get the max date for the projects vulnerability metrics stored in the database
	projectMaxDate, err := u.db.VulnerabilityMetricsMaxDate(ctx, instance.Env, instance.Name, workloadType, teamSlug)
	if err != nil {
		u.log.Errorf("getting max date for vulnerability metrics: %v", err)
		return []gensql.VulnerabilityMetricsUpsertParams{}
	}

	// If the max date is not zero, we set the historical date to the max date
	// This is to avoid fetching metrics that are already stored in the database
	historicalDate := setHistoricalDate(projectMaxDate.Time)
	// Get the project metrics for the workload from the defined date and up to most recent
	metric, err := u.dpTrackClient.GetProjectMetrics(ctx, instance, historicalDate)
	if err != nil {
		u.log.Errorf("getting project metrics for workload %s: %v", instance.Name, err)
	}

	// If no metrics are found, we skip the workload
	if metric == nil {
		u.log.Debugf("no metrics found for workload %s", instance.Name)
		return []gensql.VulnerabilityMetricsUpsertParams{}
	}

	err = u.db.CreateDependencytrackProject(ctx, projectParams(instance, teamSlug, metric.ProjectID))
	if err != nil {
		u.log.Errorf("creating dependencytrack project for workload %s: %v", instance.Name, err)
		return []gensql.VulnerabilityMetricsUpsertParams{}
	}

	return u.vulnerabilityMetricsParams(metric, projectMaxDate.Time, now)
}

func (u *Updater) getAllWorkloadInstances(ctx context.Context, team string) ([]*dependencytrack.WorkloadInstance, error) {
	apps, err := u.k8sClient.Apps(ctx, team)
	if err != nil {
		return nil, err
	}
	jobs, err := u.k8sClient.NaisJobs(ctx, team)
	if err != nil {
		return nil, err
	}

	workloadInstances := make([]*dependencytrack.WorkloadInstance, 0)
	for _, app := range apps {
		workloadInstances = append(workloadInstances, &dependencytrack.WorkloadInstance{
			Env:   app.Env.Name,
			Team:  team,
			Name:  app.Name,
			Image: app.Image,
			Kind:  "app",
		})
	}
	for _, job := range jobs {
		workloadInstances = append(workloadInstances, &dependencytrack.WorkloadInstance{
			Env:   job.Env.Name,
			Team:  team,
			Name:  job.Name,
			Image: job.Image,
			Kind:  "job",
		})
	}

	return workloadInstances, nil
}

func (u *Updater) UpdateVulnerabilityMetrics(ctx context.Context) (int, error) {
	// Get all teams
	teams, err := u.db.GetTeams(ctx)
	if err != nil {
		return 0, err
	}

	results := 0
	batchErrors := 0
	for _, team := range teams {
		log := u.log.WithField("team", team.Slug)
		workloadInstances, err := u.getAllWorkloadInstances(ctx, team.Slug.String())
		if err != nil {
			return 0, fmt.Errorf("getting getAllWorkloadInstances for team %s: %w", team.Slug, err)
		}

		log = log.WithField("num_apps", len(workloadInstances))
		batch, err := u.UpsertBatchParams(ctx, team.Slug, workloadInstances, time.Now())
		if err != nil {
			log.WithError(err).Errorf("creating upsert batch")
			batchErrors++
		}
		vulnUpsert := u.db.VulnerabilityMetricsUpsert(ctx, batch)
		if vulnUpsert == nil {
			log.Warn("upsert metrics response is null")
			return results, nil
		}
		vulnUpsert.Exec(func(i int, err error) {
			if err != nil {
				log.WithError(err).Errorf("updating vulnerability metrics for team")
				batchErrors++
			}
		})
		log.WithFields(logrus.Fields{
			"num_rows":   len(batch),
			"num_errors": batchErrors,
		}).Debugf("batch upsert")
		results += len(batch) - batchErrors
	}
	return results, nil
}

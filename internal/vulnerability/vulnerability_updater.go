package vulnerability

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/api/internal/database"
	"github.com/nais/api/internal/database/gensql"
	"github.com/nais/api/internal/graph"
	"github.com/nais/api/internal/k8s"
	"github.com/nais/api/internal/slug"
	"github.com/nais/api/internal/thirdparty/dependencytrack"
	"github.com/sirupsen/logrus"
)

type DependencytrackClient interface {
	graph.DependencytrackClient
	GetProjectMetric(ctx context.Context, app *dependencytrack.AppInstance) (*dependencytrack.ProjectMetric, error)
}

type Updater struct {
	dpTrackClient DependencytrackClient
	k8sClient     *k8s.Client
	db            database.Database
	log           logrus.FieldLogger
}

func NewMetricUpdater(client *k8s.Client, dpTrackClient DependencytrackClient, db database.Database, log logrus.FieldLogger) *Updater {
	return &Updater{
		dpTrackClient: dpTrackClient,
		k8sClient:     client,
		db:            db,
		log:           log,
	}
}

func (u *Updater) UpdateVulnerabilityMetrics(ctx context.Context) (int, error) {
	// Get all teams
	teams, err := u.db.GetActiveTeams(ctx)
	if err != nil {
		return 0, err
	}

	results := 0
	batchErrors := 0
	for _, team := range teams {
		log := u.log.WithField("team", team.Slug)
		appInstances, err := u.getApps(ctx, team.Slug.String())
		if err != nil {
			return 0, fmt.Errorf("getting getApps for team %s: %v", team.Slug, err)
		}

		log = log.WithField("num_apps", len(appInstances))
		batch, err := u.UpsertBatchParams(ctx, team.Slug, appInstances)
		if err != nil {
			u.log.Errorf("creating upsert batch for team %s: %v", team.Slug, err)
			batchErrors++
		}
		u.db.VulnerabilityMetricsUpsert(ctx, batch).Exec(func(i int, err error) {
			if err != nil {
				u.log.Errorf("updating vulnerability metrics for team %s: %v", team.Slug, err)
				batchErrors++
			}
		})
		log.WithFields(logrus.Fields{
			"num_rows":   len(batch),
			"num_errors": batchErrors,
		}).Debugf("batch upsert")
		results += len(batch) - batchErrors
	}
	return results, nil
}

func (u *Updater) getApps(ctx context.Context, team string) ([]*dependencytrack.AppInstance, error) {
	apps, err := u.k8sClient.Apps(ctx, team)
	if err != nil {
		return nil, err
	}

	appInstances := make([]*dependencytrack.AppInstance, 0)
	for _, app := range apps {
		appInstances = append(appInstances, &dependencytrack.AppInstance{
			Env:   app.Env.Name,
			Team:  team,
			App:   app.Name,
			Image: app.Image,
		})
	}
	return appInstances, nil
}

func (u *Updater) UpsertBatchParams(ctx context.Context, teamSlug slug.Slug, appInstances []*dependencytrack.AppInstance) ([]gensql.VulnerabilityMetricsUpsertParams, error) {
	var wg sync.WaitGroup
	now := time.Now()
	vulnerabilityMetricsUpsertParams := make([]gensql.VulnerabilityMetricsUpsertParams, 0)
	for _, app := range appInstances {
		wg.Add(1)
		go func(app *dependencytrack.AppInstance) {
			defer wg.Done() // Decrease the counter when the goroutine completes.
			metrics, err := u.dpTrackClient.GetProjectMetric(ctx, app)
			if err != nil {
				u.log.Errorf("getting project metrics for app %s: %v", app.App, err)
			}

			if metrics == nil {
				u.log.Debugf("no metrics found for app %s", app.App)
				return
			}

			uuId, err := metrics.ProjectID.AsUUID()
			if err != nil {
				u.log.Errorf("parsing project id %s: %v", metrics.ProjectID, err)
				return
			}

			dependencytrackProjectParams := gensql.CreateDependencytrackProjectParams{
				Environment: app.Env,
				TeamSlug:    teamSlug,
				App:         app.App,
				Projectid:   uuId,
			}
			err = u.db.CreateDependencytrackProject(ctx, dependencytrackProjectParams)
			if err != nil {
				u.log.Errorf("creating dependencytrack project for app %s: %v", app.App, err)
				return
			}

			vulnerabilityMetricsUpsertParams = append(vulnerabilityMetricsUpsertParams, gensql.VulnerabilityMetricsUpsertParams{
				Date:                     pgtype.Date{Time: time.Now().UTC(), Valid: true},
				DependencytrackProjectID: uuId,
				High:                     int32(metrics.VulnerabilitySummary.High),
				Medium:                   int32(metrics.VulnerabilitySummary.Medium),
				Low:                      int32(metrics.VulnerabilitySummary.Low),
				Critical:                 int32(metrics.VulnerabilitySummary.Critical),
				RiskScore:                float64(metrics.VulnerabilitySummary.RiskScore),
			})
		}(app)
	}
	wg.Wait()
	u.log.WithFields(logrus.Fields{
		"duration": time.Since(now),
	}).Debugf("DependencyTrack fetch of metrics for %d apps", len(appInstances))

	return vulnerabilityMetricsUpsertParams, nil
}

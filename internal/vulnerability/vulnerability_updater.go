package vulnerability

import (
	"context"
	"fmt"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/api/internal/database"
	"github.com/nais/api/internal/database/gensql"
	"github.com/nais/api/internal/graph"
	"github.com/nais/api/internal/k8s"
	"github.com/nais/api/internal/thirdparty/dependencytrack"
	"github.com/sirupsen/logrus"
	"time"
)

type Updater struct {
	dpTrackClient graph.DependencytrackClient
	k8sClient     *k8s.Client
	db            database.Database
	log           logrus.FieldLogger
}

func NewMetricUpdater(client *k8s.Client, dpTrackClient graph.DependencytrackClient, db database.Database, log logrus.FieldLogger) *Updater {
	return &Updater{
		dpTrackClient: dpTrackClient,
		k8sClient:     client,
		db:            db,
		log:           log,
	}
}

func (u *Updater) UpdateVulnerabilityMetrics(ctx context.Context) (int, error) {
	// Get all teams
	teams, err := u.db.GetActiveTeams(ctx)
	if err != nil {
		return 0, err
	}

	for _, team := range teams {
		apps, err := u.k8sClient.Apps(ctx, team.Slug.String())
		if err != nil {
			return 0, err
		}

		appInstances := make([]*dependencytrack.AppInstance, len(apps))
		for _, app := range apps {
			appInstances = append(appInstances, &dependencytrack.AppInstance{
				Env:   app.Env.Name,
				Team:  team.Slug.String(),
				App:   app.Name,
				Image: app.Image,
			})
		}

		args := make([]gensql.VulnerabilityMetricsUpsertParams, len(appInstances))
		for _, app := range appInstances {
			metrics, err := u.dpTrackClient.GetProjectMetrics(ctx, app)
			if err != nil {
				return 0, err
			}

			uuId, err := uuid.Parse(metrics.ProjectID)
			if err != nil {
				return 0, err
			}
			err = u.db.CreateDependencytrackProject(ctx, app.Env, team.Slug, app.App, uuId)
			if err != nil {
				return 0, err
			}

			args = append(args, gensql.VulnerabilityMetricsUpsertParams{
				Date:                     pgtype.Date{Time: time.Now()},
				DependencytrackProjectID: uuId,
				High:                     int32(metrics.VulnerabilitySummary.High),
				Medium:                   int32(metrics.VulnerabilitySummary.Medium),
				Low:                      int32(metrics.VulnerabilitySummary.Low),
				Critical:                 int32(metrics.VulnerabilitySummary.Critical),
				RiskScore:                float64(metrics.VulnerabilitySummary.RiskScore),
			})
		}

		result, err := u.db.VulnerabilityMetricsUpsert(ctx, args)
		fmt.Println(result, err)
	}

	return 0, nil
}

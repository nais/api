package fake

import (
	"context"
	"math"
	"strings"
	"sync"
	"time"

	"github.com/nais/api/internal/graph/model"
	"github.com/nais/api/internal/graph/sortfilter"
	"github.com/nais/v13s/pkg/api/vulnerabilities"
	"github.com/nais/v13s/pkg/api/vulnerabilities/management"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/types/known/timestamppb"
)

var _ vulnerabilities.Client = (*fakeVulnerabilitiesClient)(nil)

type fakeVulnerabilitiesClient struct {
	once     sync.Once
	fakeData *fakeData
}

var vulnSorter = sortfilter.New[*vulnerabilities.Vulnerability, string, struct{}]()

func init() {
	registerSorters()
}

func NewFakeVulnerabilitiesClient() vulnerabilities.Client {
	return &fakeVulnerabilitiesClient{}
}

func (f *fakeVulnerabilitiesClient) createFakeDataIfNotSet(ctx context.Context) {
	f.once.Do(func() {
		f.fakeData = createFakeData(ctx)
	})
}

func (f *fakeVulnerabilitiesClient) ListVulnerabilities(ctx context.Context, opts ...vulnerabilities.Option) (*vulnerabilities.ListVulnerabilitiesResponse, error) {
	f.createFakeDataIfNotSet(ctx)
	return &vulnerabilities.ListVulnerabilitiesResponse{}, nil
}

func (f *fakeVulnerabilitiesClient) ListVulnerabilitiesForImage(ctx context.Context, imageName, imageTag string, opts ...vulnerabilities.Option) (*vulnerabilities.ListVulnerabilitiesForImageResponse, error) {
	f.createFakeDataIfNotSet(ctx)
	orderBy := vulnerabilities.GetOrderBy(opts...)

	direction := model.OrderDirectionAsc
	if orderBy.GetDirection() == vulnerabilities.Direction_DESC {
		direction = model.OrderDirectionDesc
	}
	vulnz := f.vulnerabilitiesFor(imageName, imageTag)
	vulnSorter.Sort(ctx, vulnz, orderBy.Field, direction)

	vulnz, pageInfo := paginate(vulnz, opts)

	return &vulnerabilities.ListVulnerabilitiesForImageResponse{
		Nodes:    vulnz,
		PageInfo: pageInfo,
	}, nil
}

func (f *fakeVulnerabilitiesClient) ListSuppressedVulnerabilities(ctx context.Context, opts ...vulnerabilities.Option) (*vulnerabilities.ListSuppressedVulnerabilitiesResponse, error) {
	f.createFakeDataIfNotSet(ctx)
	return &vulnerabilities.ListSuppressedVulnerabilitiesResponse{}, nil
}

func (f *fakeVulnerabilitiesClient) ListVulnerabilitySummaries(ctx context.Context, opts ...vulnerabilities.Option) (*vulnerabilities.ListVulnerabilitySummariesResponse, error) {
	f.createFakeDataIfNotSet(ctx)
	filter := vulnerabilities.GetFilter(opts...)
	nodes := make([]*vulnerabilities.WorkloadSummary, 0)
	for _, s := range f.fakeData.workloadSummaries {
		if filter != nil && filter.Namespace != nil && s.Workload.Namespace == *filter.Namespace {
			nodes = append(nodes, s)
		}
	}
	nodes, pageInfo := paginate(nodes, opts)

	return &vulnerabilities.ListVulnerabilitySummariesResponse{
		Nodes:    nodes,
		PageInfo: pageInfo,
	}, nil
}

func (f *fakeVulnerabilitiesClient) GetVulnerabilitySummary(ctx context.Context, opts ...vulnerabilities.Option) (*vulnerabilities.GetVulnerabilitySummaryResponse, error) {
	f.createFakeDataIfNotSet(ctx)
	filter := vulnerabilities.GetFilter(opts...)

	resp := &vulnerabilities.GetVulnerabilitySummaryResponse{
		Filter:               filter,
		VulnerabilitySummary: &vulnerabilities.Summary{},
		SbomCount:            0,
		WorkloadCount:        0,
		Coverage:             0.0,
	}

	for _, s := range f.fakeData.workloadSummaries {
		resp.VulnerabilitySummary.Critical += s.VulnerabilitySummary.Critical
		resp.VulnerabilitySummary.High += s.VulnerabilitySummary.High
		resp.VulnerabilitySummary.Medium += s.VulnerabilitySummary.Medium
		resp.VulnerabilitySummary.Low += s.VulnerabilitySummary.Low
		resp.VulnerabilitySummary.Unassigned += s.VulnerabilitySummary.Unassigned
		resp.VulnerabilitySummary.Total += s.VulnerabilitySummary.Total
		resp.VulnerabilitySummary.RiskScore += s.VulnerabilitySummary.RiskScore
		if s.VulnerabilitySummary.HasSbom {
			resp.SbomCount += 1
		}
		resp.WorkloadCount += 1
	}
	resp.Coverage = float32(resp.SbomCount) / float32(resp.WorkloadCount) * 100

	return resp, nil
}

func (f *fakeVulnerabilitiesClient) GetVulnerabilitySummaryForImage(ctx context.Context, imageName, imageTag string) (*vulnerabilities.GetVulnerabilitySummaryForImageResponse, error) {
	f.createFakeDataIfNotSet(ctx)
	summary := &vulnerabilities.Summary{}
	workloadRefs := make([]*vulnerabilities.Workload, 0)
	for _, s := range f.fakeData.workloadSummaries {
		if s.Workload.ImageName == imageName && s.Workload.ImageTag == imageTag {
			summary = s.VulnerabilitySummary
			workloadRefs = append(workloadRefs, s.Workload)
		}
	}
	return &vulnerabilities.GetVulnerabilitySummaryForImageResponse{
		VulnerabilitySummary: summary,
		WorkloadRef:          workloadRefs,
	}, nil
}

func (f *fakeVulnerabilitiesClient) GetVulnerabilityById(ctx context.Context, id string) (*vulnerabilities.GetVulnerabilityByIdResponse, error) {
	f.createFakeDataIfNotSet(ctx)
	return &vulnerabilities.GetVulnerabilityByIdResponse{}, nil
}

func (f *fakeVulnerabilitiesClient) GetVulnerabilitySummaryTimeSeries(ctx context.Context, opts ...vulnerabilities.Option) (*vulnerabilities.GetVulnerabilitySummaryTimeSeriesResponse, error) {
	f.createFakeDataIfNotSet(ctx)
	resp := &vulnerabilities.GetVulnerabilitySummaryTimeSeriesResponse{
		Points: []*vulnerabilities.VulnerabilitySummaryPoint{
			{
				Total:      1,
				Critical:   1,
				High:       1,
				Medium:     1,
				Low:        1,
				Unassigned: 1,
				BucketTime: timestamppb.New(time.Now()),
			},
		},
	}
	return resp, nil
}

func (f *fakeVulnerabilitiesClient) SuppressVulnerability(ctx context.Context, id, reason, suppressedBy string, state vulnerabilities.SuppressState, suppress bool) error {
	f.createFakeDataIfNotSet(ctx)
	return nil
}

func (f *fakeVulnerabilitiesClient) RegisterWorkload(_ context.Context, in *management.RegisterWorkloadRequest, opts ...grpc.CallOption) (*management.RegisterWorkloadResponse, error) {
	return &management.RegisterWorkloadResponse{}, nil
}

func (f *fakeVulnerabilitiesClient) TriggerSync(_ context.Context, in *management.TriggerSyncRequest, opts ...grpc.CallOption) (*management.TriggerSyncResponse, error) {
	return &management.TriggerSyncResponse{}, nil
}

func (f *fakeVulnerabilitiesClient) Close() error {
	return nil
}

func (f *fakeVulnerabilitiesClient) vulnerabilitiesFor(imageName, imageTag string) []*vulnerabilities.Vulnerability {
	return f.fakeData.imageVulnerabilities[imageName+":"+imageTag]
}

func registerSorters() {
	vulnSorter.RegisterSort(vulnerabilities.OrderBySeverity.String(), func(ctx context.Context, a, b *vulnerabilities.Vulnerability) int {
		return int(a.Cve.Severity - b.Cve.Severity)
	}, vulnerabilities.OrderByPackage.String(), vulnerabilities.OrderByCveId.String(), vulnerabilities.OrderBySuppressed.String(), vulnerabilities.OrderByReason.String())
	vulnSorter.RegisterSort(vulnerabilities.OrderByPackage.String(), func(ctx context.Context, a, b *vulnerabilities.Vulnerability) int {
		return strings.Compare(a.Package, b.Package)
	}, vulnerabilities.OrderBySeverity.String(), vulnerabilities.OrderByCveId.String(), vulnerabilities.OrderBySuppressed.String(), vulnerabilities.OrderByReason.String())
	vulnSorter.RegisterSort(vulnerabilities.OrderByCveId.String(), func(ctx context.Context, a, b *vulnerabilities.Vulnerability) int {
		return strings.Compare(a.Cve.Id, b.Cve.Id)
	}, vulnerabilities.OrderBySeverity.String(), vulnerabilities.OrderByPackage.String(), vulnerabilities.OrderBySuppressed.String(), vulnerabilities.OrderByReason.String())
	vulnSorter.RegisterSort(vulnerabilities.OrderBySuppressed.String(), func(ctx context.Context, a, b *vulnerabilities.Vulnerability) int {
		if a.Suppression != nil && b.Suppression == nil {
			return -1
		} else if a.Suppression == nil && b.Suppression != nil {
			return 1
		}
		return 0
	}, vulnerabilities.OrderBySeverity.String(), vulnerabilities.OrderByPackage.String(), vulnerabilities.OrderByCveId.String(), vulnerabilities.OrderByReason.String())
	vulnSorter.RegisterSort(vulnerabilities.OrderByReason.String(), func(ctx context.Context, a, b *vulnerabilities.Vulnerability) int {
		if a.Suppression != nil && b.Suppression != nil {
			return strings.Compare(a.Suppression.SuppressedReason.String(), b.Suppression.SuppressedReason.String())
		}
		return 0
	}, vulnerabilities.OrderBySeverity.String(), vulnerabilities.OrderByPackage.String(), vulnerabilities.OrderByCveId.String(), vulnerabilities.OrderBySuppressed.String())
}

func paginate[T any](items []T, opts []vulnerabilities.Option) ([]T, *vulnerabilities.PageInfo) {
	limit := vulnerabilities.GetLimit(opts...)
	offset := vulnerabilities.GetOffset(opts...)
	if limit <= 0 {
		limit = 10
	}

	total := safeInt32(len(items))

	if offset > total {
		return []T{}, nil
	}

	end := offset + limit
	if end > total {
		end = total
	}

	pageInfo := &vulnerabilities.PageInfo{
		TotalCount:      int64(total),
		HasNextPage:     int(offset)+int(limit) < int(total),
		HasPreviousPage: offset > 0,
	}

	return items[offset:end], pageInfo
}

func safeInt32(i int) int32 {
	if i > math.MaxInt32 || i < math.MinInt32 {
		return 0
	}
	return int32(i)
}

package fake

import (
	"context"
	"sort"
	"strings"
	"time"

	promv1 "github.com/prometheus/client_golang/api/prometheus/v1"
	"github.com/prometheus/common/model"
)

type FakePrometheusClient struct {
	fakeData *fakeData
}

func NewFakePrometheusClient() *FakePrometheusClient {
	return &FakePrometheusClient{}
}

func (f *FakePrometheusClient) createFakeDataIfNotSet(ctx context.Context) {
	if f.fakeData == nil {
		f.fakeData = createFakeData(ctx)
	}
}

func (f *FakePrometheusClient) Query(ctx context.Context, query string, _ time.Time, _ ...promv1.Option) (model.Value, promv1.Warnings, error) {
	f.createFakeDataIfNotSet(ctx)
	// Stores aggregated risk scores per team
	teamRiskScores := make(map[string]float64)

	for _, p := range f.fakeData.workloadSummaries {
		team := p.Workload.Namespace
		if strings.Contains(query, "slsa_workload_riskscore") {
			teamRiskScores[team] += float64(p.VulnerabilitySummary.RiskScore)
		}
	}

	val := model.Vector{}
	for teamName, riskScore := range teamRiskScores {
		val = append(val, &model.Sample{
			Metric: model.Metric{
				"workload_namespace": model.LabelValue(teamName),
			},
			Value:     model.SampleValue(riskScore),
			Timestamp: 1234567,
		})
	}

	// Sort the results by risk score (descending order)
	sort.Slice(val, func(i, j int) bool {
		return val[i].Value > val[j].Value
	})

	return val, nil, nil
}

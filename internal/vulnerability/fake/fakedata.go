package fake

import (
	"context"
	"fmt"
	"math/rand/v2"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/nais/api/internal/team"
	"github.com/nais/api/internal/workload/application"
	"github.com/nais/api/internal/workload/job"
	"github.com/nais/v13s/pkg/api/vulnerabilities"
	log "github.com/sirupsen/logrus"
	"google.golang.org/protobuf/types/known/timestamppb"
)

type fakeData struct {
	workloadSummaries    []*vulnerabilities.WorkloadSummary
	imageVulnerabilities imageVulnerabilities
}

type imageVulnerabilities map[string][]*vulnerabilities.Vulnerability

func createFakeData(ctx context.Context) *fakeData {
	summaries := make([]*vulnerabilities.WorkloadSummary, 0)
	vulnz := map[string][]*vulnerabilities.Vulnerability{}

	slugs, err := team.ListAllSlugs(ctx)
	if err != nil {
		log.Fatalf("list all slugs: %v", err)
	}

	apps := make([]*application.Application, 0)
	jobs := make([]*job.Job, 0)
	for _, slug := range slugs {
		apps = append(apps, application.ListAllForTeam(ctx, slug, nil, nil)...)
		jobs = append(jobs, job.ListAllForTeam(ctx, slug, nil, nil)...)
	}

	i := int32(0)
	for _, app := range apps {
		sum := createWorkloadSummary(
			app.EnvironmentName,
			app.GetTeamSlug().String(),
			"app",
			app.Name,
			app.ImageString,
			i,
		)
		i += 1
		summaries = append(summaries, sum)
		vulnz[app.ImageString] = createVulnerabilities(sum)
	}

	for _, job := range jobs {
		sum := createWorkloadSummary(
			job.EnvironmentName,
			job.GetTeamSlug().String(),
			"job",
			job.Name,
			job.ImageString,
			i,
		)
		i += 1
		summaries = append(summaries, sum)
		vulnz[job.ImageString] = createVulnerabilities(sum)
	}

	return &fakeData{
		workloadSummaries:    summaries,
		imageVulnerabilities: vulnz,
	}
}

func createWorkloadSummary(env, team, workloadType, name, image string, vulnFactor int32) *vulnerabilities.WorkloadSummary {
	parts := strings.Split(image, ":")
	imageName := parts[0]
	imageTag := parts[1]
	summary := &vulnerabilities.Summary{
		Critical:    vulnFactor,
		High:        vulnFactor * 2,
		Medium:      vulnFactor + 2,
		Low:         vulnFactor + 1,
		Unassigned:  vulnFactor,
		Total:       vulnFactor + (vulnFactor * 2) + (vulnFactor + 2) + (vulnFactor + 1) + vulnFactor,
		RiskScore:   vulnFactor*10 + (vulnFactor*2)*5 + (vulnFactor+2)*3 + (vulnFactor + 1) + vulnFactor*5,
		HasSbom:     true,
		LastUpdated: timestamppb.New(time.Now()),
	}

	if name == "no-errors" {
		summary = &vulnerabilities.Summary{
			Critical:    0,
			High:        0,
			Medium:      0,
			Low:         0,
			Unassigned:  0,
			Total:       0,
			RiskScore:   0,
			HasSbom:     true,
			LastUpdated: timestamppb.New(time.Now()),
		}
	}

	return &vulnerabilities.WorkloadSummary{
		Id: uuid.New().String(),
		Workload: &vulnerabilities.Workload{
			Cluster:   env,
			Namespace: team,
			Type:      workloadType,
			Name:      name,
			ImageName: imageName,
			ImageTag:  imageTag,
		},
		VulnerabilitySummary: summary,
	}
}

func createVulnerabilities(w *vulnerabilities.WorkloadSummary) []*vulnerabilities.Vulnerability {
	findings := make([]*vulnerabilities.Vulnerability, 0)
	for i := range w.VulnerabilitySummary.Critical {
		findings = append(findings, createVulnerability(vulnerabilities.Severity_CRITICAL, fmt.Sprintf("some-component-%d", i)))
	}
	for i := range w.VulnerabilitySummary.High {
		findings = append(findings, createVulnerability(vulnerabilities.Severity_HIGH, fmt.Sprintf("some-component-%d", i)))
	}
	for i := range w.VulnerabilitySummary.Medium {
		findings = append(findings, createVulnerability(vulnerabilities.Severity_MEDIUM, fmt.Sprintf("some-component-%d", i)))
	}
	for i := range w.VulnerabilitySummary.Low {
		findings = append(findings, createVulnerability(vulnerabilities.Severity_LOW, fmt.Sprintf("some-component-%d", i)))
	}
	for i := range w.VulnerabilitySummary.Unassigned {
		findings = append(findings, createVulnerability(vulnerabilities.Severity_UNASSIGNED, fmt.Sprintf("some-component-%d", i)))
	}
	return findings
}

func createVulnerability(severity vulnerabilities.Severity, componentName string) *vulnerabilities.Vulnerability {
	return &vulnerabilities.Vulnerability{
		Id:      uuid.New().String(),
		Package: fmt.Sprintf("pkg:golang/%s@v2.0.8?type=module", componentName),
		Cve: &vulnerabilities.Cve{
			Id:          fmt.Sprintf("CVE-2024-%d", rand.IntN(100000)),
			Title:       "title for " + componentName,
			Description: "desc for " + componentName,
			Link:        "",
			Severity:    severity,
			References:  nil,
		},
		LatestVersion: "",
		// TODO: check if suppression is ever nil in protobuf
		Suppression: nil,
	}
}

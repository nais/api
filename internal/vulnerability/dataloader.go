package vulnerability

import (
	"context"
	"github.com/nais/api/internal/graph/loader"
	"github.com/sirupsen/logrus"
	"github.com/sourcegraph/conc/pool"
	"github.com/vikstrous/dataloadgen"
)

type ctxKey int

const loadersKey ctxKey = iota

func NewLoaderContext(ctx context.Context, mgr Manager, logger logrus.FieldLogger) context.Context {
	return context.WithValue(ctx, loadersKey, newLoaders(mgr, logger))
}

func fromContext(ctx context.Context) *loaders {
	return ctx.Value(loadersKey).(*loaders)
}

type loaders struct {
	imageLoader *dataloadgen.Loader[string, *ImageDetails]
	manager     Manager
}

func newLoaders(mgr Manager, logger logrus.FieldLogger) *loaders {
	vulnerabilityLoader := &dataloader{manager: mgr, log: logger}

	return &loaders{
		imageLoader: dataloadgen.NewLoader(vulnerabilityLoader.imageList, loader.DefaultDataLoaderOptions...),
		manager:     mgr,
	}
}

type dataloader struct {
	manager Manager
	log     logrus.FieldLogger
}

func (l dataloader) imageList(ctx context.Context, imageRef []string) ([]*ImageDetails, []error) {
	wg := pool.New().WithContext(ctx)

	ret := make([]*ImageDetails, len(imageRef))
	errs := make([]error, len(imageRef))

	for i, ref := range imageRef {
		wg.Go(func(ctx context.Context) error {
			m, err := l.manager.GetMetadataForImage(ctx, ref)
			if err != nil {
				errs[i] = err
			} else {
				ret[i] = m
			}
			return nil
		})
	}

	if err := wg.Wait(); err != nil {
		l.log.WithError(err).Error("error waiting for dataloader")
	}

	return ret, errs
}

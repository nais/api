package vulnerability

import (
	"context"
	"testing"

	"github.com/google/go-cmp/cmp"
	dependencytrack "github.com/nais/dependencytrack/pkg/client"
	"github.com/sirupsen/logrus"
)

func TestClient_GetFindingsForImage(t *testing.T) {
	log := logrus.New().WithField("test", "dependencytrack")
	ctx := context.Background()

	workloadTags := workloadInstanceTags("dev", "team1", "app1", "image:latest")
	p := project(&dependencytrack.ProjectMetric{}, workloadTags...)

	mock := NewMockInternalClient(t)
	mock.EXPECT().
		GetFindings(ctx, p.Uuid, false).Return(findings(), nil)
	c := NewDependencyTrackClient(DependencyTrackConfig{}, log, WithClient(mock))

	f, err := c.GetFindingsForImageByProjectID(ctx, "uuid", false)
	if err != nil {
		t.Fatal(err)
	}

	want := []*ImageVulnerability{
		{Severity: ImageVulnerabilitySeverityLow, projectID: "uuid"},
		{Identifier: "4", Severity: ImageVulnerabilitySeverityCritical, Description: "title4", projectID: "uuid"},
	}

	opts := cmp.AllowUnexported(ImageVulnerability{})
	if !cmp.Equal(want, f, opts) {
		t.Errorf("diff -want +got:\n%v", cmp.Diff(want, f, opts))
	}
}

func workloadInstanceTags(env, team, app, image string) []string {
	return []string{
		dependencytrack.EnvironmentTagPrefix.With(env),
		dependencytrack.TeamTagPrefix.With(team),
		dependencytrack.WorkloadTagPrefix.With(env + "|" + team + "|" + "app" + "|" + app),
		dependencytrack.ImageTagPrefix.With(image),
	}
}

func project(metrics *dependencytrack.ProjectMetric, tags ...string) *dependencytrack.Project {
	p := &dependencytrack.Project{
		Uuid:    "uuid",
		Name:    "name",
		Tags:    make([]dependencytrack.Tag, 0),
		Metrics: metrics,
	}
	for _, tag := range tags {
		p.Tags = append(p.Tags, dependencytrack.Tag{Name: tag})
	}
	return p
}

func findings() []*dependencytrack.Finding {
	return []*dependencytrack.Finding{
		{
			Vulnerability: dependencytrack.Vulnerability{
				Severity: "LOW",
			},
		},
		{
			Vulnerability: dependencytrack.Vulnerability{
				Severity: "MEDIUM",
			},
		},
		{
			Vulnerability: dependencytrack.Vulnerability{
				Severity: "HIGH",
			},
		},
		{
			Vulnerability: dependencytrack.Vulnerability{
				Severity: "CRITICAL",
				VulnId:   "4",
				Title:    "title4",
				Aliases: []dependencytrack.Alias{
					{
						CveId:  "CVE-2021-1234",
						GhsaId: "GHSA-2021-1234",
					},
				},
			},
		},
	}
}

func Test_ProjectsToExclude(t *testing.T) {
	tt := []struct {
		name    string
		project *dependencytrack.Project
		want    bool
	}{
		{
			name: "should exclude projects with matching name",
			project: &dependencytrack.Project{
				Name: "europe-north1-docker.pkg.dev/nais-io/nais/images/wonderwall",
			},
			want: true,
		},
		{
			name: "should exclude projects with matching name",
			project: &dependencytrack.Project{
				Name: "europe-north1-docker.pkg.dev/nais-io/nais/images/elector",
			},
			want: true,
		},
		{
			name: "should not exclude projects with matching name",
			project: &dependencytrack.Project{
				Name: "europe-north1-docker.pkg.dev/nais-io/nais/images/wonderwalled-idporten",
			},
			want: false,
		},
	}
	for _, tc := range tt {
		t.Run(tc.name, func(t *testing.T) {
			got := excludeProject(tc.project)
			if got != tc.want {
				t.Errorf("got %v, want %v", got, tc.want)
			}
		})
	}
}

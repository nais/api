// Code generated by sqlc. DO NOT EDIT.
// source: cost.sql

package costsql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/api/internal/slug"
)

const costForService = `-- name: CostForService :one
SELECT
	COALESCE(SUM(daily_cost), 0)::REAL
FROM
	cost
WHERE
	team_slug = $1
	AND service = $2
	AND app_label = $3
	AND date >= $4
	AND date <= $5
	AND environment = $6::TEXT
`

type CostForServiceParams struct {
	TeamSlug    slug.Slug
	Service     string
	AppLabel    string
	FromDate    pgtype.Date
	ToDate      pgtype.Date
	Environment string
}

func (q *Queries) CostForService(ctx context.Context, arg CostForServiceParams) (float32, error) {
	row := q.db.QueryRow(ctx, costForService,
		arg.TeamSlug,
		arg.Service,
		arg.AppLabel,
		arg.FromDate,
		arg.ToDate,
		arg.Environment,
	)
	var column_1 float32
	err := row.Scan(&column_1)
	return column_1, err
}

const costForTeam = `-- name: CostForTeam :one
SELECT
	COALESCE(SUM(daily_cost), 0)::REAL
FROM
	cost
WHERE
	team_slug = $1
	AND service = $2
	AND date >= $3
	AND date <= $4
`

type CostForTeamParams struct {
	TeamSlug slug.Slug
	Service  string
	FromDate pgtype.Date
	ToDate   pgtype.Date
}

func (q *Queries) CostForTeam(ctx context.Context, arg CostForTeamParams) (float32, error) {
	row := q.db.QueryRow(ctx, costForTeam,
		arg.TeamSlug,
		arg.Service,
		arg.FromDate,
		arg.ToDate,
	)
	var column_1 float32
	err := row.Scan(&column_1)
	return column_1, err
}

const dailyCostForTeam = `-- name: DailyCostForTeam :many
WITH
	date_range AS (
		SELECT
			date
		FROM
			GENERATE_SERIES(
				$1::date,
				$2::date,
				'1 day'::INTERVAL
			) AS date
	),
	cost_data AS (
		SELECT
			cost.date AS date,
			cost.service AS service,
			COALESCE(SUM(cost.daily_cost), 0)::REAL AS daily_cost
		FROM
			cost
		WHERE
			cost.date >= $1::date
			AND cost.date <= $2::date
			AND team_slug = $3::slug
			AND (
				$4::TEXT[] IS NULL
				OR cost.service = ANY ($4)
			)
		GROUP BY
			cost.date,
			cost.service
	)
SELECT
	date_range.date::date AS date,
	cost_data.service,
	COALESCE(cost_data.daily_cost, 0) AS cost
FROM
	date_range
	LEFT OUTER JOIN cost_data ON cost_data.date = date_range.date
ORDER BY
	date_range.date,
	cost_data.service ASC
`

type DailyCostForTeamParams struct {
	FromDate pgtype.Date
	ToDate   pgtype.Date
	TeamSlug slug.Slug
	Services []string
}

type DailyCostForTeamRow struct {
	Date    pgtype.Date
	Service *string
	Cost    float32
}

func (q *Queries) DailyCostForTeam(ctx context.Context, arg DailyCostForTeamParams) ([]*DailyCostForTeamRow, error) {
	rows, err := q.db.Query(ctx, dailyCostForTeam,
		arg.FromDate,
		arg.ToDate,
		arg.TeamSlug,
		arg.Services,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyCostForTeamRow{}
	for rows.Next() {
		var i DailyCostForTeamRow
		if err := rows.Scan(&i.Date, &i.Service, &i.Cost); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dailyCostForTeamEnvironment = `-- name: DailyCostForTeamEnvironment :many
WITH
	date_range AS (
		SELECT
			date
		FROM
			GENERATE_SERIES(
				$1::date,
				$2::date,
				'1 day'::INTERVAL
			) AS date
	),
	cost_data AS (
		SELECT
			cost.date AS date,
			cost.environment AS environment,
			cost.team_slug AS team_slug,
			cost.app_label AS app_label,
			COALESCE(SUM(cost.daily_cost), 0)::REAL AS daily_cost
		FROM
			cost
		WHERE
			cost.date >= $1::date
			AND cost.date <= $2::date
			AND environment = $3::TEXT
			AND team_slug = $4::slug
		GROUP BY
			cost.date,
			cost.environment,
			cost.team_slug,
			cost.app_label
	)
SELECT
	date_range.date::date AS date,
	cost_data.environment,
	cost_data.team_slug,
	cost_data.app_label,
	COALESCE(cost_data.daily_cost, 0) AS daily_cost
FROM
	date_range
	LEFT OUTER JOIN cost_data ON cost_data.date = date_range.date
ORDER BY
	date_range.date,
	cost_data.app_label ASC
`

type DailyCostForTeamEnvironmentParams struct {
	FromDate    pgtype.Date
	ToDate      pgtype.Date
	Environment string
	TeamSlug    slug.Slug
}

type DailyCostForTeamEnvironmentRow struct {
	Date        pgtype.Date
	Environment *string
	TeamSlug    *slug.Slug
	AppLabel    *string
	DailyCost   float32
}

func (q *Queries) DailyCostForTeamEnvironment(ctx context.Context, arg DailyCostForTeamEnvironmentParams) ([]*DailyCostForTeamEnvironmentRow, error) {
	rows, err := q.db.Query(ctx, dailyCostForTeamEnvironment,
		arg.FromDate,
		arg.ToDate,
		arg.Environment,
		arg.TeamSlug,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyCostForTeamEnvironmentRow{}
	for rows.Next() {
		var i DailyCostForTeamEnvironmentRow
		if err := rows.Scan(
			&i.Date,
			&i.Environment,
			&i.TeamSlug,
			&i.AppLabel,
			&i.DailyCost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dailyCostForWorkload = `-- name: DailyCostForWorkload :many
WITH
	date_range AS (
		SELECT
			date
		FROM
			GENERATE_SERIES(
				$1::date,
				$2::date,
				'1 day'::INTERVAL
			) AS date
	),
	cost_data AS (
		SELECT
			cost.date AS date,
			cost.environment AS environment,
			cost.team_slug AS team_slug,
			cost.app_label AS app_label,
			cost.service AS service,
			COALESCE(SUM(cost.daily_cost), 0)::REAL AS daily_cost
		FROM
			cost
		WHERE
			cost.date >= $1::date
			AND cost.date <= $2::date
			AND environment = $3::TEXT
			AND team_slug = $4::slug
			AND app_label = $5
		GROUP BY
			cost.date,
			cost.environment,
			cost.team_slug,
			cost.app_label,
			cost.service
	)
SELECT
	date_range.date::date AS date,
	cost_data.environment,
	cost_data.team_slug,
	cost_data.app_label,
	cost_data.service,
	cost_data.daily_cost
FROM
	date_range
	LEFT OUTER JOIN cost_data ON cost_data.date = date_range.date
ORDER BY
	date_range.date,
	cost_data.service ASC
`

type DailyCostForWorkloadParams struct {
	FromDate    pgtype.Date
	ToDate      pgtype.Date
	Environment string
	TeamSlug    slug.Slug
	AppLabel    string
}

type DailyCostForWorkloadRow struct {
	Date        pgtype.Date
	Environment *string
	TeamSlug    *slug.Slug
	AppLabel    *string
	Service     *string
	DailyCost   *float32
}

func (q *Queries) DailyCostForWorkload(ctx context.Context, arg DailyCostForWorkloadParams) ([]*DailyCostForWorkloadRow, error) {
	rows, err := q.db.Query(ctx, dailyCostForWorkload,
		arg.FromDate,
		arg.ToDate,
		arg.Environment,
		arg.TeamSlug,
		arg.AppLabel,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyCostForWorkloadRow{}
	for rows.Next() {
		var i DailyCostForWorkloadRow
		if err := rows.Scan(
			&i.Date,
			&i.Environment,
			&i.TeamSlug,
			&i.AppLabel,
			&i.Service,
			&i.DailyCost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dailyEnvCostForTeam = `-- name: DailyEnvCostForTeam :many
SELECT
	team_slug,
	app_label,
	date,
	SUM(daily_cost)::REAL AS daily_cost
FROM
	cost
WHERE
	date >= $1::date
	AND date <= $2::date
	AND environment = $3
	AND team_slug = $4::slug
GROUP BY
	team_slug,
	app_label,
	date
ORDER BY
	date,
	app_label ASC
`

type DailyEnvCostForTeamParams struct {
	FromDate    pgtype.Date
	ToDate      pgtype.Date
	Environment *string
	TeamSlug    slug.Slug
}

type DailyEnvCostForTeamRow struct {
	TeamSlug  slug.Slug
	AppLabel  string
	Date      pgtype.Date
	DailyCost float32
}

func (q *Queries) DailyEnvCostForTeam(ctx context.Context, arg DailyEnvCostForTeamParams) ([]*DailyEnvCostForTeamRow, error) {
	rows, err := q.db.Query(ctx, dailyEnvCostForTeam,
		arg.FromDate,
		arg.ToDate,
		arg.Environment,
		arg.TeamSlug,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DailyEnvCostForTeamRow{}
	for rows.Next() {
		var i DailyEnvCostForTeamRow
		if err := rows.Scan(
			&i.TeamSlug,
			&i.AppLabel,
			&i.Date,
			&i.DailyCost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lastCostDate = `-- name: LastCostDate :one
SELECT
	MAX(date)::date AS date
FROM
	cost
`

func (q *Queries) LastCostDate(ctx context.Context) (pgtype.Date, error) {
	row := q.db.QueryRow(ctx, lastCostDate)
	var date pgtype.Date
	err := row.Scan(&date)
	return date, err
}

const listTeamSlugsForCostUpdater = `-- name: ListTeamSlugsForCostUpdater :many
SELECT
	slug
FROM
	teams
ORDER BY
	teams.slug ASC
`

func (q *Queries) ListTeamSlugsForCostUpdater(ctx context.Context) ([]slug.Slug, error) {
	rows, err := q.db.Query(ctx, listTeamSlugsForCostUpdater)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []slug.Slug{}
	for rows.Next() {
		var slug slug.Slug
		if err := rows.Scan(&slug); err != nil {
			return nil, err
		}
		items = append(items, slug)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monthlyCostForTeam = `-- name: MonthlyCostForTeam :many
SELECT
	team_slug, month, last_recorded_date, daily_cost
FROM
	cost_monthly_team
WHERE
	team_slug = $1::slug
ORDER BY
	MONTH DESC
LIMIT
	12
`

func (q *Queries) MonthlyCostForTeam(ctx context.Context, teamSlug slug.Slug) ([]*CostMonthlyTeam, error) {
	rows, err := q.db.Query(ctx, monthlyCostForTeam, teamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CostMonthlyTeam{}
	for rows.Next() {
		var i CostMonthlyTeam
		if err := rows.Scan(
			&i.TeamSlug,
			&i.Month,
			&i.LastRecordedDate,
			&i.DailyCost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monthlyCostForTenant = `-- name: MonthlyCostForTenant :many
SELECT
	service, month, last_recorded_date, daily_cost
FROM
	cost_monthly_tenant
WHERE
	MONTH >= $1
	AND MONTH <= $2
ORDER BY
	MONTH ASC
`

type MonthlyCostForTenantParams struct {
	FromDate pgtype.Date
	ToDate   pgtype.Date
}

func (q *Queries) MonthlyCostForTenant(ctx context.Context, arg MonthlyCostForTenantParams) ([]*CostMonthlyTenant, error) {
	rows, err := q.db.Query(ctx, monthlyCostForTenant, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CostMonthlyTenant{}
	for rows.Next() {
		var i CostMonthlyTenant
		if err := rows.Scan(
			&i.Service,
			&i.Month,
			&i.LastRecordedDate,
			&i.DailyCost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monthlyCostForWorkload = `-- name: MonthlyCostForWorkload :many
WITH
	last_run AS (
		SELECT
			MAX(date)::date AS "last_run"
		FROM
			cost
	)
SELECT
	team_slug,
	app_label,
	environment,
	DATE_TRUNC('month', date)::date AS MONTH,
	service,
	-- Extract last day of known cost samples for the month, or the last recorded date
	-- This helps with estimation etc
	MAX(
		CASE
			WHEN DATE_TRUNC('month', date) < DATE_TRUNC('month', last_run) THEN DATE_TRUNC('month', date) + INTERVAL '1 month' - INTERVAL '1 day'
			ELSE DATE_TRUNC('day', last_run)
		END
	)::date AS last_recorded_date,
	SUM(daily_cost)::REAL AS daily_cost
FROM
	cost c
	LEFT JOIN last_run ON TRUE
WHERE
	c.team_slug = $1::slug
	AND c.app_label = $2
	AND c.environment = $3::TEXT
	AND c.date >= DATE_TRUNC('month', last_run) - INTERVAL '1 year'
GROUP BY
	team_slug,
	app_label,
	environment,
	service,
	MONTH
ORDER BY
	MONTH DESC
`

type MonthlyCostForWorkloadParams struct {
	TeamSlug    slug.Slug
	AppLabel    string
	Environment string
}

type MonthlyCostForWorkloadRow struct {
	TeamSlug         slug.Slug
	AppLabel         string
	Environment      *string
	Month            pgtype.Date
	Service          string
	LastRecordedDate pgtype.Date
	DailyCost        float32
}

func (q *Queries) MonthlyCostForWorkload(ctx context.Context, arg MonthlyCostForWorkloadParams) ([]*MonthlyCostForWorkloadRow, error) {
	rows, err := q.db.Query(ctx, monthlyCostForWorkload, arg.TeamSlug, arg.AppLabel, arg.Environment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MonthlyCostForWorkloadRow{}
	for rows.Next() {
		var i MonthlyCostForWorkloadRow
		if err := rows.Scan(
			&i.TeamSlug,
			&i.AppLabel,
			&i.Environment,
			&i.Month,
			&i.Service,
			&i.LastRecordedDate,
			&i.DailyCost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshCostMonthlyTeam = `-- name: RefreshCostMonthlyTeam :exec
REFRESH MATERIALIZED VIEW CONCURRENTLY cost_monthly_team
`

func (q *Queries) RefreshCostMonthlyTeam(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshCostMonthlyTeam)
	return err
}

const refreshCostMonthlyTenant = `-- name: RefreshCostMonthlyTenant :exec
REFRESH MATERIALIZED VIEW CONCURRENTLY cost_monthly_tenant
`

func (q *Queries) RefreshCostMonthlyTenant(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshCostMonthlyTenant)
	return err
}

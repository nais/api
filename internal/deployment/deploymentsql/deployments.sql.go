// Code generated by sqlc. DO NOT EDIT.
// source: deployments.sql

package deploymentsql

import (
	"context"

	"github.com/google/uuid"
	"github.com/nais/api/internal/slug"
)

const countForTeam = `-- name: CountForTeam :one
SELECT
	COUNT(*)
FROM
	deployments
WHERE
	team_slug = $1::slug
`

func (q *Queries) CountForTeam(ctx context.Context, teamSlug slug.Slug) (int64, error) {
	row := q.db.QueryRow(ctx, countForTeam, teamSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countForWorkload = `-- name: CountForWorkload :one
SELECT
	COUNT(*)
FROM
	deployments
	JOIN deployment_k8s_resources ON deployments.id = deployment_k8s_resources.deployment_id
WHERE
	deployment_k8s_resources.name = $1
	AND deployment_k8s_resources.kind = $2
	AND deployments.environment_name = $3
	AND deployments.team_slug = $4
`

type CountForWorkloadParams struct {
	WorkloadName    string
	WorkloadKind    string
	EnvironmentName string
	TeamSlug        slug.Slug
}

func (q *Queries) CountForWorkload(ctx context.Context, arg CountForWorkloadParams) (int64, error) {
	row := q.db.QueryRow(ctx, countForWorkload,
		arg.WorkloadName,
		arg.WorkloadKind,
		arg.EnvironmentName,
		arg.TeamSlug,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countResourcesForDeployment = `-- name: CountResourcesForDeployment :one
SELECT
	COUNT(*)
FROM
	deployment_k8s_resources
WHERE
	deployment_id = $1
`

func (q *Queries) CountResourcesForDeployment(ctx context.Context, deploymentID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countResourcesForDeployment, deploymentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStatusesForDeployment = `-- name: CountStatusesForDeployment :one
SELECT
	COUNT(*)
FROM
	deployment_statuses
WHERE
	deployment_id = $1
`

func (q *Queries) CountStatusesForDeployment(ctx context.Context, deploymentID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countStatusesForDeployment, deploymentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listByIDs = `-- name: ListByIDs :many
SELECT
	id, created_at, team_slug, repository, environment_name
FROM
	deployments
WHERE
	id = ANY ($1::UUID[])
ORDER BY
	created_at
`

func (q *Queries) ListByIDs(ctx context.Context, ids []uuid.UUID) ([]*Deployment, error) {
	rows, err := q.db.Query(ctx, listByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.TeamSlug,
			&i.Repository,
			&i.EnvironmentName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listByTeamSlug = `-- name: ListByTeamSlug :many
SELECT
	id, created_at, team_slug, repository, environment_name
FROM
	deployments
WHERE
	team_slug = $1::slug
ORDER BY
	created_at DESC
LIMIT
	$3
OFFSET
	$2
`

type ListByTeamSlugParams struct {
	TeamSlug slug.Slug
	Offset   int32
	Limit    int32
}

func (q *Queries) ListByTeamSlug(ctx context.Context, arg ListByTeamSlugParams) ([]*Deployment, error) {
	rows, err := q.db.Query(ctx, listByTeamSlug, arg.TeamSlug, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.TeamSlug,
			&i.Repository,
			&i.EnvironmentName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeploymentResourcesByIDs = `-- name: ListDeploymentResourcesByIDs :many
SELECT
	id, created_at, deployment_id, "group", version, kind, name, namespace
FROM
	deployment_k8s_resources
WHERE
	id = ANY ($1::UUID[])
ORDER BY
	created_at
`

func (q *Queries) ListDeploymentResourcesByIDs(ctx context.Context, ids []uuid.UUID) ([]*DeploymentK8sResource, error) {
	rows, err := q.db.Query(ctx, listDeploymentResourcesByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DeploymentK8sResource{}
	for rows.Next() {
		var i DeploymentK8sResource
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.DeploymentID,
			&i.Group,
			&i.Version,
			&i.Kind,
			&i.Name,
			&i.Namespace,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeploymentStatusesByIDs = `-- name: ListDeploymentStatusesByIDs :many
SELECT
	id, created_at, deployment_id, state, message
FROM
	deployment_statuses
WHERE
	id = ANY ($1::UUID[])
ORDER BY
	created_at
`

func (q *Queries) ListDeploymentStatusesByIDs(ctx context.Context, ids []uuid.UUID) ([]*DeploymentStatus, error) {
	rows, err := q.db.Query(ctx, listDeploymentStatusesByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DeploymentStatus{}
	for rows.Next() {
		var i DeploymentStatus
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.DeploymentID,
			&i.State,
			&i.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listForWorkload = `-- name: ListForWorkload :many
SELECT
	deployments.id, deployments.created_at, deployments.team_slug, deployments.repository, deployments.environment_name
FROM
	deployments
	JOIN deployment_k8s_resources ON deployments.id = deployment_k8s_resources.deployment_id
WHERE
	deployment_k8s_resources.name = $1
	AND deployment_k8s_resources.kind = $2
	AND deployments.environment_name = $3
	AND deployments.team_slug = $4
ORDER BY
	deployments.created_at DESC
LIMIT
	$6
OFFSET
	$5
`

type ListForWorkloadParams struct {
	WorkloadName    string
	WorkloadKind    string
	EnvironmentName string
	TeamSlug        slug.Slug
	Offset          int32
	Limit           int32
}

func (q *Queries) ListForWorkload(ctx context.Context, arg ListForWorkloadParams) ([]*Deployment, error) {
	rows, err := q.db.Query(ctx, listForWorkload,
		arg.WorkloadName,
		arg.WorkloadKind,
		arg.EnvironmentName,
		arg.TeamSlug,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.TeamSlug,
			&i.Repository,
			&i.EnvironmentName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcesForDeployment = `-- name: ListResourcesForDeployment :many
SELECT
	id, created_at, deployment_id, "group", version, kind, name, namespace
FROM
	deployment_k8s_resources
WHERE
	deployment_id = $1
ORDER BY
	created_at DESC
LIMIT
	$3
OFFSET
	$2
`

type ListResourcesForDeploymentParams struct {
	DeploymentID uuid.UUID
	Offset       int32
	Limit        int32
}

func (q *Queries) ListResourcesForDeployment(ctx context.Context, arg ListResourcesForDeploymentParams) ([]*DeploymentK8sResource, error) {
	rows, err := q.db.Query(ctx, listResourcesForDeployment, arg.DeploymentID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DeploymentK8sResource{}
	for rows.Next() {
		var i DeploymentK8sResource
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.DeploymentID,
			&i.Group,
			&i.Version,
			&i.Kind,
			&i.Name,
			&i.Namespace,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStatusesForDeployment = `-- name: ListStatusesForDeployment :many
SELECT
	id, created_at, deployment_id, state, message
FROM
	deployment_statuses
WHERE
	deployment_id = $1
ORDER BY
	created_at DESC
LIMIT
	$3
OFFSET
	$2
`

type ListStatusesForDeploymentParams struct {
	DeploymentID uuid.UUID
	Offset       int32
	Limit        int32
}

func (q *Queries) ListStatusesForDeployment(ctx context.Context, arg ListStatusesForDeploymentParams) ([]*DeploymentStatus, error) {
	rows, err := q.db.Query(ctx, listStatusesForDeployment, arg.DeploymentID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DeploymentStatus{}
	for rows.Next() {
		var i DeploymentStatus
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.DeploymentID,
			&i.State,
			&i.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

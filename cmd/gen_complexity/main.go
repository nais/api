// This program generates a complexity function for all fields in GraphQL
// that contains a first and last parameter.

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"
	"os"
	"slices"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

const (
	sourcePackage = "./internal/graph/gengql"
	output        = "./internal/graph/gengql/complexity.go"
)

var tpl = `
// Code generated by ./cmd/gen_complexity, DO NOT EDIT.

package gengql

import (
	{{- range .Imports }}
	{{if .Name}}{{.Name}} {{end}}"{{ .Path }}"
	{{- end }}
)

func NewComplexityRoot() ComplexityRoot {
	c := ComplexityRoot{}

	{{ range .Funcs -}}
	c.{{.Name}} = func({{ .Signature }}) int {
		return cursorComplexity(first, last) * childComplexity
	}
	{{ end }}
	return c
}

func cursorComplexity(first, last *int) int {
	if first != nil {
		return *first
	}
	if last != nil {
		return *last
	}
	return pagination.DefaultPageSize
}

`

func main() {
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName | packages.NeedTypes,
	}, sourcePackage)
	if err != nil {
		panic(err)
	}

	if len(pkgs) != 1 {
		panic("expected exactly one package")
	}

	root := pkgs[0].Types.Scope().Lookup("ComplexityRoot").(*types.TypeName)

	fields := generateForStruct(root.Name(), root.Type().Underlying().(*types.Struct))

	tplData := struct {
		Funcs   []Func
		Imports []Import
	}{
		Imports: importsForField(fields),
		Funcs:   combine(fields),
	}

	// Deduplicate import packages
	slices.SortFunc(tplData.Imports, func(i, j Import) int {
		return strings.Compare(i.Path, j.Path)
	})
	tplData.Imports = slices.CompactFunc(tplData.Imports, func(e1, e2 Import) bool {
		return e1.Path == e2.Path
	})[1:]

	buf := &bytes.Buffer{}
	if err := template.Must(template.New("root").Parse(tpl)).Execute(buf, tplData); err != nil {
		panic(err)
	}

	b, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	// #nosec G306
	if err := os.WriteFile(output, b, 0o644); err != nil {
		panic(err)
	}
}

type Func struct {
	Name      string
	Signature string
}

func combine(f *Field, parent ...string) (ret []Func) {
	for _, n := range f.Nested {
		if n.Params != nil {
			ret = append(ret, Func{
				Name:      strings.Join(append(parent, n.Name), "."),
				Signature: signature(n.Params),
			})
		} else {
			ret = append(ret, combine(n, append(parent, n.Name)...)...)
		}
	}
	return ret
}

func signature(t *types.Tuple) string {
	var ret []string
	for i := 0; i < t.Len(); i++ {
		param := t.At(i)
		ret = append(ret, param.Name()+" "+formatParam(param.Type()))
	}
	return strings.Join(ret, ", ")
}

func formatParam(t types.Type) string {
	if p, ok := t.(*types.Pointer); ok {
		return "*" + formatParam(p.Elem())
	}

	if n, ok := t.(*types.Named); ok {
		if n.Obj().Pkg() == nil {
			return n.Obj().Name()
		} else {
			return n.Obj().Pkg().Name() + "." + n.Obj().Name()
		}
	}

	return t.String()
}

type Field struct {
	Name   string
	Params *types.Tuple
	Nested []*Field
}

func generateForStruct(name string, str *types.Struct) *Field {
	ret := &Field{
		Name: name,
	}
	for i := 0; i < str.NumFields(); i++ {
		field := str.Field(i)
		switch f := field.Type().Underlying().(type) {
		case *types.Struct:
			s := generateForStruct(field.Name(), f)
			if s != nil {
				ret.Nested = append(ret.Nested, s)
			}
		case *types.Signature:
			if f.Params().Len() < 4 {
				continue
			}

			var first, last *types.Var
			for i := 0; i < f.Params().Len(); i++ {
				param := f.Params().At(i)
				if param.Name() == "first" {
					first = param
				} else if param.Name() == "last" {
					last = param
				}
			}
			if first == nil || last == nil {
				continue
			}

			ret.Nested = append(ret.Nested, &Field{
				Name:   field.Name(),
				Params: f.Params(),
			})
		default:
			fmt.Printf("Unknown for field type %T\n", field)
		}
	}

	if len(ret.Nested) == 0 {
		return nil
	}

	return ret
}

type Import struct {
	Name string
	Path string
}

func importsForField(f *Field) []Import {
	var ret []Import
	for _, n := range f.Nested {
		ret = append(ret, importsForField(n)...)
	}

	for i := 0; i < f.Params.Len(); i++ {
		param := f.Params.At(i)
		ret = append(ret, importFromType(param.Type()))
	}

	return ret
}

func importFromType(t types.Type) Import {
	if p, ok := t.(*types.Pointer); ok {
		t = p.Elem()
	}

	if n, ok := t.(*types.Named); ok {
		return Import{
			Name: n.Obj().Pkg().Name(),
			Path: n.Obj().Pkg().Path(),
		}
	}

	return Import{}
}
